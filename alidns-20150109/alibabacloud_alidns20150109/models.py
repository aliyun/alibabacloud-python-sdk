# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict


class AddCustomLineRequestIpSegment(TeaModel):
    def __init__(
        self,
        end_ip: str = None,
        start_ip: str = None,
    ):
        # The end IP address of the CIDR block.
        self.end_ip = end_ip
        # The start IP address of the CIDR block.
        self.start_ip = start_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ip is not None:
            result['EndIp'] = self.end_ip
        if self.start_ip is not None:
            result['StartIp'] = self.start_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndIp') is not None:
            self.end_ip = m.get('EndIp')
        if m.get('StartIp') is not None:
            self.start_ip = m.get('StartIp')
        return self


class AddCustomLineRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        ip_segment: List[AddCustomLineRequestIpSegment] = None,
        lang: str = None,
        line_name: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The CIDR blocks.
        # 
        # This parameter is required.
        self.ip_segment = ip_segment
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The name of the custom line.
        # 
        # This parameter is required.
        self.line_name = line_name

    def validate(self):
        if self.ip_segment:
            for k in self.ip_segment:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        result['IpSegment'] = []
        if self.ip_segment is not None:
            for k in self.ip_segment:
                result['IpSegment'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        self.ip_segment = []
        if m.get('IpSegment') is not None:
            for k in m.get('IpSegment'):
                temp_model = AddCustomLineRequestIpSegment()
                self.ip_segment.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class AddCustomLineResponseBody(TeaModel):
    def __init__(
        self,
        line_code: str = None,
        line_id: int = None,
        request_id: str = None,
    ):
        # The code of the custom line.
        self.line_code = line_code
        # The unique ID of the custom line.
        self.line_id = line_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_id is not None:
            result['LineId'] = self.line_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineId') is not None:
            self.line_id = m.get('LineId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCustomLineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCustomLineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCustomLineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDnsCacheDomainRequestSourceDnsServer(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: str = None,
    ):
        # The domain name or IP address of the origin DNS server.
        # 
        # This parameter is required.
        self.host = host
        # The port of the origin DNS server.
        # 
        # This parameter is required.
        self.port = port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        return self


class AddDnsCacheDomainRequest(TeaModel):
    def __init__(
        self,
        cache_ttl_max: int = None,
        cache_ttl_min: int = None,
        domain_name: str = None,
        instance_id: str = None,
        lang: str = None,
        remark: str = None,
        source_dns_server: List[AddDnsCacheDomainRequestSourceDnsServer] = None,
        source_edns: str = None,
        source_protocol: str = None,
    ):
        # The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.
        # 
        # This parameter is required.
        self.cache_ttl_max = cache_ttl_max
        # The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.
        # 
        # This parameter is required.
        self.cache_ttl_min = cache_ttl_min
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The instance ID of the cache-accelerated domain name. You can call the [ListCloudGtmInstances](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English Default: **zh**\
        self.lang = lang
        # The remarks.
        self.remark = remark
        # The origin DNS servers. A maximum of 10 origin DNS servers are supported.
        # 
        # This parameter is required.
        self.source_dns_server = source_dns_server
        # Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.
        # 
        # This parameter is required.
        self.source_edns = source_edns
        # The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.
        # 
        # This parameter is required.
        self.source_protocol = source_protocol

    def validate(self):
        if self.source_dns_server:
            for k in self.source_dns_server:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cache_ttl_max is not None:
            result['CacheTtlMax'] = self.cache_ttl_max
        if self.cache_ttl_min is not None:
            result['CacheTtlMin'] = self.cache_ttl_min
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.remark is not None:
            result['Remark'] = self.remark
        result['SourceDnsServer'] = []
        if self.source_dns_server is not None:
            for k in self.source_dns_server:
                result['SourceDnsServer'].append(k.to_map() if k else None)
        if self.source_edns is not None:
            result['SourceEdns'] = self.source_edns
        if self.source_protocol is not None:
            result['SourceProtocol'] = self.source_protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CacheTtlMax') is not None:
            self.cache_ttl_max = m.get('CacheTtlMax')
        if m.get('CacheTtlMin') is not None:
            self.cache_ttl_min = m.get('CacheTtlMin')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        self.source_dns_server = []
        if m.get('SourceDnsServer') is not None:
            for k in m.get('SourceDnsServer'):
                temp_model = AddDnsCacheDomainRequestSourceDnsServer()
                self.source_dns_server.append(temp_model.from_map(k))
        if m.get('SourceEdns') is not None:
            self.source_edns = m.get('SourceEdns')
        if m.get('SourceProtocol') is not None:
            self.source_protocol = m.get('SourceProtocol')
        return self


class AddDnsCacheDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddDnsCacheDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDnsCacheDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDnsCacheDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDnsGtmAccessStrategyRequestDefaultAddrPool(TeaModel):
    def __init__(
        self,
        id: str = None,
        lba_weight: int = None,
    ):
        # The ID of the address pool in the primary address pool set.
        self.id = id
        # The weight of the address pool in the primary address pool set.
        self.lba_weight = lba_weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        return self


class AddDnsGtmAccessStrategyRequestFailoverAddrPool(TeaModel):
    def __init__(
        self,
        id: str = None,
        lba_weight: int = None,
    ):
        # The ID of the address pool in the secondary address pool set.
        self.id = id
        # The weight of the address pool in the secondary address pool set.
        self.lba_weight = lba_weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        return self


class AddDnsGtmAccessStrategyRequest(TeaModel):
    def __init__(
        self,
        default_addr_pool: List[AddDnsGtmAccessStrategyRequestDefaultAddrPool] = None,
        default_addr_pool_type: str = None,
        default_latency_optimization: str = None,
        default_lba_strategy: str = None,
        default_max_return_addr_num: int = None,
        default_min_available_addr_num: int = None,
        failover_addr_pool: List[AddDnsGtmAccessStrategyRequestFailoverAddrPool] = None,
        failover_addr_pool_type: str = None,
        failover_latency_optimization: str = None,
        failover_lba_strategy: str = None,
        failover_max_return_addr_num: int = None,
        failover_min_available_addr_num: int = None,
        instance_id: str = None,
        lang: str = None,
        lines: str = None,
        strategy_mode: str = None,
        strategy_name: str = None,
    ):
        # The address pools in the primary address pool set.
        # 
        # This parameter is required.
        self.default_addr_pool = default_addr_pool
        # The type of the primary address pool. Valid values:
        # 
        # *   IPV4
        # *   IPV6
        # *   DOMAIN
        # 
        # This parameter is required.
        self.default_addr_pool_type = default_addr_pool_type
        # Specifies whether to enable DNS resolution with optimal latency for the primary address pool set. Valid values:
        # 
        # *   OPEN
        # *   CLOSE
        self.default_latency_optimization = default_latency_optimization
        # The load balancing policy of the primary address pool set. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        self.default_lba_strategy = default_lba_strategy
        # The maximum number of addresses returned from the primary address pool set.
        self.default_max_return_addr_num = default_max_return_addr_num
        # The minimum number of available addresses in the primary address pool set.
        # 
        # This parameter is required.
        self.default_min_available_addr_num = default_min_available_addr_num
        # The address pools in the secondary address pool set. If no address pool exists in the secondary address pool set, set this parameter to EMPTY.
        self.failover_addr_pool = failover_addr_pool
        # The type of the secondary address pool. Valid values:
        # 
        # *   IPV4
        # *   IPV6
        # *   DOMAIN
        self.failover_addr_pool_type = failover_addr_pool_type
        # Specifies whether to enable DNS resolution with optimal latency for the secondary address pool set. Valid values:
        # 
        # *   OPEN
        # *   CLOSE
        self.failover_latency_optimization = failover_latency_optimization
        # The load balancing policy of the secondary address pool set. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        self.failover_lba_strategy = failover_lba_strategy
        # The maximum number of addresses returned from the secondary address pool set.
        self.failover_max_return_addr_num = failover_max_return_addr_num
        # The minimum number of available addresses in the secondary address pool set.
        self.failover_min_available_addr_num = failover_min_available_addr_num
        # The instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The Domain Name System (DNS) request source. For example: `["default", "drpeng"]` indicates Global and Dr. Peng Group.
        self.lines = lines
        # The type of the access policy. Valid values:
        # 
        # *   GEO: geographical location-based access policy
        # *   LATENCY: latency-based access policy
        # 
        # This parameter is required.
        self.strategy_mode = strategy_mode
        # The name of the access policy.
        # 
        # This parameter is required.
        self.strategy_name = strategy_name

    def validate(self):
        if self.default_addr_pool:
            for k in self.default_addr_pool:
                if k:
                    k.validate()
        if self.failover_addr_pool:
            for k in self.failover_addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DefaultAddrPool'] = []
        if self.default_addr_pool is not None:
            for k in self.default_addr_pool:
                result['DefaultAddrPool'].append(k.to_map() if k else None)
        if self.default_addr_pool_type is not None:
            result['DefaultAddrPoolType'] = self.default_addr_pool_type
        if self.default_latency_optimization is not None:
            result['DefaultLatencyOptimization'] = self.default_latency_optimization
        if self.default_lba_strategy is not None:
            result['DefaultLbaStrategy'] = self.default_lba_strategy
        if self.default_max_return_addr_num is not None:
            result['DefaultMaxReturnAddrNum'] = self.default_max_return_addr_num
        if self.default_min_available_addr_num is not None:
            result['DefaultMinAvailableAddrNum'] = self.default_min_available_addr_num
        result['FailoverAddrPool'] = []
        if self.failover_addr_pool is not None:
            for k in self.failover_addr_pool:
                result['FailoverAddrPool'].append(k.to_map() if k else None)
        if self.failover_addr_pool_type is not None:
            result['FailoverAddrPoolType'] = self.failover_addr_pool_type
        if self.failover_latency_optimization is not None:
            result['FailoverLatencyOptimization'] = self.failover_latency_optimization
        if self.failover_lba_strategy is not None:
            result['FailoverLbaStrategy'] = self.failover_lba_strategy
        if self.failover_max_return_addr_num is not None:
            result['FailoverMaxReturnAddrNum'] = self.failover_max_return_addr_num
        if self.failover_min_available_addr_num is not None:
            result['FailoverMinAvailableAddrNum'] = self.failover_min_available_addr_num
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.default_addr_pool = []
        if m.get('DefaultAddrPool') is not None:
            for k in m.get('DefaultAddrPool'):
                temp_model = AddDnsGtmAccessStrategyRequestDefaultAddrPool()
                self.default_addr_pool.append(temp_model.from_map(k))
        if m.get('DefaultAddrPoolType') is not None:
            self.default_addr_pool_type = m.get('DefaultAddrPoolType')
        if m.get('DefaultLatencyOptimization') is not None:
            self.default_latency_optimization = m.get('DefaultLatencyOptimization')
        if m.get('DefaultLbaStrategy') is not None:
            self.default_lba_strategy = m.get('DefaultLbaStrategy')
        if m.get('DefaultMaxReturnAddrNum') is not None:
            self.default_max_return_addr_num = m.get('DefaultMaxReturnAddrNum')
        if m.get('DefaultMinAvailableAddrNum') is not None:
            self.default_min_available_addr_num = m.get('DefaultMinAvailableAddrNum')
        self.failover_addr_pool = []
        if m.get('FailoverAddrPool') is not None:
            for k in m.get('FailoverAddrPool'):
                temp_model = AddDnsGtmAccessStrategyRequestFailoverAddrPool()
                self.failover_addr_pool.append(temp_model.from_map(k))
        if m.get('FailoverAddrPoolType') is not None:
            self.failover_addr_pool_type = m.get('FailoverAddrPoolType')
        if m.get('FailoverLatencyOptimization') is not None:
            self.failover_latency_optimization = m.get('FailoverLatencyOptimization')
        if m.get('FailoverLbaStrategy') is not None:
            self.failover_lba_strategy = m.get('FailoverLbaStrategy')
        if m.get('FailoverMaxReturnAddrNum') is not None:
            self.failover_max_return_addr_num = m.get('FailoverMaxReturnAddrNum')
        if m.get('FailoverMinAvailableAddrNum') is not None:
            self.failover_min_available_addr_num = m.get('FailoverMinAvailableAddrNum')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class AddDnsGtmAccessStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        strategy_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the access policy.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class AddDnsGtmAccessStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDnsGtmAccessStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDnsGtmAccessStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDnsGtmAddressPoolRequestAddr(TeaModel):
    def __init__(
        self,
        addr: str = None,
        attribute_info: str = None,
        lba_weight: int = None,
        mode: str = None,
        remark: str = None,
    ):
        # The address in the address pool.
        # 
        # This parameter is required.
        self.addr = addr
        # The information about the source region of the address. The value of this parameter is a JSON string. Valid values:
        # 
        # *   lineCode: the line code of the source region for the address
        # 
        # *   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:
        # 
        #     *   NO_NEED: no need for rectification
        #     *   RECTIFIED: rectified
        #     *   AUTO: automatic rectification
        # 
        # This parameter is required.
        self.attribute_info = attribute_info
        # The weight of the address.
        self.lba_weight = lba_weight
        # The return mode of the addresses: Valid values:
        # 
        # *   SMART: smart return
        # *   ONLINE: always online
        # *   OFFLINE: always offline
        # 
        # This parameter is required.
        self.mode = mode
        # The description of the address pool.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr is not None:
            result['Addr'] = self.addr
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Addr') is not None:
            self.addr = m.get('Addr')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class AddDnsGtmAddressPoolRequestIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        isp_code: str = None,
    ):
        # The city code.
        # 
        # Specify the parameter according to the value of CityCode returned by the DescribeGtmMonitorAvailableConfig operation.
        self.city_code = city_code
        # *   The Internet service provider (ISP) node. Specify the parameter according to the value of IspCode returned by the DescribeGtmMonitorAvailableConfig operation.
        # *   If the returned value of GroupType for the DescribeGtmMonitorAvailableConfig operation is BGP or Overseas, IspCode is not required and is set to 465 by default.
        # *   If the returned value of GroupType for the DescribeGtmMonitorAvailableConfig operation is not BGP or Overseas, IspCode is required. When IspCode is specified, CityCode is required.
        self.isp_code = isp_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        return self


class AddDnsGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        addr: List[AddDnsGtmAddressPoolRequestAddr] = None,
        evaluation_count: int = None,
        instance_id: str = None,
        interval: int = None,
        isp_city_node: List[AddDnsGtmAddressPoolRequestIspCityNode] = None,
        lang: str = None,
        lba_strategy: str = None,
        monitor_extend_info: str = None,
        monitor_status: str = None,
        name: str = None,
        protocol_type: str = None,
        timeout: int = None,
        type: str = None,
    ):
        # The address pools.
        # 
        # This parameter is required.
        self.addr = addr
        # The number of consecutive failures.
        self.evaluation_count = evaluation_count
        # The instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The health check interval. Unit: seconds.
        self.interval = interval
        # The nodes for monitoring.
        self.isp_city_node = isp_city_node
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The load balancing policy of the address pool. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        # 
        # This parameter is required.
        self.lba_strategy = lba_strategy
        # The extended information. The required parameters vary based on the health check protocol.
        # 
        # *   HTTP or HTTPS:
        # 
        #     *   port: the port that you want to check
        # 
        #     *   host: the host settings
        # 
        #     *   path: the URL
        # 
        #     *   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:
        # 
        #         *   true: enables SNI.
        #         *   other: disables SNI.
        # 
        #     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # *   ping:
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   packetNum: the number of ping packets
        # 
        #     *   packetLossRate: the loss rate of ping packets
        # 
        #     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # *   TCP:
        # 
        #     *   port: the port that you want to check
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        self.monitor_extend_info = monitor_extend_info
        # Specifies whether to enable the health check feature. If you set this parameter to OPEN, the system verifies the health check configurations. If you set this parameter to CLOSE, the system discards the health check configurations. Default value: CLOSE. Valid values:
        # 
        # *   OPEN: enables the health check feature.
        # *   CLOSE: disables the health check feature.
        self.monitor_status = monitor_status
        # The name of the address pool.
        # 
        # This parameter is required.
        self.name = name
        # The health check protocol. Valid values:
        # 
        # *   HTTP
        # *   HTTPS
        # *   PING
        # *   TCP
        self.protocol_type = protocol_type
        # The timeout period. Unit: milliseconds.
        self.timeout = timeout
        # The type of the address pool. Valid values:
        # 
        # *   IPV4: IPv4 address
        # *   IPV6: IPv6 address
        # *   DOMAIN: domain name
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.addr:
            for k in self.addr:
                if k:
                    k.validate()
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addr'] = []
        if self.addr is not None:
            for k in self.addr:
                result['Addr'].append(k.to_map() if k else None)
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.interval is not None:
            result['Interval'] = self.interval
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.lba_strategy is not None:
            result['LbaStrategy'] = self.lba_strategy
        if self.monitor_extend_info is not None:
            result['MonitorExtendInfo'] = self.monitor_extend_info
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.name is not None:
            result['Name'] = self.name
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr = []
        if m.get('Addr') is not None:
            for k in m.get('Addr'):
                temp_model = AddDnsGtmAddressPoolRequestAddr()
                self.addr.append(temp_model.from_map(k))
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = AddDnsGtmAddressPoolRequestIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LbaStrategy') is not None:
            self.lba_strategy = m.get('LbaStrategy')
        if m.get('MonitorExtendInfo') is not None:
            self.monitor_extend_info = m.get('MonitorExtendInfo')
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddDnsGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        monitor_config_id: str = None,
        request_id: str = None,
    ):
        # The ID of the address pool.
        self.addr_pool_id = addr_pool_id
        # The ID of the health check configuration.
        self.monitor_config_id = monitor_config_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddDnsGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDnsGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDnsGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDnsGtmMonitorRequestIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        isp_code: str = None,
    ):
        # The code of the city where the monitored node is deployed.
        self.city_code = city_code
        # The code of the Internet service provider (ISP) to which the monitored node belongs.
        self.isp_code = isp_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        return self


class AddDnsGtmMonitorRequest(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        evaluation_count: int = None,
        interval: int = None,
        isp_city_node: List[AddDnsGtmMonitorRequestIspCityNode] = None,
        lang: str = None,
        monitor_extend_info: str = None,
        protocol_type: str = None,
        timeout: int = None,
    ):
        # The ID of the address pool.
        # 
        # This parameter is required.
        self.addr_pool_id = addr_pool_id
        # The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
        # 
        # This parameter is required.
        self.evaluation_count = evaluation_count
        # The health check interval. Unit: seconds.
        # 
        # This parameter is required.
        self.interval = interval
        # The monitored nodes.
        # 
        # This parameter is required.
        self.isp_city_node = isp_city_node
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The extended information. The required parameters vary based on the value of ProtocolType.
        # 
        # *   HTTP or HTTPS
        # 
        #     *   port: the port that you want to check
        # 
        #     *   host: the host settings
        # 
        #     *   path: the URL path
        # 
        #     *   code: the response code. The health check result is deemed abnormal if the returned value is greater than the specified value.
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:
        # 
        #         *   true: enables SNI.
        #         *   false: disables SNI.
        # 
        #     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # *   PING
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   packetNum: the number of ping packets
        # 
        #     *   packetLossRate: the loss rate of ping packets
        # 
        #     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # *   TCP
        # 
        #     *   port: the port that you want to check
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # This parameter is required.
        self.monitor_extend_info = monitor_extend_info
        # The health check protocol. Valid values:
        # 
        # *   HTTP
        # *   HTTPS
        # *   PING
        # *   TCP
        # 
        # This parameter is required.
        self.protocol_type = protocol_type
        # The timeout period. Unit: milliseconds.
        # 
        # This parameter is required.
        self.timeout = timeout

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.interval is not None:
            result['Interval'] = self.interval
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.monitor_extend_info is not None:
            result['MonitorExtendInfo'] = self.monitor_extend_info
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = AddDnsGtmMonitorRequestIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MonitorExtendInfo') is not None:
            self.monitor_extend_info = m.get('MonitorExtendInfo')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class AddDnsGtmMonitorResponseBody(TeaModel):
    def __init__(
        self,
        monitor_config_id: str = None,
        request_id: str = None,
    ):
        # The ID of the health check configuration.
        self.monitor_config_id = monitor_config_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddDnsGtmMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDnsGtmMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDnsGtmMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDomainRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        group_id: str = None,
        lang: str = None,
        resource_group_id: str = None,
    ):
        # The domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The ID of the group to which the domain name will belong. The default value is the ID of the default group.
        self.group_id = group_id
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang
        # The ID of the resource group.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class AddDomainResponseBodyDnsServers(TeaModel):
    def __init__(
        self,
        dns_server: List[str] = None,
    ):
        self.dns_server = dns_server

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server is not None:
            result['DnsServer'] = self.dns_server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServer') is not None:
            self.dns_server = m.get('DnsServer')
        return self


class AddDomainResponseBody(TeaModel):
    def __init__(
        self,
        dns_servers: AddDomainResponseBodyDnsServers = None,
        domain_id: str = None,
        domain_name: str = None,
        group_id: str = None,
        group_name: str = None,
        puny_code: str = None,
        request_id: str = None,
    ):
        # The Domain Name System (DNS) servers configured for the domain name.
        self.dns_servers = dns_servers
        # The ID of the domain name.
        self.domain_id = domain_id
        # The domain name.
        self.domain_name = domain_name
        # The ID of the domain name group.
        self.group_id = group_id
        # The name of the domain name group.
        self.group_name = group_name
        # The Punycode for the domain name. This parameter is returned only for Chinese domain names.
        self.puny_code = puny_code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.dns_servers:
            self.dns_servers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_servers is not None:
            result['DnsServers'] = self.dns_servers.to_map()
        if self.domain_id is not None:
            result['DomainId'] = self.domain_id
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.puny_code is not None:
            result['PunyCode'] = self.puny_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServers') is not None:
            temp_model = AddDomainResponseBodyDnsServers()
            self.dns_servers = temp_model.from_map(m['DnsServers'])
        if m.get('DomainId') is not None:
            self.domain_id = m.get('DomainId')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('PunyCode') is not None:
            self.puny_code = m.get('PunyCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDomainBackupRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        period_type: str = None,
    ):
        # The domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang
        # The backup cycle. Valid values:
        # 
        # *   DAY: backs up data on a daily basis.
        # *   HOUR: backs up data on an hourly basis.
        # 
        # This parameter is required.
        self.period_type = period_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.period_type is not None:
            result['PeriodType'] = self.period_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PeriodType') is not None:
            self.period_type = m.get('PeriodType')
        return self


class AddDomainBackupResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        period_type: str = None,
        request_id: str = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The backup cycle.
        self.period_type = period_type
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.period_type is not None:
            result['PeriodType'] = self.period_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('PeriodType') is not None:
            self.period_type = m.get('PeriodType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddDomainBackupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDomainBackupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDomainBackupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDomainGroupRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        lang: str = None,
    ):
        # The name of the domain name group.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class AddDomainGroupResponseBody(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_name: str = None,
        request_id: str = None,
    ):
        # The ID of the domain name group.
        self.group_id = group_id
        # The name of the domain name group.
        self.group_name = group_name
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddDomainGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDomainGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDomainGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDomainRecordRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        line: str = None,
        priority: int = None,
        rr: str = None,
        ttl: int = None,
        type: str = None,
        user_client_ip: str = None,
        value: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English Default: **zh**\
        self.lang = lang
        # The resolution line. Default value: **default**. For more information, see
        # 
        # [DNS resolution lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).
        self.line = line
        # The priority of the mail exchanger (MX) record. Valid values: `1 to 50`.
        # 
        # This parameter is required if the type of the DNS record is MX. A smaller value indicates a higher priority.
        self.priority = priority
        # The hostname.
        # 
        # For example, to resolve @.example.com, you must set this parameter to an at sign (@). You cannot leave this parameter empty.
        # 
        # This parameter is required.
        self.rr = rr
        # The time to live (TTL) period of the Alibaba Cloud DNS (DNS) record. Default value: 600. Unit: seconds. For more information, see
        # 
        # [TTL definition](https://www.alibabacloud.com/help/zh/doc-detail/29806.htm).
        self.ttl = ttl
        # The type of the DNS record. For more information, see
        # 
        # [DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).
        # 
        # This parameter is required.
        self.type = type
        # The IP address of the client.
        self.user_client_ip = user_client_ip
        # The value of the DNS record.
        # 
        # This parameter is required.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line is not None:
            result['Line'] = self.line
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.rr is not None:
            result['RR'] = self.rr
        if self.ttl is not None:
            result['TTL'] = self.ttl
        if self.type is not None:
            result['Type'] = self.type
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('TTL') is not None:
            self.ttl = m.get('TTL')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AddDomainRecordResponseBody(TeaModel):
    def __init__(
        self,
        record_id: str = None,
        request_id: str = None,
    ):
        # The ID of the DNS record.
        self.record_id = record_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddDomainRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDomainRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDomainRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddGtmAccessStrategyRequest(TeaModel):
    def __init__(
        self,
        access_lines: str = None,
        default_addr_pool_id: str = None,
        failover_addr_pool_id: str = None,
        instance_id: str = None,
        lang: str = None,
        strategy_name: str = None,
    ):
        # The line codes of access regions.
        # 
        # This parameter is required.
        self.access_lines = access_lines
        # The ID of the default address pool.
        # 
        # This parameter is required.
        self.default_addr_pool_id = default_addr_pool_id
        # The ID of the failover address pool.
        # 
        # If the failover address pool is not set, pass the **Empty** value.
        # 
        # This parameter is required.
        self.failover_addr_pool_id = failover_addr_pool_id
        # The ID of the GTM instance for which you want to create an access policy.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language used by the user.
        self.lang = lang
        # The name of the access policy.
        # 
        # This parameter is required.
        self.strategy_name = strategy_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_lines is not None:
            result['AccessLines'] = self.access_lines
        if self.default_addr_pool_id is not None:
            result['DefaultAddrPoolId'] = self.default_addr_pool_id
        if self.failover_addr_pool_id is not None:
            result['FailoverAddrPoolId'] = self.failover_addr_pool_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessLines') is not None:
            self.access_lines = m.get('AccessLines')
        if m.get('DefaultAddrPoolId') is not None:
            self.default_addr_pool_id = m.get('DefaultAddrPoolId')
        if m.get('FailoverAddrPoolId') is not None:
            self.failover_addr_pool_id = m.get('FailoverAddrPoolId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class AddGtmAccessStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        strategy_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the access policy created.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class AddGtmAccessStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddGtmAccessStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddGtmAccessStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddGtmAddressPoolRequestAddr(TeaModel):
    def __init__(
        self,
        lba_weight: int = None,
        mode: str = None,
        value: str = None,
    ):
        # The weight of the address pool.
        self.lba_weight = lba_weight
        # The mode of the address pool. Valid values:
        # 
        # *   **SMART**: smart return
        # *   **ONLINE**: always online
        # *   **OFFLINE**: always offline
        self.mode = mode
        # The address in the address pool.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AddGtmAddressPoolRequestIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        isp_code: str = None,
    ):
        # The code of the city where the monitored node is deployed. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
        self.city_code = city_code
        # *   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
        # *   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
        # *   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.
        self.isp_code = isp_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        return self


class AddGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        addr: List[AddGtmAddressPoolRequestAddr] = None,
        evaluation_count: int = None,
        instance_id: str = None,
        interval: int = None,
        isp_city_node: List[AddGtmAddressPoolRequestIspCityNode] = None,
        lang: str = None,
        min_available_addr_num: int = None,
        monitor_extend_info: str = None,
        monitor_status: str = None,
        name: str = None,
        protocol_type: str = None,
        timeout: int = None,
        type: str = None,
    ):
        # The address pools.
        # 
        # This parameter is required.
        self.addr = addr
        # The number of consecutive failures.
        self.evaluation_count = evaluation_count
        # The ID of the GTM instance for which you want to create an address pool.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The health check interval. Unit: seconds. Set the value to 60.
        self.interval = interval
        # The monitored nodes.
        self.isp_city_node = isp_city_node
        # The language of the values of specific response parameters.
        self.lang = lang
        # The minimum number of available addresses in the address pool.
        # 
        # This parameter is required.
        self.min_available_addr_num = min_available_addr_num
        # The extended information. The required parameters vary based on the value of ProtocolType.
        # 
        # When ProtocolType is set to HTTP or HTTPS:
        # 
        # *   port: the port that you want to check
        # *   failureRate: the failure rate
        # *   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
        # *   host: the host settings
        # *   path: the URL path
        # 
        # When ProtocolType is set to PING:
        # 
        # *   packetNum: the number of ping packets
        # *   packetLossRate: the packet loss rate
        # *   failureRate: the failure rate
        # 
        # When ProtocolType is set to TCP:
        # 
        # *   port: the port that you want to check
        # *   failureRate: the failure rate
        self.monitor_extend_info = monitor_extend_info
        # Specifies whether to enable the health check. Valid values:
        # 
        # *   **OPEN**: enables the health check.
        # *   **CLOSE**: disables the health check. This is the default value.
        self.monitor_status = monitor_status
        # The name of the address pool.
        # 
        # This parameter is required.
        self.name = name
        # The health check protocol. Valid values:
        # 
        # *   HTTP
        # *   HTTPS
        # *   Ping
        # *   TCP
        self.protocol_type = protocol_type
        # The timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
        self.timeout = timeout
        # The type of the address pool. Valid values:
        # 
        # *   **IP**: IPv4 address
        # *   **DOMAIN**: domain name
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.addr:
            for k in self.addr:
                if k:
                    k.validate()
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addr'] = []
        if self.addr is not None:
            for k in self.addr:
                result['Addr'].append(k.to_map() if k else None)
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.interval is not None:
            result['Interval'] = self.interval
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.min_available_addr_num is not None:
            result['MinAvailableAddrNum'] = self.min_available_addr_num
        if self.monitor_extend_info is not None:
            result['MonitorExtendInfo'] = self.monitor_extend_info
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.name is not None:
            result['Name'] = self.name
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr = []
        if m.get('Addr') is not None:
            for k in m.get('Addr'):
                temp_model = AddGtmAddressPoolRequestAddr()
                self.addr.append(temp_model.from_map(k))
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = AddGtmAddressPoolRequestIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MinAvailableAddrNum') is not None:
            self.min_available_addr_num = m.get('MinAvailableAddrNum')
        if m.get('MonitorExtendInfo') is not None:
            self.monitor_extend_info = m.get('MonitorExtendInfo')
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        monitor_config_id: str = None,
        request_id: str = None,
    ):
        # The ID of the address pool created.
        self.addr_pool_id = addr_pool_id
        # The ID of the health check configuration.
        self.monitor_config_id = monitor_config_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddGtmMonitorRequestIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        isp_code: str = None,
    ):
        # The city code.
        # 
        # Specify the parameter according to the value of CityCode returned by the DescribeGtmMonitorAvailableConfig operation.
        self.city_code = city_code
        # The Internet service provider (ISP) node. Specify the parameter according to the value of IspCode returned by the DescribeGtmMonitorAvailableConfig operation.
        # 
        # *   If the return value of GroupType for the DescribeGtmMonitorAvailableConfig operation is BGP or Overseas, IspCode is not required and is set to 465 by default.
        # *   If the return value of GroupType for the DescribeGtmMonitorAvailableConfig operation is not BGP or Overseas, IspCode is required. When IspCode is specified, CityCode is required.
        self.isp_code = isp_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        return self


class AddGtmMonitorRequest(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        evaluation_count: int = None,
        interval: int = None,
        isp_city_node: List[AddGtmMonitorRequestIspCityNode] = None,
        lang: str = None,
        monitor_extend_info: str = None,
        protocol_type: str = None,
        timeout: int = None,
    ):
        # The ID of the address pool.
        # 
        # This parameter is required.
        self.addr_pool_id = addr_pool_id
        # The number of consecutive failures.
        # 
        # This parameter is required.
        self.evaluation_count = evaluation_count
        # The health check interval. Unit: seconds. Set the value to 60.
        # 
        # This parameter is required.
        self.interval = interval
        # The nodes for monitoring.
        # 
        # This parameter is required.
        self.isp_city_node = isp_city_node
        # The language.
        self.lang = lang
        # The extended information. The required parameters vary based on the health check protocol.
        # 
        # HTTP or HTTPS
        # 
        # *   port: the port that you want to check
        # *   failureRate: the failure rate
        # *   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
        # *   host: the host settings
        # *   path: the URL path
        # 
        # PING
        # 
        # *   packetNum: the number of ping packets
        # *   packetLossRate: the packet loss rate
        # *   failureRate: the failure rate
        # 
        # TCP
        # 
        # *   port: the port that you want to check
        # *   failureRate: the failure rate
        # 
        # This parameter is required.
        self.monitor_extend_info = monitor_extend_info
        # The protocol used for the health check. Valid values:
        # 
        # *   HTTP
        # *   HTTPS
        # *   PING
        # *   TCP
        # 
        # This parameter is required.
        self.protocol_type = protocol_type
        # The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
        # 
        # This parameter is required.
        self.timeout = timeout

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.interval is not None:
            result['Interval'] = self.interval
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.monitor_extend_info is not None:
            result['MonitorExtendInfo'] = self.monitor_extend_info
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = AddGtmMonitorRequestIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MonitorExtendInfo') is not None:
            self.monitor_extend_info = m.get('MonitorExtendInfo')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class AddGtmMonitorResponseBody(TeaModel):
    def __init__(
        self,
        monitor_config_id: str = None,
        request_id: str = None,
    ):
        # The ID of the health check configuration.
        self.monitor_config_id = monitor_config_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddGtmMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddGtmMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddGtmMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddGtmRecoveryPlanRequest(TeaModel):
    def __init__(
        self,
        fault_addr_pool: str = None,
        lang: str = None,
        name: str = None,
        remark: str = None,
    ):
        # The IDs of faulty address pools.
        # 
        # This parameter is required.
        self.fault_addr_pool = fault_addr_pool
        # The language.
        self.lang = lang
        # The name of the disaster recovery plan.
        # 
        # This parameter is required.
        self.name = name
        # The description of the disaster recovery plan.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fault_addr_pool is not None:
            result['FaultAddrPool'] = self.fault_addr_pool
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FaultAddrPool') is not None:
            self.fault_addr_pool = m.get('FaultAddrPool')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class AddGtmRecoveryPlanResponseBody(TeaModel):
    def __init__(
        self,
        recovery_plan_id: str = None,
        request_id: str = None,
    ):
        # The ID of the disaster recovery plan.
        self.recovery_plan_id = recovery_plan_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddGtmRecoveryPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddGtmRecoveryPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddGtmRecoveryPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindInstanceDomainsRequest(TeaModel):
    def __init__(
        self,
        domain_names: str = None,
        instance_id: str = None,
        lang: str = None,
    ):
        # The domain names.
        # 
        # >  Separate multiple domain names with commas (,). Up to 100 domain names can be entered.
        # 
        # This parameter is required.
        self.domain_names = domain_names
        # The instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_names is not None:
            result['DomainNames'] = self.domain_names
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainNames') is not None:
            self.domain_names = m.get('DomainNames')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class BindInstanceDomainsResponseBody(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        request_id: str = None,
        success_count: int = None,
    ):
        # The number of domain names that failed to be bound to the instance.
        self.failed_count = failed_count
        # The request ID.
        self.request_id = request_id
        # The number of domain names that are bound to the instance.
        self.success_count = success_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class BindInstanceDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindInstanceDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindInstanceDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeDomainGroupRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        group_id: str = None,
        lang: str = None,
    ):
        # The domain name. You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The ID of the target domain name group.
        # 
        # *   If you do not specify GroupId, the domain name belongs to the default group.
        # *   If you specify an empty string "" for GroupId, the domain name belongs to the default group.
        # *   If you set GroupId to defaultGroup, the domain name belongs to the default group.
        # *   If you specify GroupId to another value and the value is verified existent, the value of GroupId for the target domain name is updated. If the value is verified inexistent, the value of GroupId for the target domain name is not updated.
        self.group_id = group_id
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class ChangeDomainGroupResponseBody(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_name: str = None,
        request_id: str = None,
    ):
        # The ID of the target domain name group.
        self.group_id = group_id
        # The name of the destination domain name group.
        self.group_name = group_name
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeDomainGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeDomainGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeDomainGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeDomainOfDnsProductRequest(TeaModel):
    def __init__(
        self,
        force: bool = None,
        instance_id: str = None,
        lang: str = None,
        new_domain: str = None,
        user_client_ip: str = None,
    ):
        # Specifies whether to forcibly bind a domain name to the instance. Valid values:
        # 
        # *   **false****: no**\
        # *   **true**: **yes**\
        # 
        # Default value: **false**.
        self.force = force
        # The ID of the Alibaba Cloud Domain Name System (DNS) instance.
        # 
        # You can call the [ListCloudGtmInstances ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        # 
        # Default value: **zh**.
        self.lang = lang
        # The domain name that you want to bind to the instance. If you leave this parameter empty, the domain name that is bound to the instance is unbound from the instance.
        self.new_domain = new_domain
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.new_domain is not None:
            result['NewDomain'] = self.new_domain
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NewDomain') is not None:
            self.new_domain = m.get('NewDomain')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class ChangeDomainOfDnsProductResponseBody(TeaModel):
    def __init__(
        self,
        original_domain: str = None,
        request_id: str = None,
    ):
        # The domain name that is originally bound to the instance. If no value is returned for this parameter, the instance is bound to a domain name for the first time.
        self.original_domain = original_domain
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_domain is not None:
            result['OriginalDomain'] = self.original_domain
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OriginalDomain') is not None:
            self.original_domain = m.get('OriginalDomain')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeDomainOfDnsProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeDomainOfDnsProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeDomainOfDnsProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyGtmConfigRequest(TeaModel):
    def __init__(
        self,
        copy_type: str = None,
        lang: str = None,
        source_id: str = None,
        target_id: str = None,
    ):
        # The type of the object that is copied. Only the INSTANCE type is supported.
        # 
        # This parameter is required.
        self.copy_type = copy_type
        # The language.
        self.lang = lang
        # The ID of the source object. Only instance IDs are supported.
        # 
        # This parameter is required.
        self.source_id = source_id
        # The ID of the target object. Only instance IDs are supported.
        # 
        # This parameter is required.
        self.target_id = target_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.copy_type is not None:
            result['CopyType'] = self.copy_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_id is not None:
            result['SourceId'] = self.source_id
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CopyType') is not None:
            self.copy_type = m.get('CopyType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceId') is not None:
            self.source_id = m.get('SourceId')
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        return self


class CopyGtmConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CopyGtmConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CopyGtmConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyGtmConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCloudGtmAddressRequestHealthTasks(TeaModel):
    def __init__(
        self,
        port: int = None,
        template_id: str = None,
    ):
        # The service port of the address on which health check tasks are performed. If the ping protocol is used for health checks, the configuration of the service port is not supported.
        self.port = port
        # The ID of the health check template associated with the address.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['Port'] = self.port
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateCloudGtmAddressRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        client_token: str = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_tasks: List[CreateCloudGtmAddressRequestHealthTasks] = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        type: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # IP address or domain name.
        # 
        # This parameter is required.
        self.address = address
        # Address ownership information.
        self.attribute_info = attribute_info
        # The failover mode that is used when address exceptions are identified. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # 
        # This parameter is required.
        self.available_mode = available_mode
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # Indicates the current enabled status of the address:
        # - enable: Enabled status 
        # - disable: Disabled status
        # 
        # This parameter is required.
        self.enable_status = enable_status
        # The condition for determining the health status of the address. This parameter is required when HealthTasks is specified. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        # 
        # This parameter is required.
        self.health_judgement = health_judgement
        # The health check tasks associated with the address.
        self.health_tasks = health_tasks
        # The availability state of the address. This parameter is required when AvailableMode is set to **manual**. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        # 
        # This parameter is required.
        self.name = name
        # Remarks.
        self.remark = remark
        # Address type:
        # - IPv4
        # - IPv6
        # - domain
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.health_tasks:
            for k in self.health_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address is not None:
            result['Address'] = self.address
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        result['HealthTasks'] = []
        if self.health_tasks is not None:
            for k in self.health_tasks:
                result['HealthTasks'].append(k.to_map() if k else None)
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        self.health_tasks = []
        if m.get('HealthTasks') is not None:
            for k in m.get('HealthTasks'):
                temp_model = CreateCloudGtmAddressRequestHealthTasks()
                self.health_tasks.append(temp_model.from_map(k))
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateCloudGtmAddressShrinkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        client_token: str = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_tasks_shrink: str = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        type: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # IP address or domain name.
        # 
        # This parameter is required.
        self.address = address
        # Address ownership information.
        self.attribute_info = attribute_info
        # The failover mode that is used when address exceptions are identified. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # 
        # This parameter is required.
        self.available_mode = available_mode
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # Indicates the current enabled status of the address:
        # - enable: Enabled status 
        # - disable: Disabled status
        # 
        # This parameter is required.
        self.enable_status = enable_status
        # The condition for determining the health status of the address. This parameter is required when HealthTasks is specified. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        # 
        # This parameter is required.
        self.health_judgement = health_judgement
        # The health check tasks associated with the address.
        self.health_tasks_shrink = health_tasks_shrink
        # The availability state of the address. This parameter is required when AvailableMode is set to **manual**. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        # 
        # This parameter is required.
        self.name = name
        # Remarks.
        self.remark = remark
        # Address type:
        # - IPv4
        # - IPv6
        # - domain
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address is not None:
            result['Address'] = self.address
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_tasks_shrink is not None:
            result['HealthTasks'] = self.health_tasks_shrink
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthTasks') is not None:
            self.health_tasks_shrink = m.get('HealthTasks')
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateCloudGtmAddressResponseBody(TeaModel):
    def __init__(
        self,
        address_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the address creation operation is successful:
        # - true: Operation was successful
        # - false: Operation was failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateCloudGtmAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCloudGtmAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCloudGtmAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCloudGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        client_token: str = None,
        enable_status: str = None,
        health_judgement: str = None,
        remark: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # Address pool name, helping users distinguish the purpose of address pools.
        self.address_pool_name = address_pool_name
        # The type of the address pool. Valid values:
        # 
        # *   IPv4: IPv4 addresses are returned for Domain Name System (DNS) resolution.
        # *   IPv6: IPv6 addresses are returned for DNS resolution.
        # *   domain: Domain names are returned for DNS resolution.
        self.address_pool_type = address_pool_type
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The enabling state of the address pool. Valid values:
        # 
        # *   enable: The address pool is enabled, and the addresses in the address pool are returned for DNS resolution when the health check results are normal.
        # *   disable: The address pool is disabled, and the addresses in the address pool are not returned for DNS resolution regardless of whether the health check results are normal or not.
        self.enable_status = enable_status
        # The condition for determining the health status of the address pool. Valid values:
        # 
        # *   any_ok: At least one address in the address pool is available.
        # *   p30_ok: At least 30% of the addresses in the address pool are available.
        # *   p50_ok: At least 50% of the addresses in the address pool are available.
        # *   p70_ok: At least 70% of the addresses in the address pool are available.
        # *   all_ok: All addresses in the address pool are available.
        self.health_judgement = health_judgement
        # Remarks for the address pool, helping users distinguish the usage scenarios of different address pools.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class CreateCloudGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the address pool creation operation was successful:
        # - true: Operation was successful
        # - false: Operation was failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateCloudGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCloudGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCloudGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCloudGtmInstanceConfigRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        enable_status: str = None,
        instance_id: str = None,
        remark: str = None,
        schedule_hostname: str = None,
        schedule_rr_type: str = None,
        schedule_zone_mode: str = None,
        schedule_zone_name: str = None,
        ttl: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
        # *   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance is unavailable.
        self.enable_status = enable_status
        # The ID of the Global Traffic Manager (GTM) 3.0 instance. This ID uniquely identifies a GTM 3.0 instance.
        self.instance_id = instance_id
        # The description of the access domain name.
        self.remark = remark
        # The hostname of the access domain name.
        self.schedule_hostname = schedule_hostname
        # The type of the Domain Name System (DNS) record configured for the access domain name. Valid values:
        # 
        # *   A: IPv4 address
        # *   AAAA: IPv6 address
        # *   CNAME: domain name
        self.schedule_rr_type = schedule_rr_type
        # The configuration mode of the access domain name. Valid values:
        # 
        # *   sys_assign: system allocation. This mode is not supported.
        # *   custom: custom allocation. You must select a zone within the account to which the instance belongs and enter a hostname to generate an access domain name.
        self.schedule_zone_mode = schedule_zone_mode
        # The name of the parent zone for the access domain name configured in GTM. In most cases, the value of this parameter is the name of a zone hosted by Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs. You can specify the name of a zone or subzone.
        self.schedule_zone_name = schedule_zone_name
        # The global time to live (TTL) period. Unit: seconds. The global TTL period affects how long the DNS records that map the access domain name to the addresses in the address pools are cached in the local DNS servers of Internet service providers (ISPs). You can specify a custom value.
        self.ttl = ttl

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schedule_hostname is not None:
            result['ScheduleHostname'] = self.schedule_hostname
        if self.schedule_rr_type is not None:
            result['ScheduleRrType'] = self.schedule_rr_type
        if self.schedule_zone_mode is not None:
            result['ScheduleZoneMode'] = self.schedule_zone_mode
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScheduleHostname') is not None:
            self.schedule_hostname = m.get('ScheduleHostname')
        if m.get('ScheduleRrType') is not None:
            self.schedule_rr_type = m.get('ScheduleRrType')
        if m.get('ScheduleZoneMode') is not None:
            self.schedule_zone_mode = m.get('ScheduleZoneMode')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        return self


class CreateCloudGtmInstanceConfigResponseBody(TeaModel):
    def __init__(
        self,
        config_id: bool = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        self.config_id = config_id
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateCloudGtmInstanceConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCloudGtmInstanceConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCloudGtmInstanceConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCloudGtmMonitorTemplateRequestIspCityNodes(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        isp_code: str = None,
    ):
        # The city code of the health check node.
        self.city_code = city_code
        # The Internet service provider (ISP) code of the health check node.
        self.isp_code = isp_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        return self


class CreateCloudGtmMonitorTemplateRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        evaluation_count: int = None,
        extend_info: str = None,
        failure_rate: int = None,
        interval: int = None,
        ip_version: str = None,
        isp_city_nodes: List[CreateCloudGtmMonitorTemplateRequestIspCityNodes] = None,
        name: str = None,
        protocol: str = None,
        timeout: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # This parameter is required.
        self.evaluation_count = evaluation_count
        # The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.
        # 
        # *   HTTP or HTTPS:
        # 
        #     **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.
        # 
        #     **path**: the URL for HTTP or HTTPS health checks. Default value: /.
        # 
        #     **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:
        # 
        #     *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
        #     *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.
        # 
        #     **sni**: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:
        # 
        #     *   true: enables SNI.
        #     *   false: disables SNI.
        # 
        #     **followRedirect**: specifies whether to follow 3XX redirects. Valid values:
        # 
        #     *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
        #     *   false: does not follow 3XX redirects.
        # 
        # *   ping:
        # 
        #     **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.
        # 
        #     **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.
        self.extend_info = extend_info
        # This parameter is required.
        self.failure_rate = failure_rate
        # This parameter is required.
        self.interval = interval
        # The IP address type of health check nodes. Valid values:
        # 
        # *   IPv4: You can set IpVersion to IPv4 to perform health checks on IPv4 addresses.
        # *   IPv6: You can set IpVersion to IPv6 to perform health checks on IPv6 addresses.
        # 
        # This parameter is required.
        self.ip_version = ip_version
        # The health check nodes. You can call the [ListCloudGtmMonitorNodes](~~ListCloudGtmMonitorNodes~~) operation to obtain the health check nodes.
        # 
        # This parameter is required.
        self.isp_city_nodes = isp_city_nodes
        # The name of the health check template. We recommend that you use a name that distinguishes the type of health check protocol used.
        # 
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.protocol = protocol
        # This parameter is required.
        self.timeout = timeout

    def validate(self):
        if self.isp_city_nodes:
            for k in self.isp_city_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.extend_info is not None:
            result['ExtendInfo'] = self.extend_info
        if self.failure_rate is not None:
            result['FailureRate'] = self.failure_rate
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.ip_version is not None:
            result['IpVersion'] = self.ip_version
        result['IspCityNodes'] = []
        if self.isp_city_nodes is not None:
            for k in self.isp_city_nodes:
                result['IspCityNodes'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('ExtendInfo') is not None:
            self.extend_info = m.get('ExtendInfo')
        if m.get('FailureRate') is not None:
            self.failure_rate = m.get('FailureRate')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IpVersion') is not None:
            self.ip_version = m.get('IpVersion')
        self.isp_city_nodes = []
        if m.get('IspCityNodes') is not None:
            for k in m.get('IspCityNodes'):
                temp_model = CreateCloudGtmMonitorTemplateRequestIspCityNodes()
                self.isp_city_nodes.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class CreateCloudGtmMonitorTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        evaluation_count: int = None,
        extend_info: str = None,
        failure_rate: int = None,
        interval: int = None,
        ip_version: str = None,
        isp_city_nodes_shrink: str = None,
        name: str = None,
        protocol: str = None,
        timeout: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # This parameter is required.
        self.evaluation_count = evaluation_count
        # The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.
        # 
        # *   HTTP or HTTPS:
        # 
        #     **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.
        # 
        #     **path**: the URL for HTTP or HTTPS health checks. Default value: /.
        # 
        #     **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:
        # 
        #     *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
        #     *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.
        # 
        #     **sni**: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:
        # 
        #     *   true: enables SNI.
        #     *   false: disables SNI.
        # 
        #     **followRedirect**: specifies whether to follow 3XX redirects. Valid values:
        # 
        #     *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
        #     *   false: does not follow 3XX redirects.
        # 
        # *   ping:
        # 
        #     **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.
        # 
        #     **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.
        self.extend_info = extend_info
        # This parameter is required.
        self.failure_rate = failure_rate
        # This parameter is required.
        self.interval = interval
        # The IP address type of health check nodes. Valid values:
        # 
        # *   IPv4: You can set IpVersion to IPv4 to perform health checks on IPv4 addresses.
        # *   IPv6: You can set IpVersion to IPv6 to perform health checks on IPv6 addresses.
        # 
        # This parameter is required.
        self.ip_version = ip_version
        # The health check nodes. You can call the [ListCloudGtmMonitorNodes](~~ListCloudGtmMonitorNodes~~) operation to obtain the health check nodes.
        # 
        # This parameter is required.
        self.isp_city_nodes_shrink = isp_city_nodes_shrink
        # The name of the health check template. We recommend that you use a name that distinguishes the type of health check protocol used.
        # 
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.protocol = protocol
        # This parameter is required.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.extend_info is not None:
            result['ExtendInfo'] = self.extend_info
        if self.failure_rate is not None:
            result['FailureRate'] = self.failure_rate
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.ip_version is not None:
            result['IpVersion'] = self.ip_version
        if self.isp_city_nodes_shrink is not None:
            result['IspCityNodes'] = self.isp_city_nodes_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('ExtendInfo') is not None:
            self.extend_info = m.get('ExtendInfo')
        if m.get('FailureRate') is not None:
            self.failure_rate = m.get('FailureRate')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IpVersion') is not None:
            self.ip_version = m.get('IpVersion')
        if m.get('IspCityNodes') is not None:
            self.isp_city_nodes_shrink = m.get('IspCityNodes')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class CreateCloudGtmMonitorTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        template_id: str = None,
    ):
        self.request_id = request_id
        self.success = success
        # The ID of the health check template. This ID uniquely identifies the health check template.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateCloudGtmMonitorTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCloudGtmMonitorTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCloudGtmMonitorTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePdnsAppKeyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        remark: str = None,
    ):
        self.lang = lang
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class CreatePdnsAppKeyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePdnsAppKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePdnsAppKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePdnsAppKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePdnsUdpIpSegmentRequest(TeaModel):
    def __init__(
        self,
        ip: str = None,
        ip_token: str = None,
        lang: str = None,
        name: str = None,
    ):
        self.ip = ip
        self.ip_token = ip_token
        self.lang = lang
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.ip_token is not None:
            result['IpToken'] = self.ip_token
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('IpToken') is not None:
            self.ip_token = m.get('IpToken')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreatePdnsUdpIpSegmentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        valid_message: str = None,
    ):
        self.request_id = request_id
        self.valid_message = valid_message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.valid_message is not None:
            result['ValidMessage'] = self.valid_message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ValidMessage') is not None:
            self.valid_message = m.get('ValidMessage')
        return self


class CreatePdnsUdpIpSegmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePdnsUdpIpSegmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePdnsUdpIpSegmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCloudGtmAddressRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_id: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The address ID. This ID uniquely identifies the address.
        # 
        # This parameter is required.
        self.address_id = address_id
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DeleteCloudGtmAddressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the address deletion operation was successful:
        # - true: Operation successful
        # - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCloudGtmAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCloudGtmAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCloudGtmAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCloudGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_id: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DeleteCloudGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCloudGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCloudGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCloudGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCloudGtmInstanceConfigRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration. You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.
        self.config_id = config_id
        # The access domain name that is configured for the desired GTM 3.0 instance. You can delete only one access domain name.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DeleteCloudGtmInstanceConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the operation to delete domain instance configurations was successful:
        # - true: Operation successful - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCloudGtmInstanceConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCloudGtmInstanceConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCloudGtmInstanceConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCloudGtmMonitorTemplateRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        template_id: str = None,
    ):
        # The language in which the returned results are displayed. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The ID of the health check template. This ID uniquely identifies a health check template.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteCloudGtmMonitorTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the operation to delete the health check template was successful:
        # - true: Operation successful
        # - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCloudGtmMonitorTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCloudGtmMonitorTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCloudGtmMonitorTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomLinesRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        line_ids: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The unique IDs of the custom lines that you want to delete. Separate the unique IDs with commas (,). You can call the [DescribeCustomLines](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.line_ids = line_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line_ids is not None:
            result['LineIds'] = self.line_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LineIds') is not None:
            self.line_ids = m.get('LineIds')
        return self


class DeleteCustomLinesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomLinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomLinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomLinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDnsCacheDomainRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English Default: **zh**\
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DeleteDnsCacheDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDnsCacheDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDnsCacheDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDnsCacheDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDnsGtmAccessStrategyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        strategy_id: str = None,
    ):
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The ID of the access policy.
        # 
        # This parameter is required.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class DeleteDnsGtmAccessStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDnsGtmAccessStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDnsGtmAccessStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDnsGtmAccessStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDnsGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        lang: str = None,
    ):
        # The ID of the address pool.
        # 
        # This parameter is required.
        self.addr_pool_id = addr_pool_id
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DeleteDnsGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDnsGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDnsGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDnsGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDomainRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
    ):
        # The domain name that already exists in Alibaba Cloud DNS. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DeleteDomainResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        request_id: str = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDomainGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        lang: str = None,
    ):
        # The ID of the domain name group. You can call the [DescribeDomainGroups](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DeleteDomainGroupResponseBody(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        request_id: str = None,
    ):
        # The name of the domain name group.
        self.group_name = group_name
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDomainGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDomainGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDomainGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDomainRecordRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        record_id: str = None,
        user_client_ip: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) to obtain the ID.
        # 
        # This parameter is required.
        self.record_id = record_id
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class DeleteDomainRecordResponseBody(TeaModel):
    def __init__(
        self,
        record_id: str = None,
        request_id: str = None,
    ):
        # The ID of the DNS record.
        self.record_id = record_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDomainRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDomainRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDomainRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGtmAccessStrategyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        strategy_id: str = None,
    ):
        # The language used by the user.
        self.lang = lang
        # The ID of the access policy that you want to delete.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class DeleteGtmAccessStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteGtmAccessStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGtmAccessStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGtmAccessStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        lang: str = None,
    ):
        # The ID of the address pool that you want to delete.
        # 
        # This parameter is required.
        self.addr_pool_id = addr_pool_id
        # The language used by the user.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DeleteGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGtmRecoveryPlanRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        recovery_plan_id: int = None,
    ):
        # The language used by the user.
        self.lang = lang
        # The ID of the disaster recovery plan that you want to delete.
        # 
        # This parameter is required.
        self.recovery_plan_id = recovery_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        return self


class DeleteGtmRecoveryPlanResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteGtmRecoveryPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGtmRecoveryPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGtmRecoveryPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSubDomainRecordsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        rr: str = None,
        type: str = None,
        user_client_ip: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The hostname field in the DNS record.
        # 
        # For example, if you want to resolve @.example.com, you must set this parameter to an at sign (@) instead of leaving it empty.
        # 
        # This parameter is required.
        self.rr = rr
        # The type of DNS records. If you do not specify this parameter, all types of DNS records corresponding to the subdomain are returned.
        # 
        # Valid values: **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**. The value is not case-sensitive.
        self.type = type
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.rr is not None:
            result['RR'] = self.rr
        if self.type is not None:
            result['Type'] = self.type
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class DeleteSubDomainRecordsResponseBody(TeaModel):
    def __init__(
        self,
        rr: str = None,
        request_id: str = None,
        total_count: str = None,
    ):
        # The hostname.
        self.rr = rr
        # The request ID.
        self.request_id = request_id
        # The total number of the DNS records to be deleted.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rr is not None:
            result['RR'] = self.rr
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DeleteSubDomainRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSubDomainRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSubDomainRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBatchResultCountRequest(TeaModel):
    def __init__(
        self,
        batch_type: str = None,
        lang: str = None,
        task_id: int = None,
    ):
        # The type of the batch operation. Valid values:
        # 
        # *   **DOMAIN_ADD**: adds domain names in batches.
        # *   **DOMAIN_DEL**: deletes domain names in batches.
        # *   **RR_ADD**: adds Domain Name System (DNS) records in batches.
        # *   **RR_DEL**: deletes DNS records in batches.
        # 
        # >  If you do not specify this parameter, filtering is not required.
        self.batch_type = batch_type
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The task ID.
        # 
        # >  If you specify TaskId, the execution result of the specified task is returned. If you do not specify TaskId, the execution result of the last task is returned.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeBatchResultCountResponseBody(TeaModel):
    def __init__(
        self,
        batch_type: str = None,
        failed_count: int = None,
        reason: str = None,
        request_id: str = None,
        status: int = None,
        success_count: int = None,
        task_id: int = None,
        total_count: int = None,
    ):
        # The type of the batch operation.
        self.batch_type = batch_type
        # The total number of domain names or DNS records that failed to be processed.
        self.failed_count = failed_count
        # The cause of the execution failure.
        self.reason = reason
        # The request ID.
        self.request_id = request_id
        # The state of the task. Valid values:
        # 
        # *   **-1**: No task for importing domain names or DNS records is submitted.
        # *   **0**: The task is being processed.
        # *   **1**: The task is complete.
        # *   **2**: The task failed.
        self.status = status
        # The total number of domain names or DNS records that were processed.
        self.success_count = success_count
        # The ID of the last task.
        self.task_id = task_id
        # The total number of DNS records that were processed in batches.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBatchResultCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBatchResultCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBatchResultCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBatchResultDetailRequest(TeaModel):
    def __init__(
        self,
        batch_type: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        status: str = None,
        task_id: int = None,
    ):
        # The type of the batch operation. Valid values:
        # 
        # *   **DOMAIN_ADD**: adds domain names in batches.
        # *   **DOMAIN_DEL**: deletes domain names in batches.
        # *   **RR_ADD**: adds Domain Name System (DNS) records in batches.
        # *   **RR_DEL**: deletes DNS records in batches.
        # 
        # >  Do not perform filtering when this field is empty.
        self.batch_type = batch_type
        # The language of the content within the request and response. Default: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The execution result. If you do not specify this parameter, all results are returned.
        self.status = status
        # The task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail(TeaModel):
    def __init__(
        self,
        batch_type: str = None,
        domain: str = None,
        line: str = None,
        new_rr: str = None,
        new_value: str = None,
        operate_date_str: str = None,
        priority: str = None,
        reason: str = None,
        record_id: str = None,
        remark: str = None,
        rr: str = None,
        rr_status: str = None,
        status: bool = None,
        ttl: str = None,
        type: str = None,
        value: str = None,
    ):
        # The type of the batch operation.
        self.batch_type = batch_type
        # The domain name.
        self.domain = domain
        # The line code.
        self.line = line
        # The new hostname.
        self.new_rr = new_rr
        # The new record value.
        self.new_value = new_value
        # The time when the operation was performed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.operate_date_str = operate_date_str
        # The priority of the mail exchanger (MX) record.
        self.priority = priority
        # The cause of the execution failure.
        self.reason = reason
        # The ID of the DNS record.
        self.record_id = record_id
        # The description of the DNS record.
        self.remark = remark
        # The hostname.
        self.rr = rr
        # The status of the DNS record.
        self.rr_status = rr_status
        # The execution result of the batch operation. Valid values: **true**: The operation succeeded. **false**: The operation failed.
        self.status = status
        # The time-to-live (TTL) of the DNS record.
        self.ttl = ttl
        # The type of the DNS record.
        self.type = type
        # The value of the DNS record.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.line is not None:
            result['Line'] = self.line
        if self.new_rr is not None:
            result['NewRr'] = self.new_rr
        if self.new_value is not None:
            result['NewValue'] = self.new_value
        if self.operate_date_str is not None:
            result['OperateDateStr'] = self.operate_date_str
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.rr is not None:
            result['Rr'] = self.rr
        if self.rr_status is not None:
            result['RrStatus'] = self.rr_status
        if self.status is not None:
            result['Status'] = self.status
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('NewRr') is not None:
            self.new_rr = m.get('NewRr')
        if m.get('NewValue') is not None:
            self.new_value = m.get('NewValue')
        if m.get('OperateDateStr') is not None:
            self.operate_date_str = m.get('OperateDateStr')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Rr') is not None:
            self.rr = m.get('Rr')
        if m.get('RrStatus') is not None:
            self.rr_status = m.get('RrStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeBatchResultDetailResponseBodyBatchResultDetails(TeaModel):
    def __init__(
        self,
        batch_result_detail: List[DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail] = None,
    ):
        self.batch_result_detail = batch_result_detail

    def validate(self):
        if self.batch_result_detail:
            for k in self.batch_result_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BatchResultDetail'] = []
        if self.batch_result_detail is not None:
            for k in self.batch_result_detail:
                result['BatchResultDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.batch_result_detail = []
        if m.get('BatchResultDetail') is not None:
            for k in m.get('BatchResultDetail'):
                temp_model = DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail()
                self.batch_result_detail.append(temp_model.from_map(k))
        return self


class DescribeBatchResultDetailResponseBody(TeaModel):
    def __init__(
        self,
        batch_result_details: DescribeBatchResultDetailResponseBodyBatchResultDetails = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The detailed results of the batch operation.
        self.batch_result_details = batch_result_details
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.batch_result_details:
            self.batch_result_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_result_details is not None:
            result['BatchResultDetails'] = self.batch_result_details.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchResultDetails') is not None:
            temp_model = DescribeBatchResultDetailResponseBodyBatchResultDetails()
            self.batch_result_details = temp_model.from_map(m['BatchResultDetails'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBatchResultDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBatchResultDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBatchResultDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmAddressRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_id: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The address ID. This ID uniquely identifies the address.
        # 
        # This parameter is required.
        self.address_id = address_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask(TeaModel):
    def __init__(
        self,
        monitor_status: str = None,
        port: int = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The state of the health check task. Valid values:
        # 
        # *   ok: The task is normal.
        # *   alert: An alert is triggered.
        # *   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.
        self.monitor_status = monitor_status
        # The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.
        self.port = port
        # The ID of the health check template associated with the address.
        self.template_id = template_id
        # The name of the health check template.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.port is not None:
            result['Port'] = self.port
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class DescribeCloudGtmAddressResponseBodyHealthTasks(TeaModel):
    def __init__(
        self,
        health_task: List[DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask] = None,
    ):
        self.health_task = health_task

    def validate(self):
        if self.health_task:
            for k in self.health_task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HealthTask'] = []
        if self.health_task is not None:
            for k in self.health_task:
                result['HealthTask'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.health_task = []
        if m.get('HealthTask') is not None:
            for k in m.get('HealthTask'):
                temp_model = DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask()
                self.health_task.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmAddressResponseBody(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        health_tasks: DescribeCloudGtmAddressResponseBodyHealthTasks = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        request_id: str = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # IP address or domain name.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # Address ownership information.
        self.attribute_info = attribute_info
        # The failover method that is used if the address fails health checks. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        self.available_mode = available_mode
        # Address availability status:
        # - available: Available
        # - unavailable: Unavailable
        self.available_status = available_status
        # Address creation time.
        self.create_time = create_time
        # Creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Indicates the current enabled status of the address:
        # enabled: enabled state
        # disabled: disabled state
        self.enable_status = enable_status
        # The condition for determining the health status of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check state of the address. Valid values:
        # 
        # *   ok: The address passes all health checks of the referenced health check templates.
        # *   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
        # *   ok_no_monitor: The address does not reference a health check template.
        # *   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.
        self.health_status = health_status
        # The health check tasks referenced by the address.
        self.health_tasks = health_tasks
        # The availability state of the address when AvailableMode is set to manual. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        self.name = name
        # Remarks.
        self.remark = remark
        # Unique request identification code.
        self.request_id = request_id
        # Address type:
        # - IPv4
        # - IPv6
        # - domain
        self.type = type
        # The last modification time of the address configuration.
        self.update_time = update_time
        # Modified time (timestamp).
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.health_tasks:
            self.health_tasks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.health_tasks is not None:
            result['HealthTasks'] = self.health_tasks.to_map()
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('HealthTasks') is not None:
            temp_model = DescribeCloudGtmAddressResponseBodyHealthTasks()
            self.health_tasks = temp_model.from_map(m['HealthTasks'])
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeCloudGtmAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_id: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask(TeaModel):
    def __init__(
        self,
        port: int = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.
        self.port = port
        # ID of the health check template associated with the address.
        self.template_id = template_id
        # Health check template name.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['Port'] = self.port
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks(TeaModel):
    def __init__(
        self,
        health_task: List[DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask] = None,
    ):
        self.health_task = health_task

    def validate(self):
        if self.health_task:
            for k in self.health_task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HealthTask'] = []
        if self.health_task is not None:
            for k in self.health_task:
                result['HealthTask'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.health_task = []
        if m.get('HealthTask') is not None:
            for k in m.get('HealthTask'):
                temp_model = DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask()
                self.health_task.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource(TeaModel):
    def __init__(
        self,
        request_source: List[str] = None,
    ):
        self.request_source = request_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        return self


class DescribeCloudGtmAddressPoolResponseBodyAddressesAddress(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        health_tasks: DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        request_source: DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource = None,
        seq_non_preemptive_schedule: bool = None,
        serial_number: int = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
        weight_value: int = None,
    ):
        # IP address or domain name.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # Address ownership information, not supported in the current version.
        self.attribute_info = attribute_info
        # The failover method that is used if the address fails health checks. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        self.available_mode = available_mode
        # Address availability status:
        # - available: Address available
        # - unavailable: Address unavailable
        self.available_status = available_status
        # Address creation time.
        self.create_time = create_time
        # Address creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Address enable status, indicating whether the address is currently available:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check state of the address. Valid values:
        # 
        # *   ok: The address passes all health checks of the referenced health check templates.
        # *   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
        # *   ok_no_monitor: The address does not reference a health check template and is normal.
        # *   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.
        self.health_status = health_status
        # Health check task list.
        self.health_tasks = health_tasks
        # The availability state of the address when AvailableMode is set to manual. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        self.name = name
        # Remarks for the address.
        self.remark = remark
        # The request source list.
        self.request_source = request_source
        # Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: - true: yes - false: no
        self.seq_non_preemptive_schedule = seq_non_preemptive_schedule
        # Sequence number, indicating the priority of address return, where smaller numbers have higher priority.
        self.serial_number = serial_number
        # The address type. Valid values:
        # 
        # *   IPv4: IPv4 address
        # *   IPv6: IPv6 address
        # *   domain: domain name
        self.type = type
        # The last time the address was modified.
        self.update_time = update_time
        # The last modification time of the address (timestamp).
        self.update_timestamp = update_timestamp
        # Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address, enabling resolution queries to return addresses according to the weighted ratio.
        self.weight_value = weight_value

    def validate(self):
        if self.health_tasks:
            self.health_tasks.validate()
        if self.request_source:
            self.request_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.health_tasks is not None:
            result['HealthTasks'] = self.health_tasks.to_map()
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_source is not None:
            result['RequestSource'] = self.request_source.to_map()
        if self.seq_non_preemptive_schedule is not None:
            result['SeqNonPreemptiveSchedule'] = self.seq_non_preemptive_schedule
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('HealthTasks') is not None:
            temp_model = DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks()
            self.health_tasks = temp_model.from_map(m['HealthTasks'])
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestSource') is not None:
            temp_model = DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource()
            self.request_source = temp_model.from_map(m['RequestSource'])
        if m.get('SeqNonPreemptiveSchedule') is not None:
            self.seq_non_preemptive_schedule = m.get('SeqNonPreemptiveSchedule')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class DescribeCloudGtmAddressPoolResponseBodyAddresses(TeaModel):
    def __init__(
        self,
        address: List[DescribeCloudGtmAddressPoolResponseBodyAddressesAddress] = None,
    ):
        self.address = address

    def validate(self):
        if self.address:
            for k in self.address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Address'] = []
        if self.address is not None:
            for k in self.address:
                result['Address'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address = []
        if m.get('Address') is not None:
            for k in m.get('Address'):
                temp_model = DescribeCloudGtmAddressPoolResponseBodyAddressesAddress()
                self.address.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        address_lb_strategy: str = None,
        address_pool_id: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        addresses: DescribeCloudGtmAddressPoolResponseBodyAddresses = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        remark: str = None,
        request_id: str = None,
        sequence_lb_strategy_mode: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # Load balancing policy among addresses in the address pool:
        # - round_robin: Round-robin, where for any source of DNS resolution requests, all addresses are returned, with a rotation of the order for every request.
        # - sequence: Sequential, where for any source of DNS resolution requests, the address with the lower sequence number (indicating a higher priority, the smaller the number, the higher the priority) is returned. If the address with the lower sequence number is unavailable, the next address with a lower sequence number is returned.
        # - weight: Weighted, supporting the setting of different weight values for each address to realize returning addresses according to the weight ratio of query resolutions.
        # - source_nearest: Source-nearest, also known as intelligent resolution, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby servers.
        self.address_lb_strategy = address_lb_strategy
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name.
        self.address_pool_name = address_pool_name
        # Address pool type:
        # - IPv4
        # - IPv6
        # - domain
        self.address_pool_type = address_pool_type
        # The addresses.
        self.addresses = addresses
        # Address pool availability status:
        # - available: Available
        # - unavailable: Unavailable
        self.available_status = available_status
        # Address pool creation time.
        self.create_time = create_time
        # Address pool creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Address pool status:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address pool. Valid values:
        # 
        # *   any_ok: At least one address in the address pool is available.
        # *   p30_ok: At least 30% of the addresses in the address pool are available.
        # *   p50_ok: At least 50% of the addresses in the address pool are available.
        # *   p70_ok: At least 70% of the addresses in the address pool are available.
        # *   all_ok: All addresses in the address pool are available.
        self.health_judgement = health_judgement
        # The health state of the address pool. Valid values:
        # 
        # *   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
        # *   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for Domain Name System (DNS) requests.
        # *   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.
        self.health_status = health_status
        # Remarks for the address.
        self.remark = remark
        # Unique request identification code.
        self.request_id = request_id
        # The mode used if the address with the smallest sequence number is recovered. This parameter is returned only when the policy for load balancing between addresses is sequence. Valid values:
        # 
        # *   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
        # *   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # The last modification time of the address pool.
        self.update_time = update_time
        # Last modification time of the address pool (timestamp).
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.addresses:
            self.addresses.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_lb_strategy is not None:
            result['AddressLbStrategy'] = self.address_lb_strategy
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.addresses is not None:
            result['Addresses'] = self.addresses.to_map()
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressLbStrategy') is not None:
            self.address_lb_strategy = m.get('AddressLbStrategy')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('Addresses') is not None:
            temp_model = DescribeCloudGtmAddressPoolResponseBodyAddresses()
            self.addresses = temp_model.from_map(m['Addresses'])
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeCloudGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmAddressPoolReferenceRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_id: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig(TeaModel):
    def __init__(
        self,
        address_pool_lb_strategy: str = None,
        available_status: str = None,
        config_id: str = None,
        enable_status: str = None,
        health_status: str = None,
        instance_id: str = None,
        instance_name: str = None,
        remark: str = None,
        schedule_domain_name: str = None,
        schedule_hostname: str = None,
        schedule_rr_type: str = None,
        schedule_zone_name: str = None,
        sequence_lb_strategy_mode: str = None,
        ttl: int = None,
        version_code: str = None,
    ):
        # The policy for load balancing between address pools. Valid values:
        # 
        # *   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
        # *   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
        # *   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
        # *   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.
        self.address_pool_lb_strategy = address_pool_lb_strategy
        # The availability state of the access domain name. Valid values:
        # 
        # *   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
        # *   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.
        self.available_status = available_status
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        self.config_id = config_id
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
        # *   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.
        self.enable_status = enable_status
        # The health state of the access domain name. Valid values:
        # 
        # *   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
        # *   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
        # *   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.
        self.health_status = health_status
        # The ID of the Global Traffic Manager (GTM) 3.0 instance.
        self.instance_id = instance_id
        # Instance name.
        self.instance_name = instance_name
        # Remarks.
        self.remark = remark
        # The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.
        self.schedule_domain_name = schedule_domain_name
        # Host record of the domain accessed by GTM.
        self.schedule_hostname = schedule_hostname
        # DNS record types for scheduling domains:
        # - A: IPv4 address
        # - AAAA: IPv6 address
        # - CNAME: Domain name
        self.schedule_rr_type = schedule_rr_type
        # The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.
        self.schedule_zone_name = schedule_zone_name
        # The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
        # *   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Global TTL, the TTL value for resolving the accessed domain name to addresses in the address pool, which affects the caching time of DNS records in the operator\\"s LocalDNS. Supports custom TTL values.
        self.ttl = ttl
        # Global Traffic Management version 3.0 instance types:
        # - standard: Standard Edition
        # - ultimate: Ultimate Edition
        self.version_code = version_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_lb_strategy is not None:
            result['AddressPoolLbStrategy'] = self.address_pool_lb_strategy
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.schedule_hostname is not None:
            result['ScheduleHostname'] = self.schedule_hostname
        if self.schedule_rr_type is not None:
            result['ScheduleRrType'] = self.schedule_rr_type
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolLbStrategy') is not None:
            self.address_pool_lb_strategy = m.get('AddressPoolLbStrategy')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('ScheduleHostname') is not None:
            self.schedule_hostname = m.get('ScheduleHostname')
        if m.get('ScheduleRrType') is not None:
            self.schedule_rr_type = m.get('ScheduleRrType')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs(TeaModel):
    def __init__(
        self,
        instance_config: List[DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig] = None,
    ):
        self.instance_config = instance_config

    def validate(self):
        if self.instance_config:
            for k in self.instance_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceConfig'] = []
        if self.instance_config is not None:
            for k in self.instance_config:
                result['InstanceConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_config = []
        if m.get('InstanceConfig') is not None:
            for k in m.get('InstanceConfig'):
                temp_model = DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig()
                self.instance_config.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmAddressPoolReferenceResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        address_pool_name: str = None,
        instance_configs: DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs = None,
        request_id: str = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name.
        self.address_pool_name = address_pool_name
        # The access domain names that reference the address pool.
        self.instance_configs = instance_configs
        # Unique request identification code.
        self.request_id = request_id

    def validate(self):
        if self.instance_configs:
            self.instance_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.instance_configs is not None:
            result['InstanceConfigs'] = self.instance_configs.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('InstanceConfigs') is not None:
            temp_model = DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs()
            self.instance_configs = temp_model.from_map(m['InstanceConfigs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCloudGtmAddressPoolReferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmAddressPoolReferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmAddressPoolReferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmAddressReferenceRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_id: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig(TeaModel):
    def __init__(
        self,
        address_pool_lb_strategy: str = None,
        available_status: str = None,
        config_id: str = None,
        enable_status: str = None,
        health_status: str = None,
        instance_id: str = None,
        instance_name: str = None,
        remark: str = None,
        schedule_domain_name: str = None,
        schedule_hostname: str = None,
        schedule_rr_type: str = None,
        schedule_zone_name: str = None,
        sequence_lb_strategy_mode: str = None,
        ttl: int = None,
        version_code: str = None,
    ):
        # The policy for load balancing between address pools. Valid values:
        # 
        # *   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
        # *   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
        # *   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
        # *   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.
        self.address_pool_lb_strategy = address_pool_lb_strategy
        # The availability state of the access domain name. Valid values:
        # 
        # *   available: If the access domain name is **enabled** and the health state is normal, the access domain name is deemed **available**.
        # *   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.
        self.available_status = available_status
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        self.config_id = config_id
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
        # *   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.
        self.enable_status = enable_status
        # The health state of the access domain name. Valid values:
        # 
        # *   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
        # *   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
        # *   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.
        self.health_status = health_status
        # The ID of the GTM 3.0 instance.
        self.instance_id = instance_id
        # Instance name.
        self.instance_name = instance_name
        # Remarks.
        self.remark = remark
        # The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.
        self.schedule_domain_name = schedule_domain_name
        # Host record of the domain accessed by GTM.
        self.schedule_hostname = schedule_hostname
        # DNS record types for the scheduling domain:
        # - A: IPv4 address
        # - AAAA: IPv6 address
        # - CNAME: Domain name
        self.schedule_rr_type = schedule_rr_type
        # The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.
        self.schedule_zone_name = schedule_zone_name
        # The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
        # *   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Global TTL (in seconds), the TTL value for domain name resolution to addresses in the address pool, which affects the caching time of DNS records in the ISP\\"s LocalDNS. Custom TTL values are supported.
        self.ttl = ttl
        # Global Traffic Management version 3.0 instance types:
        # - standard: Standard Edition
        # - ultimate: Ultimate Edition
        self.version_code = version_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_lb_strategy is not None:
            result['AddressPoolLbStrategy'] = self.address_pool_lb_strategy
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.schedule_hostname is not None:
            result['ScheduleHostname'] = self.schedule_hostname
        if self.schedule_rr_type is not None:
            result['ScheduleRrType'] = self.schedule_rr_type
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolLbStrategy') is not None:
            self.address_pool_lb_strategy = m.get('AddressPoolLbStrategy')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('ScheduleHostname') is not None:
            self.schedule_hostname = m.get('ScheduleHostname')
        if m.get('ScheduleRrType') is not None:
            self.schedule_rr_type = m.get('ScheduleRrType')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs(TeaModel):
    def __init__(
        self,
        instance_config: List[DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig] = None,
    ):
        self.instance_config = instance_config

    def validate(self):
        if self.instance_config:
            for k in self.instance_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceConfig'] = []
        if self.instance_config is not None:
            for k in self.instance_config:
                result['InstanceConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_config = []
        if m.get('InstanceConfig') is not None:
            for k in m.get('InstanceConfig'):
                temp_model = DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig()
                self.instance_config.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool(TeaModel):
    def __init__(
        self,
        address_lb_strategy: str = None,
        address_pool_id: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        available_status: str = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        instance_configs: DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs = None,
        remark: str = None,
        sequence_lb_strategy_mode: str = None,
    ):
        # Load balancing policy among addresses in the address pool:
        # - round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned, with a rotation sort applied to all addresses each time.
        # - sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of address return, with smaller numbers having higher priority). If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
        # - weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the ratio of weight for DNS query resolutions.
        # - source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.
        self.address_lb_strategy = address_lb_strategy
        # The ID of the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name.
        self.address_pool_name = address_pool_name
        # Address pool type:
        # - IPv4
        # - IPv6
        # - domain
        self.address_pool_type = address_pool_type
        # Address pool availability status:
        # - available
        # - unavailable
        self.available_status = available_status
        # Address pool status:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address pool. Valid values:
        # 
        # *   any_ok: At least one address in the address pool is available.
        # *   p30_ok: At least 30% of the addresses in the address pool are available.
        # *   p50_ok: At least 50% of the addresses in the address pool are available.
        # *   p70_ok: At least 70% of the addresses in the address pool are available.
        # *   all_ok: All addresses in the address pool are available.
        self.health_judgement = health_judgement
        # The health state of the address pool. Valid values:
        # 
        # *   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
        # *   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
        # *   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.
        self.health_status = health_status
        # The instances that reference the address pool.
        self.instance_configs = instance_configs
        # Remarks for the address pool.
        self.remark = remark
        # Load balancing policy between addresses in sequential mode during the recovery of preceding resources service mode:
        # - preemptive: Preemption mode, where upon recovery of preceding resources, priority is given to using addresses with smaller sequence numbers;
        # - non_preemptive: Non-preemption mode, where upon recovery of preceding resources, the current address continues to be used;
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode

    def validate(self):
        if self.instance_configs:
            self.instance_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_lb_strategy is not None:
            result['AddressLbStrategy'] = self.address_lb_strategy
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_configs is not None:
            result['InstanceConfigs'] = self.instance_configs.to_map()
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressLbStrategy') is not None:
            self.address_lb_strategy = m.get('AddressLbStrategy')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceConfigs') is not None:
            temp_model = DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs()
            self.instance_configs = temp_model.from_map(m['InstanceConfigs'])
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        return self


class DescribeCloudGtmAddressReferenceResponseBodyAddressPools(TeaModel):
    def __init__(
        self,
        address_pool: List[DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool] = None,
    ):
        self.address_pool = address_pool

    def validate(self):
        if self.address_pool:
            for k in self.address_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddressPool'] = []
        if self.address_pool is not None:
            for k in self.address_pool:
                result['AddressPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address_pool = []
        if m.get('AddressPool') is not None:
            for k in m.get('AddressPool'):
                temp_model = DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool()
                self.address_pool.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmAddressReferenceResponseBody(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_id: str = None,
        address_pools: DescribeCloudGtmAddressReferenceResponseBodyAddressPools = None,
        name: str = None,
        request_id: str = None,
    ):
        # IP address or domain name.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # The address pools.
        self.address_pools = address_pools
        # Address name.
        self.name = name
        # Unique request identification code.
        self.request_id = request_id

    def validate(self):
        if self.address_pools:
            self.address_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.address_pools is not None:
            result['AddressPools'] = self.address_pools.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AddressPools') is not None:
            temp_model = DescribeCloudGtmAddressReferenceResponseBodyAddressPools()
            self.address_pools = temp_model.from_map(m['AddressPools'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCloudGtmAddressReferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmAddressReferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmAddressReferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmGlobalAlertRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig(TeaModel):
    def __init__(
        self,
        dingtalk_notice: bool = None,
        email_notice: bool = None,
        notice_type: str = None,
        sms_notice: bool = None,
    ):
        # Indicates whether DingTalk notifications are configured. Valid values:
        # 
        # *   true: DingTalk notifications are configured. DingTalk notifications are sent when alerts are triggered.
        # *   false: DingTalk notifications are not configured.
        self.dingtalk_notice = dingtalk_notice
        # Indicates whether email notifications are configured. Valid values:
        # 
        # *   true: Email notifications are configured. Emails are sent when alerts are triggered.
        # *   false: Email notifications are not configured.
        self.email_notice = email_notice
        # The type of the alert event. Valid values:
        # 
        # *   addr_alert: The address is unavailable.
        # *   addr_resume: The address becomes available.
        # *   addr_pool_unavailable: The address pool is unavailable.
        # *   addr_pool_available: The address pool becomes available.
        self.notice_type = notice_type
        # Indicates whether text message notifications are configured. Valid values:
        # 
        # *   true: Text message notifications are configured. Text messages are sent when alerts are triggered.
        # *   false: Text message notifications are not configured.
        # 
        # Only the China site (aliyun.com) supports text message notifications.
        self.sms_notice = sms_notice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_notice is not None:
            result['DingtalkNotice'] = self.dingtalk_notice
        if self.email_notice is not None:
            result['EmailNotice'] = self.email_notice
        if self.notice_type is not None:
            result['NoticeType'] = self.notice_type
        if self.sms_notice is not None:
            result['SmsNotice'] = self.sms_notice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkNotice') is not None:
            self.dingtalk_notice = m.get('DingtalkNotice')
        if m.get('EmailNotice') is not None:
            self.email_notice = m.get('EmailNotice')
        if m.get('NoticeType') is not None:
            self.notice_type = m.get('NoticeType')
        if m.get('SmsNotice') is not None:
            self.sms_notice = m.get('SmsNotice')
        return self


class DescribeCloudGtmGlobalAlertResponseBodyAlertConfig(TeaModel):
    def __init__(
        self,
        alert_config: List[DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig] = None,
    ):
        self.alert_config = alert_config

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmGlobalAlertResponseBodyAlertGroup(TeaModel):
    def __init__(
        self,
        alert_group: List[str] = None,
    ):
        self.alert_group = alert_group

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        return self


class DescribeCloudGtmGlobalAlertResponseBody(TeaModel):
    def __init__(
        self,
        alert_config: DescribeCloudGtmGlobalAlertResponseBodyAlertConfig = None,
        alert_group: DescribeCloudGtmGlobalAlertResponseBodyAlertGroup = None,
        request_id: str = None,
    ):
        # The alert configurations.
        self.alert_config = alert_config
        # The alert contact groups.
        self.alert_group = alert_group
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.alert_config:
            self.alert_config.validate()
        if self.alert_group:
            self.alert_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_config is not None:
            result['AlertConfig'] = self.alert_config.to_map()
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertConfig') is not None:
            temp_model = DescribeCloudGtmGlobalAlertResponseBodyAlertConfig()
            self.alert_config = temp_model.from_map(m['AlertConfig'])
        if m.get('AlertGroup') is not None:
            temp_model = DescribeCloudGtmGlobalAlertResponseBodyAlertGroup()
            self.alert_group = temp_model.from_map(m['AlertGroup'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCloudGtmGlobalAlertResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmGlobalAlertResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmGlobalAlertResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmInstanceConfigAlertRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US**: English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        self.config_id = config_id
        # The ID of the Global Traffic Manager (GTM) 3.0 instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig(TeaModel):
    def __init__(
        self,
        dingtalk_notice: bool = None,
        email_notice: bool = None,
        notice_type: str = None,
        sms_notice: bool = None,
    ):
        # Indicates whether DingTalk notifications are configured. Valid values:
        # 
        # *   true: DingTalk notifications are configured. DingTalk notifications are sent after alerts are triggered.
        # *   false: DingTalk notifications are not configured.
        self.dingtalk_notice = dingtalk_notice
        # Indicates whether email notifications are configured. Valid values:
        # 
        # *   true: Email notifications are configured. Emails are sent after alerts are triggered.
        # *   false: Email notifications are not configured.
        self.email_notice = email_notice
        # The type of the alert event. Valid values:
        # 
        # *   addr_alert: The address is unavailable.
        # *   addr_resume: The address becomes available.
        # *   addr_pool_unavailable: The address pool is unavailable.
        # *   addr_pool_available: The address pool becomes available.
        self.notice_type = notice_type
        # Indicates whether text message notifications are configured. Valid values:
        # 
        # *   true: Text message notifications are configured. Text messages are sent after alerts are triggered.
        # *   false: Text message notifications are not configured.
        # 
        # Only the China site (aliyun.com) supports text message notifications.
        self.sms_notice = sms_notice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_notice is not None:
            result['DingtalkNotice'] = self.dingtalk_notice
        if self.email_notice is not None:
            result['EmailNotice'] = self.email_notice
        if self.notice_type is not None:
            result['NoticeType'] = self.notice_type
        if self.sms_notice is not None:
            result['SmsNotice'] = self.sms_notice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkNotice') is not None:
            self.dingtalk_notice = m.get('DingtalkNotice')
        if m.get('EmailNotice') is not None:
            self.email_notice = m.get('EmailNotice')
        if m.get('NoticeType') is not None:
            self.notice_type = m.get('NoticeType')
        if m.get('SmsNotice') is not None:
            self.sms_notice = m.get('SmsNotice')
        return self


class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig(TeaModel):
    def __init__(
        self,
        alert_config: List[DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig] = None,
    ):
        self.alert_config = alert_config

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup(TeaModel):
    def __init__(
        self,
        alert_group: List[str] = None,
    ):
        self.alert_group = alert_group

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        return self


class DescribeCloudGtmInstanceConfigAlertResponseBody(TeaModel):
    def __init__(
        self,
        alert_config: DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig = None,
        alert_group: DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup = None,
        alert_mode: str = None,
        config_id: str = None,
        instance_id: str = None,
        request_id: str = None,
    ):
        # The alert configurations.
        self.alert_config = alert_config
        # The alert contact groups.
        self.alert_group = alert_group
        # The alert configuration mode of the instance. Valid values:
        # 
        # *   global: global alert configuration
        # *   instance_config: custom alert configuration
        self.alert_mode = alert_mode
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        self.config_id = config_id
        # The ID of the GTM 3.0 instance.
        self.instance_id = instance_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.alert_config:
            self.alert_config.validate()
        if self.alert_group:
            self.alert_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_config is not None:
            result['AlertConfig'] = self.alert_config.to_map()
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group.to_map()
        if self.alert_mode is not None:
            result['AlertMode'] = self.alert_mode
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertConfig') is not None:
            temp_model = DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig()
            self.alert_config = temp_model.from_map(m['AlertConfig'])
        if m.get('AlertGroup') is not None:
            temp_model = DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup()
            self.alert_group = temp_model.from_map(m['AlertGroup'])
        if m.get('AlertMode') is not None:
            self.alert_mode = m.get('AlertMode')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCloudGtmInstanceConfigAlertResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmInstanceConfigAlertResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmInstanceConfigAlertResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmInstanceConfigFullInfoRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        # 
        # You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the value of ConfigId for the access domain name.
        self.config_id = config_id
        # The ID of the GTM 3.0 instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource(TeaModel):
    def __init__(
        self,
        request_source: List[str] = None,
    ):
        self.request_source = request_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        return self


class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        request_source: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource = None,
        seq_non_preemptive_schedule: bool = None,
        serial_number: int = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
        weight_value: int = None,
    ):
        # IP address or domain name.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # Address ownership information, not supported in the current version.
        self.attribute_info = attribute_info
        # The failover mode that is used when address exceptions are identified. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        self.available_mode = available_mode
        # The availability state of the address. Valid values:
        # 
        # *   available
        # *   unavailable
        self.available_status = available_status
        # Address creation time.
        self.create_time = create_time
        # Address creation time (timestamp).
        self.create_timestamp = create_timestamp
        # The enabling state of the address. Valid values:
        # 
        # *   enable
        # *   disable
        self.enable_status = enable_status
        # The condition for determining the health state of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check state of the address. Valid values:
        # 
        # *   ok: The address passes all health checks of the referenced health check templates.
        # *   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
        # *   ok_no_monitor: The address does not reference any health check template and is normal.
        # *   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.
        self.health_status = health_status
        # The availability state of the address when AvailableMode is set to manual. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        self.name = name
        # The remark of the address.
        self.remark = remark
        # Request source list.
        self.request_source = request_source
        # Indicates whether it is a sequential (non-preemptive) mode scheduling object, applicable to hybrid cloud management scenarios: 
        # 
        # - true: yes
        # - false: no
        self.seq_non_preemptive_schedule = seq_non_preemptive_schedule
        # Sequence number, indicating the priority of address return, where smaller numbers have higher priority.
        self.serial_number = serial_number
        # The type of the address. Valid values:
        # 
        # *   IPV4: the IPv4 address
        # *   IPv6: the IPv6 address
        # *   domain: the domain name
        self.type = type
        # Last modified time of the address.
        self.update_time = update_time
        # The last modification time of the address (timestamp).
        self.update_timestamp = update_timestamp
        # Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address, enabling resolution queries to return addresses in proportion to their weights.
        self.weight_value = weight_value

    def validate(self):
        if self.request_source:
            self.request_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_source is not None:
            result['RequestSource'] = self.request_source.to_map()
        if self.seq_non_preemptive_schedule is not None:
            result['SeqNonPreemptiveSchedule'] = self.seq_non_preemptive_schedule
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestSource') is not None:
            temp_model = DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource()
            self.request_source = temp_model.from_map(m['RequestSource'])
        if m.get('SeqNonPreemptiveSchedule') is not None:
            self.seq_non_preemptive_schedule = m.get('SeqNonPreemptiveSchedule')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses(TeaModel):
    def __init__(
        self,
        address: List[DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress] = None,
    ):
        self.address = address

    def validate(self):
        if self.address:
            for k in self.address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Address'] = []
        if self.address is not None:
            for k in self.address:
                result['Address'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address = []
        if m.get('Address') is not None:
            for k in m.get('Address'):
                temp_model = DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress()
                self.address.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource(TeaModel):
    def __init__(
        self,
        request_source: List[str] = None,
    ):
        self.request_source = request_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        return self


class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool(TeaModel):
    def __init__(
        self,
        address_lb_strategy: str = None,
        address_pool_id: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        addresses: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        request_source: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource = None,
        seq_non_preemptive_schedule: bool = None,
        sequence_lb_strategy_mode: str = None,
        serial_number: int = None,
        update_time: str = None,
        update_timestamp: int = None,
        weight_value: int = None,
    ):
        # Load balancing policy among addresses in the address pool:
        # - round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates their order for each request.
        # - sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, with smaller numbers having higher priority). If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
        # - weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
        # - source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.
        self.address_lb_strategy = address_lb_strategy
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name.
        self.address_pool_name = address_pool_name
        # Address pool type:
        # - IPv4
        # - IPv6
        # - domain
        self.address_pool_type = address_pool_type
        # The addresses.
        self.addresses = addresses
        # The availability state of the address pool. Valid values:
        # 
        # *   Available
        # *   unavailable
        self.available_status = available_status
        # Address pool creation time.
        self.create_time = create_time
        # Address pool creation time (timestamp).
        self.create_timestamp = create_timestamp
        # The enabling state of the address pool. Valid values:
        # 
        # *   enable
        # *   disable
        self.enable_status = enable_status
        # The condition for determining the health state of the address pool. Valid values:
        # 
        # *   any_ok: At least one address in the address pool is available.
        # *   p30_ok: At least 30% of the addresses in the address pool are available.
        # *   p50_ok: At least 50% of the addresses in the address pool are available.
        # *   p70_ok: At least 70% of the addresses in the address pool are available.
        # *   all_ok: All addresses in the address pool are available.
        self.health_judgement = health_judgement
        # Address pool health status:
        # - ok: Normal, all addresses referenced by the address pool are available.
        # - ok_alert: Warning, some addresses referenced by the address pool are unavailable, but the address pool status is deemed normal. In the warning state, available address pools are resolved normally, while unavailable ones stop resolving.
        # - exceptional: Abnormal, some or all of the addresses referenced by the address pool are unavailable, and the address pool status is determined to be abnormal.
        self.health_status = health_status
        # Parse the list of request sources.
        self.request_source = request_source
        # Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: 
        # - true: yes 
        # - false: no
        self.seq_non_preemptive_schedule = seq_non_preemptive_schedule
        # The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
        # *   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Sequence number. For any parsing request from any source, the address pool with the smaller sequence number is returned (the sequence number indicates the priority of the address pool returned, with smaller numbers having higher priority).
        self.serial_number = serial_number
        # Last modification time of the address pool.
        self.update_time = update_time
        # Last modification time of the address pool (timestamp).
        self.update_timestamp = update_timestamp
        # Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address pool, enabling resolution queries to return address pools according to the weighted ratio.
        self.weight_value = weight_value

    def validate(self):
        if self.addresses:
            self.addresses.validate()
        if self.request_source:
            self.request_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_lb_strategy is not None:
            result['AddressLbStrategy'] = self.address_lb_strategy
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.addresses is not None:
            result['Addresses'] = self.addresses.to_map()
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.request_source is not None:
            result['RequestSource'] = self.request_source.to_map()
        if self.seq_non_preemptive_schedule is not None:
            result['SeqNonPreemptiveSchedule'] = self.seq_non_preemptive_schedule
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressLbStrategy') is not None:
            self.address_lb_strategy = m.get('AddressLbStrategy')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('Addresses') is not None:
            temp_model = DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses()
            self.addresses = temp_model.from_map(m['Addresses'])
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('RequestSource') is not None:
            temp_model = DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource()
            self.request_source = temp_model.from_map(m['RequestSource'])
        if m.get('SeqNonPreemptiveSchedule') is not None:
            self.seq_non_preemptive_schedule = m.get('SeqNonPreemptiveSchedule')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools(TeaModel):
    def __init__(
        self,
        address_pool: List[DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool] = None,
    ):
        self.address_pool = address_pool

    def validate(self):
        if self.address_pool:
            for k in self.address_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddressPool'] = []
        if self.address_pool is not None:
            for k in self.address_pool:
                result['AddressPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address_pool = []
        if m.get('AddressPool') is not None:
            for k in m.get('AddressPool'):
                temp_model = DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool()
                self.address_pool.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmInstanceConfigFullInfoResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_lb_strategy: str = None,
        address_pools: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools = None,
        alert_config: str = None,
        alert_group: str = None,
        available_status: str = None,
        commodity_code: str = None,
        config_id: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_status: str = None,
        instance_id: str = None,
        instance_name: str = None,
        remark: str = None,
        request_id: str = None,
        schedule_domain_name: str = None,
        schedule_hostname: str = None,
        schedule_rr_type: str = None,
        schedule_zone_mode: str = None,
        schedule_zone_name: str = None,
        sequence_lb_strategy_mode: str = None,
        ttl: int = None,
        update_time: str = None,
        update_timestamp: int = None,
        version_code: str = None,
    ):
        # The policy for load balancing between address pools. Valid values:
        # 
        # *   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
        # *   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
        # *   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
        # *   source_nearest: GTM returns different addresses based on the sources of DNS requests. This way, users can access nearby addresses.
        self.address_pool_lb_strategy = address_pool_lb_strategy
        # The address pools.
        self.address_pools = address_pools
        # Alert notification configuration.
        self.alert_config = alert_config
        # Alert notification group.
        self.alert_group = alert_group
        # The availability state of the access domain name. Valid values:
        # 
        # *   available: If the access domain name is **enabled** and the health state of the access domain name is **Normal**, the access domain name is deemed **available**.
        # *   unavailable: If the access domain name is **disabled** or the health state of the access domain name is **Abnormal**, the access domain name is deemed **unavailable**.
        self.available_status = available_status
        # The commodity code. Valid values:
        # 
        # *   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
        # *   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)
        self.commodity_code = commodity_code
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        self.config_id = config_id
        # Instance creation time.
        self.create_time = create_time
        # Instance creation time (timestamp).
        self.create_timestamp = create_timestamp
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
        # *   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.
        self.enable_status = enable_status
        # The health state of the access domain name. Valid values:
        # 
        # *   ok: The health state of the access domain name is Normal and all address pools that are referenced by the access domain name are available.
        # *   ok_alert: The health state of the access domain name is Warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, the available address pools are normally used for DNS resolution, but the unavailable address pools cannot be used for DNS resolution.
        # *   exceptional: The health state of the access domain name is Abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.
        self.health_status = health_status
        # The ID of the GTM 3.0 instance.
        self.instance_id = instance_id
        # Schedule instance name.
        self.instance_name = instance_name
        # Remarks of the configuration of domain instance.
        self.remark = remark
        # Unique request identification code.
        self.request_id = request_id
        # The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.
        self.schedule_domain_name = schedule_domain_name
        # Host name of the domain accessed by GTM.
        self.schedule_hostname = schedule_hostname
        # DNS record types for the ScheduleDomainName:
        # - A: IPv4 address
        # - AAAA: IPv6 address
        # - CNAME: Domain name
        self.schedule_rr_type = schedule_rr_type
        # The allocation mode of the access domain name. Valid values:
        # 
        # *   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone or subzone within the account to which the GTM instance belongs to generate an access domain name.
        # *   sys_assign: The system assigns an access domain name by default. This mode is no longer supported. Do not choose this mode.
        self.schedule_zone_mode = schedule_zone_mode
        # The zone (such as example.com) or subzone (such as a.example.com) associated with the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.
        self.schedule_zone_name = schedule_zone_name
        # The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
        # *   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Global TTL (in seconds), the TTL value for resolving the access domain to addresses in the address pool, which affects the caching time of DNS records in the ISP\\"s LocalDNS. Custom TTL values are supported.
        self.ttl = ttl
        # Last modified time.
        self.update_time = update_time
        # Last modified time (timestamp).
        self.update_timestamp = update_timestamp
        # Global Traffic Management version 3.0 instances:
        # - standard: Standard Edition
        # - ultimate: Ultimate Edition
        self.version_code = version_code

    def validate(self):
        if self.address_pools:
            self.address_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_lb_strategy is not None:
            result['AddressPoolLbStrategy'] = self.address_pool_lb_strategy
        if self.address_pools is not None:
            result['AddressPools'] = self.address_pools.to_map()
        if self.alert_config is not None:
            result['AlertConfig'] = self.alert_config
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.schedule_hostname is not None:
            result['ScheduleHostname'] = self.schedule_hostname
        if self.schedule_rr_type is not None:
            result['ScheduleRrType'] = self.schedule_rr_type
        if self.schedule_zone_mode is not None:
            result['ScheduleZoneMode'] = self.schedule_zone_mode
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolLbStrategy') is not None:
            self.address_pool_lb_strategy = m.get('AddressPoolLbStrategy')
        if m.get('AddressPools') is not None:
            temp_model = DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools()
            self.address_pools = temp_model.from_map(m['AddressPools'])
        if m.get('AlertConfig') is not None:
            self.alert_config = m.get('AlertConfig')
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('ScheduleHostname') is not None:
            self.schedule_hostname = m.get('ScheduleHostname')
        if m.get('ScheduleRrType') is not None:
            self.schedule_rr_type = m.get('ScheduleRrType')
        if m.get('ScheduleZoneMode') is not None:
            self.schedule_zone_mode = m.get('ScheduleZoneMode')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeCloudGtmInstanceConfigFullInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmInstanceConfigFullInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmInstanceConfigFullInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmMonitorTemplateRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        template_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US** (default): English
        self.accept_language = accept_language
        # The ID of the health check template that you want to query. This ID uniquely identifies the health check template.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        country_code: str = None,
        country_name: str = None,
        group_name: str = None,
        group_type: str = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        # City code
        self.city_code = city_code
        # City name
        self.city_name = city_name
        # Country Code
        self.country_code = country_code
        # Country Name
        self.country_name = country_name
        # Probe node group type name
        self.group_name = group_name
        # Probe node group types:
        # - BGP: BGP nodes
        # - OVERSEAS: International nodes
        # - ISP: Carrier nodes
        self.group_type = group_type
        # Operator Code
        self.isp_code = isp_code
        # Operator Name
        self.isp_name = isp_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.country_code is not None:
            result['CountryCode'] = self.country_code
        if self.country_name is not None:
            result['CountryName'] = self.country_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('CountryCode') is not None:
            self.country_code = m.get('CountryCode')
        if m.get('CountryName') is not None:
            self.country_name = m.get('CountryName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes(TeaModel):
    def __init__(
        self,
        isp_city_node: List[DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode] = None,
    ):
        self.isp_city_node = isp_city_node

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmMonitorTemplateResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        evaluation_count: int = None,
        extend_info: str = None,
        failure_rate: int = None,
        interval: int = None,
        ip_version: str = None,
        isp_city_nodes: DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes = None,
        name: str = None,
        protocol: str = None,
        remark: str = None,
        request_id: str = None,
        template_id: str = None,
        timeout: int = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # Health check template creation time.
        self.create_time = create_time
        # Health check template creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Retries count. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry counts are:
        # - 1
        # - 2
        # - 3
        self.evaluation_count = evaluation_count
        # The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.
        # 
        # *   HTTP or HTTPS:
        # 
        #     **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.
        # 
        #     **path**: the URL for HTTP or HTTPS health checks. Default value: /.
        # 
        #     **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:
        # 
        #     *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must specify an exact URL for path if you set code to 400.
        #     *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.
        # 
        #     **sni**: indicates whether Server Name Indication (SNI) is enabled. This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:
        # 
        #     *   true: SNI is enabled.
        #     *   false: SNI is disabled.
        # 
        #     **followRedirect**: indicates whether 3XX redirects are followed. Valid values:
        # 
        #     *   true: 3XX redirects are followed. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
        #     *   false: 3XX redirects are not followed.
        # 
        # *   ping:
        # 
        #     **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.
        # 
        #     **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.
        self.extend_info = extend_info
        # Percentage of selected node probe failures (%), that is, the percentage of abnormal detection points among the total detection points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
        # - 20
        # - 50
        # - 80
        # - 100
        self.failure_rate = failure_rate
        # The time interval (in seconds) between each check, with a default interval of 1 minute. The minimum supported health check interval is 15 seconds, available for flagship edition instances.
        self.interval = interval
        # Detect the type of the node IP address:
        # - IPv4: Applicable when the target address type is IPv4;
        # - IPv6: Applicable when the target address type is IPv6.
        self.ip_version = ip_version
        # Probe node list, detailed information can be obtained by calling ListCloudGtmMonitorNodes.
        self.isp_city_nodes = isp_city_nodes
        # The name of the health check probe template, which is recommended to be distinguishable for configuration personnel to differentiate and remember, ideally indicating the health check protocol.
        self.name = name
        # Protocol types to initiate probes to the target IP address:
        # - ping
        # - tcp
        # - http
        # - https
        self.protocol = protocol
        # Remarks for the health check template.
        self.remark = remark
        # Unique request identification code.
        self.request_id = request_id
        # The ID of the health check template. This ID uniquely identifies the health check template.
        self.template_id = template_id
        # Probe timeout (in milliseconds), data packets not returned within the timeout period are deemed as health check timeouts:
        # - 2000
        # - 3000
        # - 5000
        # - 10000
        self.timeout = timeout
        # Health check template configuration modification time.
        self.update_time = update_time
        # Health check template configuration modification time (timestamp).
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.isp_city_nodes:
            self.isp_city_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.extend_info is not None:
            result['ExtendInfo'] = self.extend_info
        if self.failure_rate is not None:
            result['FailureRate'] = self.failure_rate
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.ip_version is not None:
            result['IpVersion'] = self.ip_version
        if self.isp_city_nodes is not None:
            result['IspCityNodes'] = self.isp_city_nodes.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('ExtendInfo') is not None:
            self.extend_info = m.get('ExtendInfo')
        if m.get('FailureRate') is not None:
            self.failure_rate = m.get('FailureRate')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IpVersion') is not None:
            self.ip_version = m.get('IpVersion')
        if m.get('IspCityNodes') is not None:
            temp_model = DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes()
            self.isp_city_nodes = temp_model.from_map(m['IspCityNodes'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeCloudGtmMonitorTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmMonitorTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmMonitorTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmSummaryRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        return self


class DescribeCloudGtmSummaryResponseBody(TeaModel):
    def __init__(
        self,
        instance_total_count: int = None,
        monitor_task_total_count: int = None,
        monitor_task_total_quota: int = None,
        request_id: str = None,
    ):
        # The total number of instances within the current account.
        self.instance_total_count = instance_total_count
        # The total number of configured health check tasks.
        self.monitor_task_total_count = monitor_task_total_count
        # The quota on the number of health check tasks.
        self.monitor_task_total_quota = monitor_task_total_quota
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_total_count is not None:
            result['InstanceTotalCount'] = self.instance_total_count
        if self.monitor_task_total_count is not None:
            result['MonitorTaskTotalCount'] = self.monitor_task_total_count
        if self.monitor_task_total_quota is not None:
            result['MonitorTaskTotalQuota'] = self.monitor_task_total_quota
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceTotalCount') is not None:
            self.instance_total_count = m.get('InstanceTotalCount')
        if m.get('MonitorTaskTotalCount') is not None:
            self.monitor_task_total_count = m.get('MonitorTaskTotalCount')
        if m.get('MonitorTaskTotalQuota') is not None:
            self.monitor_task_total_quota = m.get('MonitorTaskTotalQuota')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCloudGtmSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine(TeaModel):
    def __init__(
        self,
        code: str = None,
        display_name: str = None,
        is_available: bool = None,
        name: str = None,
        parent_code: str = None,
    ):
        # The line code.
        self.code = code
        # The display name of the line.
        self.display_name = display_name
        # Indicates whether the line can be selected as the source of a Domain Name System (DNS) request. Valid values:
        # 
        # *   true
        # *   false
        self.is_available = is_available
        # The name of the line.
        self.name = name
        # The code of the parent line.
        self.parent_code = parent_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.is_available is not None:
            result['IsAvailable'] = self.is_available
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_code is not None:
            result['ParentCode'] = self.parent_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('IsAvailable') is not None:
            self.is_available = m.get('IsAvailable')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentCode') is not None:
            self.parent_code = m.get('ParentCode')
        return self


class DescribeCloudGtmSystemLinesResponseBodySystemLines(TeaModel):
    def __init__(
        self,
        system_line: List[DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine] = None,
    ):
        self.system_line = system_line

    def validate(self):
        if self.system_line:
            for k in self.system_line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SystemLine'] = []
        if self.system_line is not None:
            for k in self.system_line:
                result['SystemLine'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.system_line = []
        if m.get('SystemLine') is not None:
            for k in m.get('SystemLine'):
                temp_model = DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine()
                self.system_line.append(temp_model.from_map(k))
        return self


class DescribeCloudGtmSystemLinesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        system_lines: DescribeCloudGtmSystemLinesResponseBodySystemLines = None,
        system_lines_tree: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The system lines.
        self.system_lines = system_lines
        # The system lines, which are in a tree structure. Only a system line is listed in this example.
        self.system_lines_tree = system_lines_tree

    def validate(self):
        if self.system_lines:
            self.system_lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.system_lines is not None:
            result['SystemLines'] = self.system_lines.to_map()
        if self.system_lines_tree is not None:
            result['SystemLinesTree'] = self.system_lines_tree
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SystemLines') is not None:
            temp_model = DescribeCloudGtmSystemLinesResponseBodySystemLines()
            self.system_lines = temp_model.from_map(m['SystemLines'])
        if m.get('SystemLinesTree') is not None:
            self.system_lines_tree = m.get('SystemLinesTree')
        return self


class DescribeCloudGtmSystemLinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudGtmSystemLinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudGtmSystemLinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomLineRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        line_id: int = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The unique ID of the custom line. You can call [DescribeCustomLines](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID
        self.line_id = line_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line_id is not None:
            result['LineId'] = self.line_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LineId') is not None:
            self.line_id = m.get('LineId')
        return self


class DescribeCustomLineResponseBodyIpSegmentList(TeaModel):
    def __init__(
        self,
        end_ip: str = None,
        start_ip: str = None,
    ):
        # The end IP address of the CIDR block.
        self.end_ip = end_ip
        # The start IP address of the CIDR block.
        self.start_ip = start_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ip is not None:
            result['EndIp'] = self.end_ip
        if self.start_ip is not None:
            result['StartIp'] = self.start_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndIp') is not None:
            self.end_ip = m.get('EndIp')
        if m.get('StartIp') is not None:
            self.start_ip = m.get('StartIp')
        return self


class DescribeCustomLineResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        domain_name: str = None,
        id: int = None,
        ip_segment_list: List[DescribeCustomLineResponseBodyIpSegmentList] = None,
        name: str = None,
        request_id: str = None,
    ):
        # The code of the custom line.
        self.code = code
        # The domain name.
        self.domain_name = domain_name
        # The ID/Name of the custom line.
        self.id = id
        # The CIDR blocks. Separate IP addresses with a hyphen (-). Enter a CIDR block in each row. You can enter 1 to 50 CIDR blocks at a time. If a CIDR block contains only one IP address, enter the IP address in the format of IP1-IP1. Different CIDR blocks cannot be overlapped.
        self.ip_segment_list = ip_segment_list
        # The name of the custom line.
        self.name = name
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.ip_segment_list:
            for k in self.ip_segment_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.id is not None:
            result['Id'] = self.id
        result['IpSegmentList'] = []
        if self.ip_segment_list is not None:
            for k in self.ip_segment_list:
                result['IpSegmentList'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.ip_segment_list = []
        if m.get('IpSegmentList') is not None:
            for k in m.get('IpSegmentList'):
                temp_model = DescribeCustomLineResponseBodyIpSegmentList()
                self.ip_segment_list.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCustomLineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCustomLineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomLineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomLinesRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The domain name that already exists in Alibaba Cloud Domain Name System (DNS). You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en
        self.lang = lang
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeCustomLinesResponseBodyCustomLinesIpSegmentList(TeaModel):
    def __init__(
        self,
        end_ip: str = None,
        start_ip: str = None,
    ):
        self.end_ip = end_ip
        self.start_ip = start_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ip is not None:
            result['EndIp'] = self.end_ip
        if self.start_ip is not None:
            result['StartIp'] = self.start_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndIp') is not None:
            self.end_ip = m.get('EndIp')
        if m.get('StartIp') is not None:
            self.start_ip = m.get('StartIp')
        return self


class DescribeCustomLinesResponseBodyCustomLines(TeaModel):
    def __init__(
        self,
        code: str = None,
        id: int = None,
        ip_segment_list: List[DescribeCustomLinesResponseBodyCustomLinesIpSegmentList] = None,
        name: str = None,
    ):
        # The code of the custom line.
        self.code = code
        # The unique ID of the custom line.
        self.id = id
        self.ip_segment_list = ip_segment_list
        # The name of the custom line.
        self.name = name

    def validate(self):
        if self.ip_segment_list:
            for k in self.ip_segment_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        result['IpSegmentList'] = []
        if self.ip_segment_list is not None:
            for k in self.ip_segment_list:
                result['IpSegmentList'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.ip_segment_list = []
        if m.get('IpSegmentList') is not None:
            for k in m.get('IpSegmentList'):
                temp_model = DescribeCustomLinesResponseBodyCustomLinesIpSegmentList()
                self.ip_segment_list.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeCustomLinesResponseBody(TeaModel):
    def __init__(
        self,
        custom_lines: List[DescribeCustomLinesResponseBodyCustomLines] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The custom lines.
        self.custom_lines = custom_lines
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of custom lines.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.custom_lines:
            for k in self.custom_lines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomLines'] = []
        if self.custom_lines is not None:
            for k in self.custom_lines:
                result['CustomLines'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_lines = []
        if m.get('CustomLines') is not None:
            for k in m.get('CustomLines'):
                temp_model = DescribeCustomLinesResponseBodyCustomLines()
                self.custom_lines.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeCustomLinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCustomLinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomLinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDNSSLBSubDomainsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        rr: str = None,
        user_client_ip: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the response. Valid values:
        # 
        # *   **zh** (default): Chinese
        # *   **en**: English
        self.lang = lang
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # The hostname.
        self.rr = rr
        # The IP address of the user account.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rr is not None:
            result['Rr'] = self.rr
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Rr') is not None:
            self.rr = m.get('Rr')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm(TeaModel):
    def __init__(
        self,
        line: str = None,
        open: bool = None,
    ):
        # The DNS resolution line. The line can be China Telecom, China Mobile, and China Unicom.
        self.line = line
        # Indicates whether weighted round-robin is enabled for the line. Valid values:
        # 
        # *   **true** (default): Weighted round-robin is enabled.
        # *   **false**: Weighted round-robin is disabled.
        self.open = open

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.line is not None:
            result['Line'] = self.line
        if self.open is not None:
            result['Open'] = self.open
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Open') is not None:
            self.open = m.get('Open')
        return self


class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms(TeaModel):
    def __init__(
        self,
        line_algorithm: List[DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm] = None,
    ):
        self.line_algorithm = line_algorithm

    def validate(self):
        if self.line_algorithm:
            for k in self.line_algorithm:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LineAlgorithm'] = []
        if self.line_algorithm is not None:
            for k in self.line_algorithm:
                result['LineAlgorithm'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.line_algorithm = []
        if m.get('LineAlgorithm') is not None:
            for k in m.get('LineAlgorithm'):
                temp_model = DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm()
                self.line_algorithm.append(temp_model.from_map(k))
        return self


class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain(TeaModel):
    def __init__(
        self,
        line_algorithms: DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms = None,
        open: bool = None,
        record_count: int = None,
        sub_domain: str = None,
        type: str = None,
    ):
        # The lines for which weighted round-robin is enabled.
        self.line_algorithms = line_algorithms
        # Indicates whether weighted round-robin is enabled for the subdomain.
        self.open = open
        # The number of DNS records added for the subdomain.
        self.record_count = record_count
        # The name of the subdomain.
        self.sub_domain = sub_domain
        # The type of the Domain Name System (DNS) record that supports weighted round-robin. Valid values: A, AAAA, and CNAME.
        self.type = type

    def validate(self):
        if self.line_algorithms:
            self.line_algorithms.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.line_algorithms is not None:
            result['LineAlgorithms'] = self.line_algorithms.to_map()
        if self.open is not None:
            result['Open'] = self.open
        if self.record_count is not None:
            result['RecordCount'] = self.record_count
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LineAlgorithms') is not None:
            temp_model = DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms()
            self.line_algorithms = temp_model.from_map(m['LineAlgorithms'])
        if m.get('Open') is not None:
            self.open = m.get('Open')
        if m.get('RecordCount') is not None:
            self.record_count = m.get('RecordCount')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDNSSLBSubDomainsResponseBodySlbSubDomains(TeaModel):
    def __init__(
        self,
        slb_sub_domain: List[DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain] = None,
    ):
        self.slb_sub_domain = slb_sub_domain

    def validate(self):
        if self.slb_sub_domain:
            for k in self.slb_sub_domain:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SlbSubDomain'] = []
        if self.slb_sub_domain is not None:
            for k in self.slb_sub_domain:
                result['SlbSubDomain'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.slb_sub_domain = []
        if m.get('SlbSubDomain') is not None:
            for k in m.get('SlbSubDomain'):
                temp_model = DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain()
                self.slb_sub_domain.append(temp_model.from_map(k))
        return self


class DescribeDNSSLBSubDomainsResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        slb_sub_domains: DescribeDNSSLBSubDomainsResponseBodySlbSubDomains = None,
        total_count: int = None,
    ):
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The subdomains for which weighted round-robin is enabled.
        self.slb_sub_domains = slb_sub_domains
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.slb_sub_domains:
            self.slb_sub_domains.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slb_sub_domains is not None:
            result['SlbSubDomains'] = self.slb_sub_domains.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SlbSubDomains') is not None:
            temp_model = DescribeDNSSLBSubDomainsResponseBodySlbSubDomains()
            self.slb_sub_domains = temp_model.from_map(m['SlbSubDomains'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDNSSLBSubDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDNSSLBSubDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDNSSLBSubDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsCacheDomainsRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
        self.keyword = keyword
        # The language.
        self.lang = lang
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: str = None,
    ):
        # The domain name or IP address of the origin DNS server.
        self.host = host
        # The port of the origin DNS server.
        self.port = port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        return self


class DescribeDnsCacheDomainsResponseBodyDomains(TeaModel):
    def __init__(
        self,
        cache_ttl_max: int = None,
        cache_ttl_min: int = None,
        create_time: str = None,
        create_timestamp: int = None,
        domain_id: str = None,
        domain_name: str = None,
        expire_time: str = None,
        expire_timestamp: int = None,
        instance_id: str = None,
        remark: str = None,
        source_dns_servers: List[DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers] = None,
        source_edns: str = None,
        source_protocol: str = None,
        update_time: str = None,
        update_timestamp: int = None,
        version_code: str = None,
    ):
        # The maximum time-to-live (TTL) period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.
        self.cache_ttl_max = cache_ttl_max
        # The minimum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.
        self.cache_ttl_min = cache_ttl_min
        # The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the domain name was added. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_timestamp = create_timestamp
        # The ID of the cache-accelerated domain name.
        self.domain_id = domain_id
        # The cache-accelerated domain name.
        self.domain_name = domain_name
        # The time when the instance expires. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.expire_time = expire_time
        # The time when the instance expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.expire_timestamp = expire_timestamp
        # The instance ID of the cache-accelerated domain name.
        self.instance_id = instance_id
        # The description of the domain name.
        self.remark = remark
        # The origin DNS servers.
        self.source_dns_servers = source_dns_servers
        # Specifies whether the origin Domain Name System (DNS) server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.
        self.source_edns = source_edns
        # The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.
        self.source_protocol = source_protocol
        # The time when the configurations of the domain name were updated. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.update_time = update_time
        # The time when the configurations of the domain name were updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_timestamp = update_timestamp
        # The edition code of Alibaba Cloud DNS.
        self.version_code = version_code

    def validate(self):
        if self.source_dns_servers:
            for k in self.source_dns_servers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cache_ttl_max is not None:
            result['CacheTtlMax'] = self.cache_ttl_max
        if self.cache_ttl_min is not None:
            result['CacheTtlMin'] = self.cache_ttl_min
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.domain_id is not None:
            result['DomainId'] = self.domain_id
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.expire_timestamp is not None:
            result['ExpireTimestamp'] = self.expire_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        result['SourceDnsServers'] = []
        if self.source_dns_servers is not None:
            for k in self.source_dns_servers:
                result['SourceDnsServers'].append(k.to_map() if k else None)
        if self.source_edns is not None:
            result['SourceEdns'] = self.source_edns
        if self.source_protocol is not None:
            result['SourceProtocol'] = self.source_protocol
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CacheTtlMax') is not None:
            self.cache_ttl_max = m.get('CacheTtlMax')
        if m.get('CacheTtlMin') is not None:
            self.cache_ttl_min = m.get('CacheTtlMin')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DomainId') is not None:
            self.domain_id = m.get('DomainId')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ExpireTimestamp') is not None:
            self.expire_timestamp = m.get('ExpireTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        self.source_dns_servers = []
        if m.get('SourceDnsServers') is not None:
            for k in m.get('SourceDnsServers'):
                temp_model = DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers()
                self.source_dns_servers.append(temp_model.from_map(k))
        if m.get('SourceEdns') is not None:
            self.source_edns = m.get('SourceEdns')
        if m.get('SourceProtocol') is not None:
            self.source_protocol = m.get('SourceProtocol')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeDnsCacheDomainsResponseBody(TeaModel):
    def __init__(
        self,
        domains: List[DescribeDnsCacheDomainsResponseBodyDomains] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The domain names.
        self.domains = domains
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: 1 to 100. Default value: 20.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.domains:
            for k in self.domains:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Domains'] = []
        if self.domains is not None:
            for k in self.domains:
                result['Domains'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domains = []
        if m.get('Domains') is not None:
            for k in m.get('Domains'):
                temp_model = DescribeDnsCacheDomainsResponseBodyDomains()
                self.domains.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDnsCacheDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsCacheDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsCacheDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmAccessStrategiesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        strategy_mode: str = None,
    ):
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The type of the access policy. Valid values:
        # 
        # *   GEO: geographical location-based
        # *   LATENCY: latency-based
        # 
        # This parameter is required.
        self.strategy_mode = strategy_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        return self


class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        id: str = None,
        lba_weight: int = None,
        name: str = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.id = id
        # The weight of the address pool.
        self.lba_weight = lba_weight
        # The name of the address pool.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.id is not None:
            result['Id'] = self.id
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools(TeaModel):
    def __init__(
        self,
        effective_addr_pool: List[DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool] = None,
    ):
        self.effective_addr_pool = effective_addr_pool

    def validate(self):
        if self.effective_addr_pool:
            for k in self.effective_addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EffectiveAddrPool'] = []
        if self.effective_addr_pool is not None:
            for k in self.effective_addr_pool:
                result['EffectiveAddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.effective_addr_pool = []
        if m.get('EffectiveAddrPool') is not None:
            for k in m.get('EffectiveAddrPool'):
                temp_model = DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool()
                self.effective_addr_pool.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine(TeaModel):
    def __init__(
        self,
        group_code: str = None,
        group_name: str = None,
        line_code: str = None,
        line_name: str = None,
    ):
        # The code of the source region group.
        self.group_code = group_code
        # The name of the source region group.
        self.group_name = group_name
        # The line code of the source region.
        self.line_code = line_code
        # The line name of the source region.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_code is not None:
            result['GroupCode'] = self.group_code
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupCode') is not None:
            self.group_code = m.get('GroupCode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines(TeaModel):
    def __init__(
        self,
        line: List[DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine] = None,
    ):
        self.line = line

    def validate(self):
        if self.line:
            for k in self.line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Line'] = []
        if self.line is not None:
            for k in self.line:
                result['Line'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.line = []
        if m.get('Line') is not None:
            for k in m.get('Line'):
                temp_model = DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine()
                self.line.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        effective_addr_pool_group_type: str = None,
        effective_addr_pool_type: str = None,
        effective_addr_pools: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools = None,
        effective_lba_strategy: str = None,
        lines: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines = None,
        strategy_id: str = None,
        strategy_name: str = None,
    ):
        # The time when the access policy was created.
        self.create_time = create_time
        # The timestamp that indicates when the access policy was created.
        self.create_timestamp = create_timestamp
        # The type of the active address pool group. Valid values:
        # 
        # *   DEFAULT: the primary address pool group
        # *   FAILOVER: the secondary address pool group
        self.effective_addr_pool_group_type = effective_addr_pool_group_type
        # The type of the active address pools. Valid values:
        # 
        # *   IPV4
        # *   IPV6
        # *   DOMAIN
        self.effective_addr_pool_type = effective_addr_pool_type
        # The active address pool groups.
        self.effective_addr_pools = effective_addr_pools
        # The load balancing policy of the active address pool group. Data is returned when StrategyMode is set to GEO. Valid values: 
        # 
        # - ALL_RR: returns all addresses.
        # - RATIO: returns addresses by weight.
        self.effective_lba_strategy = effective_lba_strategy
        # The source regions. Data is returned when StrategyMode is set to GEO. Valid values:
        self.lines = lines
        # The ID of the access policy.
        self.strategy_id = strategy_id
        # The name of the access policy.
        self.strategy_name = strategy_name

    def validate(self):
        if self.effective_addr_pools:
            self.effective_addr_pools.validate()
        if self.lines:
            self.lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.effective_addr_pool_group_type is not None:
            result['EffectiveAddrPoolGroupType'] = self.effective_addr_pool_group_type
        if self.effective_addr_pool_type is not None:
            result['EffectiveAddrPoolType'] = self.effective_addr_pool_type
        if self.effective_addr_pools is not None:
            result['EffectiveAddrPools'] = self.effective_addr_pools.to_map()
        if self.effective_lba_strategy is not None:
            result['EffectiveLbaStrategy'] = self.effective_lba_strategy
        if self.lines is not None:
            result['Lines'] = self.lines.to_map()
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EffectiveAddrPoolGroupType') is not None:
            self.effective_addr_pool_group_type = m.get('EffectiveAddrPoolGroupType')
        if m.get('EffectiveAddrPoolType') is not None:
            self.effective_addr_pool_type = m.get('EffectiveAddrPoolType')
        if m.get('EffectiveAddrPools') is not None:
            temp_model = DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools()
            self.effective_addr_pools = temp_model.from_map(m['EffectiveAddrPools'])
        if m.get('EffectiveLbaStrategy') is not None:
            self.effective_lba_strategy = m.get('EffectiveLbaStrategy')
        if m.get('Lines') is not None:
            temp_model = DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines()
            self.lines = temp_model.from_map(m['Lines'])
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class DescribeDnsGtmAccessStrategiesResponseBodyStrategies(TeaModel):
    def __init__(
        self,
        strategy: List[DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy] = None,
    ):
        self.strategy = strategy

    def validate(self):
        if self.strategy:
            for k in self.strategy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Strategy'] = []
        if self.strategy is not None:
            for k in self.strategy:
                result['Strategy'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.strategy = []
        if m.get('Strategy') is not None:
            for k in m.get('Strategy'):
                temp_model = DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy()
                self.strategy.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategiesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        strategies: DescribeDnsGtmAccessStrategiesResponseBodyStrategies = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The access policies.
        self.strategies = strategies
        # The total number of entries returned on all pages.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.strategies:
            self.strategies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategies is not None:
            result['Strategies'] = self.strategies.to_map()
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Strategies') is not None:
            temp_model = DescribeDnsGtmAccessStrategiesResponseBodyStrategies()
            self.strategies = temp_model.from_map(m['Strategies'])
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeDnsGtmAccessStrategiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmAccessStrategiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmAccessStrategiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmAccessStrategyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        strategy_id: str = None,
    ):
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The ID of the access policy.
        # 
        # This parameter is required.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        id: str = None,
        lba_weight: int = None,
        name: str = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.id = id
        # The weight of the address pool.
        self.lba_weight = lba_weight
        # The name of the address pool.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.id is not None:
            result['Id'] = self.id
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools(TeaModel):
    def __init__(
        self,
        default_addr_pool: List[DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool] = None,
    ):
        self.default_addr_pool = default_addr_pool

    def validate(self):
        if self.default_addr_pool:
            for k in self.default_addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DefaultAddrPool'] = []
        if self.default_addr_pool is not None:
            for k in self.default_addr_pool:
                result['DefaultAddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.default_addr_pool = []
        if m.get('DefaultAddrPool') is not None:
            for k in m.get('DefaultAddrPool'):
                temp_model = DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool()
                self.default_addr_pool.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        id: str = None,
        lba_weight: int = None,
        name: str = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.id = id
        # The weight of the address pool.
        self.lba_weight = lba_weight
        # The name of the address pool.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.id is not None:
            result['Id'] = self.id
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools(TeaModel):
    def __init__(
        self,
        failover_addr_pool: List[DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool] = None,
    ):
        self.failover_addr_pool = failover_addr_pool

    def validate(self):
        if self.failover_addr_pool:
            for k in self.failover_addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FailoverAddrPool'] = []
        if self.failover_addr_pool is not None:
            for k in self.failover_addr_pool:
                result['FailoverAddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.failover_addr_pool = []
        if m.get('FailoverAddrPool') is not None:
            for k in m.get('FailoverAddrPool'):
                temp_model = DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool()
                self.failover_addr_pool.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategyResponseBodyLinesLine(TeaModel):
    def __init__(
        self,
        group_code: str = None,
        group_name: str = None,
        line_code: str = None,
        line_name: str = None,
    ):
        # The code of the source region group.
        self.group_code = group_code
        # The name of the source region group.
        self.group_name = group_name
        # The line code of the source region.
        self.line_code = line_code
        # The line name of the source region.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_code is not None:
            result['GroupCode'] = self.group_code
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupCode') is not None:
            self.group_code = m.get('GroupCode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeDnsGtmAccessStrategyResponseBodyLines(TeaModel):
    def __init__(
        self,
        line: List[DescribeDnsGtmAccessStrategyResponseBodyLinesLine] = None,
    ):
        self.line = line

    def validate(self):
        if self.line:
            for k in self.line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Line'] = []
        if self.line is not None:
            for k in self.line:
                result['Line'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.line = []
        if m.get('Line') is not None:
            for k in m.get('Line'):
                temp_model = DescribeDnsGtmAccessStrategyResponseBodyLinesLine()
                self.line.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategyResponseBody(TeaModel):
    def __init__(
        self,
        access_mode: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        default_addr_pool_group_status: str = None,
        default_addr_pool_type: str = None,
        default_addr_pools: DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools = None,
        default_available_addr_num: int = None,
        default_latency_optimization: str = None,
        default_lba_strategy: str = None,
        default_max_return_addr_num: int = None,
        default_min_available_addr_num: int = None,
        effective_addr_pool_group_type: str = None,
        failover_addr_pool_group_status: str = None,
        failover_addr_pool_type: str = None,
        failover_addr_pools: DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools = None,
        failover_available_addr_num: int = None,
        failover_latency_optimization: str = None,
        failover_lba_strategy: str = None,
        failover_max_return_addr_num: int = None,
        failover_min_available_addr_num: int = None,
        instance_id: str = None,
        lines: DescribeDnsGtmAccessStrategyResponseBodyLines = None,
        request_id: str = None,
        strategy_id: str = None,
        strategy_mode: str = None,
        strategy_name: str = None,
    ):
        # The primary/secondary switchover policy for address pool groups. Valid values:
        # 
        # *   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
        # *   DEFAULT: uses the primary address pool group.
        # *   FAILOVER: uses the secondary address pool group.
        self.access_mode = access_mode
        # The time when the access policy was created.
        self.create_time = create_time
        # The timestamp that indicates when the access policy was created.
        self.create_timestamp = create_timestamp
        # The status of the primary address pool group. Valid values:
        # 
        # *   AVAILABLE: available
        # *   NOT_AVAILABLE: unavailable
        self.default_addr_pool_group_status = default_addr_pool_group_status
        # The type of the primary address pool. Valid values:
        # 
        # *   IPV4
        # *   IPV6
        # *   DOMAIN
        self.default_addr_pool_type = default_addr_pool_type
        # The address pools in the primary address pool group.
        self.default_addr_pools = default_addr_pools
        # The number of available addresses in the primary address pool.
        self.default_available_addr_num = default_available_addr_num
        # Indicates whether scheduling optimization for latency resolution was enabled for the primary address pool group. Valid values:
        # 
        # *   OPEN: enabled
        # *   CLOSE: disabled
        self.default_latency_optimization = default_latency_optimization
        # The load balancing policy of the primary address pool group. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        self.default_lba_strategy = default_lba_strategy
        # The maximum number of addresses returned from the primary address pool group.
        self.default_max_return_addr_num = default_max_return_addr_num
        # The minimum number of available addresses in the primary address pool group.
        self.default_min_available_addr_num = default_min_available_addr_num
        # The type of the active address pool group. Valid values:
        # 
        # *   DEFAULT: the primary address pool group
        # *   FAILOVER: the secondary address pool group
        self.effective_addr_pool_group_type = effective_addr_pool_group_type
        # The status of the secondary address pool group. Valid values:
        # 
        # *   AVAILABLE: available
        # *   NOT_AVAILABLE: unavailable
        self.failover_addr_pool_group_status = failover_addr_pool_group_status
        # The type of the secondary address pool. Valid values:
        # 
        # *   IPV4
        # *   IPV6
        # *   DOMAIN
        self.failover_addr_pool_type = failover_addr_pool_type
        # The address pools in the secondary address pool group.
        self.failover_addr_pools = failover_addr_pools
        # The number of available addresses in the secondary address pool.
        self.failover_available_addr_num = failover_available_addr_num
        # Indicates whether scheduling optimization for latency resolution was enabled for the secondary address pool group. Valid values:
        # 
        # *   OPEN: enabled
        # *   CLOSE: disabled
        self.failover_latency_optimization = failover_latency_optimization
        # The load balancing policy of the secondary address pool group. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        self.failover_lba_strategy = failover_lba_strategy
        # The maximum number of addresses returned from the secondary address pool group.
        self.failover_max_return_addr_num = failover_max_return_addr_num
        # The minimum number of available addresses in the secondary address pool group.
        self.failover_min_available_addr_num = failover_min_available_addr_num
        # The ID of the associated instance.
        self.instance_id = instance_id
        # The source regions.
        self.lines = lines
        # The ID of the request.
        self.request_id = request_id
        # The ID of the access policy.
        self.strategy_id = strategy_id
        # The type of the access policy. Valid values:
        # 
        # *   GEO: geographical location-based
        # *   LATENCY: latency-based
        self.strategy_mode = strategy_mode
        # The name of the access policy.
        self.strategy_name = strategy_name

    def validate(self):
        if self.default_addr_pools:
            self.default_addr_pools.validate()
        if self.failover_addr_pools:
            self.failover_addr_pools.validate()
        if self.lines:
            self.lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_mode is not None:
            result['AccessMode'] = self.access_mode
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.default_addr_pool_group_status is not None:
            result['DefaultAddrPoolGroupStatus'] = self.default_addr_pool_group_status
        if self.default_addr_pool_type is not None:
            result['DefaultAddrPoolType'] = self.default_addr_pool_type
        if self.default_addr_pools is not None:
            result['DefaultAddrPools'] = self.default_addr_pools.to_map()
        if self.default_available_addr_num is not None:
            result['DefaultAvailableAddrNum'] = self.default_available_addr_num
        if self.default_latency_optimization is not None:
            result['DefaultLatencyOptimization'] = self.default_latency_optimization
        if self.default_lba_strategy is not None:
            result['DefaultLbaStrategy'] = self.default_lba_strategy
        if self.default_max_return_addr_num is not None:
            result['DefaultMaxReturnAddrNum'] = self.default_max_return_addr_num
        if self.default_min_available_addr_num is not None:
            result['DefaultMinAvailableAddrNum'] = self.default_min_available_addr_num
        if self.effective_addr_pool_group_type is not None:
            result['EffectiveAddrPoolGroupType'] = self.effective_addr_pool_group_type
        if self.failover_addr_pool_group_status is not None:
            result['FailoverAddrPoolGroupStatus'] = self.failover_addr_pool_group_status
        if self.failover_addr_pool_type is not None:
            result['FailoverAddrPoolType'] = self.failover_addr_pool_type
        if self.failover_addr_pools is not None:
            result['FailoverAddrPools'] = self.failover_addr_pools.to_map()
        if self.failover_available_addr_num is not None:
            result['FailoverAvailableAddrNum'] = self.failover_available_addr_num
        if self.failover_latency_optimization is not None:
            result['FailoverLatencyOptimization'] = self.failover_latency_optimization
        if self.failover_lba_strategy is not None:
            result['FailoverLbaStrategy'] = self.failover_lba_strategy
        if self.failover_max_return_addr_num is not None:
            result['FailoverMaxReturnAddrNum'] = self.failover_max_return_addr_num
        if self.failover_min_available_addr_num is not None:
            result['FailoverMinAvailableAddrNum'] = self.failover_min_available_addr_num
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lines is not None:
            result['Lines'] = self.lines.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessMode') is not None:
            self.access_mode = m.get('AccessMode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DefaultAddrPoolGroupStatus') is not None:
            self.default_addr_pool_group_status = m.get('DefaultAddrPoolGroupStatus')
        if m.get('DefaultAddrPoolType') is not None:
            self.default_addr_pool_type = m.get('DefaultAddrPoolType')
        if m.get('DefaultAddrPools') is not None:
            temp_model = DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools()
            self.default_addr_pools = temp_model.from_map(m['DefaultAddrPools'])
        if m.get('DefaultAvailableAddrNum') is not None:
            self.default_available_addr_num = m.get('DefaultAvailableAddrNum')
        if m.get('DefaultLatencyOptimization') is not None:
            self.default_latency_optimization = m.get('DefaultLatencyOptimization')
        if m.get('DefaultLbaStrategy') is not None:
            self.default_lba_strategy = m.get('DefaultLbaStrategy')
        if m.get('DefaultMaxReturnAddrNum') is not None:
            self.default_max_return_addr_num = m.get('DefaultMaxReturnAddrNum')
        if m.get('DefaultMinAvailableAddrNum') is not None:
            self.default_min_available_addr_num = m.get('DefaultMinAvailableAddrNum')
        if m.get('EffectiveAddrPoolGroupType') is not None:
            self.effective_addr_pool_group_type = m.get('EffectiveAddrPoolGroupType')
        if m.get('FailoverAddrPoolGroupStatus') is not None:
            self.failover_addr_pool_group_status = m.get('FailoverAddrPoolGroupStatus')
        if m.get('FailoverAddrPoolType') is not None:
            self.failover_addr_pool_type = m.get('FailoverAddrPoolType')
        if m.get('FailoverAddrPools') is not None:
            temp_model = DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools()
            self.failover_addr_pools = temp_model.from_map(m['FailoverAddrPools'])
        if m.get('FailoverAvailableAddrNum') is not None:
            self.failover_available_addr_num = m.get('FailoverAvailableAddrNum')
        if m.get('FailoverLatencyOptimization') is not None:
            self.failover_latency_optimization = m.get('FailoverLatencyOptimization')
        if m.get('FailoverLbaStrategy') is not None:
            self.failover_lba_strategy = m.get('FailoverLbaStrategy')
        if m.get('FailoverMaxReturnAddrNum') is not None:
            self.failover_max_return_addr_num = m.get('FailoverMaxReturnAddrNum')
        if m.get('FailoverMinAvailableAddrNum') is not None:
            self.failover_min_available_addr_num = m.get('FailoverMinAvailableAddrNum')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lines') is not None:
            temp_model = DescribeDnsGtmAccessStrategyResponseBodyLines()
            self.lines = temp_model.from_map(m['Lines'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class DescribeDnsGtmAccessStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmAccessStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmAccessStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        strategy_mode: str = None,
    ):
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The type of the access policy. Valid values:
        # 
        # *   GEO: geographical location-based
        # *   LATENCY: latency-based
        # 
        # This parameter is required.
        self.strategy_mode = strategy_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        id: str = None,
        name: str = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.id = id
        # The name of the address pool.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools(TeaModel):
    def __init__(
        self,
        domain_addr_pool: List[DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool] = None,
    ):
        self.domain_addr_pool = domain_addr_pool

    def validate(self):
        if self.domain_addr_pool:
            for k in self.domain_addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainAddrPool'] = []
        if self.domain_addr_pool is not None:
            for k in self.domain_addr_pool:
                result['DomainAddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_addr_pool = []
        if m.get('DomainAddrPool') is not None:
            for k in m.get('DomainAddrPool'):
                temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool()
                self.domain_addr_pool.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        id: str = None,
        name: str = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.id = id
        # The name of the address pool.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools(TeaModel):
    def __init__(
        self,
        ipv_4addr_pool: List[DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool] = None,
    ):
        self.ipv_4addr_pool = ipv_4addr_pool

    def validate(self):
        if self.ipv_4addr_pool:
            for k in self.ipv_4addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv4AddrPool'] = []
        if self.ipv_4addr_pool is not None:
            for k in self.ipv_4addr_pool:
                result['Ipv4AddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ipv_4addr_pool = []
        if m.get('Ipv4AddrPool') is not None:
            for k in m.get('Ipv4AddrPool'):
                temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool()
                self.ipv_4addr_pool.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        id: str = None,
        name: str = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.id = id
        # The name of the address pool.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools(TeaModel):
    def __init__(
        self,
        ipv_6addr_pool: List[DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool] = None,
    ):
        self.ipv_6addr_pool = ipv_6addr_pool

    def validate(self):
        if self.ipv_6addr_pool:
            for k in self.ipv_6addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6AddrPool'] = []
        if self.ipv_6addr_pool is not None:
            for k in self.ipv_6addr_pool:
                result['Ipv6AddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ipv_6addr_pool = []
        if m.get('Ipv6AddrPool') is not None:
            for k in m.get('Ipv6AddrPool'):
                temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool()
                self.ipv_6addr_pool.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine(TeaModel):
    def __init__(
        self,
        father_code: str = None,
        group_code: str = None,
        group_name: str = None,
        line_code: str = None,
        line_name: str = None,
    ):
        # The parent line code of the source region. Leave it blank if no parent line exists.
        self.father_code = father_code
        # The line name of the source region.
        self.group_code = group_code
        # The name of the source region group.
        self.group_name = group_name
        # The line code of the source region.
        self.line_code = line_code
        # The code of the source region group.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.father_code is not None:
            result['FatherCode'] = self.father_code
        if self.group_code is not None:
            result['GroupCode'] = self.group_code
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FatherCode') is not None:
            self.father_code = m.get('FatherCode')
        if m.get('GroupCode') is not None:
            self.group_code = m.get('GroupCode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines(TeaModel):
    def __init__(
        self,
        line: List[DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine] = None,
    ):
        self.line = line

    def validate(self):
        if self.line:
            for k in self.line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Line'] = []
        if self.line is not None:
            for k in self.line:
                result['Line'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.line = []
        if m.get('Line') is not None:
            for k in m.get('Line'):
                temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine()
                self.line.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines(TeaModel):
    def __init__(
        self,
        selected_domain_line: List[str] = None,
    ):
        self.selected_domain_line = selected_domain_line

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.selected_domain_line is not None:
            result['SelectedDomainLine'] = self.selected_domain_line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SelectedDomainLine') is not None:
            self.selected_domain_line = m.get('SelectedDomainLine')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines(TeaModel):
    def __init__(
        self,
        selected_ipv_4line: List[str] = None,
    ):
        self.selected_ipv_4line = selected_ipv_4line

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.selected_ipv_4line is not None:
            result['SelectedIpv4Line'] = self.selected_ipv_4line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SelectedIpv4Line') is not None:
            self.selected_ipv_4line = m.get('SelectedIpv4Line')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines(TeaModel):
    def __init__(
        self,
        selected_ipv_6line: List[str] = None,
    ):
        self.selected_ipv_6line = selected_ipv_6line

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.selected_ipv_6line is not None:
            result['SelectedIpv6Line'] = self.selected_ipv_6line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SelectedIpv6Line') is not None:
            self.selected_ipv_6line = m.get('SelectedIpv6Line')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponseBody(TeaModel):
    def __init__(
        self,
        domain_addr_pools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools = None,
        ipv_4addr_pools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools = None,
        ipv_6addr_pools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools = None,
        lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines = None,
        request_id: str = None,
        selected_domain_lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines = None,
        selected_ipv_4lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines = None,
        selected_ipv_6lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines = None,
        suggest_set_default_line: bool = None,
    ):
        # The available address pools of the domain name type.
        self.domain_addr_pools = domain_addr_pools
        # The available address pools of the IPv4 type.
        self.ipv_4addr_pools = ipv_4addr_pools
        # The available address pools of the IPv6 type.
        self.ipv_6addr_pools = ipv_6addr_pools
        # The source regions.
        self.lines = lines
        # The ID of the request.
        self.request_id = request_id
        self.selected_domain_lines = selected_domain_lines
        self.selected_ipv_4lines = selected_ipv_4lines
        self.selected_ipv_6lines = selected_ipv_6lines
        # Indicates whether we recommend that you set the source region to global.
        self.suggest_set_default_line = suggest_set_default_line

    def validate(self):
        if self.domain_addr_pools:
            self.domain_addr_pools.validate()
        if self.ipv_4addr_pools:
            self.ipv_4addr_pools.validate()
        if self.ipv_6addr_pools:
            self.ipv_6addr_pools.validate()
        if self.lines:
            self.lines.validate()
        if self.selected_domain_lines:
            self.selected_domain_lines.validate()
        if self.selected_ipv_4lines:
            self.selected_ipv_4lines.validate()
        if self.selected_ipv_6lines:
            self.selected_ipv_6lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_addr_pools is not None:
            result['DomainAddrPools'] = self.domain_addr_pools.to_map()
        if self.ipv_4addr_pools is not None:
            result['Ipv4AddrPools'] = self.ipv_4addr_pools.to_map()
        if self.ipv_6addr_pools is not None:
            result['Ipv6AddrPools'] = self.ipv_6addr_pools.to_map()
        if self.lines is not None:
            result['Lines'] = self.lines.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.selected_domain_lines is not None:
            result['SelectedDomainLines'] = self.selected_domain_lines.to_map()
        if self.selected_ipv_4lines is not None:
            result['SelectedIpv4Lines'] = self.selected_ipv_4lines.to_map()
        if self.selected_ipv_6lines is not None:
            result['SelectedIpv6Lines'] = self.selected_ipv_6lines.to_map()
        if self.suggest_set_default_line is not None:
            result['SuggestSetDefaultLine'] = self.suggest_set_default_line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainAddrPools') is not None:
            temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools()
            self.domain_addr_pools = temp_model.from_map(m['DomainAddrPools'])
        if m.get('Ipv4AddrPools') is not None:
            temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools()
            self.ipv_4addr_pools = temp_model.from_map(m['Ipv4AddrPools'])
        if m.get('Ipv6AddrPools') is not None:
            temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools()
            self.ipv_6addr_pools = temp_model.from_map(m['Ipv6AddrPools'])
        if m.get('Lines') is not None:
            temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines()
            self.lines = temp_model.from_map(m['Lines'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SelectedDomainLines') is not None:
            temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines()
            self.selected_domain_lines = temp_model.from_map(m['SelectedDomainLines'])
        if m.get('SelectedIpv4Lines') is not None:
            temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines()
            self.selected_ipv_4lines = temp_model.from_map(m['SelectedIpv4Lines'])
        if m.get('SelectedIpv6Lines') is not None:
            temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines()
            self.selected_ipv_6lines = temp_model.from_map(m['SelectedIpv6Lines'])
        if m.get('SuggestSetDefaultLine') is not None:
            self.suggest_set_default_line = m.get('SuggestSetDefaultLine')
        return self


class DescribeDnsGtmAccessStrategyAvailableConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmAddrAttributeInfoRequest(TeaModel):
    def __init__(
        self,
        addrs: str = None,
        lang: str = None,
        type: str = None,
    ):
        # The addresses.
        # 
        # This parameter is required.
        self.addrs = addrs
        # The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The type of addresses. Valid values:
        # 
        # *   IPV4: IPv4 address
        # *   IPv6: IPv6 address
        # *   DOMAIN: domain name
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addrs is not None:
            result['Addrs'] = self.addrs
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Addrs') is not None:
            self.addrs = m.get('Addrs')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo(TeaModel):
    def __init__(
        self,
        father_code: str = None,
        group_code: str = None,
        group_name: str = None,
        line_code: str = None,
        line_name: str = None,
    ):
        # The parent line code of the source region.
        self.father_code = father_code
        # The code of the source region group.
        self.group_code = group_code
        # The name of the source region group.
        self.group_name = group_name
        # The line code of the source region.
        self.line_code = line_code
        # The line name of the source region.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.father_code is not None:
            result['FatherCode'] = self.father_code
        if self.group_code is not None:
            result['GroupCode'] = self.group_code
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FatherCode') is not None:
            self.father_code = m.get('FatherCode')
        if m.get('GroupCode') is not None:
            self.group_code = m.get('GroupCode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr(TeaModel):
    def __init__(
        self,
        addr: str = None,
        attribute_info: DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo = None,
    ):
        # The address in the address pool.
        self.addr = addr
        # The information about the source region of the address.
        self.attribute_info = attribute_info

    def validate(self):
        if self.attribute_info:
            self.attribute_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr is not None:
            result['Addr'] = self.addr
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Addr') is not None:
            self.addr = m.get('Addr')
        if m.get('AttributeInfo') is not None:
            temp_model = DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo()
            self.attribute_info = temp_model.from_map(m['AttributeInfo'])
        return self


class DescribeDnsGtmAddrAttributeInfoResponseBodyAddr(TeaModel):
    def __init__(
        self,
        addr: List[DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr] = None,
    ):
        self.addr = addr

    def validate(self):
        if self.addr:
            for k in self.addr:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addr'] = []
        if self.addr is not None:
            for k in self.addr:
                result['Addr'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr = []
        if m.get('Addr') is not None:
            for k in m.get('Addr'):
                temp_model = DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr()
                self.addr.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAddrAttributeInfoResponseBody(TeaModel):
    def __init__(
        self,
        addr: DescribeDnsGtmAddrAttributeInfoResponseBodyAddr = None,
        request_id: str = None,
    ):
        # The address in the address pool.
        self.addr = addr
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.addr:
            self.addr.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr is not None:
            result['Addr'] = self.addr.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Addr') is not None:
            temp_model = DescribeDnsGtmAddrAttributeInfoResponseBodyAddr()
            self.addr = temp_model.from_map(m['Addr'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDnsGtmAddrAttributeInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmAddrAttributeInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmAddrAttributeInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmAddressPoolAvailableConfigRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
    ):
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo(TeaModel):
    def __init__(
        self,
        father_code: str = None,
        group_code: str = None,
        group_name: str = None,
        line_code: str = None,
        line_name: str = None,
    ):
        # The parent line code of the source region.
        self.father_code = father_code
        # The code of the source region group.
        self.group_code = group_code
        # The name of the request source group.
        self.group_name = group_name
        # The line code of the source region.
        self.line_code = line_code
        # The line name of the source region.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.father_code is not None:
            result['FatherCode'] = self.father_code
        if self.group_code is not None:
            result['GroupCode'] = self.group_code
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FatherCode') is not None:
            self.father_code = m.get('FatherCode')
        if m.get('GroupCode') is not None:
            self.group_code = m.get('GroupCode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos(TeaModel):
    def __init__(
        self,
        attribute_info: List[DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo] = None,
    ):
        self.attribute_info = attribute_info

    def validate(self):
        if self.attribute_info:
            for k in self.attribute_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AttributeInfo'] = []
        if self.attribute_info is not None:
            for k in self.attribute_info:
                result['AttributeInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attribute_info = []
        if m.get('AttributeInfo') is not None:
            for k in m.get('AttributeInfo'):
                temp_model = DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo()
                self.attribute_info.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmAddressPoolAvailableConfigResponseBody(TeaModel):
    def __init__(
        self,
        attribute_infos: DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos = None,
        request_id: str = None,
    ):
        # The supported source regions.
        self.attribute_infos = attribute_infos
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.attribute_infos:
            self.attribute_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attribute_infos is not None:
            result['AttributeInfos'] = self.attribute_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttributeInfos') is not None:
            temp_model = DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos()
            self.attribute_infos = temp_model.from_map(m['AttributeInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDnsGtmAddressPoolAvailableConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmAddressPoolAvailableConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmAvailableAlertGroupRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDnsGtmAvailableAlertGroupResponseBody(TeaModel):
    def __init__(
        self,
        available_alert_group: str = None,
        request_id: str = None,
    ):
        # The returned available alert groups.
        self.available_alert_group = available_alert_group
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_alert_group is not None:
            result['AvailableAlertGroup'] = self.available_alert_group
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableAlertGroup') is not None:
            self.available_alert_group = m.get('AvailableAlertGroup')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDnsGtmAvailableAlertGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmAvailableAlertGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmAvailableAlertGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
    ):
        # The ID of the instance about which you want to query the information.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig(TeaModel):
    def __init__(
        self,
        dingtalk_notice: bool = None,
        email_notice: bool = None,
        notice_type: str = None,
        sms_notice: bool = None,
    ):
        self.dingtalk_notice = dingtalk_notice
        # Indicates whether email notification is configured. Valid values:
        # 
        # *   true: Email notification is configured.
        # *   false: Email notification is not configured. null: Email notification is not configured.
        self.email_notice = email_notice
        # The type of the alert event. Valid values:
        # 
        # *   ADDR_ALERT: The address is unavailable.
        # *   ADDR_RESUME: The address is restored and becomes available.
        # *   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
        # *   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
        # *   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
        # *   MONITOR_NODE_IP_CHANGE: The IP address of the monitoring node has changed.
        self.notice_type = notice_type
        # Indicates whether SMS notification is configured. Valid values:
        # 
        # *   true: SMS notification is configured.
        # *   false: SMS notification is not configured. null: SMS notification is not configured.
        self.sms_notice = sms_notice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_notice is not None:
            result['DingtalkNotice'] = self.dingtalk_notice
        if self.email_notice is not None:
            result['EmailNotice'] = self.email_notice
        if self.notice_type is not None:
            result['NoticeType'] = self.notice_type
        if self.sms_notice is not None:
            result['SmsNotice'] = self.sms_notice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkNotice') is not None:
            self.dingtalk_notice = m.get('DingtalkNotice')
        if m.get('EmailNotice') is not None:
            self.email_notice = m.get('EmailNotice')
        if m.get('NoticeType') is not None:
            self.notice_type = m.get('NoticeType')
        if m.get('SmsNotice') is not None:
            self.sms_notice = m.get('SmsNotice')
        return self


class DescribeDnsGtmInstanceResponseBodyConfigAlertConfig(TeaModel):
    def __init__(
        self,
        alert_config: List[DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig] = None,
    ):
        self.alert_config = alert_config

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmInstanceResponseBodyConfig(TeaModel):
    def __init__(
        self,
        alert_config: DescribeDnsGtmInstanceResponseBodyConfigAlertConfig = None,
        alert_group: str = None,
        cname_type: str = None,
        instance_name: str = None,
        pubic_zone_name: str = None,
        public_cname_mode: str = None,
        public_rr: str = None,
        public_user_domain_name: str = None,
        strategy_mode: str = None,
        ttl: int = None,
    ):
        # The alert notification method.
        self.alert_config = alert_config
        # The name of the alert group.
        self.alert_group = alert_group
        # The type of the CNAME domain name that is used to access the instance. Valid value:
        # 
        # *   PUBLIC: The CNAME domain name is used to access the instance over the Internet.
        self.cname_type = cname_type
        # The name of the instance.
        self.instance_name = instance_name
        # The domain name that is used to access the instance over the Internet.
        self.pubic_zone_name = pubic_zone_name
        # Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access the instance over the Internet. Valid values:
        # 
        # *   CUSTOM: A custom CNAME domain name is used.
        # *   SYSTEM_ASSIGN: A CNAME domain name assigned by the system is used.
        self.public_cname_mode = public_cname_mode
        # The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.
        self.public_rr = public_rr
        # The service domain name that is used over the Internet.
        self.public_user_domain_name = public_user_domain_name
        # The type of the access policy. Valid values:
        # 
        # *   LATENCY: Latency-based
        # *   GEO: Geographical location-based
        self.strategy_mode = strategy_mode
        # The global time to live (TTL).
        self.ttl = ttl

    def validate(self):
        if self.alert_config:
            self.alert_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_config is not None:
            result['AlertConfig'] = self.alert_config.to_map()
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.cname_type is not None:
            result['CnameType'] = self.cname_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.pubic_zone_name is not None:
            result['PubicZoneName'] = self.pubic_zone_name
        if self.public_cname_mode is not None:
            result['PublicCnameMode'] = self.public_cname_mode
        if self.public_rr is not None:
            result['PublicRr'] = self.public_rr
        if self.public_user_domain_name is not None:
            result['PublicUserDomainName'] = self.public_user_domain_name
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertConfig') is not None:
            temp_model = DescribeDnsGtmInstanceResponseBodyConfigAlertConfig()
            self.alert_config = temp_model.from_map(m['AlertConfig'])
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('CnameType') is not None:
            self.cname_type = m.get('CnameType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PubicZoneName') is not None:
            self.pubic_zone_name = m.get('PubicZoneName')
        if m.get('PublicCnameMode') is not None:
            self.public_cname_mode = m.get('PublicCnameMode')
        if m.get('PublicRr') is not None:
            self.public_rr = m.get('PublicRr')
        if m.get('PublicUserDomainName') is not None:
            self.public_user_domain_name = m.get('PublicUserDomainName')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        return self


class DescribeDnsGtmInstanceResponseBodyUsedQuota(TeaModel):
    def __init__(
        self,
        dingtalk_used_count: int = None,
        email_used_count: int = None,
        sms_used_count: int = None,
        task_used_count: int = None,
    ):
        self.dingtalk_used_count = dingtalk_used_count
        # The total number of emails that were sent.
        self.email_used_count = email_used_count
        # The total number of short messages that were sent.
        self.sms_used_count = sms_used_count
        # The number of detection tasks that were created.
        self.task_used_count = task_used_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_used_count is not None:
            result['DingtalkUsedCount'] = self.dingtalk_used_count
        if self.email_used_count is not None:
            result['EmailUsedCount'] = self.email_used_count
        if self.sms_used_count is not None:
            result['SmsUsedCount'] = self.sms_used_count
        if self.task_used_count is not None:
            result['TaskUsedCount'] = self.task_used_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkUsedCount') is not None:
            self.dingtalk_used_count = m.get('DingtalkUsedCount')
        if m.get('EmailUsedCount') is not None:
            self.email_used_count = m.get('EmailUsedCount')
        if m.get('SmsUsedCount') is not None:
            self.sms_used_count = m.get('SmsUsedCount')
        if m.get('TaskUsedCount') is not None:
            self.task_used_count = m.get('TaskUsedCount')
        return self


class DescribeDnsGtmInstanceResponseBody(TeaModel):
    def __init__(
        self,
        config: DescribeDnsGtmInstanceResponseBodyConfig = None,
        create_time: str = None,
        create_timestamp: int = None,
        expire_time: str = None,
        expire_timestamp: int = None,
        instance_id: str = None,
        payment_type: str = None,
        request_id: str = None,
        resource_group_id: str = None,
        sms_quota: int = None,
        task_quota: int = None,
        used_quota: DescribeDnsGtmInstanceResponseBodyUsedQuota = None,
        version_code: str = None,
    ):
        # The configurations of the instance.
        self.config = config
        # The time when the instance was created.
        self.create_time = create_time
        # The UNIX timestamp that indicates when the instance was created.
        self.create_timestamp = create_timestamp
        # The time when the instance expires.
        self.expire_time = expire_time
        # The UNIX timestamp that indicates when the instance expires.
        self.expire_timestamp = expire_timestamp
        # The ID of the instance.
        self.instance_id = instance_id
        # The billing method. Valid value:
        # 
        # *   Subscription: You can pay in advance for the use of resources.
        self.payment_type = payment_type
        # The ID of the request.
        self.request_id = request_id
        # The ID of the resource group to which the instance belongs.
        self.resource_group_id = resource_group_id
        # The total number of SMS notifications.
        self.sms_quota = sms_quota
        # The total number of detection tasks.
        self.task_quota = task_quota
        # The used quota.
        self.used_quota = used_quota
        # The version of the instance.
        self.version_code = version_code

    def validate(self):
        if self.config:
            self.config.validate()
        if self.used_quota:
            self.used_quota.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.expire_timestamp is not None:
            result['ExpireTimestamp'] = self.expire_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.sms_quota is not None:
            result['SmsQuota'] = self.sms_quota
        if self.task_quota is not None:
            result['TaskQuota'] = self.task_quota
        if self.used_quota is not None:
            result['UsedQuota'] = self.used_quota.to_map()
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            temp_model = DescribeDnsGtmInstanceResponseBodyConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ExpireTimestamp') is not None:
            self.expire_timestamp = m.get('ExpireTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SmsQuota') is not None:
            self.sms_quota = m.get('SmsQuota')
        if m.get('TaskQuota') is not None:
            self.task_quota = m.get('TaskQuota')
        if m.get('UsedQuota') is not None:
            temp_model = DescribeDnsGtmInstanceResponseBodyUsedQuota()
            self.used_quota = temp_model.from_map(m['UsedQuota'])
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeDnsGtmInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmInstanceAddressPoolRequest(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        lang: str = None,
    ):
        # The ID of the address pool.
        # 
        # This parameter is required.
        self.addr_pool_id = addr_pool_id
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr(TeaModel):
    def __init__(
        self,
        addr: str = None,
        alert_status: str = None,
        attribute_info: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        lba_weight: int = None,
        mode: str = None,
        remark: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The address.
        self.addr = addr
        # The status of the last health check on the address. Valid values:
        # 
        # *   OK: No active alerts are triggered.
        # *   ALERT: Alerts are triggered based on the alert rules.
        self.alert_status = alert_status
        # The source region of the address.
        # 
        # *   lineCode: the line code of the source region of the address. This parameter is deprecated, and lineCodes prevails.
        # *   lineName: the line name of the source region of the address. This parameter is deprecated.
        # *   lineCodes: the line codes of the source regions of the address.
        self.attribute_info = attribute_info
        # The time when the address was added into the address pool.
        self.create_time = create_time
        # The timestamp that indicates the time when the address was added into the address pool.
        self.create_timestamp = create_timestamp
        # The weight of the address.
        self.lba_weight = lba_weight
        # The mode of the address. Valid values:
        # 
        # *   SMART: smart return
        # *   ONLINE: always online
        # *   OFFLINE: always offline
        self.mode = mode
        # The description of the address.
        self.remark = remark
        # The time when the address was last updated.
        self.update_time = update_time
        # The timestamp that indicates the time when the address was last updated.
        self.update_timestamp = update_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr is not None:
            result['Addr'] = self.addr
        if self.alert_status is not None:
            result['AlertStatus'] = self.alert_status
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Addr') is not None:
            self.addr = m.get('Addr')
        if m.get('AlertStatus') is not None:
            self.alert_status = m.get('AlertStatus')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs(TeaModel):
    def __init__(
        self,
        addr: List[DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr] = None,
    ):
        self.addr = addr

    def validate(self):
        if self.addr:
            for k in self.addr:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addr'] = []
        if self.addr is not None:
            for k in self.addr:
                result['Addr'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr = []
        if m.get('Addr') is not None:
            for k in m.get('Addr'):
                temp_model = DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr()
                self.addr.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmInstanceAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        addr_pool_id: str = None,
        addrs: DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs = None,
        create_time: str = None,
        create_timestamp: int = None,
        lba_strategy: str = None,
        monitor_config_id: str = None,
        monitor_status: str = None,
        name: str = None,
        request_id: str = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.addr_pool_id = addr_pool_id
        # The addresses in the address pool.
        self.addrs = addrs
        # The time when the address pool was created.
        self.create_time = create_time
        # The timestamp that indicates the time when the address pool was created.
        self.create_timestamp = create_timestamp
        # The load balancing policy for the address pool. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        self.lba_strategy = lba_strategy
        # The ID of the health check configuration.
        self.monitor_config_id = monitor_config_id
        # Indicates the status of the health check. Valid values:
        # 
        # *   OPEN: The health check is enabled.
        # *   CLOSE: The health check is disabled.
        # *   UNCONFIGURED: The health check is not configured.
        self.monitor_status = monitor_status
        # The name of the address pool.
        self.name = name
        # The ID of the request.
        self.request_id = request_id
        # The type of the address pool. Valid values:
        # 
        # *   IPV4: IPv4 address
        # *   IPV6: IPv6 address
        # *   DOMAIN: domain name
        self.type = type
        # The time when the address pool was last updated.
        self.update_time = update_time
        # The timestamp that indicates the time when the address pool was last updated.
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.addrs:
            self.addrs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.addrs is not None:
            result['Addrs'] = self.addrs.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.lba_strategy is not None:
            result['LbaStrategy'] = self.lba_strategy
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Addrs') is not None:
            temp_model = DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs()
            self.addrs = temp_model.from_map(m['Addrs'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('LbaStrategy') is not None:
            self.lba_strategy = m.get('LbaStrategy')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeDnsGtmInstanceAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmInstanceAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmInstanceAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmInstanceAddressPoolsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: 100. Default value: 20.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        addr_pool_id: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        lba_strategy: str = None,
        monitor_config_id: str = None,
        monitor_status: str = None,
        name: str = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.addr_pool_id = addr_pool_id
        # The time when the address pool was created.
        self.create_time = create_time
        # The timestamp that indicates when the address pool was created.
        self.create_timestamp = create_timestamp
        # The load balancing policy of the address pool. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        self.lba_strategy = lba_strategy
        # The ID of the health check task.
        self.monitor_config_id = monitor_config_id
        # Indicates whether health checks are configured. Valid values:
        # 
        # *   OPEN: enabled
        # *   CLOSE: disabled
        # *   UNCONFIGURED: not configured
        self.monitor_status = monitor_status
        # The name of the address pool.
        self.name = name
        # The type of the address pool. Valid values:
        # 
        # *   IPV4: IPv4 address
        # *   IPV6: IPv6 address
        # *   DOMAIN: domain name
        self.type = type
        # The time when the address pool was updated.
        self.update_time = update_time
        # The timestamp that indicates when the address pool was updated.
        self.update_timestamp = update_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.lba_strategy is not None:
            result['LbaStrategy'] = self.lba_strategy
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('LbaStrategy') is not None:
            self.lba_strategy = m.get('LbaStrategy')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools(TeaModel):
    def __init__(
        self,
        addr_pool: List[DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool] = None,
    ):
        self.addr_pool = addr_pool

    def validate(self):
        if self.addr_pool:
            for k in self.addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddrPool'] = []
        if self.addr_pool is not None:
            for k in self.addr_pool:
                result['AddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr_pool = []
        if m.get('AddrPool') is not None:
            for k in m.get('AddrPool'):
                temp_model = DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool()
                self.addr_pool.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmInstanceAddressPoolsResponseBody(TeaModel):
    def __init__(
        self,
        addr_pools: DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The returned address pools.
        self.addr_pools = addr_pools
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned on all pages.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.addr_pools:
            self.addr_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pools is not None:
            result['AddrPools'] = self.addr_pools.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPools') is not None:
            temp_model = DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools()
            self.addr_pools = temp_model.from_map(m['AddrPools'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeDnsGtmInstanceAddressPoolsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmInstanceAddressPoolsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmInstanceAddressPoolsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmInstanceStatusRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
    ):
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDnsGtmInstanceStatusResponseBody(TeaModel):
    def __init__(
        self,
        addr_available_num: int = None,
        addr_not_available_num: int = None,
        addr_pool_group_not_available_num: int = None,
        request_id: str = None,
        strategy_not_available_num: int = None,
        switch_to_failover_strategy_num: int = None,
    ):
        # The number of available addresses.
        self.addr_available_num = addr_available_num
        # The number of unavailable addresses.
        self.addr_not_available_num = addr_not_available_num
        # The number of unavailable address pool groups.
        self.addr_pool_group_not_available_num = addr_pool_group_not_available_num
        # The ID of the request.
        self.request_id = request_id
        # The number of access policies that are unavailable in the current active address pool group.
        self.strategy_not_available_num = strategy_not_available_num
        # The number of access policies switched to the secondary address pool group.
        self.switch_to_failover_strategy_num = switch_to_failover_strategy_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_available_num is not None:
            result['AddrAvailableNum'] = self.addr_available_num
        if self.addr_not_available_num is not None:
            result['AddrNotAvailableNum'] = self.addr_not_available_num
        if self.addr_pool_group_not_available_num is not None:
            result['AddrPoolGroupNotAvailableNum'] = self.addr_pool_group_not_available_num
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy_not_available_num is not None:
            result['StrategyNotAvailableNum'] = self.strategy_not_available_num
        if self.switch_to_failover_strategy_num is not None:
            result['SwitchToFailoverStrategyNum'] = self.switch_to_failover_strategy_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrAvailableNum') is not None:
            self.addr_available_num = m.get('AddrAvailableNum')
        if m.get('AddrNotAvailableNum') is not None:
            self.addr_not_available_num = m.get('AddrNotAvailableNum')
        if m.get('AddrPoolGroupNotAvailableNum') is not None:
            self.addr_pool_group_not_available_num = m.get('AddrPoolGroupNotAvailableNum')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StrategyNotAvailableNum') is not None:
            self.strategy_not_available_num = m.get('StrategyNotAvailableNum')
        if m.get('SwitchToFailoverStrategyNum') is not None:
            self.switch_to_failover_strategy_num = m.get('SwitchToFailoverStrategyNum')
        return self


class DescribeDnsGtmInstanceStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmInstanceStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmInstanceStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmInstanceSystemCnameRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
    ):
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDnsGtmInstanceSystemCnameResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        system_cname: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The CNAME domain name assigned by the system.
        self.system_cname = system_cname

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.system_cname is not None:
            result['SystemCname'] = self.system_cname
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SystemCname') is not None:
            self.system_cname = m.get('SystemCname')
        return self


class DescribeDnsGtmInstanceSystemCnameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmInstanceSystemCnameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmInstanceSystemCnameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmInstancesRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        resource_group_id: str = None,
    ):
        # The keyword that you use for the query. Fuzzy search by instance ID or instance name is supported.
        self.keyword = keyword
        # The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size
        # The resource group ID.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig(TeaModel):
    def __init__(
        self,
        dingtalk_notice: str = None,
        email_notice: str = None,
        notice_type: str = None,
        sms_notice: str = None,
    ):
        # Indicates whether DingTalk alert notifications are configured. Valid values:
        # 
        # *   true
        # *   false | null
        self.dingtalk_notice = dingtalk_notice
        # Indicates whether email notifications are configured. Valid values:
        # 
        # *   true
        # *   false | null
        self.email_notice = email_notice
        # The type of the alert event. Valid values:
        # 
        # *   ADDR_ALERT: The address is unavailable.
        # *   ADDR_RESUME: The address becomes available.
        # *   ADDR_POOL_GROUP_UNAVAILABLE: The address pool set is unavailable.
        # *   ADDR_POOL_GROUP_AVAILABLE: The address pool set becomes available.
        # *   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
        self.notice_type = notice_type
        # Indicates whether SMS notifications are configured. Valid values:
        # 
        # *   true
        # *   false | null
        self.sms_notice = sms_notice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_notice is not None:
            result['DingtalkNotice'] = self.dingtalk_notice
        if self.email_notice is not None:
            result['EmailNotice'] = self.email_notice
        if self.notice_type is not None:
            result['NoticeType'] = self.notice_type
        if self.sms_notice is not None:
            result['SmsNotice'] = self.sms_notice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkNotice') is not None:
            self.dingtalk_notice = m.get('DingtalkNotice')
        if m.get('EmailNotice') is not None:
            self.email_notice = m.get('EmailNotice')
        if m.get('NoticeType') is not None:
            self.notice_type = m.get('NoticeType')
        if m.get('SmsNotice') is not None:
            self.sms_notice = m.get('SmsNotice')
        return self


class DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig(TeaModel):
    def __init__(
        self,
        alert_config: List[DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig] = None,
        alert_group: str = None,
        cname_type: str = None,
        instance_name: str = None,
        public_cname_mode: str = None,
        public_rr: str = None,
        public_user_domain_name: str = None,
        public_zone_name: str = None,
        strategy_mode: str = None,
        ttl: int = None,
    ):
        # The alert notification method.
        self.alert_config = alert_config
        # The alert contact groups. The value is in the JSON format.
        self.alert_group = alert_group
        # The type of the CNAME. Valid value:
        # 
        # *   PUBLIC
        self.cname_type = cname_type
        # The name of the instance.
        self.instance_name = instance_name
        # Specifies whether to use a custom CNAME or a system-assigned CNAME to access GTM over the Internet. Valid values:
        # 
        # *   CUSTOM: a custom CNAME
        # *   SYSTEM_ASSIGN: a system-assigned CNAME. You cannot set PublicCnameMode to this value.
        self.public_cname_mode = public_cname_mode
        # The hostname of the domain name that is used to access GTM over the Internet.
        self.public_rr = public_rr
        # The domain name that is used to access GTM over the Internet.
        self.public_user_domain_name = public_user_domain_name
        # The canonical name (CNAME) that is used to access GTM over the Internet.
        self.public_zone_name = public_zone_name
        # The type of the access policy. Valid values:
        # 
        # *   LATENCY: latency-based access policy
        # *   GEO: geographical location-based access policy
        self.strategy_mode = strategy_mode
        # The global time to live (TTL).
        self.ttl = ttl

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.cname_type is not None:
            result['CnameType'] = self.cname_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.public_cname_mode is not None:
            result['PublicCnameMode'] = self.public_cname_mode
        if self.public_rr is not None:
            result['PublicRr'] = self.public_rr
        if self.public_user_domain_name is not None:
            result['PublicUserDomainName'] = self.public_user_domain_name
        if self.public_zone_name is not None:
            result['PublicZoneName'] = self.public_zone_name
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('CnameType') is not None:
            self.cname_type = m.get('CnameType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PublicCnameMode') is not None:
            self.public_cname_mode = m.get('PublicCnameMode')
        if m.get('PublicRr') is not None:
            self.public_rr = m.get('PublicRr')
        if m.get('PublicUserDomainName') is not None:
            self.public_user_domain_name = m.get('PublicUserDomainName')
        if m.get('PublicZoneName') is not None:
            self.public_zone_name = m.get('PublicZoneName')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        return self


class DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota(TeaModel):
    def __init__(
        self,
        dingtalk_used_count: int = None,
        email_used_count: int = None,
        sms_used_count: int = None,
        task_used_count: int = None,
    ):
        # The total number of sent DingTalk notifications.
        self.dingtalk_used_count = dingtalk_used_count
        # The total number of sent email notifications.
        self.email_used_count = email_used_count
        # The total number of sent SMS notifications.
        self.sms_used_count = sms_used_count
        # The number of created detection tasks.
        self.task_used_count = task_used_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_used_count is not None:
            result['DingtalkUsedCount'] = self.dingtalk_used_count
        if self.email_used_count is not None:
            result['EmailUsedCount'] = self.email_used_count
        if self.sms_used_count is not None:
            result['SmsUsedCount'] = self.sms_used_count
        if self.task_used_count is not None:
            result['TaskUsedCount'] = self.task_used_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkUsedCount') is not None:
            self.dingtalk_used_count = m.get('DingtalkUsedCount')
        if m.get('EmailUsedCount') is not None:
            self.email_used_count = m.get('EmailUsedCount')
        if m.get('SmsUsedCount') is not None:
            self.sms_used_count = m.get('SmsUsedCount')
        if m.get('TaskUsedCount') is not None:
            self.task_used_count = m.get('TaskUsedCount')
        return self


class DescribeDnsGtmInstancesResponseBodyGtmInstances(TeaModel):
    def __init__(
        self,
        config: DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig = None,
        create_time: str = None,
        create_timestamp: int = None,
        expire_time: str = None,
        expire_timestamp: int = None,
        instance_id: str = None,
        payment_type: str = None,
        resource_group_id: str = None,
        sms_quota: int = None,
        task_quota: int = None,
        used_quota: DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota = None,
        version_code: str = None,
    ):
        # The configurations of the instance.
        self.config = config
        # The time when the instance was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_timestamp = create_timestamp
        # The time when the instance expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.expire_time = expire_time
        # The time when the instance expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.expire_timestamp = expire_timestamp
        # The instance ID.
        self.instance_id = instance_id
        # The billing method of the GTM instance. Valid value:
        # 
        # *   Subscription.
        self.payment_type = payment_type
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The total number of Short Message Service (SMS) notifications.
        self.sms_quota = sms_quota
        # The total number of detection tasks.
        self.task_quota = task_quota
        # The used quota.
        self.used_quota = used_quota
        # The version of the instance.
        self.version_code = version_code

    def validate(self):
        if self.config:
            self.config.validate()
        if self.used_quota:
            self.used_quota.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.expire_timestamp is not None:
            result['ExpireTimestamp'] = self.expire_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.sms_quota is not None:
            result['SmsQuota'] = self.sms_quota
        if self.task_quota is not None:
            result['TaskQuota'] = self.task_quota
        if self.used_quota is not None:
            result['UsedQuota'] = self.used_quota.to_map()
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            temp_model = DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ExpireTimestamp') is not None:
            self.expire_timestamp = m.get('ExpireTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SmsQuota') is not None:
            self.sms_quota = m.get('SmsQuota')
        if m.get('TaskQuota') is not None:
            self.task_quota = m.get('TaskQuota')
        if m.get('UsedQuota') is not None:
            temp_model = DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota()
            self.used_quota = temp_model.from_map(m['UsedQuota'])
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeDnsGtmInstancesResponseBody(TeaModel):
    def __init__(
        self,
        gtm_instances: List[DescribeDnsGtmInstancesResponseBodyGtmInstances] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The Global Traffic Manager (GTM) instances.
        self.gtm_instances = gtm_instances
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: 100. Default value: 20.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.gtm_instances:
            for k in self.gtm_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GtmInstances'] = []
        if self.gtm_instances is not None:
            for k in self.gtm_instances:
                result['GtmInstances'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.gtm_instances = []
        if m.get('GtmInstances') is not None:
            for k in m.get('GtmInstances'):
                temp_model = DescribeDnsGtmInstancesResponseBodyGtmInstances()
                self.gtm_instances.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeDnsGtmInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmLogsRequest(TeaModel):
    def __init__(
        self,
        end_timestamp: int = None,
        instance_id: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_timestamp: int = None,
    ):
        # The timestamp that specifies the end of the time range to query.
        self.end_timestamp = end_timestamp
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
        self.keyword = keyword
        # The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: 100. Default value: 20.
        self.page_size = page_size
        # The timestamp that specifies the beginning of the time range to query.
        self.start_timestamp = start_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_timestamp is not None:
            result['EndTimestamp'] = self.end_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTimestamp') is not None:
            self.end_timestamp = m.get('EndTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        return self


class DescribeDnsGtmLogsResponseBodyLogsLog(TeaModel):
    def __init__(
        self,
        content: str = None,
        entity_id: str = None,
        entity_name: str = None,
        entity_type: str = None,
        id: int = None,
        oper_action: str = None,
        oper_time: str = None,
        oper_timestamp: int = None,
    ):
        # The formatted message content.
        self.content = content
        # The ID of the object on which the operation was performed.
        self.entity_id = entity_id
        # The name of the object on which the operation was performed.
        self.entity_name = entity_name
        # The type of the object on which the operation was performed.
        self.entity_type = entity_type
        # The ID of the record.
        self.id = id
        # The operation performed.
        self.oper_action = oper_action
        # The time when the operation was performed.
        self.oper_time = oper_time
        # The timestamp of the operation.
        self.oper_timestamp = oper_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.entity_name is not None:
            result['EntityName'] = self.entity_name
        if self.entity_type is not None:
            result['EntityType'] = self.entity_type
        if self.id is not None:
            result['Id'] = self.id
        if self.oper_action is not None:
            result['OperAction'] = self.oper_action
        if self.oper_time is not None:
            result['OperTime'] = self.oper_time
        if self.oper_timestamp is not None:
            result['OperTimestamp'] = self.oper_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('EntityName') is not None:
            self.entity_name = m.get('EntityName')
        if m.get('EntityType') is not None:
            self.entity_type = m.get('EntityType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('OperAction') is not None:
            self.oper_action = m.get('OperAction')
        if m.get('OperTime') is not None:
            self.oper_time = m.get('OperTime')
        if m.get('OperTimestamp') is not None:
            self.oper_timestamp = m.get('OperTimestamp')
        return self


class DescribeDnsGtmLogsResponseBodyLogs(TeaModel):
    def __init__(
        self,
        log: List[DescribeDnsGtmLogsResponseBodyLogsLog] = None,
    ):
        self.log = log

    def validate(self):
        if self.log:
            for k in self.log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Log'] = []
        if self.log is not None:
            for k in self.log:
                result['Log'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log = []
        if m.get('Log') is not None:
            for k in m.get('Log'):
                temp_model = DescribeDnsGtmLogsResponseBodyLogsLog()
                self.log.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmLogsResponseBody(TeaModel):
    def __init__(
        self,
        logs: DescribeDnsGtmLogsResponseBodyLogs = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The returned logs.
        self.logs = logs
        # The number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned on all pages.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.logs:
            self.logs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logs is not None:
            result['Logs'] = self.logs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logs') is not None:
            temp_model = DescribeDnsGtmLogsResponseBodyLogs()
            self.logs = temp_model.from_map(m['Logs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeDnsGtmLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmMonitorAvailableConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps(TeaModel):
    def __init__(
        self,
        ip: List[str] = None,
    ):
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        default_selected: bool = None,
        group_name: str = None,
        group_type: str = None,
        ips: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        # The city code.
        self.city_code = city_code
        # The display name of the city.
        self.city_name = city_name
        # Indicates whether the health check node is selected by default.
        self.default_selected = default_selected
        # The name of the node group.
        self.group_name = group_name
        # The type of the node group. Valid values:
        # 
        # *   BGP: BGP node
        # *   OVERSEAS: node outside the Chinese mainland
        # *   ISP: ISP node
        self.group_type = group_type
        # The IP addresses of the health check nodes.
        self.ips = ips
        # The ISP code.
        self.isp_code = isp_code
        # The display name of the ISP.
        self.isp_name = isp_name

    def validate(self):
        if self.ips:
            self.ips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.default_selected is not None:
            result['DefaultSelected'] = self.default_selected
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.ips is not None:
            result['Ips'] = self.ips.to_map()
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('DefaultSelected') is not None:
            self.default_selected = m.get('DefaultSelected')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('Ips') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps()
            self.ips = temp_model.from_map(m['Ips'])
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes(TeaModel):
    def __init__(
        self,
        domain_ipv_4isp_city_node: List[DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode] = None,
    ):
        self.domain_ipv_4isp_city_node = domain_ipv_4isp_city_node

    def validate(self):
        if self.domain_ipv_4isp_city_node:
            for k in self.domain_ipv_4isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainIpv4IspCityNode'] = []
        if self.domain_ipv_4isp_city_node is not None:
            for k in self.domain_ipv_4isp_city_node:
                result['DomainIpv4IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_ipv_4isp_city_node = []
        if m.get('DomainIpv4IspCityNode') is not None:
            for k in m.get('DomainIpv4IspCityNode'):
                temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode()
                self.domain_ipv_4isp_city_node.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps(TeaModel):
    def __init__(
        self,
        ip: List[str] = None,
    ):
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        default_selected: bool = None,
        group_name: str = None,
        group_type: str = None,
        ips: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        # The city code.
        self.city_code = city_code
        # The display name of the city.
        self.city_name = city_name
        # Indicates whether the health check node is selected by default.
        self.default_selected = default_selected
        # The name of the node group.
        self.group_name = group_name
        # The type of the node group. Valid values:
        # 
        # *   BGP: BGP node
        # *   OVERSEAS: node outside the Chinese mainland
        # *   ISP: ISP node
        self.group_type = group_type
        # This parameter is not returned.
        self.ips = ips
        # The ISP code.
        self.isp_code = isp_code
        # The display name of the ISP.
        self.isp_name = isp_name

    def validate(self):
        if self.ips:
            self.ips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.default_selected is not None:
            result['DefaultSelected'] = self.default_selected
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.ips is not None:
            result['Ips'] = self.ips.to_map()
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('DefaultSelected') is not None:
            self.default_selected = m.get('DefaultSelected')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('Ips') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps()
            self.ips = temp_model.from_map(m['Ips'])
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes(TeaModel):
    def __init__(
        self,
        domain_ipv_6isp_city_node: List[DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode] = None,
    ):
        self.domain_ipv_6isp_city_node = domain_ipv_6isp_city_node

    def validate(self):
        if self.domain_ipv_6isp_city_node:
            for k in self.domain_ipv_6isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainIpv6IspCityNode'] = []
        if self.domain_ipv_6isp_city_node is not None:
            for k in self.domain_ipv_6isp_city_node:
                result['DomainIpv6IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_ipv_6isp_city_node = []
        if m.get('DomainIpv6IspCityNode') is not None:
            for k in m.get('DomainIpv6IspCityNode'):
                temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode()
                self.domain_ipv_6isp_city_node.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps(TeaModel):
    def __init__(
        self,
        ip: List[str] = None,
    ):
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        default_selected: bool = None,
        group_name: str = None,
        group_type: str = None,
        ips: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        # The city code.
        self.city_code = city_code
        # The display name of the city.
        self.city_name = city_name
        # Indicates whether the health check node is selected by default.
        self.default_selected = default_selected
        # The name of the node group.
        self.group_name = group_name
        # The type of the node group. Valid values:
        # 
        # *   BGP: Border Gateway Protocol (BGP) node
        # *   OVERSEAS: node outside the Chinese mainland
        # *   ISP: ISP node
        self.group_type = group_type
        # The IP addresses of the health check nodes.
        self.ips = ips
        # The Internet service provider (ISP) code.
        self.isp_code = isp_code
        # The display name of the ISP.
        self.isp_name = isp_name

    def validate(self):
        if self.ips:
            self.ips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.default_selected is not None:
            result['DefaultSelected'] = self.default_selected
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.ips is not None:
            result['Ips'] = self.ips.to_map()
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('DefaultSelected') is not None:
            self.default_selected = m.get('DefaultSelected')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('Ips') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps()
            self.ips = temp_model.from_map(m['Ips'])
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes(TeaModel):
    def __init__(
        self,
        ipv_4isp_city_node: List[DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode] = None,
    ):
        self.ipv_4isp_city_node = ipv_4isp_city_node

    def validate(self):
        if self.ipv_4isp_city_node:
            for k in self.ipv_4isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv4IspCityNode'] = []
        if self.ipv_4isp_city_node is not None:
            for k in self.ipv_4isp_city_node:
                result['Ipv4IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ipv_4isp_city_node = []
        if m.get('Ipv4IspCityNode') is not None:
            for k in m.get('Ipv4IspCityNode'):
                temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode()
                self.ipv_4isp_city_node.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps(TeaModel):
    def __init__(
        self,
        ip: List[str] = None,
    ):
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        default_selected: bool = None,
        group_name: str = None,
        group_type: str = None,
        ips: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        # The city code.
        self.city_code = city_code
        # The display name of the city.
        self.city_name = city_name
        # Indicates whether the health check node is selected by default.
        self.default_selected = default_selected
        # The name of the node group.
        self.group_name = group_name
        # The type of the node group. Valid values:
        # 
        # *   BGP: BGP node
        # *   OVERSEAS: node outside the Chinese mainland
        # *   ISP: ISP node
        self.group_type = group_type
        # This parameter is not returned.
        self.ips = ips
        # The ISP code.
        self.isp_code = isp_code
        # The display name of the ISP.
        self.isp_name = isp_name

    def validate(self):
        if self.ips:
            self.ips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.default_selected is not None:
            result['DefaultSelected'] = self.default_selected
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.ips is not None:
            result['Ips'] = self.ips.to_map()
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('DefaultSelected') is not None:
            self.default_selected = m.get('DefaultSelected')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('Ips') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps()
            self.ips = temp_model.from_map(m['Ips'])
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes(TeaModel):
    def __init__(
        self,
        ipv_6isp_city_node: List[DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode] = None,
    ):
        self.ipv_6isp_city_node = ipv_6isp_city_node

    def validate(self):
        if self.ipv_6isp_city_node:
            for k in self.ipv_6isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6IspCityNode'] = []
        if self.ipv_6isp_city_node is not None:
            for k in self.ipv_6isp_city_node:
                result['Ipv6IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ipv_6isp_city_node = []
        if m.get('Ipv6IspCityNode') is not None:
            for k in m.get('Ipv6IspCityNode'):
                temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode()
                self.ipv_6isp_city_node.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmMonitorAvailableConfigResponseBody(TeaModel):
    def __init__(
        self,
        domain_ipv_4isp_city_nodes: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes = None,
        domain_ipv_6isp_city_nodes: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes = None,
        ipv_4isp_city_nodes: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes = None,
        ipv_6isp_city_nodes: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes = None,
        request_id: str = None,
    ):
        # The nodes that perform health checks on domain names that use public IPv4 addresses.
        self.domain_ipv_4isp_city_nodes = domain_ipv_4isp_city_nodes
        # The nodes that perform health checks on domain names that use public IPv6 addresses.
        self.domain_ipv_6isp_city_nodes = domain_ipv_6isp_city_nodes
        # The nodes that perform health checks on public IPv4 addresses.
        self.ipv_4isp_city_nodes = ipv_4isp_city_nodes
        # The nodes that perform health checks on public IPv6 addresses.
        self.ipv_6isp_city_nodes = ipv_6isp_city_nodes
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.domain_ipv_4isp_city_nodes:
            self.domain_ipv_4isp_city_nodes.validate()
        if self.domain_ipv_6isp_city_nodes:
            self.domain_ipv_6isp_city_nodes.validate()
        if self.ipv_4isp_city_nodes:
            self.ipv_4isp_city_nodes.validate()
        if self.ipv_6isp_city_nodes:
            self.ipv_6isp_city_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_ipv_4isp_city_nodes is not None:
            result['DomainIpv4IspCityNodes'] = self.domain_ipv_4isp_city_nodes.to_map()
        if self.domain_ipv_6isp_city_nodes is not None:
            result['DomainIpv6IspCityNodes'] = self.domain_ipv_6isp_city_nodes.to_map()
        if self.ipv_4isp_city_nodes is not None:
            result['Ipv4IspCityNodes'] = self.ipv_4isp_city_nodes.to_map()
        if self.ipv_6isp_city_nodes is not None:
            result['Ipv6IspCityNodes'] = self.ipv_6isp_city_nodes.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainIpv4IspCityNodes') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes()
            self.domain_ipv_4isp_city_nodes = temp_model.from_map(m['DomainIpv4IspCityNodes'])
        if m.get('DomainIpv6IspCityNodes') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes()
            self.domain_ipv_6isp_city_nodes = temp_model.from_map(m['DomainIpv6IspCityNodes'])
        if m.get('Ipv4IspCityNodes') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes()
            self.ipv_4isp_city_nodes = temp_model.from_map(m['Ipv4IspCityNodes'])
        if m.get('Ipv6IspCityNodes') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes()
            self.ipv_6isp_city_nodes = temp_model.from_map(m['Ipv6IspCityNodes'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDnsGtmMonitorAvailableConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmMonitorAvailableConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmMonitorAvailableConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsGtmMonitorConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        monitor_config_id: str = None,
    ):
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The ID of the health check task.
        # 
        # This parameter is required.
        self.monitor_config_id = monitor_config_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        return self


class DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        country_code: str = None,
        country_name: str = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        # The city code.
        self.city_code = city_code
        # The display name of the city.
        self.city_name = city_name
        # The code of the country or region.
        self.country_code = country_code
        # The display name of the country or region.
        self.country_name = country_name
        # The Internet service provider (ISP) code.
        self.isp_code = isp_code
        # The display name of the ISP.
        self.isp_name = isp_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.country_code is not None:
            result['CountryCode'] = self.country_code
        if self.country_name is not None:
            result['CountryName'] = self.country_name
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('CountryCode') is not None:
            self.country_code = m.get('CountryCode')
        if m.get('CountryName') is not None:
            self.country_name = m.get('CountryName')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes(TeaModel):
    def __init__(
        self,
        isp_city_node: List[DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode] = None,
    ):
        self.isp_city_node = isp_city_node

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        return self


class DescribeDnsGtmMonitorConfigResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        evaluation_count: int = None,
        interval: int = None,
        isp_city_nodes: DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes = None,
        monitor_config_id: str = None,
        monitor_extend_info: str = None,
        protocol_type: str = None,
        request_id: str = None,
        timeout: int = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The time when the health check configuration was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the health check configuration was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_timestamp = create_timestamp
        # The number of consecutive failures.
        self.evaluation_count = evaluation_count
        # The health check interval. Unit: seconds.
        self.interval = interval
        # The health check nodes.
        self.isp_city_nodes = isp_city_nodes
        # The ID of the health check configuration.
        self.monitor_config_id = monitor_config_id
        # The extended information. The required parameters vary based on the value of ProtocolType.
        # 
        # *   HTTP or HTTPS
        # 
        #     *   port: the port that you want to check
        # 
        #     *   host: the host settings
        # 
        #     *   path: the URL path
        # 
        #     *   code: the response code. The health check result is deemed abnormal if the returned value is greater than the specified value.
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:
        # 
        #         *   true: enables SNI.
        #         *   false: disables SNI.
        # 
        #     *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # *   PING:
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   packetNum: the number of ping packets
        # 
        #     *   packetLossRate: the loss rate of ping packets
        # 
        #     *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # *   TCP
        # 
        #     *   port: the port that you want to check
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   nodeType: the type of the node for monitoring when the address pool type is domain name. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        self.monitor_extend_info = monitor_extend_info
        # The health check protocol. Valid values:
        # 
        # *   HTTP
        # *   HTTPS
        # *   PING
        # *   TCP
        self.protocol_type = protocol_type
        # The request ID.
        self.request_id = request_id
        # The timeout period. Unit: milliseconds.
        self.timeout = timeout
        # The time when the health check configuration was updated. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.update_time = update_time
        # The time when the health check configuration was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.isp_city_nodes:
            self.isp_city_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_city_nodes is not None:
            result['IspCityNodes'] = self.isp_city_nodes.to_map()
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.monitor_extend_info is not None:
            result['MonitorExtendInfo'] = self.monitor_extend_info
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspCityNodes') is not None:
            temp_model = DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes()
            self.isp_city_nodes = temp_model.from_map(m['IspCityNodes'])
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('MonitorExtendInfo') is not None:
            self.monitor_extend_info = m.get('MonitorExtendInfo')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeDnsGtmMonitorConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsGtmMonitorConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsGtmMonitorConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsProductInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        user_client_ip: str = None,
    ):
        # The ID of the DNS instance. . You can call the [DescribeDomainInfo](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaininfo?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en
        self.lang = lang
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class DescribeDnsProductInstanceResponseBodyDnsServers(TeaModel):
    def __init__(
        self,
        dns_server: List[str] = None,
    ):
        self.dns_server = dns_server

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server is not None:
            result['DnsServer'] = self.dns_server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServer') is not None:
            self.dns_server = m.get('DnsServer')
        return self


class DescribeDnsProductInstanceResponseBody(TeaModel):
    def __init__(
        self,
        auto_renewal: bool = None,
        bind_count: int = None,
        bind_domain_count: int = None,
        bind_domain_used_count: int = None,
        bind_used_count: int = None,
        ddos_defend_flow: int = None,
        ddos_defend_query: int = None,
        dns_slbcount: int = None,
        dns_security: str = None,
        dns_servers: DescribeDnsProductInstanceResponseBodyDnsServers = None,
        domain: str = None,
        domain_type: str = None,
        end_time: str = None,
        end_timestamp: int = None,
        gslb: bool = None,
        isplines: str = None,
        ispregion_lines: str = None,
        in_black_hole: bool = None,
        in_clean: bool = None,
        instance_id: str = None,
        monitor_frequency: int = None,
        monitor_node_count: int = None,
        monitor_task_count: int = None,
        oversea_ddos_defend_flow: int = None,
        oversea_line: str = None,
        payment_type: str = None,
        region_lines: bool = None,
        request_id: str = None,
        search_engine_lines: str = None,
        start_time: str = None,
        start_timestamp: int = None,
        sub_domain_level: int = None,
        ttlmin_value: int = None,
        urlforward_count: int = None,
        version_code: str = None,
        version_name: str = None,
    ):
        # Indicates whether auto-renewal was enabled. Valid values:
        # 
        # *   true: Auto-renewal was enabled.
        # *   false: Auto-renewal was not enabled.
        self.auto_renewal = auto_renewal
        # The number of times that you can change the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.
        self.bind_count = bind_count
        # The number of domain names that can be bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.
        self.bind_domain_count = bind_domain_count
        # The number of domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.
        self.bind_domain_used_count = bind_domain_used_count
        # The number of times that you have changed the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.
        self.bind_used_count = bind_used_count
        # The DDoS protection traffic. Unit: GB.
        self.ddos_defend_flow = ddos_defend_flow
        # The DDoS protection frequency. Unit: 10,000 QPS. This parameter applies to Alibaba Cloud DNS instances of the custom edition.
        self.ddos_defend_query = ddos_defend_query
        # The maximum number of IP addresses that are used for load balancing in a single line of a domain name.
        self.dns_slbcount = dns_slbcount
        # The level of DNS protection. Valid values:
        # 
        # *   no: No DNS protection is provided.
        # *   basic: Basic DNS protection is provided.
        # *   advanced: Advanced DNS protection is provided.
        self.dns_security = dns_security
        # The DNS servers configured for the domain names.
        self.dns_servers = dns_servers
        # The domain name that is bound to the paid instance.
        # 
        # If no value is returned for this parameter, no domain name is bound to the paid instance.
        self.domain = domain
        # The type of the instance. Valid values:
        # 
        # *   PUBLIC: authoritative domain name
        # *   CACHE: cache-accelerated domain name
        self.domain_type = domain_type
        # The time when the instance expired. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time
        # The time when the instance expired. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.end_timestamp = end_timestamp
        # Indicates whether global server load balancing (GSLB) is supported. Valid values:
        # 
        # *   true: GSLB is supported.
        # *   false: GSLB is not supported.
        self.gslb = gslb
        # The ISP resolution lines. Valid values:
        # 
        # *   China Telecom
        # *   China Mobile
        # *   China Unicom
        # *   China Education and Research Network (CERNET)
        # *   China Broadcasting Network (CBN)
        # *   Dr Peng Telecom & Media Group
        self.isplines = isplines
        # The regional ISP resolution lines. Valid values:
        # 
        # *   China Telecom (province)
        # *   China Mobile (province)
        # *   China Unicom (province)
        # *   CERNET (province)
        self.ispregion_lines = ispregion_lines
        # Indicates whether the Domain Name System (DNS) servers stopped responding to all DNS requests. Valid values:
        # 
        # *   true: The DNS servers stopped responding to all DNS requests.
        # *   false: The DNS servers did not stop responding to all DNS requests.
        self.in_black_hole = in_black_hole
        # Indicates whether the DNS servers stopped responding to abnormal requests sent to the domain names.
        # 
        # *   true: The DNS servers stopped responding to abnormal requests sent to the domain names.
        # *   false: The DNS servers did not stop responding to abnormal requests sent to the domain names.
        self.in_clean = in_clean
        # The ID of the Alibaba Cloud DNS instance.
        self.instance_id = instance_id
        # The interval at which the instance is monitored. Unit: minutes.
        self.monitor_frequency = monitor_frequency
        # The number of monitoring nodes.
        self.monitor_node_count = monitor_node_count
        # The number of monitoring tasks.
        self.monitor_task_count = monitor_task_count
        # The DDoS protection traffic outside the Chinese mainland. Unit: GB.
        self.oversea_ddos_defend_flow = oversea_ddos_defend_flow
        # The line outside the Chinese mainland.
        self.oversea_line = oversea_line
        # The billing method.
        self.payment_type = payment_type
        # Indicates whether the DNS request lines are regional lines. Valid values:
        # 
        # *   true: The DNS request lines are regional lines.
        # *   false: The DNS request lines are not regional lines.
        self.region_lines = region_lines
        # The request ID.
        self.request_id = request_id
        # The search engine resolution lines. Valid values:
        # 
        # *   Google
        # *   Baidu
        # *   Bing
        # *   Youdao
        self.search_engine_lines = search_engine_lines
        # The time when the instance was purchased. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time
        # The time when the instance was purchased. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.start_timestamp = start_timestamp
        # The number of subdomain name levels.
        self.sub_domain_level = sub_domain_level
        # The minimum time-to-live (TTL) period. Unit: seconds.
        self.ttlmin_value = ttlmin_value
        # The number of the forwarded URLs.
        self.urlforward_count = urlforward_count
        # The version code of Alibaba Cloud DNS.
        self.version_code = version_code
        # The edition of Alibaba Cloud DNS.
        self.version_name = version_name

    def validate(self):
        if self.dns_servers:
            self.dns_servers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renewal is not None:
            result['AutoRenewal'] = self.auto_renewal
        if self.bind_count is not None:
            result['BindCount'] = self.bind_count
        if self.bind_domain_count is not None:
            result['BindDomainCount'] = self.bind_domain_count
        if self.bind_domain_used_count is not None:
            result['BindDomainUsedCount'] = self.bind_domain_used_count
        if self.bind_used_count is not None:
            result['BindUsedCount'] = self.bind_used_count
        if self.ddos_defend_flow is not None:
            result['DDosDefendFlow'] = self.ddos_defend_flow
        if self.ddos_defend_query is not None:
            result['DDosDefendQuery'] = self.ddos_defend_query
        if self.dns_slbcount is not None:
            result['DnsSLBCount'] = self.dns_slbcount
        if self.dns_security is not None:
            result['DnsSecurity'] = self.dns_security
        if self.dns_servers is not None:
            result['DnsServers'] = self.dns_servers.to_map()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_timestamp is not None:
            result['EndTimestamp'] = self.end_timestamp
        if self.gslb is not None:
            result['Gslb'] = self.gslb
        if self.isplines is not None:
            result['ISPLines'] = self.isplines
        if self.ispregion_lines is not None:
            result['ISPRegionLines'] = self.ispregion_lines
        if self.in_black_hole is not None:
            result['InBlackHole'] = self.in_black_hole
        if self.in_clean is not None:
            result['InClean'] = self.in_clean
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.monitor_frequency is not None:
            result['MonitorFrequency'] = self.monitor_frequency
        if self.monitor_node_count is not None:
            result['MonitorNodeCount'] = self.monitor_node_count
        if self.monitor_task_count is not None:
            result['MonitorTaskCount'] = self.monitor_task_count
        if self.oversea_ddos_defend_flow is not None:
            result['OverseaDDosDefendFlow'] = self.oversea_ddos_defend_flow
        if self.oversea_line is not None:
            result['OverseaLine'] = self.oversea_line
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.region_lines is not None:
            result['RegionLines'] = self.region_lines
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_engine_lines is not None:
            result['SearchEngineLines'] = self.search_engine_lines
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        if self.sub_domain_level is not None:
            result['SubDomainLevel'] = self.sub_domain_level
        if self.ttlmin_value is not None:
            result['TTLMinValue'] = self.ttlmin_value
        if self.urlforward_count is not None:
            result['URLForwardCount'] = self.urlforward_count
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        if self.version_name is not None:
            result['VersionName'] = self.version_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenewal') is not None:
            self.auto_renewal = m.get('AutoRenewal')
        if m.get('BindCount') is not None:
            self.bind_count = m.get('BindCount')
        if m.get('BindDomainCount') is not None:
            self.bind_domain_count = m.get('BindDomainCount')
        if m.get('BindDomainUsedCount') is not None:
            self.bind_domain_used_count = m.get('BindDomainUsedCount')
        if m.get('BindUsedCount') is not None:
            self.bind_used_count = m.get('BindUsedCount')
        if m.get('DDosDefendFlow') is not None:
            self.ddos_defend_flow = m.get('DDosDefendFlow')
        if m.get('DDosDefendQuery') is not None:
            self.ddos_defend_query = m.get('DDosDefendQuery')
        if m.get('DnsSLBCount') is not None:
            self.dns_slbcount = m.get('DnsSLBCount')
        if m.get('DnsSecurity') is not None:
            self.dns_security = m.get('DnsSecurity')
        if m.get('DnsServers') is not None:
            temp_model = DescribeDnsProductInstanceResponseBodyDnsServers()
            self.dns_servers = temp_model.from_map(m['DnsServers'])
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndTimestamp') is not None:
            self.end_timestamp = m.get('EndTimestamp')
        if m.get('Gslb') is not None:
            self.gslb = m.get('Gslb')
        if m.get('ISPLines') is not None:
            self.isplines = m.get('ISPLines')
        if m.get('ISPRegionLines') is not None:
            self.ispregion_lines = m.get('ISPRegionLines')
        if m.get('InBlackHole') is not None:
            self.in_black_hole = m.get('InBlackHole')
        if m.get('InClean') is not None:
            self.in_clean = m.get('InClean')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MonitorFrequency') is not None:
            self.monitor_frequency = m.get('MonitorFrequency')
        if m.get('MonitorNodeCount') is not None:
            self.monitor_node_count = m.get('MonitorNodeCount')
        if m.get('MonitorTaskCount') is not None:
            self.monitor_task_count = m.get('MonitorTaskCount')
        if m.get('OverseaDDosDefendFlow') is not None:
            self.oversea_ddos_defend_flow = m.get('OverseaDDosDefendFlow')
        if m.get('OverseaLine') is not None:
            self.oversea_line = m.get('OverseaLine')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('RegionLines') is not None:
            self.region_lines = m.get('RegionLines')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchEngineLines') is not None:
            self.search_engine_lines = m.get('SearchEngineLines')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        if m.get('SubDomainLevel') is not None:
            self.sub_domain_level = m.get('SubDomainLevel')
        if m.get('TTLMinValue') is not None:
            self.ttlmin_value = m.get('TTLMinValue')
        if m.get('URLForwardCount') is not None:
            self.urlforward_count = m.get('URLForwardCount')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        if m.get('VersionName') is not None:
            self.version_name = m.get('VersionName')
        return self


class DescribeDnsProductInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsProductInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsProductInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDnsProductInstancesRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        domain_type: str = None,
        lang: str = None,
        order_by: str = None,
        page_number: int = None,
        page_size: int = None,
        user_client_ip: str = None,
        version_code: str = None,
    ):
        # The order in which you want to sort returned entries. Valid values:
        # 
        # *   DESC: Returned entries are sorted in descending order. If this parameter is left empty, returned entries are sorted in descending order by default.
        # *   ASC: Returned entries are sorted in ascending order.
        self.direction = direction
        # The type of the domain name. Valid values:
        # 
        # *   PUBLIC (default): hosted public domain name
        # *   CACHE: cached public domain name
        self.domain_type = domain_type
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en
        self.lang = lang
        # The method that is used to sort returned entries. Valid values:
        # 
        # *   createDate: sorts returned entries by creation time. If this parameter is left empty, returned entries are sorted by creation time by default.
        # *   expireDate: sorts returned entries by expiration time.
        self.order_by = order_by
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size
        # The IP address of the client.
        self.user_client_ip = user_client_ip
        # The version code of the Alibaba Cloud DNS instance.
        self.version_code = version_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct(TeaModel):
    def __init__(
        self,
        auto_renewal: bool = None,
        bind_count: int = None,
        bind_domain_count: int = None,
        bind_domain_used_count: int = None,
        bind_used_count: int = None,
        ddos_defend_flow: int = None,
        ddos_defend_query: int = None,
        dns_slbcount: int = None,
        dns_security: str = None,
        domain: str = None,
        end_time: str = None,
        end_timestamp: int = None,
        gslb: bool = None,
        isplines: str = None,
        ispregion_lines: str = None,
        in_black_hole: bool = None,
        in_clean: bool = None,
        instance_id: str = None,
        monitor_frequency: int = None,
        monitor_node_count: int = None,
        monitor_task_count: int = None,
        oversea_ddos_defend_flow: int = None,
        oversea_line: str = None,
        payment_type: str = None,
        region_lines: bool = None,
        search_engine_lines: str = None,
        start_time: str = None,
        start_timestamp: int = None,
        sub_domain_level: int = None,
        ttlmin_value: int = None,
        urlforward_count: int = None,
        version_code: str = None,
        version_name: str = None,
    ):
        # Indicates whether auto-renewal was enabled. Valid values:
        # 
        # *   true: Auto-renewal was enabled.
        # *   false: Auto-renewal was not enabled.
        self.auto_renewal = auto_renewal
        # The number of times you can change domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.
        self.bind_count = bind_count
        # The number of domain names that can be bound to the DNS instance.
        self.bind_domain_count = bind_domain_count
        # The number of domain names that have been bound to the DNS instance.
        self.bind_domain_used_count = bind_domain_used_count
        # The number of times you have changed domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.
        self.bind_used_count = bind_used_count
        # The DDoS protection traffic. Unit: GB.
        self.ddos_defend_flow = ddos_defend_flow
        # The DDoS protection frequency. Unit: 10,000 QPS.
        self.ddos_defend_query = ddos_defend_query
        # The number of IP addresses supported by a domain name or line.
        self.dns_slbcount = dns_slbcount
        # The level of DNS protection. Valid values:
        # 
        # *   no: No DNS protection is provided.
        # *   basic: Basic DNS protection is provided.
        # *   advanced: Advanced DNS protection is provided.
        self.dns_security = dns_security
        # The bound domain name.
        self.domain = domain
        # The time at which the instance expired.
        self.end_time = end_time
        # The UNIX timestamp representing the expiration time of the instance.
        self.end_timestamp = end_timestamp
        # Indicates whether global server load balancing (GSLB) is supported.
        # 
        # *   true: GSLB is supported.
        # *   false: GSLB is not supported.
        self.gslb = gslb
        # The ISP resolution lines.
        # 
        # *   China Telecom
        # *   China Mobile
        # *   China Unicom
        # *   CERNET
        # *   China Broadcasting Network (CBN)
        # *   Dr Peng Telecom & Media Group
        self.isplines = isplines
        # The regional ISP resolution lines. Valid values:
        # 
        # *   China Telecom (province)
        # *   China Mobile (province)
        # *   China Unicom (province)
        # *   China Education and Research Network (CERNET) (province)
        self.ispregion_lines = ispregion_lines
        # Indicates whether the Domain Name System (DNS) servers stopped responding to all requests. Valid values:
        # 
        # *   true: The DNS servers stopped responding to all requests.
        # *   false: The DNS servers did not stop responding to all requests.
        self.in_black_hole = in_black_hole
        # Indicates whether the request for domain name resolution was being cleared.
        self.in_clean = in_clean
        # The ID of the Alibaba Cloud DNS instance.
        self.instance_id = instance_id
        # The monitoring frequency. Unit: minutes.
        self.monitor_frequency = monitor_frequency
        # The number of monitored nodes.
        self.monitor_node_count = monitor_node_count
        # The number of monitoring tasks.
        self.monitor_task_count = monitor_task_count
        # DDoS protection traffic outside China. Unit: GB.
        self.oversea_ddos_defend_flow = oversea_ddos_defend_flow
        # The type of the overseas line.
        self.oversea_line = oversea_line
        # The billing method.
        self.payment_type = payment_type
        # Indicates whether the DNS request lines are regional lines.
        # 
        # *   true: The DNS request lines are regional lines.
        # *   false: The DNS request lines are not regional lines.
        self.region_lines = region_lines
        # The search engine resolution lines. Valid values:
        # 
        # *   Google
        # *   Baidu
        # *   Bing
        # *   Youdao
        self.search_engine_lines = search_engine_lines
        # The time when the DNS instance was purchased.
        self.start_time = start_time
        # The UNIX timestamp representing when the DNS instance was purchased.
        self.start_timestamp = start_timestamp
        # The number of subdomain name levels.
        self.sub_domain_level = sub_domain_level
        # The minimum TTL. Unit: seconds.
        self.ttlmin_value = ttlmin_value
        # The URL forwarding quantity.
        self.urlforward_count = urlforward_count
        # The version code of the Alibaba Cloud DNS instance.
        self.version_code = version_code
        # The version name of the Alibaba Cloud DNS instance.
        self.version_name = version_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renewal is not None:
            result['AutoRenewal'] = self.auto_renewal
        if self.bind_count is not None:
            result['BindCount'] = self.bind_count
        if self.bind_domain_count is not None:
            result['BindDomainCount'] = self.bind_domain_count
        if self.bind_domain_used_count is not None:
            result['BindDomainUsedCount'] = self.bind_domain_used_count
        if self.bind_used_count is not None:
            result['BindUsedCount'] = self.bind_used_count
        if self.ddos_defend_flow is not None:
            result['DDosDefendFlow'] = self.ddos_defend_flow
        if self.ddos_defend_query is not None:
            result['DDosDefendQuery'] = self.ddos_defend_query
        if self.dns_slbcount is not None:
            result['DnsSLBCount'] = self.dns_slbcount
        if self.dns_security is not None:
            result['DnsSecurity'] = self.dns_security
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_timestamp is not None:
            result['EndTimestamp'] = self.end_timestamp
        if self.gslb is not None:
            result['Gslb'] = self.gslb
        if self.isplines is not None:
            result['ISPLines'] = self.isplines
        if self.ispregion_lines is not None:
            result['ISPRegionLines'] = self.ispregion_lines
        if self.in_black_hole is not None:
            result['InBlackHole'] = self.in_black_hole
        if self.in_clean is not None:
            result['InClean'] = self.in_clean
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.monitor_frequency is not None:
            result['MonitorFrequency'] = self.monitor_frequency
        if self.monitor_node_count is not None:
            result['MonitorNodeCount'] = self.monitor_node_count
        if self.monitor_task_count is not None:
            result['MonitorTaskCount'] = self.monitor_task_count
        if self.oversea_ddos_defend_flow is not None:
            result['OverseaDDosDefendFlow'] = self.oversea_ddos_defend_flow
        if self.oversea_line is not None:
            result['OverseaLine'] = self.oversea_line
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.region_lines is not None:
            result['RegionLines'] = self.region_lines
        if self.search_engine_lines is not None:
            result['SearchEngineLines'] = self.search_engine_lines
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        if self.sub_domain_level is not None:
            result['SubDomainLevel'] = self.sub_domain_level
        if self.ttlmin_value is not None:
            result['TTLMinValue'] = self.ttlmin_value
        if self.urlforward_count is not None:
            result['URLForwardCount'] = self.urlforward_count
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        if self.version_name is not None:
            result['VersionName'] = self.version_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenewal') is not None:
            self.auto_renewal = m.get('AutoRenewal')
        if m.get('BindCount') is not None:
            self.bind_count = m.get('BindCount')
        if m.get('BindDomainCount') is not None:
            self.bind_domain_count = m.get('BindDomainCount')
        if m.get('BindDomainUsedCount') is not None:
            self.bind_domain_used_count = m.get('BindDomainUsedCount')
        if m.get('BindUsedCount') is not None:
            self.bind_used_count = m.get('BindUsedCount')
        if m.get('DDosDefendFlow') is not None:
            self.ddos_defend_flow = m.get('DDosDefendFlow')
        if m.get('DDosDefendQuery') is not None:
            self.ddos_defend_query = m.get('DDosDefendQuery')
        if m.get('DnsSLBCount') is not None:
            self.dns_slbcount = m.get('DnsSLBCount')
        if m.get('DnsSecurity') is not None:
            self.dns_security = m.get('DnsSecurity')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndTimestamp') is not None:
            self.end_timestamp = m.get('EndTimestamp')
        if m.get('Gslb') is not None:
            self.gslb = m.get('Gslb')
        if m.get('ISPLines') is not None:
            self.isplines = m.get('ISPLines')
        if m.get('ISPRegionLines') is not None:
            self.ispregion_lines = m.get('ISPRegionLines')
        if m.get('InBlackHole') is not None:
            self.in_black_hole = m.get('InBlackHole')
        if m.get('InClean') is not None:
            self.in_clean = m.get('InClean')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MonitorFrequency') is not None:
            self.monitor_frequency = m.get('MonitorFrequency')
        if m.get('MonitorNodeCount') is not None:
            self.monitor_node_count = m.get('MonitorNodeCount')
        if m.get('MonitorTaskCount') is not None:
            self.monitor_task_count = m.get('MonitorTaskCount')
        if m.get('OverseaDDosDefendFlow') is not None:
            self.oversea_ddos_defend_flow = m.get('OverseaDDosDefendFlow')
        if m.get('OverseaLine') is not None:
            self.oversea_line = m.get('OverseaLine')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('RegionLines') is not None:
            self.region_lines = m.get('RegionLines')
        if m.get('SearchEngineLines') is not None:
            self.search_engine_lines = m.get('SearchEngineLines')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        if m.get('SubDomainLevel') is not None:
            self.sub_domain_level = m.get('SubDomainLevel')
        if m.get('TTLMinValue') is not None:
            self.ttlmin_value = m.get('TTLMinValue')
        if m.get('URLForwardCount') is not None:
            self.urlforward_count = m.get('URLForwardCount')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        if m.get('VersionName') is not None:
            self.version_name = m.get('VersionName')
        return self


class DescribeDnsProductInstancesResponseBodyDnsProducts(TeaModel):
    def __init__(
        self,
        dns_product: List[DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct] = None,
    ):
        self.dns_product = dns_product

    def validate(self):
        if self.dns_product:
            for k in self.dns_product:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DnsProduct'] = []
        if self.dns_product is not None:
            for k in self.dns_product:
                result['DnsProduct'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dns_product = []
        if m.get('DnsProduct') is not None:
            for k in m.get('DnsProduct'):
                temp_model = DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct()
                self.dns_product.append(temp_model.from_map(k))
        return self


class DescribeDnsProductInstancesResponseBody(TeaModel):
    def __init__(
        self,
        dns_products: DescribeDnsProductInstancesResponseBodyDnsProducts = None,
        domain_type: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The paid Alibaba Cloud DNS instances.
        self.dns_products = dns_products
        # The type of the domain name. Valid values:
        # 
        # *   PUBLIC (default): hosted public domain name
        # *   CACHE: cached public domain name
        self.domain_type = domain_type
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of domain names.
        self.total_count = total_count

    def validate(self):
        if self.dns_products:
            self.dns_products.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_products is not None:
            result['DnsProducts'] = self.dns_products.to_map()
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsProducts') is not None:
            temp_model = DescribeDnsProductInstancesResponseBodyDnsProducts()
            self.dns_products = temp_model.from_map(m['DnsProducts'])
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDnsProductInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDnsProductInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDnsProductInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDohAccountStatisticsRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        lang: str = None,
        start_date: str = None,
    ):
        # The end of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # The default value is the day when you perform the operation.
        self.end_date = end_date
        # The language type.
        self.lang = lang
        # The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # You can query only the DNS records of the latest 90 days.`The value of StartDate must be greater than or equal to the difference between the current date and 90`.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeDohAccountStatisticsResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        timestamp: int = None,
        total_count: int = None,
        v_4http_count: int = None,
        v_4https_count: int = None,
        v_6http_count: int = None,
        v_6https_count: int = None,
    ):
        # The timestamp.
        self.timestamp = timestamp
        # The total number of requests.
        self.total_count = total_count
        # The number of IPv4-based HTTP requests.
        self.v_4http_count = v_4http_count
        # The number of IPv4-based HTTPS requests.
        self.v_4https_count = v_4https_count
        # The number of IPv6-based HTTP requests.
        self.v_6http_count = v_6http_count
        # The number of IPv6-based HTTPS requests.
        self.v_6https_count = v_6https_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.v_4http_count is not None:
            result['V4HttpCount'] = self.v_4http_count
        if self.v_4https_count is not None:
            result['V4HttpsCount'] = self.v_4https_count
        if self.v_6http_count is not None:
            result['V6HttpCount'] = self.v_6http_count
        if self.v_6https_count is not None:
            result['V6HttpsCount'] = self.v_6https_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('V4HttpCount') is not None:
            self.v_4http_count = m.get('V4HttpCount')
        if m.get('V4HttpsCount') is not None:
            self.v_4https_count = m.get('V4HttpsCount')
        if m.get('V6HttpCount') is not None:
            self.v_6http_count = m.get('V6HttpCount')
        if m.get('V6HttpsCount') is not None:
            self.v_6https_count = m.get('V6HttpsCount')
        return self


class DescribeDohAccountStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        statistics: List[DescribeDohAccountStatisticsResponseBodyStatistics] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The statistics list.
        self.statistics = statistics

    def validate(self):
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = DescribeDohAccountStatisticsResponseBodyStatistics()
                self.statistics.append(temp_model.from_map(k))
        return self


class DescribeDohAccountStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDohAccountStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDohAccountStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDohDomainStatisticsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_date: str = None,
        lang: str = None,
        start_date: str = None,
    ):
        # The domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # The default value is the day when you perform the operation.
        self.end_date = end_date
        # The language type.
        self.lang = lang
        # The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeDohDomainStatisticsResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        timestamp: int = None,
        total_count: int = None,
        v_4http_count: int = None,
        v_4https_count: int = None,
        v_6http_count: int = None,
        v_6https_count: int = None,
    ):
        # The timestamp.
        self.timestamp = timestamp
        # The total number of requests.
        self.total_count = total_count
        # The number of IPv4-based HTTP requests.
        self.v_4http_count = v_4http_count
        # The number of IPv4-based HTTPS requests.
        self.v_4https_count = v_4https_count
        # The number of IPv6-based HTTP requests.
        self.v_6http_count = v_6http_count
        # The number of IPv6-based HTTPS requests.
        self.v_6https_count = v_6https_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.v_4http_count is not None:
            result['V4HttpCount'] = self.v_4http_count
        if self.v_4https_count is not None:
            result['V4HttpsCount'] = self.v_4https_count
        if self.v_6http_count is not None:
            result['V6HttpCount'] = self.v_6http_count
        if self.v_6https_count is not None:
            result['V6HttpsCount'] = self.v_6https_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('V4HttpCount') is not None:
            self.v_4http_count = m.get('V4HttpCount')
        if m.get('V4HttpsCount') is not None:
            self.v_4https_count = m.get('V4HttpsCount')
        if m.get('V6HttpCount') is not None:
            self.v_6http_count = m.get('V6HttpCount')
        if m.get('V6HttpsCount') is not None:
            self.v_6https_count = m.get('V6HttpsCount')
        return self


class DescribeDohDomainStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        statistics: List[DescribeDohDomainStatisticsResponseBodyStatistics] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The statistics list.
        self.statistics = statistics

    def validate(self):
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = DescribeDohDomainStatisticsResponseBodyStatistics()
                self.statistics.append(temp_model.from_map(k))
        return self


class DescribeDohDomainStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDohDomainStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDohDomainStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDohDomainStatisticsSummaryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_date: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_date: str = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # The default value is the day when you perform the operation.
        self.end_date = end_date
        # The language type.
        self.lang = lang
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: 100. Default value: 20.
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeDohDomainStatisticsSummaryResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        http_count: int = None,
        https_count: int = None,
        ip_count: int = None,
        total_count: int = None,
        v_4http_count: int = None,
        v_4https_count: int = None,
        v_6http_count: int = None,
        v_6https_count: int = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The number of HTTP requests.
        self.http_count = http_count
        # The number of HTTPS requests.
        self.https_count = https_count
        # The number of IP addresses.
        self.ip_count = ip_count
        # The total number of requests.
        self.total_count = total_count
        # The number of IPv4-based HTTP requests.
        self.v_4http_count = v_4http_count
        # The number of IPv4-based HTTPS requests.
        self.v_4https_count = v_4https_count
        # The number of IPv6-based HTTP requests.
        self.v_6http_count = v_6http_count
        # The number of IPv6-based HTTPS requests.
        self.v_6https_count = v_6https_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.http_count is not None:
            result['HttpCount'] = self.http_count
        if self.https_count is not None:
            result['HttpsCount'] = self.https_count
        if self.ip_count is not None:
            result['IpCount'] = self.ip_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.v_4http_count is not None:
            result['V4HttpCount'] = self.v_4http_count
        if self.v_4https_count is not None:
            result['V4HttpsCount'] = self.v_4https_count
        if self.v_6http_count is not None:
            result['V6HttpCount'] = self.v_6http_count
        if self.v_6https_count is not None:
            result['V6HttpsCount'] = self.v_6https_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('HttpCount') is not None:
            self.http_count = m.get('HttpCount')
        if m.get('HttpsCount') is not None:
            self.https_count = m.get('HttpsCount')
        if m.get('IpCount') is not None:
            self.ip_count = m.get('IpCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('V4HttpCount') is not None:
            self.v_4http_count = m.get('V4HttpCount')
        if m.get('V4HttpsCount') is not None:
            self.v_4https_count = m.get('V4HttpsCount')
        if m.get('V6HttpCount') is not None:
            self.v_6http_count = m.get('V6HttpCount')
        if m.get('V6HttpsCount') is not None:
            self.v_6https_count = m.get('V6HttpsCount')
        return self


class DescribeDohDomainStatisticsSummaryResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        statistics: List[DescribeDohDomainStatisticsSummaryResponseBodyStatistics] = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The statistics list.
        self.statistics = statistics
        # The total number of entries returned.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = DescribeDohDomainStatisticsSummaryResponseBodyStatistics()
                self.statistics.append(temp_model.from_map(k))
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeDohDomainStatisticsSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDohDomainStatisticsSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDohDomainStatisticsSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDohSubDomainStatisticsRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        lang: str = None,
        start_date: str = None,
        sub_domain: str = None,
    ):
        # The end of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # The default value is the day when you perform the operation.
        self.end_date = end_date
        # The language type.
        self.lang = lang
        # The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
        self.start_date = start_date
        # The subdomain whose statistics you want to query.
        # 
        # This parameter is required.
        self.sub_domain = sub_domain

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        return self


class DescribeDohSubDomainStatisticsResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        timestamp: int = None,
        total_count: int = None,
        v_4http_count: int = None,
        v_4https_count: int = None,
        v_6http_count: int = None,
        v_6https_count: int = None,
    ):
        # The timestamp.
        self.timestamp = timestamp
        # The total number of requests.
        self.total_count = total_count
        # The number of IPv4-based HTTP requests.
        self.v_4http_count = v_4http_count
        # The number of IPv4-based HTTPS requests.
        self.v_4https_count = v_4https_count
        # The number of IPv6-based HTTP requests.
        self.v_6http_count = v_6http_count
        # The number of IPv6-based HTTPS requests.
        self.v_6https_count = v_6https_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.v_4http_count is not None:
            result['V4HttpCount'] = self.v_4http_count
        if self.v_4https_count is not None:
            result['V4HttpsCount'] = self.v_4https_count
        if self.v_6http_count is not None:
            result['V6HttpCount'] = self.v_6http_count
        if self.v_6https_count is not None:
            result['V6HttpsCount'] = self.v_6https_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('V4HttpCount') is not None:
            self.v_4http_count = m.get('V4HttpCount')
        if m.get('V4HttpsCount') is not None:
            self.v_4https_count = m.get('V4HttpsCount')
        if m.get('V6HttpCount') is not None:
            self.v_6http_count = m.get('V6HttpCount')
        if m.get('V6HttpsCount') is not None:
            self.v_6https_count = m.get('V6HttpsCount')
        return self


class DescribeDohSubDomainStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        statistics: List[DescribeDohSubDomainStatisticsResponseBodyStatistics] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The statistics list.
        self.statistics = statistics

    def validate(self):
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = DescribeDohSubDomainStatisticsResponseBodyStatistics()
                self.statistics.append(temp_model.from_map(k))
        return self


class DescribeDohSubDomainStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDohSubDomainStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDohSubDomainStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDohSubDomainStatisticsSummaryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_date: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_date: str = None,
        sub_domain: str = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # The default value is the day when you query the required data.
        self.end_date = end_date
        # The language type.
        self.lang = lang
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: 100. Default value: 20.
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
        self.start_date = start_date
        # The subdomain.
        self.sub_domain = sub_domain

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        return self


class DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        http_count: int = None,
        https_count: int = None,
        ip_count: int = None,
        sub_domain: str = None,
        total_count: int = None,
        v_4http_count: int = None,
        v_4https_count: int = None,
        v_6http_count: int = None,
        v_6https_count: int = None,
    ):
        # The number of HTTP requests.
        self.http_count = http_count
        # The number of HTTPS requests.
        self.https_count = https_count
        # The number of IP addresses.
        self.ip_count = ip_count
        # The subdomain.
        self.sub_domain = sub_domain
        # Total number of requests.
        self.total_count = total_count
        # The number of IPv4-based HTTP requests.
        self.v_4http_count = v_4http_count
        # The number of IPv4-based HTTPS requests.
        self.v_4https_count = v_4https_count
        # The number of IPv6-based HTTP requests.
        self.v_6http_count = v_6http_count
        # The number of IPv6-based HTTPS requests.
        self.v_6https_count = v_6https_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_count is not None:
            result['HttpCount'] = self.http_count
        if self.https_count is not None:
            result['HttpsCount'] = self.https_count
        if self.ip_count is not None:
            result['IpCount'] = self.ip_count
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.v_4http_count is not None:
            result['V4HttpCount'] = self.v_4http_count
        if self.v_4https_count is not None:
            result['V4HttpsCount'] = self.v_4https_count
        if self.v_6http_count is not None:
            result['V6HttpCount'] = self.v_6http_count
        if self.v_6https_count is not None:
            result['V6HttpsCount'] = self.v_6https_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpCount') is not None:
            self.http_count = m.get('HttpCount')
        if m.get('HttpsCount') is not None:
            self.https_count = m.get('HttpsCount')
        if m.get('IpCount') is not None:
            self.ip_count = m.get('IpCount')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('V4HttpCount') is not None:
            self.v_4http_count = m.get('V4HttpCount')
        if m.get('V4HttpsCount') is not None:
            self.v_4https_count = m.get('V4HttpsCount')
        if m.get('V6HttpCount') is not None:
            self.v_6http_count = m.get('V6HttpCount')
        if m.get('V6HttpsCount') is not None:
            self.v_6https_count = m.get('V6HttpsCount')
        return self


class DescribeDohSubDomainStatisticsSummaryResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        statistics: List[DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics] = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The statistics list.
        self.statistics = statistics
        # Total number of entries returned.
        self.total_items = total_items
        # Total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics()
                self.statistics.append(temp_model.from_map(k))
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeDohSubDomainStatisticsSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDohSubDomainStatisticsSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDohSubDomainStatisticsSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDohUserInfoRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        lang: str = None,
        start_date: str = None,
    ):
        # The end time for the query. Format: YYYY-MM-DD
        # 
        # If you do not specify this parameter, the default value is the time when you perform the query.
        self.end_date = end_date
        # The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
        self.lang = lang
        # The start time for the query. Format: YYYY-MM-DD
        # 
        # You can query the user information of the last 90 days only. `Set the parameter to a value no earlier than 90 days from the current time`.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeDohUserInfoResponseBody(TeaModel):
    def __init__(
        self,
        domain_count: int = None,
        pdns_id: int = None,
        request_id: str = None,
        sub_domain_count: int = None,
    ):
        # The number of accessed domains.
        self.domain_count = domain_count
        # The ID of the Alibaba Cloud public DNS user.
        self.pdns_id = pdns_id
        # The ID of the request.
        self.request_id = request_id
        # The number of accessed subdomains.
        self.sub_domain_count = sub_domain_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_count is not None:
            result['DomainCount'] = self.domain_count
        if self.pdns_id is not None:
            result['PdnsId'] = self.pdns_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sub_domain_count is not None:
            result['SubDomainCount'] = self.sub_domain_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainCount') is not None:
            self.domain_count = m.get('DomainCount')
        if m.get('PdnsId') is not None:
            self.pdns_id = m.get('PdnsId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubDomainCount') is not None:
            self.sub_domain_count = m.get('SubDomainCount')
        return self


class DescribeDohUserInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDohUserInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDohUserInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainDnssecInfoRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        # 
        # Default value: **zh**\
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDomainDnssecInfoResponseBody(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        digest: str = None,
        digest_type: str = None,
        domain_name: str = None,
        ds_record: str = None,
        flags: str = None,
        key_tag: str = None,
        public_key: str = None,
        request_id: str = None,
        status: str = None,
    ):
        # The algorithm type. This parameter is returned if DNSSEC is enabled.
        self.algorithm = algorithm
        # The digest. This parameter is returned if DNSSEC is enabled.
        self.digest = digest
        # The digest type. This parameter is returned if DNSSEC is enabled.
        self.digest_type = digest_type
        # The domain name.
        self.domain_name = domain_name
        # The delegation signer (DS) record. This parameter is returned if DNSSEC is enabled.
        self.ds_record = ds_record
        # The flag. This parameter is returned if DNSSEC is enabled.
        self.flags = flags
        # The key tag. This parameter is returned if DNSSEC is enabled.
        self.key_tag = key_tag
        # The public key. This parameter is returned if DNSSEC is enabled.
        self.public_key = public_key
        # The request ID.
        self.request_id = request_id
        # The state of the DNSSEC. Valid values:
        # 
        # *   ON
        # *   OFF
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.digest_type is not None:
            result['DigestType'] = self.digest_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.ds_record is not None:
            result['DsRecord'] = self.ds_record
        if self.flags is not None:
            result['Flags'] = self.flags
        if self.key_tag is not None:
            result['KeyTag'] = self.key_tag
        if self.public_key is not None:
            result['PublicKey'] = self.public_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('DigestType') is not None:
            self.digest_type = m.get('DigestType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DsRecord') is not None:
            self.ds_record = m.get('DsRecord')
        if m.get('Flags') is not None:
            self.flags = m.get('Flags')
        if m.get('KeyTag') is not None:
            self.key_tag = m.get('KeyTag')
        if m.get('PublicKey') is not None:
            self.public_key = m.get('PublicKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDomainDnssecInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainDnssecInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainDnssecInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainGroupsRequest(TeaModel):
    def __init__(
        self,
        key_word: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The keyword of the domain name group for searches in %KeyWord% mode. The value is not case-sensitive.
        self.key_word = key_word
        # The language.
        self.lang = lang
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup(TeaModel):
    def __init__(
        self,
        domain_count: int = None,
        group_id: str = None,
        group_name: str = None,
    ):
        # The number of domain name groups.
        self.domain_count = domain_count
        # The ID of the domain name group. Valid values:
        # 
        # *   defaultGroup: the default group
        # *   If an empty string is returned, it indicates the group that contains all domain names.
        self.group_id = group_id
        # The name of the domain name group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_count is not None:
            result['DomainCount'] = self.domain_count
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainCount') is not None:
            self.domain_count = m.get('DomainCount')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DescribeDomainGroupsResponseBodyDomainGroups(TeaModel):
    def __init__(
        self,
        domain_group: List[DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup] = None,
    ):
        self.domain_group = domain_group

    def validate(self):
        if self.domain_group:
            for k in self.domain_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainGroup'] = []
        if self.domain_group is not None:
            for k in self.domain_group:
                result['DomainGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_group = []
        if m.get('DomainGroup') is not None:
            for k in m.get('DomainGroup'):
                temp_model = DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup()
                self.domain_group.append(temp_model.from_map(k))
        return self


class DescribeDomainGroupsResponseBody(TeaModel):
    def __init__(
        self,
        domain_groups: DescribeDomainGroupsResponseBodyDomainGroups = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The domain name groups.
        self.domain_groups = domain_groups
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.domain_groups:
            self.domain_groups.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_groups is not None:
            result['DomainGroups'] = self.domain_groups.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainGroups') is not None:
            temp_model = DescribeDomainGroupsResponseBodyDomainGroups()
            self.domain_groups = temp_model.from_map(m['DomainGroups'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDomainGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainInfoRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        need_detail_attributes: bool = None,
    ):
        # The domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language type.
        self.lang = lang
        # Specifies whether detailed attributes are required. Default value: **false**, which indicates that detailed attributes are not returned.
        # 
        # If you set this parameter to **true**, the values of the following parameters are returned: LineType, MinTtl, RecordLineTreeJson, RecordLines, LineCode, LineDisplayName, LineName, RegionLines, and SlaveDns.
        self.need_detail_attributes = need_detail_attributes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.need_detail_attributes is not None:
            result['NeedDetailAttributes'] = self.need_detail_attributes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NeedDetailAttributes') is not None:
            self.need_detail_attributes = m.get('NeedDetailAttributes')
        return self


class DescribeDomainInfoResponseBodyAvailableTtls(TeaModel):
    def __init__(
        self,
        available_ttl: List[str] = None,
    ):
        self.available_ttl = available_ttl

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_ttl is not None:
            result['AvailableTtl'] = self.available_ttl
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableTtl') is not None:
            self.available_ttl = m.get('AvailableTtl')
        return self


class DescribeDomainInfoResponseBodyDnsServers(TeaModel):
    def __init__(
        self,
        dns_server: List[str] = None,
    ):
        self.dns_server = dns_server

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server is not None:
            result['DnsServer'] = self.dns_server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServer') is not None:
            self.dns_server = m.get('DnsServer')
        return self


class DescribeDomainInfoResponseBodyRecordLinesRecordLine(TeaModel):
    def __init__(
        self,
        father_code: str = None,
        line_code: str = None,
        line_display_name: str = None,
        line_name: str = None,
    ):
        # The code of the parent line. This parameter is not returned if the line has no parent line.
        self.father_code = father_code
        # The code of the line.
        self.line_code = line_code
        # The name of the parent line.
        self.line_display_name = line_display_name
        # The name of the line.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.father_code is not None:
            result['FatherCode'] = self.father_code
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_display_name is not None:
            result['LineDisplayName'] = self.line_display_name
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FatherCode') is not None:
            self.father_code = m.get('FatherCode')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineDisplayName') is not None:
            self.line_display_name = m.get('LineDisplayName')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeDomainInfoResponseBodyRecordLines(TeaModel):
    def __init__(
        self,
        record_line: List[DescribeDomainInfoResponseBodyRecordLinesRecordLine] = None,
    ):
        self.record_line = record_line

    def validate(self):
        if self.record_line:
            for k in self.record_line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordLine'] = []
        if self.record_line is not None:
            for k in self.record_line:
                result['RecordLine'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_line = []
        if m.get('RecordLine') is not None:
            for k in m.get('RecordLine'):
                temp_model = DescribeDomainInfoResponseBodyRecordLinesRecordLine()
                self.record_line.append(temp_model.from_map(k))
        return self


class DescribeDomainInfoResponseBody(TeaModel):
    def __init__(
        self,
        ali_domain: bool = None,
        available_ttls: DescribeDomainInfoResponseBodyAvailableTtls = None,
        create_time: str = None,
        dns_servers: DescribeDomainInfoResponseBodyDnsServers = None,
        domain_id: str = None,
        domain_logging_switch_status: str = None,
        domain_name: str = None,
        group_id: str = None,
        group_name: str = None,
        in_black_hole: bool = None,
        in_clean: bool = None,
        instance_id: str = None,
        line_type: str = None,
        min_ttl: int = None,
        puny_code: str = None,
        record_line_tree_json: str = None,
        record_lines: DescribeDomainInfoResponseBodyRecordLines = None,
        region_lines: bool = None,
        remark: str = None,
        request_id: str = None,
        resource_group_id: str = None,
        slave_dns: bool = None,
        sub_domain: bool = None,
        version_code: str = None,
        version_name: str = None,
    ):
        # Indicates whether the domain name was registered in Alibaba Cloud.
        self.ali_domain = ali_domain
        # The available time to live (TTL) values that can be configured for the domain name. Available TTL values are not returned by default. If you want to query such information, set NeedDetailAttributes to true.
        self.available_ttls = available_ttls
        # The time when the domain name was created.
        self.create_time = create_time
        # The DNS servers that are used to resolve the domain name.
        self.dns_servers = dns_servers
        # The ID of the domain name.
        self.domain_id = domain_id
        # Indicates whether the DNS traffic analysis feature is enabled. Valid values:
        self.domain_logging_switch_status = domain_logging_switch_status
        # The domain name.
        self.domain_name = domain_name
        # The ID of the domain name group.
        self.group_id = group_id
        # The name of the domain name group.
        self.group_name = group_name
        # Indicates whether blackhole filtering was triggered.
        self.in_black_hole = in_black_hole
        # Indicates whether traffic scrubbing was in progress.
        self.in_clean = in_clean
        # The ID of the Alibaba Cloud DNS instance.
        self.instance_id = instance_id
        # The type of the DNS request line.
        self.line_type = line_type
        # The minimum TTL value.
        self.min_ttl = min_ttl
        # The Punycode for the domain name. This parameter is returned only for Chinese domain names.
        self.puny_code = puny_code
        # The tree-structure DNS request lines.
        self.record_line_tree_json = record_line_tree_json
        # The DNS request lines.
        self.record_lines = record_lines
        # Indicates whether the DNS request lines are regional lines.
        self.region_lines = region_lines
        # The description.
        self.remark = remark
        # The request ID.
        self.request_id = request_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # Indicates whether secondary DNS is supported.
        self.slave_dns = slave_dns
        # Indicates whether the queried domain name is a hosted subdomain name. Valid values:
        # 
        # *   true
        # *   false
        self.sub_domain = sub_domain
        # The version ID of Alibaba Cloud DNS.
        self.version_code = version_code
        # The edition of Alibaba Cloud DNS.
        self.version_name = version_name

    def validate(self):
        if self.available_ttls:
            self.available_ttls.validate()
        if self.dns_servers:
            self.dns_servers.validate()
        if self.record_lines:
            self.record_lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_domain is not None:
            result['AliDomain'] = self.ali_domain
        if self.available_ttls is not None:
            result['AvailableTtls'] = self.available_ttls.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dns_servers is not None:
            result['DnsServers'] = self.dns_servers.to_map()
        if self.domain_id is not None:
            result['DomainId'] = self.domain_id
        if self.domain_logging_switch_status is not None:
            result['DomainLoggingSwitchStatus'] = self.domain_logging_switch_status
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.in_black_hole is not None:
            result['InBlackHole'] = self.in_black_hole
        if self.in_clean is not None:
            result['InClean'] = self.in_clean
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.line_type is not None:
            result['LineType'] = self.line_type
        if self.min_ttl is not None:
            result['MinTtl'] = self.min_ttl
        if self.puny_code is not None:
            result['PunyCode'] = self.puny_code
        if self.record_line_tree_json is not None:
            result['RecordLineTreeJson'] = self.record_line_tree_json
        if self.record_lines is not None:
            result['RecordLines'] = self.record_lines.to_map()
        if self.region_lines is not None:
            result['RegionLines'] = self.region_lines
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.slave_dns is not None:
            result['SlaveDns'] = self.slave_dns
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        if self.version_name is not None:
            result['VersionName'] = self.version_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliDomain') is not None:
            self.ali_domain = m.get('AliDomain')
        if m.get('AvailableTtls') is not None:
            temp_model = DescribeDomainInfoResponseBodyAvailableTtls()
            self.available_ttls = temp_model.from_map(m['AvailableTtls'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DnsServers') is not None:
            temp_model = DescribeDomainInfoResponseBodyDnsServers()
            self.dns_servers = temp_model.from_map(m['DnsServers'])
        if m.get('DomainId') is not None:
            self.domain_id = m.get('DomainId')
        if m.get('DomainLoggingSwitchStatus') is not None:
            self.domain_logging_switch_status = m.get('DomainLoggingSwitchStatus')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('InBlackHole') is not None:
            self.in_black_hole = m.get('InBlackHole')
        if m.get('InClean') is not None:
            self.in_clean = m.get('InClean')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LineType') is not None:
            self.line_type = m.get('LineType')
        if m.get('MinTtl') is not None:
            self.min_ttl = m.get('MinTtl')
        if m.get('PunyCode') is not None:
            self.puny_code = m.get('PunyCode')
        if m.get('RecordLineTreeJson') is not None:
            self.record_line_tree_json = m.get('RecordLineTreeJson')
        if m.get('RecordLines') is not None:
            temp_model = DescribeDomainInfoResponseBodyRecordLines()
            self.record_lines = temp_model.from_map(m['RecordLines'])
        if m.get('RegionLines') is not None:
            self.region_lines = m.get('RegionLines')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SlaveDns') is not None:
            self.slave_dns = m.get('SlaveDns')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        if m.get('VersionName') is not None:
            self.version_name = m.get('VersionName')
        return self


class DescribeDomainInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainLogsRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        key_word: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_date: str = None,
        type: str = None,
        end_date: str = None,
    ):
        # The ID of the domain name group.
        self.group_id = group_id
        # The keyword for the query in "%KeyWord%" mode. The keyword is not case-sensitive.
        self.key_word = key_word
        # The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
        self.lang = lang
        # The page number to return. The page number starts from **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return per page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size
        # The start time for the query. Format: **YYYY-MM-DD**\
        self.start_date = start_date
        # The type of object of which you want to query operation logs. Valid values:
        # 
        # *   domain: domain name
        # *   slavedns: secondary Domain Name System (DNS)
        self.type = type
        # The end time for the query. Format: **YYYY-MM-DD**\
        self.end_date = end_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.type is not None:
            result['Type'] = self.type
        if self.end_date is not None:
            result['endDate'] = self.end_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        return self


class DescribeDomainLogsResponseBodyDomainLogsDomainLog(TeaModel):
    def __init__(
        self,
        action: str = None,
        action_time: str = None,
        action_timestamp: int = None,
        client_ip: str = None,
        domain_name: str = None,
        message: str = None,
        zone_id: str = None,
    ):
        # The operation.
        self.action = action
        # The time when the operation is performed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.action_time = action_time
        # The time when the operation was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.action_timestamp = action_timestamp
        # The IP address of the operator.
        self.client_ip = client_ip
        # The domain name.
        self.domain_name = domain_name
        # The message for the operation.
        self.message = message
        # The ID of the private zone.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.action_time is not None:
            result['ActionTime'] = self.action_time
        if self.action_timestamp is not None:
            result['ActionTimestamp'] = self.action_timestamp
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.message is not None:
            result['Message'] = self.message
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('ActionTime') is not None:
            self.action_time = m.get('ActionTime')
        if m.get('ActionTimestamp') is not None:
            self.action_timestamp = m.get('ActionTimestamp')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDomainLogsResponseBodyDomainLogs(TeaModel):
    def __init__(
        self,
        domain_log: List[DescribeDomainLogsResponseBodyDomainLogsDomainLog] = None,
    ):
        self.domain_log = domain_log

    def validate(self):
        if self.domain_log:
            for k in self.domain_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainLog'] = []
        if self.domain_log is not None:
            for k in self.domain_log:
                result['DomainLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_log = []
        if m.get('DomainLog') is not None:
            for k in m.get('DomainLog'):
                temp_model = DescribeDomainLogsResponseBodyDomainLogsDomainLog()
                self.domain_log.append(temp_model.from_map(k))
        return self


class DescribeDomainLogsResponseBody(TeaModel):
    def __init__(
        self,
        domain_logs: DescribeDomainLogsResponseBodyDomainLogs = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The operation logs.
        self.domain_logs = domain_logs
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.domain_logs:
            self.domain_logs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_logs is not None:
            result['DomainLogs'] = self.domain_logs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainLogs') is not None:
            temp_model = DescribeDomainLogsResponseBodyDomainLogs()
            self.domain_logs = temp_model.from_map(m['DomainLogs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDomainLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainNsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the content in the request and response.
        # 
        # Valid values:
        # 
        # zh: Chinese\\
        # en: English
        # 
        # Default value: **zh**\
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeDomainNsResponseBodyDnsServers(TeaModel):
    def __init__(
        self,
        dns_server: List[str] = None,
    ):
        self.dns_server = dns_server

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server is not None:
            result['DnsServer'] = self.dns_server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServer') is not None:
            self.dns_server = m.get('DnsServer')
        return self


class DescribeDomainNsResponseBodyExpectDnsServers(TeaModel):
    def __init__(
        self,
        expect_dns_server: List[str] = None,
    ):
        self.expect_dns_server = expect_dns_server

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect_dns_server is not None:
            result['ExpectDnsServer'] = self.expect_dns_server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpectDnsServer') is not None:
            self.expect_dns_server = m.get('ExpectDnsServer')
        return self


class DescribeDomainNsResponseBody(TeaModel):
    def __init__(
        self,
        all_ali_dns: bool = None,
        detect_failed_reason_code: str = None,
        dns_servers: DescribeDomainNsResponseBodyDnsServers = None,
        expect_dns_servers: DescribeDomainNsResponseBodyExpectDnsServers = None,
        include_ali_dns: bool = None,
        request_id: str = None,
    ):
        # Indicates whether all the name servers are Alibaba Cloud DNS servers.
        self.all_ali_dns = all_ali_dns
        # The cause code of the detection failure.
        self.detect_failed_reason_code = detect_failed_reason_code
        # The DNS server names configured for the domain name.
        self.dns_servers = dns_servers
        # The Domain Name System (DNS) server names assigned by Alibaba Cloud DNS.
        self.expect_dns_servers = expect_dns_servers
        # Indicates whether the name servers include Alibaba Cloud DNS servers.
        self.include_ali_dns = include_ali_dns
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.dns_servers:
            self.dns_servers.validate()
        if self.expect_dns_servers:
            self.expect_dns_servers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all_ali_dns is not None:
            result['AllAliDns'] = self.all_ali_dns
        if self.detect_failed_reason_code is not None:
            result['DetectFailedReasonCode'] = self.detect_failed_reason_code
        if self.dns_servers is not None:
            result['DnsServers'] = self.dns_servers.to_map()
        if self.expect_dns_servers is not None:
            result['ExpectDnsServers'] = self.expect_dns_servers.to_map()
        if self.include_ali_dns is not None:
            result['IncludeAliDns'] = self.include_ali_dns
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllAliDns') is not None:
            self.all_ali_dns = m.get('AllAliDns')
        if m.get('DetectFailedReasonCode') is not None:
            self.detect_failed_reason_code = m.get('DetectFailedReasonCode')
        if m.get('DnsServers') is not None:
            temp_model = DescribeDomainNsResponseBodyDnsServers()
            self.dns_servers = temp_model.from_map(m['DnsServers'])
        if m.get('ExpectDnsServers') is not None:
            temp_model = DescribeDomainNsResponseBodyExpectDnsServers()
            self.expect_dns_servers = temp_model.from_map(m['ExpectDnsServers'])
        if m.get('IncludeAliDns') is not None:
            self.include_ali_dns = m.get('IncludeAliDns')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDomainNsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainNsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainNsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainRecordInfoRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        record_id: str = None,
        user_client_ip: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) to obtain the ID.
        # 
        # This parameter is required.
        self.record_id = record_id
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class DescribeDomainRecordInfoResponseBody(TeaModel):
    def __init__(
        self,
        domain_id: str = None,
        domain_name: str = None,
        group_id: str = None,
        group_name: str = None,
        line: str = None,
        locked: bool = None,
        priority: int = None,
        puny_code: str = None,
        rr: str = None,
        record_id: str = None,
        remark: str = None,
        request_id: str = None,
        status: str = None,
        ttl: int = None,
        type: str = None,
        value: str = None,
    ):
        # The ID of the domain name.
        self.domain_id = domain_id
        # The domain name.
        self.domain_name = domain_name
        # The ID of the domain name group.
        self.group_id = group_id
        # The name of the domain name group.
        self.group_name = group_name
        # The DNS resolution line.
        self.line = line
        # The lock state of the DNS record. Valid values: **true and false**.
        self.locked = locked
        # The priority of the mail exchanger (MX) record.
        self.priority = priority
        # The Punycode for the domain name. This parameter is returned only for Chinese domain names.
        self.puny_code = puny_code
        # The hostname.
        self.rr = rr
        # The ID of the DNS record.
        self.record_id = record_id
        # The description of your DNS record.
        self.remark = remark
        # The request ID.
        self.request_id = request_id
        # The status of the DNS record. Valid values:
        # 
        # Enable: enabled
        # 
        # Disable: disabled
        self.status = status
        # The time for which the DNS record is cached in a local DNS system.
        self.ttl = ttl
        # The type of the DNS record.
        self.type = type
        # The record value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['DomainId'] = self.domain_id
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line is not None:
            result['Line'] = self.line
        if self.locked is not None:
            result['Locked'] = self.locked
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.puny_code is not None:
            result['PunyCode'] = self.puny_code
        if self.rr is not None:
            result['RR'] = self.rr
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.ttl is not None:
            result['TTL'] = self.ttl
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainId') is not None:
            self.domain_id = m.get('DomainId')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Locked') is not None:
            self.locked = m.get('Locked')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('PunyCode') is not None:
            self.puny_code = m.get('PunyCode')
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TTL') is not None:
            self.ttl = m.get('TTL')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDomainRecordInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainRecordInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainRecordInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainRecordsRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        domain_name: str = None,
        group_id: int = None,
        key_word: str = None,
        lang: str = None,
        line: str = None,
        order_by: str = None,
        page_number: int = None,
        page_size: int = None,
        rrkey_word: str = None,
        search_mode: str = None,
        status: str = None,
        type: str = None,
        type_key_word: str = None,
        value_key_word: str = None,
    ):
        # The order in which you want to sort the returned DNS records. Valid values: DESC and ASC. Default value: DESC.
        self.direction = direction
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The ID of the domain name group.
        # 
        # *   If you do not specify GroupId, all domain names are queried.
        # *   If you set GroupId to 0, no value is returned.
        # *   If you set GroupId to 1, the domain names in the default group are queried.
        # *   If you set GroupId to -2, all domain names are queried.
        # *   You can also specify GroupId based on the actual group ID.
        # 
        # You can call the [DescribeDomainGroups ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID of the domain name group.
        self.group_id = group_id
        # The keyword.
        self.key_word = key_word
        # The language.
        self.lang = lang
        # The resolution line. Default value: **default**.
        # 
        # For more information, see
        # 
        # [DNS lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).
        self.line = line
        # The method that is used to sort the returned DNS records. By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
        self.order_by = order_by
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 500**. Default value: **20**.
        self.page_size = page_size
        # The hostname keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.
        self.rrkey_word = rrkey_word
        # The search mode. Valid values: **LIKE, EXACT, and ADVANCED**.
        # 
        # *   If you set SearchMode to LIKE or EXACT, specify KeyWord. In this case, RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status are invalid.
        # 
        # *   If you set SearchMode to ADVANCED, specify RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status.
        # 
        # *   If you do not specify SearchMode, the system determines the search mode based on the following rules:
        # 
        #     *   If KeyWord is specified, the system uses the LIKE mode.
        #     *   If KeyWord is not specified, the system queries DNS records based on values of RRKeyWord and ValueKeyWord in fuzzy match mode, and based on the values of TypeKeyWord, Type, Line, and Status in exact match mode.
        self.search_mode = search_mode
        # The status of the DNS records to query. Valid values: **Enable and Disable**.
        self.status = status
        # The type of the DNS records to query. For more information, see
        # 
        # [DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).
        self.type = type
        # The type keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in exact match mode. The value is not case-sensitive.
        self.type_key_word = type_key_word
        # The record value keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.
        self.value_key_word = value_key_word

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line is not None:
            result['Line'] = self.line
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rrkey_word is not None:
            result['RRKeyWord'] = self.rrkey_word
        if self.search_mode is not None:
            result['SearchMode'] = self.search_mode
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.type_key_word is not None:
            result['TypeKeyWord'] = self.type_key_word
        if self.value_key_word is not None:
            result['ValueKeyWord'] = self.value_key_word
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RRKeyWord') is not None:
            self.rrkey_word = m.get('RRKeyWord')
        if m.get('SearchMode') is not None:
            self.search_mode = m.get('SearchMode')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeKeyWord') is not None:
            self.type_key_word = m.get('TypeKeyWord')
        if m.get('ValueKeyWord') is not None:
            self.value_key_word = m.get('ValueKeyWord')
        return self


class DescribeDomainRecordsResponseBodyDomainRecordsRecord(TeaModel):
    def __init__(
        self,
        create_timestamp: int = None,
        domain_name: str = None,
        lba_status: bool = None,
        line: str = None,
        locked: bool = None,
        priority: int = None,
        rr: str = None,
        record_id: str = None,
        remark: str = None,
        status: str = None,
        ttl: int = None,
        type: str = None,
        update_timestamp: int = None,
        value: str = None,
        weight: int = None,
    ):
        # The time when the DNS record was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.
        self.create_timestamp = create_timestamp
        # The domain name.
        self.domain_name = domain_name
        self.lba_status = lba_status
        # The resolution line.
        self.line = line
        # Indicates whether the DNS record is locked.
        self.locked = locked
        # The priority of the mail exchanger (MX) record.
        self.priority = priority
        # The hostname.
        self.rr = rr
        # The ID of the DNS record.
        self.record_id = record_id
        # The description of the DNS record.
        self.remark = remark
        # The status of the DNS record.
        self.status = status
        # The time-to-live (TTL) of the cached DNS record. Unit: seconds.
        self.ttl = ttl
        # The type of the DNS record.
        self.type = type
        # The time when the DNS record was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.
        self.update_timestamp = update_timestamp
        # The record value.
        self.value = value
        # The weight of the DNS record.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lba_status is not None:
            result['LbaStatus'] = self.lba_status
        if self.line is not None:
            result['Line'] = self.line
        if self.locked is not None:
            result['Locked'] = self.locked
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.rr is not None:
            result['RR'] = self.rr
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.status is not None:
            result['Status'] = self.status
        if self.ttl is not None:
            result['TTL'] = self.ttl
        if self.type is not None:
            result['Type'] = self.type
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.value is not None:
            result['Value'] = self.value
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LbaStatus') is not None:
            self.lba_status = m.get('LbaStatus')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Locked') is not None:
            self.locked = m.get('Locked')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TTL') is not None:
            self.ttl = m.get('TTL')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class DescribeDomainRecordsResponseBodyDomainRecords(TeaModel):
    def __init__(
        self,
        record: List[DescribeDomainRecordsResponseBodyDomainRecordsRecord] = None,
    ):
        self.record = record

    def validate(self):
        if self.record:
            for k in self.record:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Record'] = []
        if self.record is not None:
            for k in self.record:
                result['Record'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record = []
        if m.get('Record') is not None:
            for k in m.get('Record'):
                temp_model = DescribeDomainRecordsResponseBodyDomainRecordsRecord()
                self.record.append(temp_model.from_map(k))
        return self


class DescribeDomainRecordsResponseBody(TeaModel):
    def __init__(
        self,
        domain_records: DescribeDomainRecordsResponseBodyDomainRecords = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The returned Domain Name System (DNS) records.
        self.domain_records = domain_records
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.domain_records:
            self.domain_records.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_records is not None:
            result['DomainRecords'] = self.domain_records.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainRecords') is not None:
            temp_model = DescribeDomainRecordsResponseBodyDomainRecords()
            self.domain_records = temp_model.from_map(m['DomainRecords'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDomainRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainResolveStatisticsSummaryRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        end_date: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        search_mode: str = None,
        start_date: str = None,
        threshold: int = None,
    ):
        # The order in which you want to sort the returned entries. Valid values:
        # 
        # *   DESC: the descending order
        # *   ASC: the ascending order
        self.direction = direction
        # The end time in the yyyy-MM-dd format, for example, 2023-03-13.
        self.end_date = end_date
        # The keyword. The Keyword parameter is used together with the SearchMode parameter.
        self.keyword = keyword
        # The language. Valid values: zh, en, and ja.
        self.lang = lang
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Valid values: 1 to 1000.
        self.page_size = page_size
        # The search mode of the keyword. Valid values:
        # 
        # *   LIKE (default): fuzzy search
        # *   EXACT: exact search
        self.search_mode = search_mode
        # The start time in the yyyy-MM-dd format, for example, 2023-03-01.
        # 
        # This parameter is required.
        self.start_date = start_date
        # The threshold for the number of Domain Name System (DNS) requests. You can query the domain names at the specified quantity level of DNS requests and query the number of DNS requests for each domain name.
        # 
        # If you do not specify this parameter, the data about the domain names that have DNS requests is obtained.
        # 
        # If you set this parameter to a value less than 0, the data about all domain names is obtained.
        # 
        # If you set this parameter to 0, the data about the domain names that do not have DNS requests is obtained.
        # 
        # If you set this parameter to a value greater than 0, the data about the domain names whose number of DNS requests is less than or equal to the value of this parameter is obtained.
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_mode is not None:
            result['SearchMode'] = self.search_mode
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchMode') is not None:
            self.search_mode = m.get('SearchMode')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeDomainResolveStatisticsSummaryResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        count: str = None,
        domain_name: str = None,
        domain_type: str = None,
    ):
        # The number of DNS requests.
        self.count = count
        # The domain name.
        self.domain_name = domain_name
        # The type of the domain name. Valid values:
        # 
        # *   PUBLIC: hosted public domain name
        # *   CACHE: cache-accelerated domain name
        self.domain_type = domain_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        return self


class DescribeDomainResolveStatisticsSummaryResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        statistics: List[DescribeDomainResolveStatisticsSummaryResponseBodyStatistics] = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The statistics.
        self.statistics = statistics
        # The total number of entries returned.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = DescribeDomainResolveStatisticsSummaryResponseBodyStatistics()
                self.statistics.append(temp_model.from_map(k))
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeDomainResolveStatisticsSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainResolveStatisticsSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainResolveStatisticsSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainStatisticsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        domain_type: str = None,
        end_date: str = None,
        lang: str = None,
        start_date: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        self.domain_name = domain_name
        # The type of the domain name. Valid values:
        # 
        # *   PUBLIC (default): hosted public domain name
        # *   CACHE: cached public domain name
        self.domain_type = domain_type
        # The end date of the query. Specify the end date in the **YYYY-MM-DD** format.
        # 
        # The default value is the day when you query the data.
        self.end_date = end_date
        # The language of the content within the request and response.
        # 
        # *   **zh**: Chinese (default)
        # *   **en**: English
        self.lang = lang
        # The start date of the query. Specify the start date in the **YYYY-MM-DD** format.
        # 
        # You can only query the DNS records within the last 90 days.``
        # 
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeDomainStatisticsResponseBodyStatisticsStatistic(TeaModel):
    def __init__(
        self,
        count: int = None,
        domain_name: str = None,
        timestamp: int = None,
    ):
        # The number of DNS requests.
        self.count = count
        # The domain name.
        self.domain_name = domain_name
        # The statistical timestamp. Unit: milliseconds. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class DescribeDomainStatisticsResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        statistic: List[DescribeDomainStatisticsResponseBodyStatisticsStatistic] = None,
    ):
        self.statistic = statistic

    def validate(self):
        if self.statistic:
            for k in self.statistic:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Statistic'] = []
        if self.statistic is not None:
            for k in self.statistic:
                result['Statistic'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.statistic = []
        if m.get('Statistic') is not None:
            for k in m.get('Statistic'):
                temp_model = DescribeDomainStatisticsResponseBodyStatisticsStatistic()
                self.statistic.append(temp_model.from_map(k))
        return self


class DescribeDomainStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        statistics: DescribeDomainStatisticsResponseBodyStatistics = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The statistics on the Domain Name System (DNS) requests.
        self.statistics = statistics

    def validate(self):
        if self.statistics:
            self.statistics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.statistics is not None:
            result['Statistics'] = self.statistics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Statistics') is not None:
            temp_model = DescribeDomainStatisticsResponseBodyStatistics()
            self.statistics = temp_model.from_map(m['Statistics'])
        return self


class DescribeDomainStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainStatisticsSummaryRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        search_mode: str = None,
        start_date: str = None,
        threshold: int = None,
    ):
        # The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.
        # 
        # The default value is the day when you perform the operation.
        self.end_date = end_date
        # The keyword for searches in %KeyWord% mode. The value is not case-sensitive.
        self.keyword = keyword
        # The language type.
        self.lang = lang
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # The search mode of the keyword. Valid values:
        # 
        # *   **LIKE**: fuzzy match (default).
        # *   **EXACT**: exact match.
        self.search_mode = search_mode
        # The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.
        # 
        # You can only query DNS records of the last 90 days.
        # 
        # This parameter is required.
        self.start_date = start_date
        # The threshold of query volume that can be obtained. You can also obtain data about a domain name with the query volume less than or equal to the threshold. For example, if you set this parameter to 100, you can query domain names with less than 100 queries.
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_mode is not None:
            result['SearchMode'] = self.search_mode
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchMode') is not None:
            self.search_mode = m.get('SearchMode')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic(TeaModel):
    def __init__(
        self,
        count: int = None,
        domain_name: str = None,
        domain_type: str = None,
        resolve_analysis_status: str = None,
    ):
        # The number of DNS requests.
        self.count = count
        # The domain name.
        self.domain_name = domain_name
        # The type of the domain name. The parameter value is not case-sensitive. Valid values:
        # 
        # PUBLIC (default): hosted public domain name
        # 
        # CACHE: cache-accelerated domain name
        self.domain_type = domain_type
        # Indicates whether the DNS traffic analysis feature is enabled for the domain name. Valid values:
        # 
        # *   OPEN
        # *   CLOSE
        self.resolve_analysis_status = resolve_analysis_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.resolve_analysis_status is not None:
            result['resolveAnalysisStatus'] = self.resolve_analysis_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('resolveAnalysisStatus') is not None:
            self.resolve_analysis_status = m.get('resolveAnalysisStatus')
        return self


class DescribeDomainStatisticsSummaryResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        statistic: List[DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic] = None,
    ):
        self.statistic = statistic

    def validate(self):
        if self.statistic:
            for k in self.statistic:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Statistic'] = []
        if self.statistic is not None:
            for k in self.statistic:
                result['Statistic'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.statistic = []
        if m.get('Statistic') is not None:
            for k in m.get('Statistic'):
                temp_model = DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic()
                self.statistic.append(temp_model.from_map(k))
        return self


class DescribeDomainStatisticsSummaryResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        statistics: DescribeDomainStatisticsSummaryResponseBodyStatistics = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The statistics on the Domain Name System (DNS) requests.
        self.statistics = statistics
        # The total number of data records.
        self.total_items = total_items
        # The total number of returned pages.
        self.total_pages = total_pages

    def validate(self):
        if self.statistics:
            self.statistics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.statistics is not None:
            result['Statistics'] = self.statistics.to_map()
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Statistics') is not None:
            temp_model = DescribeDomainStatisticsSummaryResponseBodyStatistics()
            self.statistics = temp_model.from_map(m['Statistics'])
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeDomainStatisticsSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainStatisticsSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainStatisticsSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainsRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        key_word: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        resource_group_id: str = None,
        search_mode: str = None,
        starmark: bool = None,
    ):
        # The ID of the domain name group. If you do not specify this parameter, all domain names are queried by default.
        self.group_id = group_id
        # The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
        self.key_word = key_word
        # The language type.
        self.lang = lang
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The search mode. Valid values:
        # 
        # *   **LIKE**: fuzzy match.
        # *   **EXACT**: exact match.
        self.search_mode = search_mode
        # Specifies whether to query the starmark of the domain name.
        self.starmark = starmark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.search_mode is not None:
            result['SearchMode'] = self.search_mode
        if self.starmark is not None:
            result['Starmark'] = self.starmark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SearchMode') is not None:
            self.search_mode = m.get('SearchMode')
        if m.get('Starmark') is not None:
            self.starmark = m.get('Starmark')
        return self


class DescribeDomainsResponseBodyDomainsDomainDnsServers(TeaModel):
    def __init__(
        self,
        dns_server: List[str] = None,
    ):
        self.dns_server = dns_server

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server is not None:
            result['DnsServer'] = self.dns_server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServer') is not None:
            self.dns_server = m.get('DnsServer')
        return self


class DescribeDomainsResponseBodyDomainsDomainTagsTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of tag N added to the resource.
        self.key = key
        # The value of tag N added to the resource.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDomainsResponseBodyDomainsDomainTags(TeaModel):
    def __init__(
        self,
        tag: List[DescribeDomainsResponseBodyDomainsDomainTagsTag] = None,
    ):
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDomainsResponseBodyDomainsDomainTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeDomainsResponseBodyDomainsDomain(TeaModel):
    def __init__(
        self,
        ali_domain: bool = None,
        create_time: str = None,
        create_timestamp: int = None,
        dns_servers: DescribeDomainsResponseBodyDomainsDomainDnsServers = None,
        domain_id: str = None,
        domain_logging_switch_status: str = None,
        domain_name: str = None,
        group_id: str = None,
        group_name: str = None,
        instance_end_time: str = None,
        instance_expired: bool = None,
        instance_id: str = None,
        puny_code: str = None,
        record_count: int = None,
        registrant_email: str = None,
        remark: str = None,
        resource_group_id: str = None,
        slave_dns_status: str = None,
        starmark: bool = None,
        tags: DescribeDomainsResponseBodyDomainsDomainTags = None,
        version_code: str = None,
        version_name: str = None,
    ):
        # Indicates whether the domain name was registered with Alibaba Cloud.
        self.ali_domain = ali_domain
        # The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the domain name was added. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_timestamp = create_timestamp
        # The names of the DNS servers configured for the domain name assigned by Alibaba Cloud DNS.
        self.dns_servers = dns_servers
        # The ID of the domain name.
        self.domain_id = domain_id
        # Indicates whether the DNS traffic analysis feature is enabled for the domain name. Valid values:
        # 
        # *   OPEN
        # *   CLOSE
        self.domain_logging_switch_status = domain_logging_switch_status
        # The domain name.
        self.domain_name = domain_name
        # The ID of the domain name group.
        self.group_id = group_id
        # The name of the domain name group.
        self.group_name = group_name
        # The time when the Alibaba Cloud DNS instance expires. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.instance_end_time = instance_end_time
        # Indicates whether the Alibaba Cloud DNS instance expires.
        self.instance_expired = instance_expired
        # The ID of the Alibaba Cloud DNS instance.
        self.instance_id = instance_id
        # The Punycode for the domain name. This parameter is returned only for Chinese domain names.
        self.puny_code = puny_code
        # The number of Domain Name System (DNS) records added for the domain name.
        self.record_count = record_count
        # The email address of the registrant.
        self.registrant_email = registrant_email
        # The description of the domain name.
        self.remark = remark
        # The ID of the resource group to which the domain name belongs.
        self.resource_group_id = resource_group_id
        self.slave_dns_status = slave_dns_status
        # Indicates whether the domain name was added to favorites.
        self.starmark = starmark
        # The tags added to the resource.
        self.tags = tags
        # The edition code of Alibaba Cloud DNS.
        self.version_code = version_code
        # The edition of Alibaba Cloud DNS.
        self.version_name = version_name

    def validate(self):
        if self.dns_servers:
            self.dns_servers.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_domain is not None:
            result['AliDomain'] = self.ali_domain
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.dns_servers is not None:
            result['DnsServers'] = self.dns_servers.to_map()
        if self.domain_id is not None:
            result['DomainId'] = self.domain_id
        if self.domain_logging_switch_status is not None:
            result['DomainLoggingSwitchStatus'] = self.domain_logging_switch_status
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.instance_end_time is not None:
            result['InstanceEndTime'] = self.instance_end_time
        if self.instance_expired is not None:
            result['InstanceExpired'] = self.instance_expired
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.puny_code is not None:
            result['PunyCode'] = self.puny_code
        if self.record_count is not None:
            result['RecordCount'] = self.record_count
        if self.registrant_email is not None:
            result['RegistrantEmail'] = self.registrant_email
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.slave_dns_status is not None:
            result['SlaveDnsStatus'] = self.slave_dns_status
        if self.starmark is not None:
            result['Starmark'] = self.starmark
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        if self.version_name is not None:
            result['VersionName'] = self.version_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliDomain') is not None:
            self.ali_domain = m.get('AliDomain')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DnsServers') is not None:
            temp_model = DescribeDomainsResponseBodyDomainsDomainDnsServers()
            self.dns_servers = temp_model.from_map(m['DnsServers'])
        if m.get('DomainId') is not None:
            self.domain_id = m.get('DomainId')
        if m.get('DomainLoggingSwitchStatus') is not None:
            self.domain_logging_switch_status = m.get('DomainLoggingSwitchStatus')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('InstanceEndTime') is not None:
            self.instance_end_time = m.get('InstanceEndTime')
        if m.get('InstanceExpired') is not None:
            self.instance_expired = m.get('InstanceExpired')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PunyCode') is not None:
            self.puny_code = m.get('PunyCode')
        if m.get('RecordCount') is not None:
            self.record_count = m.get('RecordCount')
        if m.get('RegistrantEmail') is not None:
            self.registrant_email = m.get('RegistrantEmail')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SlaveDnsStatus') is not None:
            self.slave_dns_status = m.get('SlaveDnsStatus')
        if m.get('Starmark') is not None:
            self.starmark = m.get('Starmark')
        if m.get('Tags') is not None:
            temp_model = DescribeDomainsResponseBodyDomainsDomainTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        if m.get('VersionName') is not None:
            self.version_name = m.get('VersionName')
        return self


class DescribeDomainsResponseBodyDomains(TeaModel):
    def __init__(
        self,
        domain: List[DescribeDomainsResponseBodyDomainsDomain] = None,
    ):
        self.domain = domain

    def validate(self):
        if self.domain:
            for k in self.domain:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Domain'] = []
        if self.domain is not None:
            for k in self.domain:
                result['Domain'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain = []
        if m.get('Domain') is not None:
            for k in m.get('Domain'):
                temp_model = DescribeDomainsResponseBodyDomainsDomain()
                self.domain.append(temp_model.from_map(k))
        return self


class DescribeDomainsResponseBody(TeaModel):
    def __init__(
        self,
        domains: DescribeDomainsResponseBodyDomains = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The domain names.
        self.domains = domains
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of domain names.
        self.total_count = total_count

    def validate(self):
        if self.domains:
            self.domains.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domains is not None:
            result['Domains'] = self.domains.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domains') is not None:
            temp_model = DescribeDomainsResponseBodyDomains()
            self.domains = temp_model.from_map(m['Domains'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmAccessStrategiesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the GTM instance whose access policies you want to query.
        self.instance_id = instance_id
        # The language used by the user.
        self.lang = lang
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return per page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine(TeaModel):
    def __init__(
        self,
        group_code: str = None,
        group_name: str = None,
        line_code: str = None,
        line_name: str = None,
    ):
        # The code of the access region group.
        self.group_code = group_code
        # The name of the access region group.
        self.group_name = group_name
        # The code for the line of the access region.
        self.line_code = line_code
        # The name for the line of the access region.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_code is not None:
            result['GroupCode'] = self.group_code
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupCode') is not None:
            self.group_code = m.get('GroupCode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines(TeaModel):
    def __init__(
        self,
        line: List[DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine] = None,
    ):
        self.line = line

    def validate(self):
        if self.line:
            for k in self.line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Line'] = []
        if self.line is not None:
            for k in self.line:
                result['Line'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.line = []
        if m.get('Line') is not None:
            for k in m.get('Line'):
                temp_model = DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine()
                self.line.append(temp_model.from_map(k))
        return self


class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy(TeaModel):
    def __init__(
        self,
        access_mode: str = None,
        access_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        default_addr_pool_id: str = None,
        default_addr_pool_monitor_status: str = None,
        default_addr_pool_name: str = None,
        default_addr_pool_status: str = None,
        failover_addr_pool_id: str = None,
        failover_addr_pool_monitor_status: str = None,
        failover_addr_pool_name: str = None,
        failover_addr_pool_status: str = None,
        instance_id: str = None,
        lines: DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines = None,
        strategy_id: str = None,
        strategy_mode: str = None,
        strategy_name: str = None,
    ):
        # The access policy. Valid values:
        # 
        # *   **AUTO**: Automatic switch
        # *   **DEFAULT**: Default address pool
        # *   **FAILOVER**: Failover address pool
        self.access_mode = access_mode
        # The access status. Valid values:
        # 
        # *   **DEFAULT**: The default address pool is currently accessed.
        # *   **FAILOVER**: The failover address pool is currently accessed.
        self.access_status = access_status
        # The time when the access policy was created.
        self.create_time = create_time
        self.create_timestamp = create_timestamp
        # The ID of the default address pool.
        self.default_addr_pool_id = default_addr_pool_id
        # Indicates whether health check was enabled for the default address pool. Valid values:
        # 
        # *   **OPEN**: Enabled
        # *   **CLOSE**: Disabled
        # *   **UNCONFIGURED**: Not configured
        self.default_addr_pool_monitor_status = default_addr_pool_monitor_status
        # The name of the default address pool.
        self.default_addr_pool_name = default_addr_pool_name
        # The availability status of the default address pool. Valid values:
        # 
        # *   **AVAILABLE**: Available
        # *   **NOT_AVAILABLE**: Unavailable
        self.default_addr_pool_status = default_addr_pool_status
        # The ID of the failover address pool.
        self.failover_addr_pool_id = failover_addr_pool_id
        # Indicates whether health check was enabled for the failover address pool.
        self.failover_addr_pool_monitor_status = failover_addr_pool_monitor_status
        # The name of the failover address pool.
        self.failover_addr_pool_name = failover_addr_pool_name
        # The availability status of the failover address pool.
        self.failover_addr_pool_status = failover_addr_pool_status
        # The ID of the GTM instance whose access policies you want to query.
        self.instance_id = instance_id
        # The returned lines of access regions.
        self.lines = lines
        # The ID of the access policy.
        self.strategy_id = strategy_id
        # The mode of the access policy. **SELF_DEFINED** indicates that the access policy is user-defined.
        self.strategy_mode = strategy_mode
        # The name of the access policy.
        self.strategy_name = strategy_name

    def validate(self):
        if self.lines:
            self.lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_mode is not None:
            result['AccessMode'] = self.access_mode
        if self.access_status is not None:
            result['AccessStatus'] = self.access_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.default_addr_pool_id is not None:
            result['DefaultAddrPoolId'] = self.default_addr_pool_id
        if self.default_addr_pool_monitor_status is not None:
            result['DefaultAddrPoolMonitorStatus'] = self.default_addr_pool_monitor_status
        if self.default_addr_pool_name is not None:
            result['DefaultAddrPoolName'] = self.default_addr_pool_name
        if self.default_addr_pool_status is not None:
            result['DefaultAddrPoolStatus'] = self.default_addr_pool_status
        if self.failover_addr_pool_id is not None:
            result['FailoverAddrPoolId'] = self.failover_addr_pool_id
        if self.failover_addr_pool_monitor_status is not None:
            result['FailoverAddrPoolMonitorStatus'] = self.failover_addr_pool_monitor_status
        if self.failover_addr_pool_name is not None:
            result['FailoverAddrPoolName'] = self.failover_addr_pool_name
        if self.failover_addr_pool_status is not None:
            result['FailoverAddrPoolStatus'] = self.failover_addr_pool_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lines is not None:
            result['Lines'] = self.lines.to_map()
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessMode') is not None:
            self.access_mode = m.get('AccessMode')
        if m.get('AccessStatus') is not None:
            self.access_status = m.get('AccessStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DefaultAddrPoolId') is not None:
            self.default_addr_pool_id = m.get('DefaultAddrPoolId')
        if m.get('DefaultAddrPoolMonitorStatus') is not None:
            self.default_addr_pool_monitor_status = m.get('DefaultAddrPoolMonitorStatus')
        if m.get('DefaultAddrPoolName') is not None:
            self.default_addr_pool_name = m.get('DefaultAddrPoolName')
        if m.get('DefaultAddrPoolStatus') is not None:
            self.default_addr_pool_status = m.get('DefaultAddrPoolStatus')
        if m.get('FailoverAddrPoolId') is not None:
            self.failover_addr_pool_id = m.get('FailoverAddrPoolId')
        if m.get('FailoverAddrPoolMonitorStatus') is not None:
            self.failover_addr_pool_monitor_status = m.get('FailoverAddrPoolMonitorStatus')
        if m.get('FailoverAddrPoolName') is not None:
            self.failover_addr_pool_name = m.get('FailoverAddrPoolName')
        if m.get('FailoverAddrPoolStatus') is not None:
            self.failover_addr_pool_status = m.get('FailoverAddrPoolStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lines') is not None:
            temp_model = DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines()
            self.lines = temp_model.from_map(m['Lines'])
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class DescribeGtmAccessStrategiesResponseBodyStrategies(TeaModel):
    def __init__(
        self,
        strategy: List[DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy] = None,
    ):
        self.strategy = strategy

    def validate(self):
        if self.strategy:
            for k in self.strategy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Strategy'] = []
        if self.strategy is not None:
            for k in self.strategy:
                result['Strategy'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.strategy = []
        if m.get('Strategy') is not None:
            for k in m.get('Strategy'):
                temp_model = DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy()
                self.strategy.append(temp_model.from_map(k))
        return self


class DescribeGtmAccessStrategiesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        strategies: DescribeGtmAccessStrategiesResponseBodyStrategies = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The number of the page returned.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The returned list of access policies of the GTM instance.
        self.strategies = strategies
        # The total number of entries returned on all pages.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.strategies:
            self.strategies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategies is not None:
            result['Strategies'] = self.strategies.to_map()
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Strategies') is not None:
            temp_model = DescribeGtmAccessStrategiesResponseBodyStrategies()
            self.strategies = temp_model.from_map(m['Strategies'])
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeGtmAccessStrategiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmAccessStrategiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmAccessStrategiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmAccessStrategyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        strategy_id: str = None,
    ):
        # The language used by the user.
        self.lang = lang
        # The ID of the access policy that you want to query.
        # 
        # This parameter is required.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class DescribeGtmAccessStrategyResponseBodyLinesLine(TeaModel):
    def __init__(
        self,
        group_code: str = None,
        group_name: str = None,
        line_code: str = None,
        line_name: str = None,
    ):
        # The code of the access region group.
        self.group_code = group_code
        # The name of the access region group.
        self.group_name = group_name
        # The code for the line of the access region.
        self.line_code = line_code
        # The name for the line of the access region.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_code is not None:
            result['GroupCode'] = self.group_code
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupCode') is not None:
            self.group_code = m.get('GroupCode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeGtmAccessStrategyResponseBodyLines(TeaModel):
    def __init__(
        self,
        line: List[DescribeGtmAccessStrategyResponseBodyLinesLine] = None,
    ):
        self.line = line

    def validate(self):
        if self.line:
            for k in self.line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Line'] = []
        if self.line is not None:
            for k in self.line:
                result['Line'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.line = []
        if m.get('Line') is not None:
            for k in m.get('Line'):
                temp_model = DescribeGtmAccessStrategyResponseBodyLinesLine()
                self.line.append(temp_model.from_map(k))
        return self


class DescribeGtmAccessStrategyResponseBody(TeaModel):
    def __init__(
        self,
        access_mode: str = None,
        access_status: str = None,
        default_addr_pool_monitor_status: str = None,
        default_addr_pool_name: str = None,
        default_addr_pool_status: str = None,
        defult_addr_pool_id: str = None,
        failover_addr_pool_id: str = None,
        failover_addr_pool_monitor_status: str = None,
        failover_addr_pool_name: str = None,
        failover_addr_pool_status: str = None,
        instance_id: str = None,
        lines: DescribeGtmAccessStrategyResponseBodyLines = None,
        request_id: str = None,
        strategy_id: str = None,
        strategy_mode: str = None,
        strategy_name: str = None,
    ):
        # The access policy.
        self.access_mode = access_mode
        # The access status. Valid values:
        # 
        # *   **DEFAULT**: Indicates normal when the default address pool is accessed.
        # *   **FAILOVER**: Indicates an exception when a failover address pool is accessed.
        self.access_status = access_status
        # Indicates whether health check is enabled for the default address pool.
        self.default_addr_pool_monitor_status = default_addr_pool_monitor_status
        # The name of the default address pool.
        self.default_addr_pool_name = default_addr_pool_name
        # The availability status of the default address pool.
        self.default_addr_pool_status = default_addr_pool_status
        # The ID of the default address pool.
        self.defult_addr_pool_id = defult_addr_pool_id
        # The ID of the failover address pool.
        self.failover_addr_pool_id = failover_addr_pool_id
        # Indicates whether health check is enabled for the failover address pool.
        self.failover_addr_pool_monitor_status = failover_addr_pool_monitor_status
        # The name of the failover address pool.
        self.failover_addr_pool_name = failover_addr_pool_name
        # The availability status of the failover address pool.
        self.failover_addr_pool_status = failover_addr_pool_status
        # The ID of the GTM instance whose access policy details you want to query.
        self.instance_id = instance_id
        # The returned lines of access regions.
        self.lines = lines
        # The ID of the request.
        self.request_id = request_id
        # The ID of the access policy queried.
        self.strategy_id = strategy_id
        # The mode of traffic scheduling.
        self.strategy_mode = strategy_mode
        # The name of the access policy queried.
        self.strategy_name = strategy_name

    def validate(self):
        if self.lines:
            self.lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_mode is not None:
            result['AccessMode'] = self.access_mode
        if self.access_status is not None:
            result['AccessStatus'] = self.access_status
        if self.default_addr_pool_monitor_status is not None:
            result['DefaultAddrPoolMonitorStatus'] = self.default_addr_pool_monitor_status
        if self.default_addr_pool_name is not None:
            result['DefaultAddrPoolName'] = self.default_addr_pool_name
        if self.default_addr_pool_status is not None:
            result['DefaultAddrPoolStatus'] = self.default_addr_pool_status
        if self.defult_addr_pool_id is not None:
            result['DefultAddrPoolId'] = self.defult_addr_pool_id
        if self.failover_addr_pool_id is not None:
            result['FailoverAddrPoolId'] = self.failover_addr_pool_id
        if self.failover_addr_pool_monitor_status is not None:
            result['FailoverAddrPoolMonitorStatus'] = self.failover_addr_pool_monitor_status
        if self.failover_addr_pool_name is not None:
            result['FailoverAddrPoolName'] = self.failover_addr_pool_name
        if self.failover_addr_pool_status is not None:
            result['FailoverAddrPoolStatus'] = self.failover_addr_pool_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lines is not None:
            result['Lines'] = self.lines.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessMode') is not None:
            self.access_mode = m.get('AccessMode')
        if m.get('AccessStatus') is not None:
            self.access_status = m.get('AccessStatus')
        if m.get('DefaultAddrPoolMonitorStatus') is not None:
            self.default_addr_pool_monitor_status = m.get('DefaultAddrPoolMonitorStatus')
        if m.get('DefaultAddrPoolName') is not None:
            self.default_addr_pool_name = m.get('DefaultAddrPoolName')
        if m.get('DefaultAddrPoolStatus') is not None:
            self.default_addr_pool_status = m.get('DefaultAddrPoolStatus')
        if m.get('DefultAddrPoolId') is not None:
            self.defult_addr_pool_id = m.get('DefultAddrPoolId')
        if m.get('FailoverAddrPoolId') is not None:
            self.failover_addr_pool_id = m.get('FailoverAddrPoolId')
        if m.get('FailoverAddrPoolMonitorStatus') is not None:
            self.failover_addr_pool_monitor_status = m.get('FailoverAddrPoolMonitorStatus')
        if m.get('FailoverAddrPoolName') is not None:
            self.failover_addr_pool_name = m.get('FailoverAddrPoolName')
        if m.get('FailoverAddrPoolStatus') is not None:
            self.failover_addr_pool_status = m.get('FailoverAddrPoolStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lines') is not None:
            temp_model = DescribeGtmAccessStrategyResponseBodyLines()
            self.lines = temp_model.from_map(m['Lines'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class DescribeGtmAccessStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmAccessStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmAccessStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmAccessStrategyAvailableConfigRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
    ):
        # The ID of the Global Traffic Manager (GTM) instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        addr_pool_name: str = None,
    ):
        # The ID of the address pool.
        self.addr_pool_id = addr_pool_id
        # The name of the address pool.
        self.addr_pool_name = addr_pool_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.addr_pool_name is not None:
            result['AddrPoolName'] = self.addr_pool_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('AddrPoolName') is not None:
            self.addr_pool_name = m.get('AddrPoolName')
        return self


class DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools(TeaModel):
    def __init__(
        self,
        addr_pool: List[DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool] = None,
    ):
        self.addr_pool = addr_pool

    def validate(self):
        if self.addr_pool:
            for k in self.addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddrPool'] = []
        if self.addr_pool is not None:
            for k in self.addr_pool:
                result['AddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr_pool = []
        if m.get('AddrPool') is not None:
            for k in m.get('AddrPool'):
                temp_model = DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool()
                self.addr_pool.append(temp_model.from_map(k))
        return self


class DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine(TeaModel):
    def __init__(
        self,
        father_code: str = None,
        group_code: str = None,
        group_name: str = None,
        line_code: str = None,
        line_name: str = None,
        status: str = None,
    ):
        # The code of the parent line. No value is returned if no parent line exists.
        self.father_code = father_code
        # The group number of the DNS request source.
        self.group_code = group_code
        # The group name of the DNS request source.
        self.group_name = group_name
        # The code of the DNS request source.
        self.line_code = line_code
        # The name of the DNS request source.
        self.line_name = line_name
        # The state of the line. Valid values:
        # 
        # *   **FORBIDDEN**: The line is unavailable.
        # *   **OPTIONAL**: The line is available.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.father_code is not None:
            result['FatherCode'] = self.father_code
        if self.group_code is not None:
            result['GroupCode'] = self.group_code
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_name is not None:
            result['LineName'] = self.line_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FatherCode') is not None:
            self.father_code = m.get('FatherCode')
        if m.get('GroupCode') is not None:
            self.group_code = m.get('GroupCode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeGtmAccessStrategyAvailableConfigResponseBodyLines(TeaModel):
    def __init__(
        self,
        line: List[DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine] = None,
    ):
        self.line = line

    def validate(self):
        if self.line:
            for k in self.line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Line'] = []
        if self.line is not None:
            for k in self.line:
                result['Line'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.line = []
        if m.get('Line') is not None:
            for k in m.get('Line'):
                temp_model = DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine()
                self.line.append(temp_model.from_map(k))
        return self


class DescribeGtmAccessStrategyAvailableConfigResponseBody(TeaModel):
    def __init__(
        self,
        addr_pools: DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools = None,
        lines: DescribeGtmAccessStrategyAvailableConfigResponseBodyLines = None,
        request_id: str = None,
        suggest_set_default_line: bool = None,
    ):
        # The address pools.
        self.addr_pools = addr_pools
        # The Domain Name System (DNS) request sources.
        self.lines = lines
        # The request ID.
        self.request_id = request_id
        # Indicates whether the global line is recommended.
        self.suggest_set_default_line = suggest_set_default_line

    def validate(self):
        if self.addr_pools:
            self.addr_pools.validate()
        if self.lines:
            self.lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pools is not None:
            result['AddrPools'] = self.addr_pools.to_map()
        if self.lines is not None:
            result['Lines'] = self.lines.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.suggest_set_default_line is not None:
            result['SuggestSetDefaultLine'] = self.suggest_set_default_line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPools') is not None:
            temp_model = DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools()
            self.addr_pools = temp_model.from_map(m['AddrPools'])
        if m.get('Lines') is not None:
            temp_model = DescribeGtmAccessStrategyAvailableConfigResponseBodyLines()
            self.lines = temp_model.from_map(m['Lines'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SuggestSetDefaultLine') is not None:
            self.suggest_set_default_line = m.get('SuggestSetDefaultLine')
        return self


class DescribeGtmAccessStrategyAvailableConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmAccessStrategyAvailableConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmAccessStrategyAvailableConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmAvailableAlertGroupRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        # The language used by the user.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeGtmAvailableAlertGroupResponseBody(TeaModel):
    def __init__(
        self,
        available_alert_group: str = None,
        request_id: str = None,
    ):
        # The available alert groups of the GTM instance.
        self.available_alert_group = available_alert_group
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_alert_group is not None:
            result['AvailableAlertGroup'] = self.available_alert_group
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableAlertGroup') is not None:
            self.available_alert_group = m.get('AvailableAlertGroup')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGtmAvailableAlertGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmAvailableAlertGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmAvailableAlertGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        need_detail_attributes: bool = None,
    ):
        # The ID of the GTM instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language of the values of specific response parameters.
        self.lang = lang
        # Specifies whether additional information is required. Default value: **false**. If the value is **true**, the AccessStrategyNum and AddressPoolNum parameters are returned.
        self.need_detail_attributes = need_detail_attributes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.need_detail_attributes is not None:
            result['NeedDetailAttributes'] = self.need_detail_attributes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NeedDetailAttributes') is not None:
            self.need_detail_attributes = m.get('NeedDetailAttributes')
        return self


class DescribeGtmInstanceResponseBody(TeaModel):
    def __init__(
        self,
        access_strategy_num: int = None,
        address_pool_num: int = None,
        alert_group: str = None,
        cname: str = None,
        cname_mode: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        expire_time: str = None,
        expire_timestamp: int = None,
        instance_id: str = None,
        instance_name: str = None,
        lba_strategy: str = None,
        request_id: str = None,
        resource_group_id: str = None,
        ttl: int = None,
        user_domain_name: str = None,
        version_code: str = None,
    ):
        # The number of access policies of the GTM instance.
        self.access_strategy_num = access_strategy_num
        # The number of address pools of the GTM instance.
        self.address_pool_num = address_pool_num
        # The alert group of the GTM instance.
        self.alert_group = alert_group
        # The domain name of the GTM instance to which the service domain name is mapped by using a CNAME record.
        self.cname = cname
        # Indicates whether the CNAME is a custom domain name or is assigned by the system. Valid values:
        # 
        # *   **SYSTEM_ASSIGN**\
        # *   **CUSTOM**\
        self.cname_mode = cname_mode
        # The time when the GTM instance was created.
        self.create_time = create_time
        # The timestamp that indicates the time when the GTM instance was created.
        self.create_timestamp = create_timestamp
        # The time when the GTM instance expires.
        self.expire_time = expire_time
        # The timestamp that indicates the time when the GTM instance expires.
        self.expire_timestamp = expire_timestamp
        # The ID of the GTM instance.
        self.instance_id = instance_id
        # The name of the GTM instance.
        self.instance_name = instance_name
        # The load balancing policy. Valid values:
        # 
        # *   **ALL_RR**: round robin
        # *   **RATIO**: weighted round-robin
        self.lba_strategy = lba_strategy
        # The ID of the request.
        self.request_id = request_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The global time to live (TTL).
        self.ttl = ttl
        # The domain name of the application.
        self.user_domain_name = user_domain_name
        # The version code.
        self.version_code = version_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_strategy_num is not None:
            result['AccessStrategyNum'] = self.access_strategy_num
        if self.address_pool_num is not None:
            result['AddressPoolNum'] = self.address_pool_num
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.cname is not None:
            result['Cname'] = self.cname
        if self.cname_mode is not None:
            result['CnameMode'] = self.cname_mode
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.expire_timestamp is not None:
            result['ExpireTimestamp'] = self.expire_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.lba_strategy is not None:
            result['LbaStrategy'] = self.lba_strategy
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.user_domain_name is not None:
            result['UserDomainName'] = self.user_domain_name
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessStrategyNum') is not None:
            self.access_strategy_num = m.get('AccessStrategyNum')
        if m.get('AddressPoolNum') is not None:
            self.address_pool_num = m.get('AddressPoolNum')
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('Cname') is not None:
            self.cname = m.get('Cname')
        if m.get('CnameMode') is not None:
            self.cname_mode = m.get('CnameMode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ExpireTimestamp') is not None:
            self.expire_timestamp = m.get('ExpireTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('LbaStrategy') is not None:
            self.lba_strategy = m.get('LbaStrategy')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('UserDomainName') is not None:
            self.user_domain_name = m.get('UserDomainName')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeGtmInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmInstanceAddressPoolRequest(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        lang: str = None,
    ):
        # The ID of the address pool that you want to query.
        # 
        # This parameter is required.
        self.addr_pool_id = addr_pool_id
        # The language used by the user.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr(TeaModel):
    def __init__(
        self,
        addr_id: int = None,
        alert_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        lba_weight: int = None,
        mode: str = None,
        update_time: str = None,
        update_timestamp: int = None,
        value: str = None,
    ):
        # The ID of the address.
        self.addr_id = addr_id
        # Indicates whether health check was enabled for the address. Valid values:
        # 
        # *   **OK**: Normal
        # *   **ALERT**: Alert
        self.alert_status = alert_status
        # The time when the address pool was created.
        self.create_time = create_time
        self.create_timestamp = create_timestamp
        # The weight of the address.
        self.lba_weight = lba_weight
        # The mode of the address. Valid values:
        # 
        # *   **SMART**: Intelligent return
        # *   **ONLINE**: Always online
        # *   **OFFLINE**: Always offline
        self.mode = mode
        # The last time when the address was updated.
        self.update_time = update_time
        # A timestamp that indicates the last time when the address was updated.
        self.update_timestamp = update_timestamp
        # The address.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_id is not None:
            result['AddrId'] = self.addr_id
        if self.alert_status is not None:
            result['AlertStatus'] = self.alert_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrId') is not None:
            self.addr_id = m.get('AddrId')
        if m.get('AlertStatus') is not None:
            self.alert_status = m.get('AlertStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeGtmInstanceAddressPoolResponseBodyAddrs(TeaModel):
    def __init__(
        self,
        addr: List[DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr] = None,
    ):
        self.addr = addr

    def validate(self):
        if self.addr:
            for k in self.addr:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addr'] = []
        if self.addr is not None:
            for k in self.addr:
                result['Addr'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr = []
        if m.get('Addr') is not None:
            for k in m.get('Addr'):
                temp_model = DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr()
                self.addr.append(temp_model.from_map(k))
        return self


class DescribeGtmInstanceAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        addr_pool_id: str = None,
        addrs: DescribeGtmInstanceAddressPoolResponseBodyAddrs = None,
        create_time: str = None,
        create_timestamp: int = None,
        min_available_addr_num: int = None,
        monitor_config_id: str = None,
        monitor_status: str = None,
        name: str = None,
        request_id: str = None,
        status: str = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The number of addresses in the address pool queried.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.addr_pool_id = addr_pool_id
        # The addresses in the address pool.
        self.addrs = addrs
        # The time when the address pool was created.
        self.create_time = create_time
        self.create_timestamp = create_timestamp
        # The minimum number of available addresses in the address pool.
        self.min_available_addr_num = min_available_addr_num
        # The health check ID of the address pool.
        self.monitor_config_id = monitor_config_id
        # Indicates whether health check was enabled for the address pool. Valid values:
        # 
        # *   **OPEN**: Enabled
        # *   **CLOSE**: Disabled
        # *   **UNCONFIGURED**: Not configured
        self.monitor_status = monitor_status
        # The name of the address pool.
        self.name = name
        # The ID of the request.
        self.request_id = request_id
        # The availability status of the address pool. Valid values:
        # 
        # *   **AVAILABLE**: Available
        # *   **NOT_AVAILABLE**: Unavailable
        self.status = status
        # The type of the address pool. Valid values:
        # 
        # *   **IP**: IP address
        # *   **DOMAIN**: Domain name
        self.type = type
        # The last time when the address pool was updated.
        self.update_time = update_time
        # A timestamp that indicates the last time the address pool was updated.
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.addrs:
            self.addrs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.addrs is not None:
            result['Addrs'] = self.addrs.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.min_available_addr_num is not None:
            result['MinAvailableAddrNum'] = self.min_available_addr_num
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Addrs') is not None:
            temp_model = DescribeGtmInstanceAddressPoolResponseBodyAddrs()
            self.addrs = temp_model.from_map(m['Addrs'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('MinAvailableAddrNum') is not None:
            self.min_available_addr_num = m.get('MinAvailableAddrNum')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeGtmInstanceAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmInstanceAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmInstanceAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmInstanceAddressPoolsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the GTM instance that you want to query.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language used by the user.
        self.lang = lang
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return per page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool(TeaModel):
    def __init__(
        self,
        addr_count: int = None,
        addr_pool_id: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        min_available_addr_num: int = None,
        monitor_config_id: str = None,
        monitor_status: str = None,
        name: str = None,
        status: str = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The number of addresses in the address pool.
        self.addr_count = addr_count
        # The ID of the address pool.
        self.addr_pool_id = addr_pool_id
        # The time when this address pool was created.
        self.create_time = create_time
        self.create_timestamp = create_timestamp
        # The minimum number of available addresses in the address pool.
        self.min_available_addr_num = min_available_addr_num
        # The health check ID of the address pool.
        self.monitor_config_id = monitor_config_id
        # Indicates whether health check was enabled for the address pool. Valid values:
        # 
        # *   **OPEN**: Enabled
        # *   **CLOSE**: Disabled
        # *   **UNCONFIGURED**: Not configured
        self.monitor_status = monitor_status
        # The name of the address pool.
        self.name = name
        # The availability status of the address pool. Valid values:
        # 
        # *   **AVAILABLE**: Available
        # *   **NOT_AVAILABLE**: Unavailable
        self.status = status
        # The type of the address pool. Valid values:
        # 
        # *   **IP**: IP address
        # *   **DOMAIN**: Domain name
        self.type = type
        # The last time when the address pool was updated.
        self.update_time = update_time
        # A timestamp that indicates the last time the address pool was updated.
        self.update_timestamp = update_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_count is not None:
            result['AddrCount'] = self.addr_count
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.min_available_addr_num is not None:
            result['MinAvailableAddrNum'] = self.min_available_addr_num
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrCount') is not None:
            self.addr_count = m.get('AddrCount')
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('MinAvailableAddrNum') is not None:
            self.min_available_addr_num = m.get('MinAvailableAddrNum')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeGtmInstanceAddressPoolsResponseBodyAddrPools(TeaModel):
    def __init__(
        self,
        addr_pool: List[DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool] = None,
    ):
        self.addr_pool = addr_pool

    def validate(self):
        if self.addr_pool:
            for k in self.addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddrPool'] = []
        if self.addr_pool is not None:
            for k in self.addr_pool:
                result['AddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr_pool = []
        if m.get('AddrPool') is not None:
            for k in m.get('AddrPool'):
                temp_model = DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool()
                self.addr_pool.append(temp_model.from_map(k))
        return self


class DescribeGtmInstanceAddressPoolsResponseBody(TeaModel):
    def __init__(
        self,
        addr_pools: DescribeGtmInstanceAddressPoolsResponseBodyAddrPools = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The returned list of address pools of the GTM instance.
        self.addr_pools = addr_pools
        # The number of the page returned.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned on all pages.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.addr_pools:
            self.addr_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pools is not None:
            result['AddrPools'] = self.addr_pools.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPools') is not None:
            temp_model = DescribeGtmInstanceAddressPoolsResponseBodyAddrPools()
            self.addr_pools = temp_model.from_map(m['AddrPools'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeGtmInstanceAddressPoolsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmInstanceAddressPoolsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmInstanceAddressPoolsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmInstanceStatusRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
    ):
        # The instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeGtmInstanceStatusResponseBody(TeaModel):
    def __init__(
        self,
        addr_not_available_num: int = None,
        addr_pool_not_available_num: int = None,
        request_id: str = None,
        status: str = None,
        status_reason: str = None,
        strategy_not_available_num: int = None,
        switch_to_failover_strategy_num: int = None,
    ):
        # The number of unavailable addresses.
        self.addr_not_available_num = addr_not_available_num
        # The number of unavailable address pools.
        self.addr_pool_not_available_num = addr_pool_not_available_num
        # The request ID.
        self.request_id = request_id
        # The state of the instance. Valid values:
        # 
        # *   ALLOW: The operation on the instance is allowed.
        # *   DENY: The operation on the instance is not allowed.
        self.status = status
        # The reasons why the instance is in the current state. Valid values:
        # 
        # *   INSTANCE_OPERATE_BLACK_LIST: The operation on the instance is not allowed.
        # *   BETA_INSTANCE: The instance is in public preview.
        self.status_reason = status_reason
        # The number of unavailable access policies.
        self.strategy_not_available_num = strategy_not_available_num
        # The number of access policies switched to the secondary address pool.
        self.switch_to_failover_strategy_num = switch_to_failover_strategy_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_not_available_num is not None:
            result['AddrNotAvailableNum'] = self.addr_not_available_num
        if self.addr_pool_not_available_num is not None:
            result['AddrPoolNotAvailableNum'] = self.addr_pool_not_available_num
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.status_reason is not None:
            result['StatusReason'] = self.status_reason
        if self.strategy_not_available_num is not None:
            result['StrategyNotAvailableNum'] = self.strategy_not_available_num
        if self.switch_to_failover_strategy_num is not None:
            result['SwitchToFailoverStrategyNum'] = self.switch_to_failover_strategy_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrNotAvailableNum') is not None:
            self.addr_not_available_num = m.get('AddrNotAvailableNum')
        if m.get('AddrPoolNotAvailableNum') is not None:
            self.addr_pool_not_available_num = m.get('AddrPoolNotAvailableNum')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusReason') is not None:
            self.status_reason = m.get('StatusReason')
        if m.get('StrategyNotAvailableNum') is not None:
            self.strategy_not_available_num = m.get('StrategyNotAvailableNum')
        if m.get('SwitchToFailoverStrategyNum') is not None:
            self.switch_to_failover_strategy_num = m.get('SwitchToFailoverStrategyNum')
        return self


class DescribeGtmInstanceStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmInstanceStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmInstanceStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmInstanceSystemCnameRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
    ):
        # The ID of the Global Traffic Manager (GTM) instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language used by the user.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeGtmInstanceSystemCnameResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        system_cname: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The CNAME record assigned by the system.
        self.system_cname = system_cname

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.system_cname is not None:
            result['SystemCname'] = self.system_cname
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SystemCname') is not None:
            self.system_cname = m.get('SystemCname')
        return self


class DescribeGtmInstanceSystemCnameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmInstanceSystemCnameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmInstanceSystemCnameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmInstancesRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        lang: str = None,
        need_detail_attributes: bool = None,
        page_number: int = None,
        page_size: int = None,
        resource_group_id: str = None,
    ):
        # The keyword that you use for query. Exact match is supported by instance ID or instance name.
        self.keyword = keyword
        # The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
        self.lang = lang
        # Specifies whether additional information is required. Default value: **false**.
        self.need_detail_attributes = need_detail_attributes
        # The page number to return.
        self.page_number = page_number
        # The number of entries to return per page.
        self.page_size = page_size
        # The ID of the resource group.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.need_detail_attributes is not None:
            result['NeedDetailAttributes'] = self.need_detail_attributes
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NeedDetailAttributes') is not None:
            self.need_detail_attributes = m.get('NeedDetailAttributes')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance(TeaModel):
    def __init__(
        self,
        access_strategy_num: int = None,
        address_pool_num: int = None,
        alert_group: str = None,
        cname: str = None,
        cname_mode: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        expire_time: str = None,
        expire_timestamp: int = None,
        instance_id: str = None,
        instance_name: str = None,
        lba_strategy: str = None,
        resource_group_id: str = None,
        ttl: int = None,
        user_domain_name: str = None,
        version_code: str = None,
    ):
        # The number of access policies.
        self.access_strategy_num = access_strategy_num
        # The number of address pools.
        self.address_pool_num = address_pool_num
        # The name of the alert group.
        self.alert_group = alert_group
        # The CNAME domain name that is used to access the instance.
        self.cname = cname
        # The CNAME domain name used to access the instance. Valid values:
        # 
        # *   **SYSTEM_ASSIGN**: A CNAME domain name assigned by the system is used.
        # *   **CUSTOM**: A custom CNAME domain name is used.
        self.cname_mode = cname_mode
        # The time when the instance was created.
        self.create_time = create_time
        # The UNIX timestamp that indicates when the instance was created.
        self.create_timestamp = create_timestamp
        # The time when the instance expires.
        self.expire_time = expire_time
        # The UNIX timestamp that indicates when the instance expires.
        self.expire_timestamp = expire_timestamp
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the instance.
        self.instance_name = instance_name
        # The load balancing policy that is used. Valid values:
        # 
        # *   **ALL_RR**: Load balancing
        # *   **RATIO**: Weighted round-robin
        self.lba_strategy = lba_strategy
        # The ID of the resource group to which the instance belongs.
        self.resource_group_id = resource_group_id
        # The global time to live (TTL).
        self.ttl = ttl
        # The domain name of the user.
        self.user_domain_name = user_domain_name
        # The version code of the instance.
        self.version_code = version_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_strategy_num is not None:
            result['AccessStrategyNum'] = self.access_strategy_num
        if self.address_pool_num is not None:
            result['AddressPoolNum'] = self.address_pool_num
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.cname is not None:
            result['Cname'] = self.cname
        if self.cname_mode is not None:
            result['CnameMode'] = self.cname_mode
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.expire_timestamp is not None:
            result['ExpireTimestamp'] = self.expire_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.lba_strategy is not None:
            result['LbaStrategy'] = self.lba_strategy
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.user_domain_name is not None:
            result['UserDomainName'] = self.user_domain_name
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessStrategyNum') is not None:
            self.access_strategy_num = m.get('AccessStrategyNum')
        if m.get('AddressPoolNum') is not None:
            self.address_pool_num = m.get('AddressPoolNum')
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('Cname') is not None:
            self.cname = m.get('Cname')
        if m.get('CnameMode') is not None:
            self.cname_mode = m.get('CnameMode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ExpireTimestamp') is not None:
            self.expire_timestamp = m.get('ExpireTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('LbaStrategy') is not None:
            self.lba_strategy = m.get('LbaStrategy')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('UserDomainName') is not None:
            self.user_domain_name = m.get('UserDomainName')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeGtmInstancesResponseBodyGtmInstances(TeaModel):
    def __init__(
        self,
        gtm_instance: List[DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance] = None,
    ):
        self.gtm_instance = gtm_instance

    def validate(self):
        if self.gtm_instance:
            for k in self.gtm_instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GtmInstance'] = []
        if self.gtm_instance is not None:
            for k in self.gtm_instance:
                result['GtmInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.gtm_instance = []
        if m.get('GtmInstance') is not None:
            for k in m.get('GtmInstance'):
                temp_model = DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance()
                self.gtm_instance.append(temp_model.from_map(k))
        return self


class DescribeGtmInstancesResponseBody(TeaModel):
    def __init__(
        self,
        gtm_instances: DescribeGtmInstancesResponseBodyGtmInstances = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The list of queried instances.
        self.gtm_instances = gtm_instances
        # The returned page number.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.gtm_instances:
            self.gtm_instances.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gtm_instances is not None:
            result['GtmInstances'] = self.gtm_instances.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GtmInstances') is not None:
            temp_model = DescribeGtmInstancesResponseBodyGtmInstances()
            self.gtm_instances = temp_model.from_map(m['GtmInstances'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeGtmInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmLogsRequest(TeaModel):
    def __init__(
        self,
        end_timestamp: int = None,
        instance_id: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_timestamp: int = None,
    ):
        # The timestamp that specifies the end of the time range to query.
        self.end_timestamp = end_timestamp
        # The ID of the GTM instance whose logs you want to query.
        self.instance_id = instance_id
        # The keyword for searching logs, in case-insensitive "%Keyword%" format.
        self.keyword = keyword
        # The language used by the user.
        self.lang = lang
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size
        # The beginning of the time range to query.
        self.start_timestamp = start_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_timestamp is not None:
            result['EndTimestamp'] = self.end_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTimestamp') is not None:
            self.end_timestamp = m.get('EndTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        return self


class DescribeGtmLogsResponseBodyLogsLog(TeaModel):
    def __init__(
        self,
        content: str = None,
        entity_id: str = None,
        entity_name: str = None,
        entity_type: str = None,
        id: int = None,
        oper_action: str = None,
        oper_ip: str = None,
        oper_time: str = None,
        oper_timestamp: int = None,
    ):
        # The formatted message content.
        self.content = content
        # The ID of the object that was operated on.
        self.entity_id = entity_id
        # The name of the object that was operated on.
        self.entity_name = entity_name
        # The type of the object that was operated on.
        self.entity_type = entity_type
        # The ID of the log record.
        self.id = id
        # The operation performed.
        self.oper_action = oper_action
        # The IP address subject to the operation.
        self.oper_ip = oper_ip
        # The time when the operation was performed.
        self.oper_time = oper_time
        # A timestamp that indicates the time when the operation was performed.
        self.oper_timestamp = oper_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.entity_name is not None:
            result['EntityName'] = self.entity_name
        if self.entity_type is not None:
            result['EntityType'] = self.entity_type
        if self.id is not None:
            result['Id'] = self.id
        if self.oper_action is not None:
            result['OperAction'] = self.oper_action
        if self.oper_ip is not None:
            result['OperIp'] = self.oper_ip
        if self.oper_time is not None:
            result['OperTime'] = self.oper_time
        if self.oper_timestamp is not None:
            result['OperTimestamp'] = self.oper_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('EntityName') is not None:
            self.entity_name = m.get('EntityName')
        if m.get('EntityType') is not None:
            self.entity_type = m.get('EntityType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('OperAction') is not None:
            self.oper_action = m.get('OperAction')
        if m.get('OperIp') is not None:
            self.oper_ip = m.get('OperIp')
        if m.get('OperTime') is not None:
            self.oper_time = m.get('OperTime')
        if m.get('OperTimestamp') is not None:
            self.oper_timestamp = m.get('OperTimestamp')
        return self


class DescribeGtmLogsResponseBodyLogs(TeaModel):
    def __init__(
        self,
        log: List[DescribeGtmLogsResponseBodyLogsLog] = None,
    ):
        self.log = log

    def validate(self):
        if self.log:
            for k in self.log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Log'] = []
        if self.log is not None:
            for k in self.log:
                result['Log'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log = []
        if m.get('Log') is not None:
            for k in m.get('Log'):
                temp_model = DescribeGtmLogsResponseBodyLogsLog()
                self.log.append(temp_model.from_map(k))
        return self


class DescribeGtmLogsResponseBody(TeaModel):
    def __init__(
        self,
        logs: DescribeGtmLogsResponseBodyLogs = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The list of logs returned.
        self.logs = logs
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned on all pages.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.logs:
            self.logs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logs is not None:
            result['Logs'] = self.logs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logs') is not None:
            temp_model = DescribeGtmLogsResponseBodyLogs()
            self.logs = temp_model.from_map(m['Logs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeGtmLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmMonitorAvailableConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        # The language of the values of specific response parameters.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        default_selected: bool = None,
        group_name: str = None,
        group_type: str = None,
        isp_code: str = None,
        isp_name: str = None,
        mainland: bool = None,
    ):
        # The code of the city where the monitored node is deployed.
        self.city_code = city_code
        # The display name of the city where the monitored node is deployed.
        self.city_name = city_name
        # Indicates whether the monitored node is selected for the health check by default.
        self.default_selected = default_selected
        # The name of the group to which the monitored node belongs.
        # 
        # Valid values: Overseas Nodes, BGP Nodes, and ISP Nodes.
        self.group_name = group_name
        # The type of the group to which the monitored node belongs.
        # 
        # Valid values: BGP, OVERSEAS, and ISP.
        self.group_type = group_type
        # The code of the Internet service provider (ISP) to which the monitored node belongs.
        # 
        # *   If the value of the GroupType parameter is BGP or OVERSEAS, the value of IspCode is 465 by default.
        # *   If the value of the GroupType parameter is not BGP or OVERSEAS, valid values of IspCode are 232, 132, and 5. and is used together with CityCode.
        self.isp_code = isp_code
        # The display name of the ISP to which the monitored node belongs.
        self.isp_name = isp_name
        # Indicates whether the monitored node is deployed in the Chinese mainland.
        self.mainland = mainland

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.default_selected is not None:
            result['DefaultSelected'] = self.default_selected
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        if self.mainland is not None:
            result['Mainland'] = self.mainland
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('DefaultSelected') is not None:
            self.default_selected = m.get('DefaultSelected')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        if m.get('Mainland') is not None:
            self.mainland = m.get('Mainland')
        return self


class DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes(TeaModel):
    def __init__(
        self,
        isp_city_node: List[DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode] = None,
    ):
        self.isp_city_node = isp_city_node

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        return self


class DescribeGtmMonitorAvailableConfigResponseBody(TeaModel):
    def __init__(
        self,
        isp_city_nodes: DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes = None,
        request_id: str = None,
    ):
        # The monitored nodes.
        self.isp_city_nodes = isp_city_nodes
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.isp_city_nodes:
            self.isp_city_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.isp_city_nodes is not None:
            result['IspCityNodes'] = self.isp_city_nodes.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IspCityNodes') is not None:
            temp_model = DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes()
            self.isp_city_nodes = temp_model.from_map(m['IspCityNodes'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGtmMonitorAvailableConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmMonitorAvailableConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmMonitorAvailableConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmMonitorConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        monitor_config_id: str = None,
    ):
        # The language of the values of specific response parameters.
        self.lang = lang
        # The ID of the health check configuration.
        # 
        # This parameter is required.
        self.monitor_config_id = monitor_config_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        return self


class DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        country_code: str = None,
        country_name: str = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        # The code of the city where the monitored node is deployed.
        self.city_code = city_code
        # The display name of the city where the monitored node is deployed.
        self.city_name = city_name
        # The code of the country where the monitored node is deployed.
        self.country_code = country_code
        # The display name of the country where the monitored node is deployed.
        self.country_name = country_name
        # The code of the Internet service provider (ISP) to which the monitored node belongs.
        self.isp_code = isp_code
        # The display name of the ISP to which the monitored node belongs.
        self.isp_name = isp_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.country_code is not None:
            result['CountryCode'] = self.country_code
        if self.country_name is not None:
            result['CountryName'] = self.country_name
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('CountryCode') is not None:
            self.country_code = m.get('CountryCode')
        if m.get('CountryName') is not None:
            self.country_name = m.get('CountryName')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class DescribeGtmMonitorConfigResponseBodyIspCityNodes(TeaModel):
    def __init__(
        self,
        isp_city_node: List[DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode] = None,
    ):
        self.isp_city_node = isp_city_node

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        return self


class DescribeGtmMonitorConfigResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        evaluation_count: int = None,
        interval: int = None,
        isp_city_nodes: DescribeGtmMonitorConfigResponseBodyIspCityNodes = None,
        monitor_config_id: str = None,
        monitor_extend_info: str = None,
        protocol_type: str = None,
        request_id: str = None,
        timeout: int = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The time when the health check configuration was created.
        self.create_time = create_time
        # The timestamp that indicates the time when the health check configuration was created.
        self.create_timestamp = create_timestamp
        # The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
        self.evaluation_count = evaluation_count
        # The health check interval. Unit: seconds. The value is 60.
        self.interval = interval
        # The monitored nodes.
        self.isp_city_nodes = isp_city_nodes
        # The ID of the health check configuration.
        self.monitor_config_id = monitor_config_id
        # The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
        # 
        # HTTP or HTTPS:
        # 
        # *   port: the port to check.
        # *   failureRate: the failure rate.
        # *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
        # *   host: the host configuration.
        # *   path: the health check URL.
        # 
        # PING:
        # 
        # *   packetNum: the number of ping packets.
        # *   packetLossRate: the loss rate of ping packets.
        # *   failureRate: the failure rate.
        # 
        # TCP:
        # 
        # *   port: the port to check.
        # *   failureRate: the failure rate.
        self.monitor_extend_info = monitor_extend_info
        # The protocol used for the health check.
        self.protocol_type = protocol_type
        # The ID of the request.
        self.request_id = request_id
        # The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
        self.timeout = timeout
        # The time when the health check configuration was last updated.
        self.update_time = update_time
        # The timestamp that indicates the time when the health check configuration was last updated.
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.isp_city_nodes:
            self.isp_city_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_city_nodes is not None:
            result['IspCityNodes'] = self.isp_city_nodes.to_map()
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.monitor_extend_info is not None:
            result['MonitorExtendInfo'] = self.monitor_extend_info
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspCityNodes') is not None:
            temp_model = DescribeGtmMonitorConfigResponseBodyIspCityNodes()
            self.isp_city_nodes = temp_model.from_map(m['IspCityNodes'])
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('MonitorExtendInfo') is not None:
            self.monitor_extend_info = m.get('MonitorExtendInfo')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeGtmMonitorConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmMonitorConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmMonitorConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmRecoveryPlanRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        recovery_plan_id: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang
        # The ID of the disaster recovery plan.
        # 
        # This parameter is required.
        self.recovery_plan_id = recovery_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        return self


class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr(TeaModel):
    def __init__(
        self,
        id: int = None,
        mode: str = None,
        value: str = None,
    ):
        # The address ID.
        self.id = id
        # The address mode.
        self.mode = mode
        # The address.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs(TeaModel):
    def __init__(
        self,
        addr: List[DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr] = None,
    ):
        self.addr = addr

    def validate(self):
        if self.addr:
            for k in self.addr:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addr'] = []
        if self.addr is not None:
            for k in self.addr:
                result['Addr'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr = []
        if m.get('Addr') is not None:
            for k in m.get('Addr'):
                temp_model = DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr()
                self.addr.append(temp_model.from_map(k))
        return self


class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        addr_pool_name: str = None,
        addrs: DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs = None,
        instance_id: str = None,
    ):
        # The address pool ID.
        self.addr_pool_id = addr_pool_id
        # The address pool name.
        self.addr_pool_name = addr_pool_name
        self.addrs = addrs
        # The instance ID.
        self.instance_id = instance_id

    def validate(self):
        if self.addrs:
            self.addrs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.addr_pool_name is not None:
            result['AddrPoolName'] = self.addr_pool_name
        if self.addrs is not None:
            result['Addrs'] = self.addrs.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('AddrPoolName') is not None:
            self.addr_pool_name = m.get('AddrPoolName')
        if m.get('Addrs') is not None:
            temp_model = DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs()
            self.addrs = temp_model.from_map(m['Addrs'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeGtmRecoveryPlanResponseBodyFaultAddrPools(TeaModel):
    def __init__(
        self,
        fault_addr_pool: List[DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool] = None,
    ):
        self.fault_addr_pool = fault_addr_pool

    def validate(self):
        if self.fault_addr_pool:
            for k in self.fault_addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FaultAddrPool'] = []
        if self.fault_addr_pool is not None:
            for k in self.fault_addr_pool:
                result['FaultAddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fault_addr_pool = []
        if m.get('FaultAddrPool') is not None:
            for k in m.get('FaultAddrPool'):
                temp_model = DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool()
                self.fault_addr_pool.append(temp_model.from_map(k))
        return self


class DescribeGtmRecoveryPlanResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        fault_addr_pool_num: int = None,
        fault_addr_pools: DescribeGtmRecoveryPlanResponseBodyFaultAddrPools = None,
        last_execute_time: str = None,
        last_execute_timestamp: int = None,
        last_rollback_time: str = None,
        last_rollback_timestamp: int = None,
        name: str = None,
        recovery_plan_id: int = None,
        remark: str = None,
        request_id: str = None,
        status: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The time when the disaster recovery plan was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the disaster recovery plan was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_timestamp = create_timestamp
        # The number of faulty address pools.
        self.fault_addr_pool_num = fault_addr_pool_num
        # The faulty address pools.
        self.fault_addr_pools = fault_addr_pools
        # The time when the disaster recovery plan was last executed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
        self.last_execute_time = last_execute_time
        # The time when the disaster recovery plan was last executed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.last_execute_timestamp = last_execute_timestamp
        # The time when the disaster recovery plan was last rolled back. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.last_rollback_time = last_rollback_time
        # The time when the disaster recovery plan was last rolled back. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.last_rollback_timestamp = last_rollback_timestamp
        # The name of the disaster recovery plan.
        self.name = name
        # The ID of the disaster recovery plan.
        self.recovery_plan_id = recovery_plan_id
        # The description of the disaster recovery plan.
        self.remark = remark
        # The request ID.
        self.request_id = request_id
        # The status of the disaster recovery plan.
        self.status = status
        # The time when the disaster recovery plan was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
        self.update_time = update_time
        # The time when the disaster recovery plan was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.fault_addr_pools:
            self.fault_addr_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.fault_addr_pool_num is not None:
            result['FaultAddrPoolNum'] = self.fault_addr_pool_num
        if self.fault_addr_pools is not None:
            result['FaultAddrPools'] = self.fault_addr_pools.to_map()
        if self.last_execute_time is not None:
            result['LastExecuteTime'] = self.last_execute_time
        if self.last_execute_timestamp is not None:
            result['LastExecuteTimestamp'] = self.last_execute_timestamp
        if self.last_rollback_time is not None:
            result['LastRollbackTime'] = self.last_rollback_time
        if self.last_rollback_timestamp is not None:
            result['LastRollbackTimestamp'] = self.last_rollback_timestamp
        if self.name is not None:
            result['Name'] = self.name
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('FaultAddrPoolNum') is not None:
            self.fault_addr_pool_num = m.get('FaultAddrPoolNum')
        if m.get('FaultAddrPools') is not None:
            temp_model = DescribeGtmRecoveryPlanResponseBodyFaultAddrPools()
            self.fault_addr_pools = temp_model.from_map(m['FaultAddrPools'])
        if m.get('LastExecuteTime') is not None:
            self.last_execute_time = m.get('LastExecuteTime')
        if m.get('LastExecuteTimestamp') is not None:
            self.last_execute_timestamp = m.get('LastExecuteTimestamp')
        if m.get('LastRollbackTime') is not None:
            self.last_rollback_time = m.get('LastRollbackTime')
        if m.get('LastRollbackTimestamp') is not None:
            self.last_rollback_timestamp = m.get('LastRollbackTimestamp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeGtmRecoveryPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmRecoveryPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmRecoveryPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmRecoveryPlanAvailableConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        # The language in which the returned results are displayed. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool(TeaModel):
    def __init__(
        self,
        addr_pool_id: str = None,
        name: str = None,
    ):
        # The address pool ID.
        self.addr_pool_id = addr_pool_id
        # The name of the address pool.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools(TeaModel):
    def __init__(
        self,
        addr_pool: List[DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool] = None,
    ):
        self.addr_pool = addr_pool

    def validate(self):
        if self.addr_pool:
            for k in self.addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddrPool'] = []
        if self.addr_pool is not None:
            for k in self.addr_pool:
                result['AddrPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr_pool = []
        if m.get('AddrPool') is not None:
            for k in m.get('AddrPool'):
                temp_model = DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool()
                self.addr_pool.append(temp_model.from_map(k))
        return self


class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance(TeaModel):
    def __init__(
        self,
        addr_pools: DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools = None,
        instance_id: str = None,
        instance_name: str = None,
    ):
        # The address pools.
        self.addr_pools = addr_pools
        # The instance ID.
        self.instance_id = instance_id
        # The instance name.
        self.instance_name = instance_name

    def validate(self):
        if self.addr_pools:
            self.addr_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr_pools is not None:
            result['AddrPools'] = self.addr_pools.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddrPools') is not None:
            temp_model = DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools()
            self.addr_pools = temp_model.from_map(m['AddrPools'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        return self


class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances(TeaModel):
    def __init__(
        self,
        instance: List[DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class DescribeGtmRecoveryPlanAvailableConfigResponseBody(TeaModel):
    def __init__(
        self,
        instances: DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances = None,
        request_id: str = None,
    ):
        # The instances.
        self.instances = instances
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Instances') is not None:
            temp_model = DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeGtmRecoveryPlanAvailableConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmRecoveryPlanAvailableConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmRecoveryPlanAvailableConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGtmRecoveryPlansRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The keyword for the query. Fuzzy match is supported by disaster recovery plan name.
        self.keyword = keyword
        # The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
        self.lang = lang
        # The page number to return. The page number starts from **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return per page. Maximum value: **100**. Default value: **20**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        fault_addr_pool_num: int = None,
        last_execute_time: str = None,
        last_execute_timestamp: int = None,
        last_rollback_time: str = None,
        last_rollback_timestamp: int = None,
        name: str = None,
        recovery_plan_id: int = None,
        remark: str = None,
        status: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # The time when the disaster recovery plan was created.
        self.create_time = create_time
        # The UNIX timestamp that indicates when the disaster recovery plan was created.
        self.create_timestamp = create_timestamp
        # The number of faulty address pools.
        self.fault_addr_pool_num = fault_addr_pool_num
        # The last time when the disaster recovery plan was executed.
        self.last_execute_time = last_execute_time
        # The UNIX timestamp that indicates the last time when the disaster recovery plan was executed.
        self.last_execute_timestamp = last_execute_timestamp
        # The last time when the disaster recovery plan was rolled back.
        self.last_rollback_time = last_rollback_time
        # The UNIX timestamp that indicates the last time when the disaster recovery plan was rolled back.
        self.last_rollback_timestamp = last_rollback_timestamp
        # The name of the disaster recovery plan.
        self.name = name
        # The ID of the disaster recovery plan.
        self.recovery_plan_id = recovery_plan_id
        # The remarks about the disaster recovery plan.
        self.remark = remark
        # The status of the disaster recovery plan. Valid values:
        # 
        # *   **UNEXECUTED**: The plan is not executed.
        # *   **EXECUTED**: The plan is executed.
        # *   **ROLLED_BACK**: The plan is rolled back.
        self.status = status
        # The last time when the disaster recovery plan was updated.
        self.update_time = update_time
        # The UNIX timestamp that indicates the last time when the disaster recovery plan was updated.
        self.update_timestamp = update_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.fault_addr_pool_num is not None:
            result['FaultAddrPoolNum'] = self.fault_addr_pool_num
        if self.last_execute_time is not None:
            result['LastExecuteTime'] = self.last_execute_time
        if self.last_execute_timestamp is not None:
            result['LastExecuteTimestamp'] = self.last_execute_timestamp
        if self.last_rollback_time is not None:
            result['LastRollbackTime'] = self.last_rollback_time
        if self.last_rollback_timestamp is not None:
            result['LastRollbackTimestamp'] = self.last_rollback_timestamp
        if self.name is not None:
            result['Name'] = self.name
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('FaultAddrPoolNum') is not None:
            self.fault_addr_pool_num = m.get('FaultAddrPoolNum')
        if m.get('LastExecuteTime') is not None:
            self.last_execute_time = m.get('LastExecuteTime')
        if m.get('LastExecuteTimestamp') is not None:
            self.last_execute_timestamp = m.get('LastExecuteTimestamp')
        if m.get('LastRollbackTime') is not None:
            self.last_rollback_time = m.get('LastRollbackTime')
        if m.get('LastRollbackTimestamp') is not None:
            self.last_rollback_timestamp = m.get('LastRollbackTimestamp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class DescribeGtmRecoveryPlansResponseBodyRecoveryPlans(TeaModel):
    def __init__(
        self,
        recovery_plan: List[DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan] = None,
    ):
        self.recovery_plan = recovery_plan

    def validate(self):
        if self.recovery_plan:
            for k in self.recovery_plan:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecoveryPlan'] = []
        if self.recovery_plan is not None:
            for k in self.recovery_plan:
                result['RecoveryPlan'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.recovery_plan = []
        if m.get('RecoveryPlan') is not None:
            for k in m.get('RecoveryPlan'):
                temp_model = DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan()
                self.recovery_plan.append(temp_model.from_map(k))
        return self


class DescribeGtmRecoveryPlansResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        recovery_plans: DescribeGtmRecoveryPlansResponseBodyRecoveryPlans = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The details about the queried disaster recovery plans.
        self.recovery_plans = recovery_plans
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.recovery_plans:
            self.recovery_plans.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.recovery_plans is not None:
            result['RecoveryPlans'] = self.recovery_plans.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RecoveryPlans') is not None:
            temp_model = DescribeGtmRecoveryPlansResponseBodyRecoveryPlans()
            self.recovery_plans = temp_model.from_map(m['RecoveryPlans'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeGtmRecoveryPlansResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGtmRecoveryPlansResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGtmRecoveryPlansResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceDomainsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the Alibaba Cloud Domain Name System (DNS) instance. You can call the [DescribeDomainInfo](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaininfo?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: English.
        self.lang = lang
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Valid values: 1 to 100. Default value: 20.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeInstanceDomainsResponseBodyInstanceDomains(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        domain_name: str = None,
    ):
        # The time when the instance was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_timestamp = create_timestamp
        # The domain name.
        self.domain_name = domain_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        return self


class DescribeInstanceDomainsResponseBody(TeaModel):
    def __init__(
        self,
        instance_domains: List[DescribeInstanceDomainsResponseBodyInstanceDomains] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The domain names that are bound to the DNS instance.
        self.instance_domains = instance_domains
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned on all pages.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.instance_domains:
            for k in self.instance_domains:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceDomains'] = []
        if self.instance_domains is not None:
            for k in self.instance_domains:
                result['InstanceDomains'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_domains = []
        if m.get('InstanceDomains') is not None:
            for k in m.get('InstanceDomains'):
                temp_model = DescribeInstanceDomainsResponseBodyInstanceDomains()
                self.instance_domains.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeInstanceDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInternetDnsLogsRequest(TeaModel):
    def __init__(
        self,
        account_id: int = None,
        domain_name: str = None,
        end_timestamp: int = None,
        lang: str = None,
        module: str = None,
        page_number: int = None,
        page_size: int = None,
        query_condition: str = None,
        recursion_protocol_type: str = None,
        start_timestamp: int = None,
    ):
        # The account ID displayed on the Recursive Resolution (Public DNS) page after you activate Alibaba Cloud Public DNS.
        self.account_id = account_id
        # The domain name.
        self.domain_name = domain_name
        # The end time of the query (timestamp, unit: milliseconds). >Warning: If the query time span is too large and the amount of resolution logs for the queried domain is excessive, it may lead to a query timeout or inaccurate query results.
        self.end_timestamp = end_timestamp
        # Return value language, options: 
        # - zh: Chinese 
        # - en: English
        # 
        # Default: en
        self.lang = lang
        # Module type 
        # - AUTHORITY (default): Public Authoritative DNS 
        # - RECURSION: Public Recursive DNS
        self.module = module
        # Page number, default value is 1.
        self.page_number = page_number
        # Page size for query.
        self.page_size = page_size
        # Query parameters 
        # - sourceIp: Source IP address 
        # - queryNameFuzzy: Domain name (fuzzy value) 
        # - queryType: Record type 
        # - value: Resolution result 
        # - status: Status 
        # - serverIp: Resolution server IP
        self.query_condition = query_condition
        self.recursion_protocol_type = recursion_protocol_type
        # The start time of the query (timestamp, unit: milliseconds).
        self.start_timestamp = start_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['AccountId'] = self.account_id
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_timestamp is not None:
            result['EndTimestamp'] = self.end_timestamp
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.module is not None:
            result['Module'] = self.module
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_condition is not None:
            result['QueryCondition'] = self.query_condition
        if self.recursion_protocol_type is not None:
            result['RecursionProtocolType'] = self.recursion_protocol_type
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountId') is not None:
            self.account_id = m.get('AccountId')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTimestamp') is not None:
            self.end_timestamp = m.get('EndTimestamp')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Module') is not None:
            self.module = m.get('Module')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryCondition') is not None:
            self.query_condition = m.get('QueryCondition')
        if m.get('RecursionProtocolType') is not None:
            self.recursion_protocol_type = m.get('RecursionProtocolType')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        return self


class DescribeInternetDnsLogsResponseBodyLogsLogValue(TeaModel):
    def __init__(
        self,
        value: List[str] = None,
    ):
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeInternetDnsLogsResponseBodyLogsLog(TeaModel):
    def __init__(
        self,
        dns_msg_id: str = None,
        log_time: int = None,
        protocol: str = None,
        query_name: str = None,
        query_type: str = None,
        rt: int = None,
        server_ip: str = None,
        source_ip: str = None,
        status: str = None,
        subnet_ip: str = None,
        value: DescribeInternetDnsLogsResponseBodyLogsLogValue = None,
        zone_name: str = None,
    ):
        # Parse log ID (can be duplicated).
        self.dns_msg_id = dns_msg_id
        # Parse timestamp.
        self.log_time = log_time
        # The protocol type of the domain name resolution query request:
        # - UDP
        # - TCP
        # - HTTP
        # - HTTPS
        # - DOH
        self.protocol = protocol
        # The domain name for which you want to query Domain Name System (DNS) records.
        self.query_name = query_name
        # Record type.
        self.query_type = query_type
        # Parse response time.
        self.rt = rt
        # Parse server IP.
        self.server_ip = server_ip
        # Source IP address.
        self.source_ip = source_ip
        # Response status.
        self.status = status
        # The value set for the edns-client-subnet option.
        self.subnet_ip = subnet_ip
        # Array of parsing results.
        self.value = value
        # The zone name.
        self.zone_name = zone_name

    def validate(self):
        if self.value:
            self.value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_msg_id is not None:
            result['DnsMsgId'] = self.dns_msg_id
        if self.log_time is not None:
            result['LogTime'] = self.log_time
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.query_name is not None:
            result['QueryName'] = self.query_name
        if self.query_type is not None:
            result['QueryType'] = self.query_type
        if self.rt is not None:
            result['Rt'] = self.rt
        if self.server_ip is not None:
            result['ServerIp'] = self.server_ip
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.subnet_ip is not None:
            result['SubnetIp'] = self.subnet_ip
        if self.value is not None:
            result['Value'] = self.value.to_map()
        if self.zone_name is not None:
            result['ZoneName'] = self.zone_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsMsgId') is not None:
            self.dns_msg_id = m.get('DnsMsgId')
        if m.get('LogTime') is not None:
            self.log_time = m.get('LogTime')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('QueryName') is not None:
            self.query_name = m.get('QueryName')
        if m.get('QueryType') is not None:
            self.query_type = m.get('QueryType')
        if m.get('Rt') is not None:
            self.rt = m.get('Rt')
        if m.get('ServerIp') is not None:
            self.server_ip = m.get('ServerIp')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubnetIp') is not None:
            self.subnet_ip = m.get('SubnetIp')
        if m.get('Value') is not None:
            temp_model = DescribeInternetDnsLogsResponseBodyLogsLogValue()
            self.value = temp_model.from_map(m['Value'])
        if m.get('ZoneName') is not None:
            self.zone_name = m.get('ZoneName')
        return self


class DescribeInternetDnsLogsResponseBodyLogs(TeaModel):
    def __init__(
        self,
        log: List[DescribeInternetDnsLogsResponseBodyLogsLog] = None,
    ):
        self.log = log

    def validate(self):
        if self.log:
            for k in self.log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Log'] = []
        if self.log is not None:
            for k in self.log:
                result['Log'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log = []
        if m.get('Log') is not None:
            for k in m.get('Log'):
                temp_model = DescribeInternetDnsLogsResponseBodyLogsLog()
                self.log.append(temp_model.from_map(k))
        return self


class DescribeInternetDnsLogsResponseBody(TeaModel):
    def __init__(
        self,
        complete: bool = None,
        cur_page: int = None,
        logs: DescribeInternetDnsLogsResponseBodyLogs = None,
        page_size: int = None,
        request_id: str = None,
        total_page: int = None,
        total_size: int = None,
    ):
        # Indicates whether the log query is precise.
        self.complete = complete
        # Current page number.
        self.cur_page = cur_page
        # The queried logs.
        self.logs = logs
        # Page size for query.
        self.page_size = page_size
        # Unique request identifier.
        self.request_id = request_id
        # Total number of pages.
        self.total_page = total_page
        # Total quantity.
        self.total_size = total_size

    def validate(self):
        if self.logs:
            self.logs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.complete is not None:
            result['Complete'] = self.complete
        if self.cur_page is not None:
            result['CurPage'] = self.cur_page
        if self.logs is not None:
            result['Logs'] = self.logs.to_map()
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Complete') is not None:
            self.complete = m.get('Complete')
        if m.get('CurPage') is not None:
            self.cur_page = m.get('CurPage')
        if m.get('Logs') is not None:
            temp_model = DescribeInternetDnsLogsResponseBodyLogs()
            self.logs = temp_model.from_map(m['Logs'])
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeInternetDnsLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInternetDnsLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInternetDnsLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIspFlushCacheInstancesRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        isp: str = None,
        keyword: str = None,
        lang: str = None,
        order_by: str = None,
        page_number: int = None,
        page_size: int = None,
        type: str = None,
    ):
        self.direction = direction
        self.isp = isp
        self.keyword = keyword
        self.lang = lang
        self.order_by = order_by
        self.page_number = page_number
        self.page_size = page_size
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo(TeaModel):
    def __init__(
        self,
        instance_quota: int = None,
        instance_quota_used: int = None,
    ):
        self.instance_quota = instance_quota
        self.instance_quota_used = instance_quota_used

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_quota is not None:
            result['InstanceQuota'] = self.instance_quota
        if self.instance_quota_used is not None:
            result['InstanceQuotaUsed'] = self.instance_quota_used
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceQuota') is not None:
            self.instance_quota = m.get('InstanceQuota')
        if m.get('InstanceQuotaUsed') is not None:
            self.instance_quota_used = m.get('InstanceQuotaUsed')
        return self


class DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances(TeaModel):
    def __init__(
        self,
        expire_time: str = None,
        expire_timestamp: int = None,
        instance_id: str = None,
        instance_name: str = None,
        isp: str = None,
        quota_info: DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo = None,
        status: str = None,
        version_code: str = None,
    ):
        self.expire_time = expire_time
        self.expire_timestamp = expire_timestamp
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.isp = isp
        self.quota_info = quota_info
        self.status = status
        self.version_code = version_code

    def validate(self):
        if self.quota_info:
            self.quota_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.expire_timestamp is not None:
            result['ExpireTimestamp'] = self.expire_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.quota_info is not None:
            result['QuotaInfo'] = self.quota_info.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ExpireTimestamp') is not None:
            self.expire_timestamp = m.get('ExpireTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('QuotaInfo') is not None:
            temp_model = DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo()
            self.quota_info = temp_model.from_map(m['QuotaInfo'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class DescribeIspFlushCacheInstancesResponseBody(TeaModel):
    def __init__(
        self,
        isp_flush_cache_instances: List[DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        self.isp_flush_cache_instances = isp_flush_cache_instances
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_items = total_items
        self.total_pages = total_pages

    def validate(self):
        if self.isp_flush_cache_instances:
            for k in self.isp_flush_cache_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspFlushCacheInstances'] = []
        if self.isp_flush_cache_instances is not None:
            for k in self.isp_flush_cache_instances:
                result['IspFlushCacheInstances'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isp_flush_cache_instances = []
        if m.get('IspFlushCacheInstances') is not None:
            for k in m.get('IspFlushCacheInstances'):
                temp_model = DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances()
                self.isp_flush_cache_instances.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeIspFlushCacheInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIspFlushCacheInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIspFlushCacheInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIspFlushCacheRemainQuotaRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeIspFlushCacheRemainQuotaResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        telecom_remain_quota: int = None,
    ):
        self.request_id = request_id
        self.telecom_remain_quota = telecom_remain_quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.telecom_remain_quota is not None:
            result['TelecomRemainQuota'] = self.telecom_remain_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TelecomRemainQuota') is not None:
            self.telecom_remain_quota = m.get('TelecomRemainQuota')
        return self


class DescribeIspFlushCacheRemainQuotaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIspFlushCacheRemainQuotaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIspFlushCacheRemainQuotaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIspFlushCacheTaskRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        task_id: str = None,
    ):
        self.lang = lang
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers(TeaModel):
    def __init__(
        self,
        name: str = None,
        record: str = None,
        ttl: int = None,
        type: str = None,
    ):
        self.name = name
        self.record = record
        self.ttl = ttl
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.record is not None:
            result['Record'] = self.record
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Record') is not None:
            self.record = m.get('Record')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes(TeaModel):
    def __init__(
        self,
        answers: List[DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers] = None,
        node_ip: str = None,
        sp_name: str = None,
        status: str = None,
    ):
        self.answers = answers
        self.node_ip = node_ip
        self.sp_name = sp_name
        self.status = status

    def validate(self):
        if self.answers:
            for k in self.answers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Answers'] = []
        if self.answers is not None:
            for k in self.answers:
                result['Answers'].append(k.to_map() if k else None)
        if self.node_ip is not None:
            result['NodeIp'] = self.node_ip
        if self.sp_name is not None:
            result['SpName'] = self.sp_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.answers = []
        if m.get('Answers') is not None:
            for k in m.get('Answers'):
                temp_model = DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers()
                self.answers.append(temp_model.from_map(k))
        if m.get('NodeIp') is not None:
            self.node_ip = m.get('NodeIp')
        if m.get('SpName') is not None:
            self.sp_name = m.get('SpName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeIspFlushCacheTaskResponseBodyFlushCacheResults(TeaModel):
    def __init__(
        self,
        dns_nodes: List[DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes] = None,
        province: str = None,
    ):
        self.dns_nodes = dns_nodes
        self.province = province

    def validate(self):
        if self.dns_nodes:
            for k in self.dns_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DnsNodes'] = []
        if self.dns_nodes is not None:
            for k in self.dns_nodes:
                result['DnsNodes'].append(k.to_map() if k else None)
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dns_nodes = []
        if m.get('DnsNodes') is not None:
            for k in m.get('DnsNodes'):
                temp_model = DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes()
                self.dns_nodes.append(temp_model.from_map(k))
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class DescribeIspFlushCacheTaskResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        domain_name: str = None,
        flush_cache_results: List[DescribeIspFlushCacheTaskResponseBodyFlushCacheResults] = None,
        instance_id: str = None,
        instance_name: str = None,
        isp: str = None,
        request_id: str = None,
        task_id: str = None,
        task_status: str = None,
    ):
        self.create_time = create_time
        self.create_timestamp = create_timestamp
        self.domain_name = domain_name
        self.flush_cache_results = flush_cache_results
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.isp = isp
        self.request_id = request_id
        self.task_id = task_id
        self.task_status = task_status

    def validate(self):
        if self.flush_cache_results:
            for k in self.flush_cache_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        result['FlushCacheResults'] = []
        if self.flush_cache_results is not None:
            for k in self.flush_cache_results:
                result['FlushCacheResults'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        self.flush_cache_results = []
        if m.get('FlushCacheResults') is not None:
            for k in m.get('FlushCacheResults'):
                temp_model = DescribeIspFlushCacheTaskResponseBodyFlushCacheResults()
                self.flush_cache_results.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeIspFlushCacheTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIspFlushCacheTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIspFlushCacheTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIspFlushCacheTasksRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        domain_name: str = None,
        instance_id: str = None,
        isp: str = None,
        lang: str = None,
        order_by: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.direction = direction
        self.domain_name = domain_name
        self.instance_id = instance_id
        self.isp = isp
        self.lang = lang
        self.order_by = order_by
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        domain_name: str = None,
        instance_id: str = None,
        instance_name: str = None,
        isp: str = None,
        task_id: str = None,
        task_status: str = None,
    ):
        self.create_time = create_time
        self.create_timestamp = create_timestamp
        self.domain_name = domain_name
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.isp = isp
        self.task_id = task_id
        self.task_status = task_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeIspFlushCacheTasksResponseBody(TeaModel):
    def __init__(
        self,
        isp_flush_cache_tasks: List[DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        self.isp_flush_cache_tasks = isp_flush_cache_tasks
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_items = total_items
        self.total_pages = total_pages

    def validate(self):
        if self.isp_flush_cache_tasks:
            for k in self.isp_flush_cache_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspFlushCacheTasks'] = []
        if self.isp_flush_cache_tasks is not None:
            for k in self.isp_flush_cache_tasks:
                result['IspFlushCacheTasks'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isp_flush_cache_tasks = []
        if m.get('IspFlushCacheTasks') is not None:
            for k in m.get('IspFlushCacheTasks'):
                temp_model = DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks()
                self.isp_flush_cache_tasks.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeIspFlushCacheTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIspFlushCacheTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIspFlushCacheTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsAccountSummaryRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        lang: str = None,
        start_date: str = None,
    ):
        self.end_date = end_date
        self.lang = lang
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribePdnsAccountSummaryResponseBodyData(TeaModel):
    def __init__(
        self,
        domain_count: int = None,
        http_count: int = None,
        https_count: int = None,
        sub_domain_count: int = None,
        threat_count: int = None,
        total_count: int = None,
        user_id: int = None,
    ):
        self.domain_count = domain_count
        self.http_count = http_count
        self.https_count = https_count
        self.sub_domain_count = sub_domain_count
        self.threat_count = threat_count
        self.total_count = total_count
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_count is not None:
            result['DomainCount'] = self.domain_count
        if self.http_count is not None:
            result['HttpCount'] = self.http_count
        if self.https_count is not None:
            result['HttpsCount'] = self.https_count
        if self.sub_domain_count is not None:
            result['SubDomainCount'] = self.sub_domain_count
        if self.threat_count is not None:
            result['ThreatCount'] = self.threat_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainCount') is not None:
            self.domain_count = m.get('DomainCount')
        if m.get('HttpCount') is not None:
            self.http_count = m.get('HttpCount')
        if m.get('HttpsCount') is not None:
            self.https_count = m.get('HttpsCount')
        if m.get('SubDomainCount') is not None:
            self.sub_domain_count = m.get('SubDomainCount')
        if m.get('ThreatCount') is not None:
            self.threat_count = m.get('ThreatCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribePdnsAccountSummaryResponseBody(TeaModel):
    def __init__(
        self,
        data: DescribePdnsAccountSummaryResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribePdnsAccountSummaryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePdnsAccountSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsAccountSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsAccountSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsAppKeyRequest(TeaModel):
    def __init__(
        self,
        app_key_id: str = None,
        auth_code: str = None,
        lang: str = None,
    ):
        self.app_key_id = app_key_id
        self.auth_code = auth_code
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key_id is not None:
            result['AppKeyId'] = self.app_key_id
        if self.auth_code is not None:
            result['AuthCode'] = self.auth_code
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppKeyId') is not None:
            self.app_key_id = m.get('AppKeyId')
        if m.get('AuthCode') is not None:
            self.auth_code = m.get('AuthCode')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribePdnsAppKeyResponseBodyAppKey(TeaModel):
    def __init__(
        self,
        app_key_id: str = None,
        app_key_secret: str = None,
        create_date: str = None,
        create_timestamp: int = None,
        remark: str = None,
        state: str = None,
    ):
        self.app_key_id = app_key_id
        self.app_key_secret = app_key_secret
        self.create_date = create_date
        self.create_timestamp = create_timestamp
        self.remark = remark
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key_id is not None:
            result['AppKeyId'] = self.app_key_id
        if self.app_key_secret is not None:
            result['AppKeySecret'] = self.app_key_secret
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppKeyId') is not None:
            self.app_key_id = m.get('AppKeyId')
        if m.get('AppKeySecret') is not None:
            self.app_key_secret = m.get('AppKeySecret')
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class DescribePdnsAppKeyResponseBody(TeaModel):
    def __init__(
        self,
        app_key: DescribePdnsAppKeyResponseBodyAppKey = None,
        request_id: str = None,
    ):
        self.app_key = app_key
        self.request_id = request_id

    def validate(self):
        if self.app_key:
            self.app_key.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key is not None:
            result['AppKey'] = self.app_key.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppKey') is not None:
            temp_model = DescribePdnsAppKeyResponseBodyAppKey()
            self.app_key = temp_model.from_map(m['AppKey'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePdnsAppKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsAppKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsAppKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsAppKeysRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribePdnsAppKeysResponseBodyAppKeys(TeaModel):
    def __init__(
        self,
        app_key_id: str = None,
        create_date: str = None,
        create_timestamp: int = None,
        remark: str = None,
        state: str = None,
    ):
        self.app_key_id = app_key_id
        self.create_date = create_date
        self.create_timestamp = create_timestamp
        self.remark = remark
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key_id is not None:
            result['AppKeyId'] = self.app_key_id
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppKeyId') is not None:
            self.app_key_id = m.get('AppKeyId')
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class DescribePdnsAppKeysResponseBody(TeaModel):
    def __init__(
        self,
        app_keys: List[DescribePdnsAppKeysResponseBodyAppKeys] = None,
        request_id: str = None,
    ):
        self.app_keys = app_keys
        self.request_id = request_id

    def validate(self):
        if self.app_keys:
            for k in self.app_keys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppKeys'] = []
        if self.app_keys is not None:
            for k in self.app_keys:
                result['AppKeys'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_keys = []
        if m.get('AppKeys') is not None:
            for k in m.get('AppKeys'):
                temp_model = DescribePdnsAppKeysResponseBodyAppKeys()
                self.app_keys.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePdnsAppKeysResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsAppKeysResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsAppKeysResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsOperateLogsRequest(TeaModel):
    def __init__(
        self,
        action_type: str = None,
        end_date: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        resource_type: str = None,
        start_date: str = None,
    ):
        self.action_type = action_type
        self.end_date = end_date
        self.keyword = keyword
        self.lang = lang
        self.page_number = page_number
        self.page_size = page_size
        self.resource_type = resource_type
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribePdnsOperateLogsResponseBodyLogs(TeaModel):
    def __init__(
        self,
        action: str = None,
        operate_time: str = None,
        type: str = None,
        content: str = None,
    ):
        self.action = action
        self.operate_time = operate_time
        self.type = type
        self.content = content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.operate_time is not None:
            result['OperateTime'] = self.operate_time
        if self.type is not None:
            result['Type'] = self.type
        if self.content is not None:
            result['content'] = self.content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('OperateTime') is not None:
            self.operate_time = m.get('OperateTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('content') is not None:
            self.content = m.get('content')
        return self


class DescribePdnsOperateLogsResponseBody(TeaModel):
    def __init__(
        self,
        logs: List[DescribePdnsOperateLogsResponseBodyLogs] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.logs = logs
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = DescribePdnsOperateLogsResponseBodyLogs()
                self.logs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePdnsOperateLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsOperateLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsOperateLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsRequestStatisticRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_date: str = None,
        lang: str = None,
        start_date: str = None,
        sub_domain: str = None,
        type: str = None,
    ):
        # The primary domain name whose statistics you want to query.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.
        # 
        # The default value is the day when you query the data.
        self.end_date = end_date
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.
        # 
        # You can query only records of the last 90 days.
        self.start_date = start_date
        # The subdomain name whose statistics you want to query.
        self.sub_domain = sub_domain
        # The type of the request statistics that you want to query. Valid values:
        # 
        # *   **ACCOUNT**: queries the request statistics by account.
        # *   **DOMAIN**: queries the request statistics by domain name.
        # *   **SUB_DOMAIN**: queries the request statistics by subdomain name.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePdnsRequestStatisticResponseBodyData(TeaModel):
    def __init__(
        self,
        doh_total_count: int = None,
        http_count: int = None,
        https_count: int = None,
        ip_count: int = None,
        timestamp: int = None,
        total_count: int = None,
        udp_total_count: int = None,
        v_4count: int = None,
        v_4http_count: int = None,
        v_4https_count: int = None,
        v_6count: int = None,
        v_6http_count: int = None,
        v_6https_count: int = None,
    ):
        # The total number of DoH requests, including HTTP and HTTPS requests.
        self.doh_total_count = doh_total_count
        # The number of HTTP requests.
        self.http_count = http_count
        # The number of HTTPS requests. On the Traffic Analysis tab of the Public DNS console, the value of this parameter includes the number of DNS over HTTPs (DoH) requests. Therefore, the number of DoH requests is not separately displayed in the console.
        self.https_count = https_count
        # The number of source IP addresses.
        self.ip_count = ip_count
        # The statistical timestamp. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.timestamp = timestamp
        # The total number of requests.
        self.total_count = total_count
        # The total number of UDP requests.
        self.udp_total_count = udp_total_count
        # The number of IPv4-based requests.
        self.v_4count = v_4count
        # The number of IPv4-based HTTP requests.
        self.v_4http_count = v_4http_count
        # The number of IPv4-based HTTPS requests.
        self.v_4https_count = v_4https_count
        # The number of IPv6-based requests.
        self.v_6count = v_6count
        # The number of IPv6-based HTTP requests.
        self.v_6http_count = v_6http_count
        # The number of IPv6-based HTTPS requests.
        self.v_6https_count = v_6https_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doh_total_count is not None:
            result['DohTotalCount'] = self.doh_total_count
        if self.http_count is not None:
            result['HttpCount'] = self.http_count
        if self.https_count is not None:
            result['HttpsCount'] = self.https_count
        if self.ip_count is not None:
            result['IpCount'] = self.ip_count
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.udp_total_count is not None:
            result['UdpTotalCount'] = self.udp_total_count
        if self.v_4count is not None:
            result['V4Count'] = self.v_4count
        if self.v_4http_count is not None:
            result['V4HttpCount'] = self.v_4http_count
        if self.v_4https_count is not None:
            result['V4HttpsCount'] = self.v_4https_count
        if self.v_6count is not None:
            result['V6Count'] = self.v_6count
        if self.v_6http_count is not None:
            result['V6HttpCount'] = self.v_6http_count
        if self.v_6https_count is not None:
            result['V6HttpsCount'] = self.v_6https_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DohTotalCount') is not None:
            self.doh_total_count = m.get('DohTotalCount')
        if m.get('HttpCount') is not None:
            self.http_count = m.get('HttpCount')
        if m.get('HttpsCount') is not None:
            self.https_count = m.get('HttpsCount')
        if m.get('IpCount') is not None:
            self.ip_count = m.get('IpCount')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UdpTotalCount') is not None:
            self.udp_total_count = m.get('UdpTotalCount')
        if m.get('V4Count') is not None:
            self.v_4count = m.get('V4Count')
        if m.get('V4HttpCount') is not None:
            self.v_4http_count = m.get('V4HttpCount')
        if m.get('V4HttpsCount') is not None:
            self.v_4https_count = m.get('V4HttpsCount')
        if m.get('V6Count') is not None:
            self.v_6count = m.get('V6Count')
        if m.get('V6HttpCount') is not None:
            self.v_6http_count = m.get('V6HttpCount')
        if m.get('V6HttpsCount') is not None:
            self.v_6https_count = m.get('V6HttpsCount')
        return self


class DescribePdnsRequestStatisticResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribePdnsRequestStatisticResponseBodyData] = None,
        request_id: str = None,
    ):
        # The statistics on the DNS requests.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribePdnsRequestStatisticResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePdnsRequestStatisticResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsRequestStatisticResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsRequestStatisticResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsRequestStatisticsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_date: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_date: str = None,
        sub_domain: str = None,
        type: str = None,
    ):
        # The primary domain name whose statistics you want to query.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # The default value is the day when you query the data.
        self.end_date = end_date
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Default value: 20. Valid values: 1 to 100.
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
        # 
        # You can query only records of the last 90 days.
        self.start_date = start_date
        # The subdomain name whose statistics you want to query.
        self.sub_domain = sub_domain
        # The type of the request statistics that you want to query. Valid values:
        # 
        # *   DOMAIN: queries the request statistics by domain name.
        # *   SUB_DOMAIN: queries the request statistics by subdomain name.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePdnsRequestStatisticsResponseBodyDataThreatInfo(TeaModel):
    def __init__(
        self,
        threat_level: str = None,
        threat_type: str = None,
    ):
        # The current version does not support this parameter.
        self.threat_level = threat_level
        # The current version does not support this parameter.
        self.threat_type = threat_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.threat_level is not None:
            result['ThreatLevel'] = self.threat_level
        if self.threat_type is not None:
            result['ThreatType'] = self.threat_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ThreatLevel') is not None:
            self.threat_level = m.get('ThreatLevel')
        if m.get('ThreatType') is not None:
            self.threat_type = m.get('ThreatType')
        return self


class DescribePdnsRequestStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        doh_total_count: int = None,
        domain_name: str = None,
        http_count: int = None,
        https_count: int = None,
        ip_count: int = None,
        max_threat_level: str = None,
        sub_domain: str = None,
        threat_count: int = None,
        threat_info: List[DescribePdnsRequestStatisticsResponseBodyDataThreatInfo] = None,
        total_count: int = None,
        udp_total_count: int = None,
        v_4count: int = None,
        v_4http_count: int = None,
        v_4https_count: int = None,
        v_6count: int = None,
        v_6http_count: int = None,
        v_6https_count: int = None,
    ):
        # The total number of DoH requests, including the HTTP and HTTPS requests.
        self.doh_total_count = doh_total_count
        # The domain name.
        self.domain_name = domain_name
        # The number of HTTP requests.
        self.http_count = http_count
        # The number of HTTPS requests. On the Traffic Analysis tab of the public DNS console, the value of this parameter includes the number of DNS over HTTPs (DoH) requests. Therefore, the number of DoH requests is not separately displayed in the console.
        self.https_count = https_count
        # The number of source IP addresses.
        self.ip_count = ip_count
        # The current version does not support this parameter.
        self.max_threat_level = max_threat_level
        # The subdomain name.
        self.sub_domain = sub_domain
        # The current version does not support this parameter.
        self.threat_count = threat_count
        # The current version does not support this parameter.
        self.threat_info = threat_info
        # The total number of requests.
        self.total_count = total_count
        # The total number of UDP requests.
        self.udp_total_count = udp_total_count
        # The number of IPv4-based requests.
        self.v_4count = v_4count
        # The number of IPv4-based HTTP requests.
        self.v_4http_count = v_4http_count
        # The number of IPv4-based HTTPS requests.
        self.v_4https_count = v_4https_count
        # The number of IPv6-based requests.
        self.v_6count = v_6count
        # The number of IPv6-based HTTP requests.
        self.v_6http_count = v_6http_count
        # The number of IPv6-based HTTPS requests.
        self.v_6https_count = v_6https_count

    def validate(self):
        if self.threat_info:
            for k in self.threat_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doh_total_count is not None:
            result['DohTotalCount'] = self.doh_total_count
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.http_count is not None:
            result['HttpCount'] = self.http_count
        if self.https_count is not None:
            result['HttpsCount'] = self.https_count
        if self.ip_count is not None:
            result['IpCount'] = self.ip_count
        if self.max_threat_level is not None:
            result['MaxThreatLevel'] = self.max_threat_level
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.threat_count is not None:
            result['ThreatCount'] = self.threat_count
        result['ThreatInfo'] = []
        if self.threat_info is not None:
            for k in self.threat_info:
                result['ThreatInfo'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.udp_total_count is not None:
            result['UdpTotalCount'] = self.udp_total_count
        if self.v_4count is not None:
            result['V4Count'] = self.v_4count
        if self.v_4http_count is not None:
            result['V4HttpCount'] = self.v_4http_count
        if self.v_4https_count is not None:
            result['V4HttpsCount'] = self.v_4https_count
        if self.v_6count is not None:
            result['V6Count'] = self.v_6count
        if self.v_6http_count is not None:
            result['V6HttpCount'] = self.v_6http_count
        if self.v_6https_count is not None:
            result['V6HttpsCount'] = self.v_6https_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DohTotalCount') is not None:
            self.doh_total_count = m.get('DohTotalCount')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('HttpCount') is not None:
            self.http_count = m.get('HttpCount')
        if m.get('HttpsCount') is not None:
            self.https_count = m.get('HttpsCount')
        if m.get('IpCount') is not None:
            self.ip_count = m.get('IpCount')
        if m.get('MaxThreatLevel') is not None:
            self.max_threat_level = m.get('MaxThreatLevel')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('ThreatCount') is not None:
            self.threat_count = m.get('ThreatCount')
        self.threat_info = []
        if m.get('ThreatInfo') is not None:
            for k in m.get('ThreatInfo'):
                temp_model = DescribePdnsRequestStatisticsResponseBodyDataThreatInfo()
                self.threat_info.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UdpTotalCount') is not None:
            self.udp_total_count = m.get('UdpTotalCount')
        if m.get('V4Count') is not None:
            self.v_4count = m.get('V4Count')
        if m.get('V4HttpCount') is not None:
            self.v_4http_count = m.get('V4HttpCount')
        if m.get('V4HttpsCount') is not None:
            self.v_4https_count = m.get('V4HttpsCount')
        if m.get('V6Count') is not None:
            self.v_6count = m.get('V6Count')
        if m.get('V6HttpCount') is not None:
            self.v_6http_count = m.get('V6HttpCount')
        if m.get('V6HttpsCount') is not None:
            self.v_6https_count = m.get('V6HttpsCount')
        return self


class DescribePdnsRequestStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribePdnsRequestStatisticsResponseBodyData] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The statistics on the DNS requests.
        self.data = data
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Default value: **20**. Valid values: **1 to 100**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribePdnsRequestStatisticsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePdnsRequestStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsRequestStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsRequestStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsThreatLogsRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_date: str = None,
        threat_level: str = None,
        threat_source_ip: str = None,
        threat_type: str = None,
    ):
        self.end_date = end_date
        self.keyword = keyword
        self.lang = lang
        self.page_number = page_number
        self.page_size = page_size
        self.start_date = start_date
        self.threat_level = threat_level
        self.threat_source_ip = threat_source_ip
        self.threat_type = threat_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.threat_level is not None:
            result['ThreatLevel'] = self.threat_level
        if self.threat_source_ip is not None:
            result['ThreatSourceIp'] = self.threat_source_ip
        if self.threat_type is not None:
            result['ThreatType'] = self.threat_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('ThreatLevel') is not None:
            self.threat_level = m.get('ThreatLevel')
        if m.get('ThreatSourceIp') is not None:
            self.threat_source_ip = m.get('ThreatSourceIp')
        if m.get('ThreatType') is not None:
            self.threat_type = m.get('ThreatType')
        return self


class DescribePdnsThreatLogsResponseBodyLogs(TeaModel):
    def __init__(
        self,
        source_ip: str = None,
        sub_domain: str = None,
        threat_level: str = None,
        threat_time: str = None,
        threat_type: str = None,
    ):
        self.source_ip = source_ip
        self.sub_domain = sub_domain
        self.threat_level = threat_level
        self.threat_time = threat_time
        self.threat_type = threat_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.threat_level is not None:
            result['ThreatLevel'] = self.threat_level
        if self.threat_time is not None:
            result['ThreatTime'] = self.threat_time
        if self.threat_type is not None:
            result['ThreatType'] = self.threat_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('ThreatLevel') is not None:
            self.threat_level = m.get('ThreatLevel')
        if m.get('ThreatTime') is not None:
            self.threat_time = m.get('ThreatTime')
        if m.get('ThreatType') is not None:
            self.threat_type = m.get('ThreatType')
        return self


class DescribePdnsThreatLogsResponseBody(TeaModel):
    def __init__(
        self,
        logs: List[DescribePdnsThreatLogsResponseBodyLogs] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.logs = logs
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = DescribePdnsThreatLogsResponseBodyLogs()
                self.logs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePdnsThreatLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsThreatLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsThreatLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsThreatStatisticRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        lang: str = None,
        start_date: str = None,
        threat_source_ip: str = None,
    ):
        self.end_date = end_date
        self.lang = lang
        self.start_date = start_date
        self.threat_source_ip = threat_source_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.threat_source_ip is not None:
            result['ThreatSourceIp'] = self.threat_source_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('ThreatSourceIp') is not None:
            self.threat_source_ip = m.get('ThreatSourceIp')
        return self


class DescribePdnsThreatStatisticResponseBodyData(TeaModel):
    def __init__(
        self,
        doh_total_count: int = None,
        threat_level: str = None,
        threat_type: str = None,
        timestamp: int = None,
        total_count: int = None,
        udp_total_count: int = None,
    ):
        self.doh_total_count = doh_total_count
        self.threat_level = threat_level
        self.threat_type = threat_type
        self.timestamp = timestamp
        self.total_count = total_count
        self.udp_total_count = udp_total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doh_total_count is not None:
            result['DohTotalCount'] = self.doh_total_count
        if self.threat_level is not None:
            result['ThreatLevel'] = self.threat_level
        if self.threat_type is not None:
            result['ThreatType'] = self.threat_type
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.udp_total_count is not None:
            result['UdpTotalCount'] = self.udp_total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DohTotalCount') is not None:
            self.doh_total_count = m.get('DohTotalCount')
        if m.get('ThreatLevel') is not None:
            self.threat_level = m.get('ThreatLevel')
        if m.get('ThreatType') is not None:
            self.threat_type = m.get('ThreatType')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UdpTotalCount') is not None:
            self.udp_total_count = m.get('UdpTotalCount')
        return self


class DescribePdnsThreatStatisticResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribePdnsThreatStatisticResponseBodyData] = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribePdnsThreatStatisticResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePdnsThreatStatisticResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsThreatStatisticResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsThreatStatisticResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsThreatStatisticsRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        domain_name: str = None,
        end_date: str = None,
        lang: str = None,
        order_by: str = None,
        page_number: int = None,
        page_size: int = None,
        start_date: str = None,
        sub_domain: str = None,
        threat_level: str = None,
        threat_source_ip: str = None,
        threat_type: str = None,
        type: str = None,
    ):
        self.direction = direction
        self.domain_name = domain_name
        self.end_date = end_date
        self.lang = lang
        self.order_by = order_by
        self.page_number = page_number
        self.page_size = page_size
        self.start_date = start_date
        self.sub_domain = sub_domain
        self.threat_level = threat_level
        self.threat_source_ip = threat_source_ip
        self.threat_type = threat_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.threat_level is not None:
            result['ThreatLevel'] = self.threat_level
        if self.threat_source_ip is not None:
            result['ThreatSourceIp'] = self.threat_source_ip
        if self.threat_type is not None:
            result['ThreatType'] = self.threat_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('ThreatLevel') is not None:
            self.threat_level = m.get('ThreatLevel')
        if m.get('ThreatSourceIp') is not None:
            self.threat_source_ip = m.get('ThreatSourceIp')
        if m.get('ThreatType') is not None:
            self.threat_type = m.get('ThreatType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePdnsThreatStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        doh_total_count: int = None,
        domain_count: int = None,
        domain_name: str = None,
        latest_threat_time: int = None,
        max_threat_level: str = None,
        source_ip: str = None,
        sub_domain: str = None,
        threat_level: str = None,
        threat_type: str = None,
        total_count: int = None,
        udp_total_count: int = None,
    ):
        self.doh_total_count = doh_total_count
        self.domain_count = domain_count
        self.domain_name = domain_name
        self.latest_threat_time = latest_threat_time
        self.max_threat_level = max_threat_level
        self.source_ip = source_ip
        self.sub_domain = sub_domain
        self.threat_level = threat_level
        self.threat_type = threat_type
        self.total_count = total_count
        self.udp_total_count = udp_total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doh_total_count is not None:
            result['DohTotalCount'] = self.doh_total_count
        if self.domain_count is not None:
            result['DomainCount'] = self.domain_count
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.latest_threat_time is not None:
            result['LatestThreatTime'] = self.latest_threat_time
        if self.max_threat_level is not None:
            result['MaxThreatLevel'] = self.max_threat_level
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.threat_level is not None:
            result['ThreatLevel'] = self.threat_level
        if self.threat_type is not None:
            result['ThreatType'] = self.threat_type
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.udp_total_count is not None:
            result['UdpTotalCount'] = self.udp_total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DohTotalCount') is not None:
            self.doh_total_count = m.get('DohTotalCount')
        if m.get('DomainCount') is not None:
            self.domain_count = m.get('DomainCount')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LatestThreatTime') is not None:
            self.latest_threat_time = m.get('LatestThreatTime')
        if m.get('MaxThreatLevel') is not None:
            self.max_threat_level = m.get('MaxThreatLevel')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('ThreatLevel') is not None:
            self.threat_level = m.get('ThreatLevel')
        if m.get('ThreatType') is not None:
            self.threat_type = m.get('ThreatType')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UdpTotalCount') is not None:
            self.udp_total_count = m.get('UdpTotalCount')
        return self


class DescribePdnsThreatStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribePdnsThreatStatisticsResponseBodyData] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.data = data
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribePdnsThreatStatisticsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePdnsThreatStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsThreatStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsThreatStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsUdpIpSegmentsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.lang = lang
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribePdnsUdpIpSegmentsResponseBodyIpSegments(TeaModel):
    def __init__(
        self,
        create_date: str = None,
        create_timestamp: int = None,
        id: str = None,
        ip: str = None,
        mask: int = None,
        name: str = None,
        secret_key: str = None,
        state: str = None,
        update_date: str = None,
    ):
        self.create_date = create_date
        self.create_timestamp = create_timestamp
        self.id = id
        self.ip = ip
        self.mask = mask
        self.name = name
        self.secret_key = secret_key
        self.state = state
        self.update_date = update_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.id is not None:
            result['Id'] = self.id
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.mask is not None:
            result['Mask'] = self.mask
        if self.name is not None:
            result['Name'] = self.name
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.state is not None:
            result['State'] = self.state
        if self.update_date is not None:
            result['UpdateDate'] = self.update_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Mask') is not None:
            self.mask = m.get('Mask')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UpdateDate') is not None:
            self.update_date = m.get('UpdateDate')
        return self


class DescribePdnsUdpIpSegmentsResponseBody(TeaModel):
    def __init__(
        self,
        ip_segments: List[DescribePdnsUdpIpSegmentsResponseBodyIpSegments] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        total_pages: str = None,
    ):
        self.ip_segments = ip_segments
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count
        self.total_pages = total_pages

    def validate(self):
        if self.ip_segments:
            for k in self.ip_segments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IpSegments'] = []
        if self.ip_segments is not None:
            for k in self.ip_segments:
                result['IpSegments'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ip_segments = []
        if m.get('IpSegments') is not None:
            for k in m.get('IpSegments'):
                temp_model = DescribePdnsUdpIpSegmentsResponseBodyIpSegments()
                self.ip_segments.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribePdnsUdpIpSegmentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsUdpIpSegmentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsUdpIpSegmentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePdnsUserInfoRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid value:
        # 
        # *   **zh**: Chinese.
        # *   **en**: English.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribePdnsUserInfoResponseBodyUserInfo(TeaModel):
    def __init__(
        self,
        available_access_security_type: str = None,
        available_service: str = None,
        pdns_id: int = None,
        secret_key: str = None,
        service_type: str = None,
        state: str = None,
        statistic_switch_status: str = None,
        stopped_service: str = None,
    ):
        # The enabled access security types.
        self.available_access_security_type = available_access_security_type
        # The enabled public recursive DNS service.
        self.available_service = available_service
        # The configuration ID of the users in public recursive DNS.
        self.pdns_id = pdns_id
        # The SecretKey configured for a UDP-based CIDR block.
        self.secret_key = secret_key
        # The type of the public recursive DNS service.
        self.service_type = service_type
        # The status of the public recursive DNS service.
        self.state = state
        # The status of the traffic analysis switch for the user in public recursive DNS service.
        self.statistic_switch_status = statistic_switch_status
        # The disabled public recursive DNS service.
        self.stopped_service = stopped_service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_access_security_type is not None:
            result['AvailableAccessSecurityType'] = self.available_access_security_type
        if self.available_service is not None:
            result['AvailableService'] = self.available_service
        if self.pdns_id is not None:
            result['PdnsId'] = self.pdns_id
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.state is not None:
            result['State'] = self.state
        if self.statistic_switch_status is not None:
            result['StatisticSwitchStatus'] = self.statistic_switch_status
        if self.stopped_service is not None:
            result['StoppedService'] = self.stopped_service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableAccessSecurityType') is not None:
            self.available_access_security_type = m.get('AvailableAccessSecurityType')
        if m.get('AvailableService') is not None:
            self.available_service = m.get('AvailableService')
        if m.get('PdnsId') is not None:
            self.pdns_id = m.get('PdnsId')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('StatisticSwitchStatus') is not None:
            self.statistic_switch_status = m.get('StatisticSwitchStatus')
        if m.get('StoppedService') is not None:
            self.stopped_service = m.get('StoppedService')
        return self


class DescribePdnsUserInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_info: DescribePdnsUserInfoResponseBodyUserInfo = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The information about the user.
        self.user_info = user_info

    def validate(self):
        if self.user_info:
            self.user_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_info is not None:
            result['UserInfo'] = self.user_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserInfo') is not None:
            temp_model = DescribePdnsUserInfoResponseBodyUserInfo()
            self.user_info = temp_model.from_map(m['UserInfo'])
        return self


class DescribePdnsUserInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePdnsUserInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePdnsUserInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecordLogsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        key_word: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_date: str = None,
        user_client_ip: str = None,
        end_date: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
        self.key_word = key_word
        # The language.
        self.lang = lang
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # The start date of the query. Specify the start date in the **YYYY-MM-DD** format.
        self.start_date = start_date
        # The IP address of the client.
        self.user_client_ip = user_client_ip
        # The end date of the query. Specify the end date in the **YYYY-MM-DD** format.
        self.end_date = end_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        if self.end_date is not None:
            result['endDate'] = self.end_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        return self


class DescribeRecordLogsResponseBodyRecordLogsRecordLog(TeaModel):
    def __init__(
        self,
        action: str = None,
        action_time: str = None,
        action_timestamp: int = None,
        client_ip: str = None,
        message: str = None,
    ):
        # The operation that you performed.
        self.action = action
        # The time when you performed the operation.
        self.action_time = action_time
        # The time when you performed the operation. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.action_timestamp = action_timestamp
        # The IP address of the operator.
        self.client_ip = client_ip
        # The operation message.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.action_time is not None:
            result['ActionTime'] = self.action_time
        if self.action_timestamp is not None:
            result['ActionTimestamp'] = self.action_timestamp
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('ActionTime') is not None:
            self.action_time = m.get('ActionTime')
        if m.get('ActionTimestamp') is not None:
            self.action_timestamp = m.get('ActionTimestamp')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class DescribeRecordLogsResponseBodyRecordLogs(TeaModel):
    def __init__(
        self,
        record_log: List[DescribeRecordLogsResponseBodyRecordLogsRecordLog] = None,
    ):
        self.record_log = record_log

    def validate(self):
        if self.record_log:
            for k in self.record_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordLog'] = []
        if self.record_log is not None:
            for k in self.record_log:
                result['RecordLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_log = []
        if m.get('RecordLog') is not None:
            for k in m.get('RecordLog'):
                temp_model = DescribeRecordLogsResponseBodyRecordLogsRecordLog()
                self.record_log.append(temp_model.from_map(k))
        return self


class DescribeRecordLogsResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        record_logs: DescribeRecordLogsResponseBodyRecordLogs = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The operation logs.
        self.record_logs = record_logs
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.record_logs:
            self.record_logs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.record_logs is not None:
            result['RecordLogs'] = self.record_logs.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RecordLogs') is not None:
            temp_model = DescribeRecordLogsResponseBodyRecordLogs()
            self.record_logs = temp_model.from_map(m['RecordLogs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRecordLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecordLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecordLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecordResolveStatisticsSummaryRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        domain_name: str = None,
        domain_type: str = None,
        end_date: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        search_mode: str = None,
        start_date: str = None,
        threshold: int = None,
    ):
        # The order in which the returned entries are sorted. Valid values:
        # 
        # *   DESC (default): descending order
        # *   ASC: ascending order
        self.direction = direction
        # The domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The type of the domain name. The parameter value is not case-sensitive. Valid values:
        # 
        # *   PUBLIC (default): hosted public domain name
        # *   CACHE: cache-accelerated domain name
        self.domain_type = domain_type
        # The end date of the time range to be queried. Specify the time in the yyyy-MM-dd format, such as 2023-03-13.
        self.end_date = end_date
        # The keyword. Keyword is used together with SearchMode.
        self.keyword = keyword
        # The language. Valid values: zh, en, and ja.
        self.lang = lang
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Valid values: 1 to 1000.
        self.page_size = page_size
        # The search mode of the keyword. Valid values:
        # 
        # *   LIKE (default): fuzzy search
        # *   EXACT: exact search
        self.search_mode = search_mode
        # The start date of the time range to be queried. Specify the time in the yyyy-MM-dd format, such as 2023-03-01.
        # 
        # This parameter is required.
        self.start_date = start_date
        # The threshold for the number of Domain Name System (DNS) requests. You can query the subdomain names at the specified quantity level of DNS requests and query the number of DNS requests for each subdomain name.
        # 
        # If you do not specify this parameter, the data about the subdomain names that have DNS requests is obtained.
        # 
        # If you set this parameter to a value less than 0, the data about all subdomain names is obtained.
        # 
        # If you set this parameter to 0, the data about the subdomain names that do not have DNS requests is obtained.
        # 
        # If you set this parameter to a value greater than 0, the data about the subdomain names whose number of DNS requests is less than or equal to the value of this parameter is obtained.
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_mode is not None:
            result['SearchMode'] = self.search_mode
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchMode') is not None:
            self.search_mode = m.get('SearchMode')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeRecordResolveStatisticsSummaryResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        count: str = None,
        domain_name: str = None,
        domain_type: str = None,
        sub_domain: str = None,
    ):
        # The number of DNS requests.
        self.count = count
        # The subdomain name.
        self.domain_name = domain_name
        # The type of the domain name. The parameter value is not case-sensitive. Valid values:
        # 
        # *   PUBLIC (default): hosted public domain name
        # *   CACHE: cache-accelerated domain name
        self.domain_type = domain_type
        # The subdomain.
        self.sub_domain = sub_domain

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        return self


class DescribeRecordResolveStatisticsSummaryResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        statistics: List[DescribeRecordResolveStatisticsSummaryResponseBodyStatistics] = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 500**. Default value: **20**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The statistics.
        self.statistics = statistics
        # The total number of entries returned.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = DescribeRecordResolveStatisticsSummaryResponseBodyStatistics()
                self.statistics.append(temp_model.from_map(k))
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeRecordResolveStatisticsSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecordResolveStatisticsSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecordResolveStatisticsSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecordStatisticsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        domain_type: str = None,
        end_date: str = None,
        lang: str = None,
        rr: str = None,
        start_date: str = None,
    ):
        # The primary domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The type of the domain name. The parameter value is not case-sensitive. Valid values:
        # 
        # *   PUBLIC (default): hosted public domain name
        # *   CACHE: cache-accelerated domain name
        self.domain_type = domain_type
        # The end date of the query. Specify the end date in the **YYYY-MM-DD** format.
        # 
        # The default value is the day when you query the data.
        self.end_date = end_date
        # The language.
        self.lang = lang
        # The hostname. If you want to resolve www.dns-exmaple.top, set Rr to www.
        # 
        # This parameter is required.
        self.rr = rr
        # The start date of the query. Specify the start date in the **YYYY-MM-DD** format.
        # 
        # You can only query the DNS records within the last 90 days.``
        # 
        # If the time range is less than or equal to seven days, data is returned on an hourly basis.````
        # 
        # If the time range is greater than seven days, data is returned on a daily basis.````
        # 
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.rr is not None:
            result['Rr'] = self.rr
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Rr') is not None:
            self.rr = m.get('Rr')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeRecordStatisticsResponseBodyStatisticsStatistic(TeaModel):
    def __init__(
        self,
        count: int = None,
        timestamp: int = None,
    ):
        # The number of DNS requests.
        self.count = count
        # The statistical timestamp. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class DescribeRecordStatisticsResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        statistic: List[DescribeRecordStatisticsResponseBodyStatisticsStatistic] = None,
    ):
        self.statistic = statistic

    def validate(self):
        if self.statistic:
            for k in self.statistic:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Statistic'] = []
        if self.statistic is not None:
            for k in self.statistic:
                result['Statistic'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.statistic = []
        if m.get('Statistic') is not None:
            for k in m.get('Statistic'):
                temp_model = DescribeRecordStatisticsResponseBodyStatisticsStatistic()
                self.statistic.append(temp_model.from_map(k))
        return self


class DescribeRecordStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        statistics: DescribeRecordStatisticsResponseBodyStatistics = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The statistics on the DNS requests.
        self.statistics = statistics

    def validate(self):
        if self.statistics:
            self.statistics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.statistics is not None:
            result['Statistics'] = self.statistics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Statistics') is not None:
            temp_model = DescribeRecordStatisticsResponseBodyStatistics()
            self.statistics = temp_model.from_map(m['Statistics'])
        return self


class DescribeRecordStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecordStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecordStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecordStatisticsSummaryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        domain_type: str = None,
        end_date: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        search_mode: str = None,
        start_date: str = None,
        threshold: int = None,
    ):
        # The domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The type of the domain name. The parameter value is not case-sensitive. Valid values:
        # 
        # *   PUBLIC (default): hosted public domain name
        # *   CACHE: cache-accelerated domain name
        self.domain_type = domain_type
        # The end date of the query. Specify the start date in the **YYYY-MM-DD** format.
        # 
        # The default value is the day when you query the data.
        self.end_date = end_date
        # The keyword for searches in %KeyWord% mode. The value is not case-sensitive.
        self.keyword = keyword
        # The language.
        self.lang = lang
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # The search mode of the keyword. Valid values:
        # 
        # *   **LIKE** (default): fuzzy search
        # *   **EXACT**: exact search
        self.search_mode = search_mode
        # The start date of the query. Specify the start date in the **YYYY-MM-DD** format.
        # 
        # You can only query the DNS records within the last 90 days.``
        # 
        # This parameter is required.
        self.start_date = start_date
        # The maximum number of DNS requests that you can obtain. You can obtain data about a domain name with DNS request volume less than or equal to the maximum number. For example, if you set this parameter to 100, you can query domain names with less than 100 DNS requests.
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_type is not None:
            result['DomainType'] = self.domain_type
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_mode is not None:
            result['SearchMode'] = self.search_mode
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainType') is not None:
            self.domain_type = m.get('DomainType')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchMode') is not None:
            self.search_mode = m.get('SearchMode')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic(TeaModel):
    def __init__(
        self,
        count: int = None,
        sub_domain: str = None,
    ):
        # The number of DNS requests.
        self.count = count
        # The subdomain.
        self.sub_domain = sub_domain

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        return self


class DescribeRecordStatisticsSummaryResponseBodyStatistics(TeaModel):
    def __init__(
        self,
        statistic: List[DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic] = None,
    ):
        self.statistic = statistic

    def validate(self):
        if self.statistic:
            for k in self.statistic:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Statistic'] = []
        if self.statistic is not None:
            for k in self.statistic:
                result['Statistic'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.statistic = []
        if m.get('Statistic') is not None:
            for k in m.get('Statistic'):
                temp_model = DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic()
                self.statistic.append(temp_model.from_map(k))
        return self


class DescribeRecordStatisticsSummaryResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        statistics: DescribeRecordStatisticsSummaryResponseBodyStatistics = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The DNS requests.
        self.statistics = statistics
        # The total number of entries returned.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.statistics:
            self.statistics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.statistics is not None:
            result['Statistics'] = self.statistics.to_map()
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Statistics') is not None:
            temp_model = DescribeRecordStatisticsSummaryResponseBodyStatistics()
            self.statistics = temp_model.from_map(m['Statistics'])
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class DescribeRecordStatisticsSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecordStatisticsSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecordStatisticsSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSubDomainRecordsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        line: str = None,
        page_number: int = None,
        page_size: int = None,
        sub_domain: str = None,
        type: str = None,
        user_client_ip: str = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The DNS resolution line.
        self.line = line
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
        self.page_size = page_size
        # If you set SubDomain to `a.www.example.com` and leave
        # 
        # DomainName empty, the system returns the DNS records that contain the hostname `a.www` for the domain name example.com. If you set SubDomain to a.www.example.com and set DomainName to www.example.com, the system returns the DNS records that contain the hostname `a` for the domain name www.example.com. If you set SubDomain to a.www.example.com and set DomainName to a.www.example.com, the system returns the DNS records that contain the hostname `@` for the domain name a.www.example.com.
        # 
        # This parameter is required.
        self.sub_domain = sub_domain
        # The type of DNS records. If you do not specify this parameter, all types of DNS records for the subdomain name are returned.
        # 
        # Valid values: **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**.
        self.type = type
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line is not None:
            result['Line'] = self.line
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.type is not None:
            result['Type'] = self.type
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class DescribeSubDomainRecordsResponseBodyDomainRecordsRecord(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        line: str = None,
        locked: bool = None,
        priority: int = None,
        rr: str = None,
        record_id: str = None,
        remark: str = None,
        status: str = None,
        ttl: int = None,
        type: str = None,
        value: str = None,
        weight: int = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The DNS resolution line.
        self.line = line
        # The lock status of the DNS record.
        self.locked = locked
        # The priority of the mail exchanger (MX) record.
        self.priority = priority
        # The hostname.
        self.rr = rr
        # The ID of the DNS record.
        self.record_id = record_id
        # The description of the DNS record.
        self.remark = remark
        # The status of the DNS record.
        self.status = status
        # The time-to-live (TTL) of the DNS record.
        self.ttl = ttl
        # The type of the DNS record.
        self.type = type
        # The record value.
        self.value = value
        # The weight of the DNS record.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.line is not None:
            result['Line'] = self.line
        if self.locked is not None:
            result['Locked'] = self.locked
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.rr is not None:
            result['RR'] = self.rr
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.status is not None:
            result['Status'] = self.status
        if self.ttl is not None:
            result['TTL'] = self.ttl
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Locked') is not None:
            self.locked = m.get('Locked')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TTL') is not None:
            self.ttl = m.get('TTL')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class DescribeSubDomainRecordsResponseBodyDomainRecords(TeaModel):
    def __init__(
        self,
        record: List[DescribeSubDomainRecordsResponseBodyDomainRecordsRecord] = None,
    ):
        self.record = record

    def validate(self):
        if self.record:
            for k in self.record:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Record'] = []
        if self.record is not None:
            for k in self.record:
                result['Record'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record = []
        if m.get('Record') is not None:
            for k in m.get('Record'):
                temp_model = DescribeSubDomainRecordsResponseBodyDomainRecordsRecord()
                self.record.append(temp_model.from_map(k))
        return self


class DescribeSubDomainRecordsResponseBody(TeaModel):
    def __init__(
        self,
        domain_records: DescribeSubDomainRecordsResponseBodyDomainRecords = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The returned Domain Name System (DNS) records.
        self.domain_records = domain_records
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.domain_records:
            self.domain_records.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_records is not None:
            result['DomainRecords'] = self.domain_records.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainRecords') is not None:
            temp_model = DescribeSubDomainRecordsResponseBodyDomainRecords()
            self.domain_records = temp_model.from_map(m['DomainRecords'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSubDomainRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSubDomainRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSubDomainRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSupportLinesRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        user_client_ip: str = None,
    ):
        self.domain_name = domain_name
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class DescribeSupportLinesResponseBodyRecordLinesRecordLine(TeaModel):
    def __init__(
        self,
        father_code: str = None,
        line_code: str = None,
        line_display_name: str = None,
        line_name: str = None,
    ):
        # The code of the parent line. Currently, no data is returned.
        self.father_code = father_code
        # The code of the child line.
        self.line_code = line_code
        # The display name of the line.
        self.line_display_name = line_display_name
        # The name of the child line.
        self.line_name = line_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.father_code is not None:
            result['FatherCode'] = self.father_code
        if self.line_code is not None:
            result['LineCode'] = self.line_code
        if self.line_display_name is not None:
            result['LineDisplayName'] = self.line_display_name
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FatherCode') is not None:
            self.father_code = m.get('FatherCode')
        if m.get('LineCode') is not None:
            self.line_code = m.get('LineCode')
        if m.get('LineDisplayName') is not None:
            self.line_display_name = m.get('LineDisplayName')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class DescribeSupportLinesResponseBodyRecordLines(TeaModel):
    def __init__(
        self,
        record_line: List[DescribeSupportLinesResponseBodyRecordLinesRecordLine] = None,
    ):
        self.record_line = record_line

    def validate(self):
        if self.record_line:
            for k in self.record_line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordLine'] = []
        if self.record_line is not None:
            for k in self.record_line:
                result['RecordLine'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_line = []
        if m.get('RecordLine') is not None:
            for k in m.get('RecordLine'):
                temp_model = DescribeSupportLinesResponseBodyRecordLinesRecordLine()
                self.record_line.append(temp_model.from_map(k))
        return self


class DescribeSupportLinesResponseBody(TeaModel):
    def __init__(
        self,
        record_lines: DescribeSupportLinesResponseBodyRecordLines = None,
        request_id: str = None,
    ):
        # The Alibaba Cloud DNS lines.
        self.record_lines = record_lines
        self.request_id = request_id

    def validate(self):
        if self.record_lines:
            self.record_lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_lines is not None:
            result['RecordLines'] = self.record_lines.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordLines') is not None:
            temp_model = DescribeSupportLinesResponseBodyRecordLines()
            self.record_lines = temp_model.from_map(m['RecordLines'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSupportLinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSupportLinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSupportLinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        resource_type: str = None,
    ):
        # The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return per page. Default value: 200.
        self.page_size = page_size
        # The type of the resource. Valid values:
        # 
        # *   **DOMAIN**: domain name
        # 
        # This parameter is required.
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeTagsResponseBodyTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        values: List[str] = None,
    ):
        # The key of tag N added to the resource.
        self.key = key
        # The values of tags added to the resource.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeTagsResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        tags: List[DescribeTagsResponseBodyTags] = None,
        total_count: int = None,
    ):
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Default value: 200.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The tags added to the resource.
        self.tags = tags
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeTagsResponseBodyTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTransferDomainsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        from_user_id: int = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        target_user_id: int = None,
        transfer_type: str = None,
    ):
        # Specifies the domain name for which you want to view the transfer record.
        self.domain_name = domain_name
        # The user ID from which the domain name was transferred to the current account.
        self.from_user_id = from_user_id
        # The language.
        self.lang = lang
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Valid values: 1 to 100. Default value: 20.
        self.page_size = page_size
        # The user ID to which the domain name was transferred from the current account.
        self.target_user_id = target_user_id
        # The transfer type. Valid values:
        # 
        # *   IN: The domain name was transferred to the current account.
        # *   OUT: The domain name was transferred from the current account.
        # 
        # This parameter is required.
        self.transfer_type = transfer_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.from_user_id is not None:
            result['FromUserId'] = self.from_user_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        if self.transfer_type is not None:
            result['TransferType'] = self.transfer_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('FromUserId') is not None:
            self.from_user_id = m.get('FromUserId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        if m.get('TransferType') is not None:
            self.transfer_type = m.get('TransferType')
        return self


class DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        domain_name: str = None,
        from_user_id: int = None,
        id: int = None,
        target_user_id: int = None,
    ):
        # The time when the domain name was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the domain name was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_timestamp = create_timestamp
        # The domain name.
        self.domain_name = domain_name
        # The user ID from which the domain name was transferred.
        self.from_user_id = from_user_id
        # The ID of the domain name that was transferred.
        self.id = id
        # The user ID to which the domain name was transferred.
        self.target_user_id = target_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.from_user_id is not None:
            result['FromUserId'] = self.from_user_id
        if self.id is not None:
            result['Id'] = self.id
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('FromUserId') is not None:
            self.from_user_id = m.get('FromUserId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        return self


class DescribeTransferDomainsResponseBodyDomainTransfers(TeaModel):
    def __init__(
        self,
        domain_transfer: List[DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer] = None,
    ):
        self.domain_transfer = domain_transfer

    def validate(self):
        if self.domain_transfer:
            for k in self.domain_transfer:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainTransfer'] = []
        if self.domain_transfer is not None:
            for k in self.domain_transfer:
                result['DomainTransfer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_transfer = []
        if m.get('DomainTransfer') is not None:
            for k in m.get('DomainTransfer'):
                temp_model = DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer()
                self.domain_transfer.append(temp_model.from_map(k))
        return self


class DescribeTransferDomainsResponseBody(TeaModel):
    def __init__(
        self,
        domain_transfers: DescribeTransferDomainsResponseBodyDomainTransfers = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The domain names that were transferred between accounts.
        self.domain_transfers = domain_transfers
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: 1 to 100. Default value: 20.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.domain_transfers:
            self.domain_transfers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_transfers is not None:
            result['DomainTransfers'] = self.domain_transfers.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainTransfers') is not None:
            temp_model = DescribeTransferDomainsResponseBodyDomainTransfers()
            self.domain_transfers = temp_model.from_map(m['DomainTransfers'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTransferDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTransferDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTransferDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteGtmRecoveryPlanRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        recovery_plan_id: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: English.
        self.lang = lang
        # The ID of the disaster recovery plan.
        # 
        # This parameter is required.
        self.recovery_plan_id = recovery_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        return self


class ExecuteGtmRecoveryPlanResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExecuteGtmRecoveryPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteGtmRecoveryPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteGtmRecoveryPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMainDomainNameRequest(TeaModel):
    def __init__(
        self,
        input_string: str = None,
        lang: str = None,
    ):
        # The string. The string can be up to 128 characters in length.
        # 
        # This parameter is required.
        self.input_string = input_string
        # The language.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_string is not None:
            result['InputString'] = self.input_string
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputString') is not None:
            self.input_string = m.get('InputString')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class GetMainDomainNameResponseBody(TeaModel):
    def __init__(
        self,
        domain_level: int = None,
        domain_name: str = None,
        rr: str = None,
        request_id: str = None,
    ):
        # The level of the entered domain name.
        self.domain_level = domain_level
        # The domain name.
        self.domain_name = domain_name
        # The hostname.
        self.rr = rr
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_level is not None:
            result['DomainLevel'] = self.domain_level
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.rr is not None:
            result['RR'] = self.rr
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainLevel') is not None:
            self.domain_level = m.get('DomainLevel')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMainDomainNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMainDomainNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMainDomainNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTxtRecordForVerifyRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        type: str = None,
    ):
        # The ID of the Domain Name System (DNS) record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        self.domain_name = domain_name
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The feature verified by using the TXT record. Valid values:
        # 
        # *   ADD_SUB_DOMAIN: add a subdomain for verification.
        # *   RETRIEVAL: add other subdomains for verification
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTxtRecordForVerifyResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        parent_domain_name: str = None,
        rr: str = None,
        request_id: str = None,
        value: str = None,
    ):
        # The domain name.
        # 
        # >  If you do not specify this parameter, it is not returned.
        self.domain_name = domain_name
        # The top-level domain name.
        self.parent_domain_name = parent_domain_name
        # The hostname.
        self.rr = rr
        # The request ID.
        self.request_id = request_id
        # The record value.
        # 
        # >  The validity period is three days.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.parent_domain_name is not None:
            result['ParentDomainName'] = self.parent_domain_name
        if self.rr is not None:
            result['RR'] = self.rr
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ParentDomainName') is not None:
            self.parent_domain_name = m.get('ParentDomainName')
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTxtRecordForVerifyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTxtRecordForVerifyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTxtRecordForVerifyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudGtmAddressPoolsRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        client_token: str = None,
        enable_status: str = None,
        page_number: int = None,
        page_size: int = None,
        remark: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # Address pool name.
        self.address_pool_name = address_pool_name
        # The type of the address pool. Valid values:
        # 
        # *   IPv4: indicates that the service address to be resolved is an IPv4 address.
        # *   IPv6: indicates that the service address to be resolved is an IPv6 address.
        # *   domain: indicates that the service address to be resolved is a domain name.
        self.address_pool_type = address_pool_type
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The enabling state of the address pool. Valid values:
        # 
        # *   enable: The address pool is enabled.
        # *   disable: The address pool is disabled.
        self.enable_status = enable_status
        # Current page number, starting at **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.
        self.page_size = page_size
        # The additional description of the address pool.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask(TeaModel):
    def __init__(
        self,
        port: int = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.
        self.port = port
        # The ID of the health check template.
        self.template_id = template_id
        # Health check template name.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['Port'] = self.port
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks(TeaModel):
    def __init__(
        self,
        health_task: List[ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask] = None,
    ):
        self.health_task = health_task

    def validate(self):
        if self.health_task:
            for k in self.health_task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HealthTask'] = []
        if self.health_task is not None:
            for k in self.health_task:
                result['HealthTask'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.health_task = []
        if m.get('HealthTask') is not None:
            for k in m.get('HealthTask'):
                temp_model = ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask()
                self.health_task.append(temp_model.from_map(k))
        return self


class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource(TeaModel):
    def __init__(
        self,
        request_source: List[str] = None,
    ):
        self.request_source = request_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        return self


class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        health_tasks: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        request_source: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource = None,
        seq_non_preemptive_schedule: bool = None,
        serial_number: int = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
        weight_value: int = None,
    ):
        # IP address or domain name.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # Address ownership information, not supported in the current version.
        self.attribute_info = attribute_info
        # The failover mode that is used when address exceptions are identified. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        self.available_mode = available_mode
        # The availability state of the address. Valid values:
        # 
        # *   available: The address is available.
        # *   unavailable: The address is unavailable.
        self.available_status = available_status
        # Address creation time.
        self.create_time = create_time
        # Address creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Address enable status:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check state of the address. Valid values:
        # 
        # *   ok: The address passes all health checks of the referenced health check templates.
        # *   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
        # *   ok_no_monitor: The address does not reference any health check template and is normal.
        # *   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.
        self.health_status = health_status
        # The health check tasks.
        self.health_tasks = health_tasks
        # The availability state of the address when AvailableMode is set to manual for the address. Valid values:
        # 
        # *   available: The address is available. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is unavailable. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        self.name = name
        # Address remarks.
        self.remark = remark
        # List of request sources.
        self.request_source = request_source
        # Indicates whether the mode of the sequence policy for load balancing between address pools is non-preemptive. This parameter is available only for the multicloud integration scenario. Valid values:
        # 
        # *   true
        # *   false
        self.seq_non_preemptive_schedule = seq_non_preemptive_schedule
        # Sequence number, indicating the priority of address return, where smaller numbers have higher priority.
        self.serial_number = serial_number
        # Address type:
        # - IPv4: IPv4 address
        # - IPv6: IPv6 address
        # - domain: Domain name
        self.type = type
        # The last time the address was modified.
        self.update_time = update_time
        # The last modification time of the address (timestamp).
        self.update_timestamp = update_timestamp
        # Weight value (integer between 1 and 100), supports setting different weight values for each address, enabling resolution queries to return addresses according to the weight ratio.
        self.weight_value = weight_value

    def validate(self):
        if self.health_tasks:
            self.health_tasks.validate()
        if self.request_source:
            self.request_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.health_tasks is not None:
            result['HealthTasks'] = self.health_tasks.to_map()
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_source is not None:
            result['RequestSource'] = self.request_source.to_map()
        if self.seq_non_preemptive_schedule is not None:
            result['SeqNonPreemptiveSchedule'] = self.seq_non_preemptive_schedule
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('HealthTasks') is not None:
            temp_model = ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks()
            self.health_tasks = temp_model.from_map(m['HealthTasks'])
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestSource') is not None:
            temp_model = ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource()
            self.request_source = temp_model.from_map(m['RequestSource'])
        if m.get('SeqNonPreemptiveSchedule') is not None:
            self.seq_non_preemptive_schedule = m.get('SeqNonPreemptiveSchedule')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses(TeaModel):
    def __init__(
        self,
        address: List[ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress] = None,
    ):
        self.address = address

    def validate(self):
        if self.address:
            for k in self.address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Address'] = []
        if self.address is not None:
            for k in self.address:
                result['Address'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address = []
        if m.get('Address') is not None:
            for k in m.get('Address'):
                temp_model = ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress()
                self.address.append(temp_model.from_map(k))
        return self


class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool(TeaModel):
    def __init__(
        self,
        address_lb_strategy: str = None,
        address_pool_id: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        addresses: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        remark: str = None,
        sequence_lb_strategy_mode: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # Load balancing policy among addresses in the address pool:
        # - round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned. The order of all addresses is rotated each time.
        # - sequence: Sequential, for any source of DNS resolution requests, the address with the smaller sequence number (the sequence number indicates the priority of address returns, with smaller numbers having higher priority) is returned. If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
        # - weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the ratio of weights in resolution queries.
        # - source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.
        self.address_lb_strategy = address_lb_strategy
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name.
        self.address_pool_name = address_pool_name
        # Address pool type:
        # - IPv4
        # - IPv6
        # - domain
        self.address_pool_type = address_pool_type
        # The addresses.
        self.addresses = addresses
        # The availability state of the address pool. Valid values:
        # 
        # *   Available: The address pool is available.
        # *   unavailable: The address pool is unavailable.
        self.available_status = available_status
        # Address pool creation time.
        self.create_time = create_time
        # Address pool creation time (timestamp).
        self.create_timestamp = create_timestamp
        # The enabling state of the address pool. Valid values:
        # 
        # *   enable: The address pool is enabled.
        # *   disable: The address pool is disabled.
        self.enable_status = enable_status
        # The condition for determining the health state of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health state of the address pool. Valid values:
        # 
        # *   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
        # *   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this state, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
        # *   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.
        self.health_status = health_status
        # Remark
        self.remark = remark
        # The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
        # *   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Last modification time of the address pool.
        self.update_time = update_time
        # Last modification time of the address pool (timestamp).
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.addresses:
            self.addresses.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_lb_strategy is not None:
            result['AddressLbStrategy'] = self.address_lb_strategy
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.addresses is not None:
            result['Addresses'] = self.addresses.to_map()
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressLbStrategy') is not None:
            self.address_lb_strategy = m.get('AddressLbStrategy')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('Addresses') is not None:
            temp_model = ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses()
            self.addresses = temp_model.from_map(m['Addresses'])
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class ListCloudGtmAddressPoolsResponseBodyAddressPools(TeaModel):
    def __init__(
        self,
        address_pool: List[ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool] = None,
    ):
        self.address_pool = address_pool

    def validate(self):
        if self.address_pool:
            for k in self.address_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddressPool'] = []
        if self.address_pool is not None:
            for k in self.address_pool:
                result['AddressPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address_pool = []
        if m.get('AddressPool') is not None:
            for k in m.get('AddressPool'):
                temp_model = ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool()
                self.address_pool.append(temp_model.from_map(k))
        return self


class ListCloudGtmAddressPoolsResponseBody(TeaModel):
    def __init__(
        self,
        address_pools: ListCloudGtmAddressPoolsResponseBodyAddressPools = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The address pools.
        self.address_pools = address_pools
        # Current page number, starting at **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Total number of entries in the address pool.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.address_pools:
            self.address_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pools is not None:
            result['AddressPools'] = self.address_pools.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPools') is not None:
            temp_model = ListCloudGtmAddressPoolsResponseBodyAddressPools()
            self.address_pools = temp_model.from_map(m['AddressPools'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class ListCloudGtmAddressPoolsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudGtmAddressPoolsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudGtmAddressPoolsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudGtmAddressesRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address: str = None,
        address_id: str = None,
        client_token: str = None,
        enable_status: str = None,
        health_status: str = None,
        monitor_template_id: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        type: str = None,
    ):
        # Return language value, options:
        # - zh-CN: Chinese.
        # - en-US: English.
        self.accept_language = accept_language
        # IP address or domain name.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # Indicates the current availability of the address:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The health check state of the address. Valid values:
        # 
        # *   ok: The address passes all health checks of the referenced health check templates.
        # *   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
        # *   ok_no_monitor: The address does not reference a health check template.
        # *   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.
        self.health_status = health_status
        # The ID of the health check template. This ID uniquely identifies the health check template.
        self.monitor_template_id = monitor_template_id
        # Address name.
        self.name = name
        # Current page number, starting from **1**, default is **1**.
        # 
        # This parameter is required.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        # 
        # This parameter is required.
        self.page_size = page_size
        # Address type:
        # - IPv4
        # - IPv6
        # - domain
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.monitor_template_id is not None:
            result['MonitorTemplateId'] = self.monitor_template_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('MonitorTemplateId') is not None:
            self.monitor_template_id = m.get('MonitorTemplateId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask(TeaModel):
    def __init__(
        self,
        monitor_status: str = None,
        port: int = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The state of the health check task. Valid values:
        # 
        # *   ok: The task is normal.
        # *   alert: An alert is triggered.
        # *   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.
        self.monitor_status = monitor_status
        # The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.
        self.port = port
        # The ID of the health check template associated with the address.
        self.template_id = template_id
        # Health check template name.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.port is not None:
            result['Port'] = self.port
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks(TeaModel):
    def __init__(
        self,
        health_task: List[ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask] = None,
    ):
        self.health_task = health_task

    def validate(self):
        if self.health_task:
            for k in self.health_task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HealthTask'] = []
        if self.health_task is not None:
            for k in self.health_task:
                result['HealthTask'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.health_task = []
        if m.get('HealthTask') is not None:
            for k in m.get('HealthTask'):
                temp_model = ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask()
                self.health_task.append(temp_model.from_map(k))
        return self


class ListCloudGtmAddressesResponseBodyAddressesAddress(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        health_tasks: ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # IP address or domain name.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # Address ownership information.
        self.attribute_info = attribute_info
        # The failover method that is used if the address fails health checks. Valid values:
        # 
        # auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # 
        # manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        self.available_mode = available_mode
        # The availability state of the address. Valid values:
        # 
        # *   available: The address is available.
        # *   unavailable: The address is unavailable.
        self.available_status = available_status
        # Address creation time.
        self.create_time = create_time
        # Creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Indicates the current availability of the address:
        # - enable: Enabled status 
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check state of the address. Valid values:
        # 
        # *   ok: The address passes all health checks of the referenced health check templates.
        # *   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
        # *   ok_no_monitor: The address does not reference a health check template.
        # *   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.
        self.health_status = health_status
        # The health check tasks referenced by the address.
        self.health_tasks = health_tasks
        # The availability state of the address when AvailableMode is set to manual. Valid values:
        # 
        # available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # 
        # unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        self.name = name
        # Remarks.
        self.remark = remark
        # Address type:
        # - IPv4
        # - IPv6
        # - domain
        self.type = type
        # Address modification time.
        self.update_time = update_time
        # Update time (timestamp).
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.health_tasks:
            self.health_tasks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.health_tasks is not None:
            result['HealthTasks'] = self.health_tasks.to_map()
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('HealthTasks') is not None:
            temp_model = ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks()
            self.health_tasks = temp_model.from_map(m['HealthTasks'])
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class ListCloudGtmAddressesResponseBodyAddresses(TeaModel):
    def __init__(
        self,
        address: List[ListCloudGtmAddressesResponseBodyAddressesAddress] = None,
    ):
        self.address = address

    def validate(self):
        if self.address:
            for k in self.address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Address'] = []
        if self.address is not None:
            for k in self.address:
                result['Address'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address = []
        if m.get('Address') is not None:
            for k in m.get('Address'):
                temp_model = ListCloudGtmAddressesResponseBodyAddressesAddress()
                self.address.append(temp_model.from_map(k))
        return self


class ListCloudGtmAddressesResponseBody(TeaModel):
    def __init__(
        self,
        addresses: ListCloudGtmAddressesResponseBodyAddresses = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The addresses.
        self.addresses = addresses
        # Current page number, starting from **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Get the total number of addresses in the address list.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.addresses:
            self.addresses.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addresses is not None:
            result['Addresses'] = self.addresses.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Addresses') is not None:
            temp_model = ListCloudGtmAddressesResponseBodyAddresses()
            self.addresses = temp_model.from_map(m['Addresses'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class ListCloudGtmAddressesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudGtmAddressesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudGtmAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudGtmAlertLogsRequest(TeaModel):
    def __init__(
        self,
        action_type: str = None,
        end_timestamp: int = None,
        entity_type: str = None,
        keyword: str = None,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        start_timestamp: int = None,
    ):
        # Alert type:
        # - ALERT
        # - RESUME
        self.action_type = action_type
        # The end time of the query (timestamp).
        # 
        # This parameter is required.
        self.end_timestamp = end_timestamp
        # Alarm object types:
        # - GTM_ADDRESS: Address
        # - GTM_ADDRESS_POOL: Address Pool
        # - GTM_INSTANCE: Instance
        # - GTM_MONITOR_TEMPLATE: Health Check Template
        self.entity_type = entity_type
        # Search keyword, usually an address ID, address pool ID, domain information, etc.
        self.keyword = keyword
        # Language type of the returned information:
        # - zh-CN: Chinese
        # - en-US: English
        self.lang = lang
        # Current page number, starting from **1**, default is **1**.
        # 
        # This parameter is required.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The start time of the query (timestamp).
        # 
        # This parameter is required.
        self.start_timestamp = start_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.end_timestamp is not None:
            result['EndTimestamp'] = self.end_timestamp
        if self.entity_type is not None:
            result['EntityType'] = self.entity_type
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_timestamp is not None:
            result['StartTimestamp'] = self.start_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('EndTimestamp') is not None:
            self.end_timestamp = m.get('EndTimestamp')
        if m.get('EntityType') is not None:
            self.entity_type = m.get('EntityType')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTimestamp') is not None:
            self.start_timestamp = m.get('StartTimestamp')
        return self


class ListCloudGtmAlertLogsResponseBodyLogsLog(TeaModel):
    def __init__(
        self,
        action_type: str = None,
        content: str = None,
        entity_type: str = None,
        timestamp: int = None,
    ):
        # Alert type:
        # - ALERT
        # - RESUME
        self.action_type = action_type
        # The alert content.
        self.content = content
        # Alarm object types:
        # - GTM_ADDRESS: Address
        # - GTM_ADDRESS_POOL: Address Pool
        # - GTM_INSTANCE: Instance
        # - GTM_MONITOR_TEMPLATE: Health Check Template
        self.entity_type = entity_type
        # Alert log time (timestamp).
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.content is not None:
            result['Content'] = self.content
        if self.entity_type is not None:
            result['EntityType'] = self.entity_type
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EntityType') is not None:
            self.entity_type = m.get('EntityType')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class ListCloudGtmAlertLogsResponseBodyLogs(TeaModel):
    def __init__(
        self,
        log: List[ListCloudGtmAlertLogsResponseBodyLogsLog] = None,
    ):
        self.log = log

    def validate(self):
        if self.log:
            for k in self.log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Log'] = []
        if self.log is not None:
            for k in self.log:
                result['Log'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log = []
        if m.get('Log') is not None:
            for k in m.get('Log'):
                temp_model = ListCloudGtmAlertLogsResponseBodyLogsLog()
                self.log.append(temp_model.from_map(k))
        return self


class ListCloudGtmAlertLogsResponseBody(TeaModel):
    def __init__(
        self,
        logs: ListCloudGtmAlertLogsResponseBodyLogs = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The alert logs.
        self.logs = logs
        # Current page number, starting from 1, default is 1.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Total number of alarm log entries.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.logs:
            self.logs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logs is not None:
            result['Logs'] = self.logs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logs') is not None:
            temp_model = ListCloudGtmAlertLogsResponseBodyLogs()
            self.logs = temp_model.from_map(m['Logs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class ListCloudGtmAlertLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudGtmAlertLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudGtmAlertLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudGtmAvailableAlertGroupsRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US**: English
        self.accept_language = accept_language

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        return self


class ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup(TeaModel):
    def __init__(
        self,
        group_name: str = None,
    ):
        # The name of the alert contact group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups(TeaModel):
    def __init__(
        self,
        alert_group: List[ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup] = None,
    ):
        self.alert_group = alert_group

    def validate(self):
        if self.alert_group:
            for k in self.alert_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertGroup'] = []
        if self.alert_group is not None:
            for k in self.alert_group:
                result['AlertGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_group = []
        if m.get('AlertGroup') is not None:
            for k in m.get('AlertGroup'):
                temp_model = ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup()
                self.alert_group.append(temp_model.from_map(k))
        return self


class ListCloudGtmAvailableAlertGroupsResponseBody(TeaModel):
    def __init__(
        self,
        alert_groups: ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups = None,
        request_id: str = None,
    ):
        # The alert contact groups.
        self.alert_groups = alert_groups
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.alert_groups:
            self.alert_groups.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_groups is not None:
            result['AlertGroups'] = self.alert_groups.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertGroups') is not None:
            temp_model = ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups()
            self.alert_groups = temp_model.from_map(m['AlertGroups'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCloudGtmAvailableAlertGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudGtmAvailableAlertGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudGtmAvailableAlertGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudGtmInstanceConfigsRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        enable_status: str = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        remark: str = None,
        schedule_domain_name: str = None,
        schedule_zone_name: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable: The access domain name is enabled and the intelligent scheduling policy of the GTM instance takes effect.
        # *   disable: The access domain name is disabled and the intelligent scheduling policy of the GTM instance does not take effect.
        self.enable_status = enable_status
        # The ID of the GTM 3.0 instance.
        self.instance_id = instance_id
        # Current page number, starting at **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.
        self.page_size = page_size
        # Remarks.
        self.remark = remark
        # The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.
        self.schedule_domain_name = schedule_domain_name
        # The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.
        self.schedule_zone_name = schedule_zone_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        return self


class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource(TeaModel):
    def __init__(
        self,
        request_source: List[str] = None,
    ):
        self.request_source = request_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        return self


class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool(TeaModel):
    def __init__(
        self,
        address_lb_strategy: str = None,
        address_pool_id: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        request_source: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource = None,
        seq_non_preemptive_schedule: bool = None,
        sequence_lb_strategy_mode: str = None,
        serial_number: int = None,
        update_time: str = None,
        update_timestamp: int = None,
        weight_value: int = None,
    ):
        # Load balancing policy among addresses in the address pool:
        # - round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates the order of all addresses each time.
        # - sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, the smaller the higher the priority). If the address with the smaller sequence number is unavailable, return the next address with a smaller sequence number.
        # - weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
        # - source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.
        self.address_lb_strategy = address_lb_strategy
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name.
        self.address_pool_name = address_pool_name
        # Address pool type:
        # - IPv4
        # - IPv6
        # - domain
        self.address_pool_type = address_pool_type
        # Address pool availability status:
        # - available: Available
        # - unavailable: Unavailable
        self.available_status = available_status
        # Address pool creation time.
        self.create_time = create_time
        # Address pool creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Address pool status:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The health state of the address pool. Valid values:
        # 
        # *   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
        # *   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
        # *   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.
        self.health_judgement = health_judgement
        # The health state of the address pool. Valid values:
        # 
        # *   ok: The health state of the address pool is Normal and all addresses that are referenced by the address pool are available.
        # *   ok_alert: The health state of the address pool is Warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
        # *   exceptional: The health state of the address pool is Abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.
        self.health_status = health_status
        # Parse the request source list.
        self.request_source = request_source
        # Indicates whether the mode of the sequence policy for load balancing between address pools is non-preemptive. This parameter is available only for the multicloud integration scenario. Valid values:
        # 
        # *   true
        # *   false
        self.seq_non_preemptive_schedule = seq_non_preemptive_schedule
        # The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
        # *   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Sequence number. For any parsing request, the address pool with the smaller sequence number (indicating the priority of the address pool returned, with smaller numbers having higher priority) is returned.
        self.serial_number = serial_number
        # Last modification time of the address pool.
        self.update_time = update_time
        # Last modification time of the address pool (timestamp).
        self.update_timestamp = update_timestamp
        # Weight value (an integer between 1 and 100, including both 1 and 100), which supports setting different weight values for each address pool, enabling the resolution query to return address pools according to the weighted ratio.
        self.weight_value = weight_value

    def validate(self):
        if self.request_source:
            self.request_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_lb_strategy is not None:
            result['AddressLbStrategy'] = self.address_lb_strategy
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.request_source is not None:
            result['RequestSource'] = self.request_source.to_map()
        if self.seq_non_preemptive_schedule is not None:
            result['SeqNonPreemptiveSchedule'] = self.seq_non_preemptive_schedule
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressLbStrategy') is not None:
            self.address_lb_strategy = m.get('AddressLbStrategy')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('RequestSource') is not None:
            temp_model = ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource()
            self.request_source = temp_model.from_map(m['RequestSource'])
        if m.get('SeqNonPreemptiveSchedule') is not None:
            self.seq_non_preemptive_schedule = m.get('SeqNonPreemptiveSchedule')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools(TeaModel):
    def __init__(
        self,
        address_pool: List[ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool] = None,
    ):
        self.address_pool = address_pool

    def validate(self):
        if self.address_pool:
            for k in self.address_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddressPool'] = []
        if self.address_pool is not None:
            for k in self.address_pool:
                result['AddressPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address_pool = []
        if m.get('AddressPool') is not None:
            for k in m.get('AddressPool'):
                temp_model = ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool()
                self.address_pool.append(temp_model.from_map(k))
        return self


class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig(TeaModel):
    def __init__(
        self,
        address_pool_lb_strategy: str = None,
        address_pools: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools = None,
        available_status: str = None,
        commodity_code: str = None,
        config_id: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_status: str = None,
        instance_id: str = None,
        remark: str = None,
        schedule_domain_name: str = None,
        schedule_hostname: str = None,
        schedule_rr_type: str = None,
        schedule_zone_mode: str = None,
        schedule_zone_name: str = None,
        sequence_lb_strategy_mode: str = None,
        ttl: int = None,
        update_time: str = None,
        update_timestamp: int = None,
        version_code: str = None,
    ):
        # The policy for load balancing between address pools. Valid values:
        # 
        # *   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
        # *   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
        # *   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
        # *   source_nearest: GTM returns different address pools based on the sources of DNS requests. This way, users can access nearby addresses.
        self.address_pool_lb_strategy = address_pool_lb_strategy
        # The address pools.
        self.address_pools = address_pools
        # The availability state of the access domain name. Valid values:
        # 
        # *   available: If the access domain name is **enabled** and the health state of the access domain name is **Normal**, the access domain name is deemed **Available**.
        # *   unavailable: If the access domain name is **disabled** or the health state of the access domain name is **Abnormal**, the access domain name is deemed **Unavailable**.
        self.available_status = available_status
        # The commodity code. Valid values:
        # 
        # *   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
        # *   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)
        self.commodity_code = commodity_code
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        self.config_id = config_id
        # Instance configuration creation time.
        self.create_time = create_time
        # Instance creation time (timestamp).
        self.create_timestamp = create_timestamp
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable: The access domain name is enabled and the intelligent scheduling policy of the GTM instance takes effect.
        # *   disable: The access domain name is disabled and the intelligent scheduling policy of the GTM instance does not take effect.
        self.enable_status = enable_status
        # The health state of the access domain name. Valid values:
        # 
        # *   ok: The health state of the access domain name is Normal and all address pools that are referenced by the access domain name are available.
        # *   ok_alert: The health state of the access domain name is Warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, available address pools are normally used for DNS resolution, but unavailable address pools cannot be used for DNS resolution.
        # *   exceptional: The health state of the access domain name is Abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.
        self.health_status = health_status
        # The ID of the GTM 3.0 instance.
        self.instance_id = instance_id
        # Remarks on the configuration of domain instance.
        self.remark = remark
        # The GTM access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.
        self.schedule_domain_name = schedule_domain_name
        # Host record of the domain accessed by GTM.
        self.schedule_hostname = schedule_hostname
        # DNS record types for the scheduling domain:
        # - A: IPv4 address
        # - AAAA: IPv6 address
        # - CNAME: Domain name
        self.schedule_rr_type = schedule_rr_type
        # The allocation mode of the access domain name. Valid values:
        # 
        # *   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone within the account to which the GTM instance belongs to generate an access domain name.
        # *   sys_assign: system allocation. This mode is not supported. Do not set ScheduleZoneMode to sys_assign.
        self.schedule_zone_mode = schedule_zone_mode
        # The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.
        self.schedule_zone_name = schedule_zone_name
        # The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
        # *   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Global TTL (in seconds), the TTL value for domain resolution to addresses in the address pool, affecting the caching time of DNS records in the ISP\\"s LocalDNS. Supports custom TTL values.
        self.ttl = ttl
        # The last modified time of the instance configuration.
        self.update_time = update_time
        # The last modification time of the instance configuration (timestamp).
        self.update_timestamp = update_timestamp
        # The edition of the GTM 3.0 instance. Valid values:
        # 
        # *   standard: Standard Edition
        # *   ultimate: Ultimate Edition
        self.version_code = version_code

    def validate(self):
        if self.address_pools:
            self.address_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_lb_strategy is not None:
            result['AddressPoolLbStrategy'] = self.address_pool_lb_strategy
        if self.address_pools is not None:
            result['AddressPools'] = self.address_pools.to_map()
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.schedule_hostname is not None:
            result['ScheduleHostname'] = self.schedule_hostname
        if self.schedule_rr_type is not None:
            result['ScheduleRrType'] = self.schedule_rr_type
        if self.schedule_zone_mode is not None:
            result['ScheduleZoneMode'] = self.schedule_zone_mode
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolLbStrategy') is not None:
            self.address_pool_lb_strategy = m.get('AddressPoolLbStrategy')
        if m.get('AddressPools') is not None:
            temp_model = ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools()
            self.address_pools = temp_model.from_map(m['AddressPools'])
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('ScheduleHostname') is not None:
            self.schedule_hostname = m.get('ScheduleHostname')
        if m.get('ScheduleRrType') is not None:
            self.schedule_rr_type = m.get('ScheduleRrType')
        if m.get('ScheduleZoneMode') is not None:
            self.schedule_zone_mode = m.get('ScheduleZoneMode')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs(TeaModel):
    def __init__(
        self,
        instance_config: List[ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig] = None,
    ):
        self.instance_config = instance_config

    def validate(self):
        if self.instance_config:
            for k in self.instance_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceConfig'] = []
        if self.instance_config is not None:
            for k in self.instance_config:
                result['InstanceConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_config = []
        if m.get('InstanceConfig') is not None:
            for k in m.get('InstanceConfig'):
                temp_model = ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig()
                self.instance_config.append(temp_model.from_map(k))
        return self


class ListCloudGtmInstanceConfigsResponseBody(TeaModel):
    def __init__(
        self,
        instance_configs: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The configurations of the instance.
        self.instance_configs = instance_configs
        # Current page number, starting from **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Total number of entries for domain instance configurations.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.instance_configs:
            self.instance_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_configs is not None:
            result['InstanceConfigs'] = self.instance_configs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceConfigs') is not None:
            temp_model = ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs()
            self.instance_configs = temp_model.from_map(m['InstanceConfigs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class ListCloudGtmInstanceConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudGtmInstanceConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudGtmInstanceConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudGtmInstancesRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        instance_id: str = None,
        instance_name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # Return language value. Options:
        # - zh-CN: Chinese.
        # - en-US: English.
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The ID of the GTM instance.
        self.instance_id = instance_id
        # Instance name, used to distinguish the business purpose of the instance.
        self.instance_name = instance_name
        # Current page number, starting from **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListCloudGtmInstancesResponseBodyInstancesInstance(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        expire_time: str = None,
        expire_timestamp: int = None,
        instance_id: str = None,
        instance_name: str = None,
        monitor_task_quota: int = None,
        monthly_email_used: int = None,
        monthly_sms_quota: int = None,
        monthly_sms_used: int = None,
        monthly_webhook_used: int = None,
        schedule_domain_name: str = None,
        update_time: str = None,
        update_timestamp: int = None,
        version_code: str = None,
    ):
        # The commodity code. Valid values:
        # 
        # *   dns_gtm_public_cn: commodity code on the China site (aliyun.com)
        # *   dns_gtm_public_intl: commodity code on the international site (alibabacloud.com)
        self.commodity_code = commodity_code
        # Instance creation time.
        self.create_time = create_time
        # Instance creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Instance expiration time.
        self.expire_time = expire_time
        # Instance expiration time (timestamp).
        self.expire_timestamp = expire_timestamp
        # The ID of the GTM instance.
        self.instance_id = instance_id
        # Instance name.
        self.instance_name = instance_name
        # Monitor probe task quota.
        self.monitor_task_quota = monitor_task_quota
        # Monthly email sending volume.
        self.monthly_email_used = monthly_email_used
        # SMS quota, only supported on the China site as international sites do not support SMS.
        self.monthly_sms_quota = monthly_sms_quota
        # Monthly SMS sending volume, only supported by the China site as international sites do not support SMS.
        self.monthly_sms_used = monthly_sms_used
        # Monthly webhook send volume.
        self.monthly_webhook_used = monthly_webhook_used
        # The access domain name, which consists of a hostname and a zone or a subzone.
        self.schedule_domain_name = schedule_domain_name
        # The last time the instance was modified.
        self.update_time = update_time
        # The last modification time of the instance (timestamp).
        self.update_timestamp = update_timestamp
        # GTM instance version:
        # - standard: Standard Edition
        # - ultimate: Ultimate Edition
        self.version_code = version_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.expire_timestamp is not None:
            result['ExpireTimestamp'] = self.expire_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.monitor_task_quota is not None:
            result['MonitorTaskQuota'] = self.monitor_task_quota
        if self.monthly_email_used is not None:
            result['MonthlyEmailUsed'] = self.monthly_email_used
        if self.monthly_sms_quota is not None:
            result['MonthlySmsQuota'] = self.monthly_sms_quota
        if self.monthly_sms_used is not None:
            result['MonthlySmsUsed'] = self.monthly_sms_used
        if self.monthly_webhook_used is not None:
            result['MonthlyWebhookUsed'] = self.monthly_webhook_used
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ExpireTimestamp') is not None:
            self.expire_timestamp = m.get('ExpireTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('MonitorTaskQuota') is not None:
            self.monitor_task_quota = m.get('MonitorTaskQuota')
        if m.get('MonthlyEmailUsed') is not None:
            self.monthly_email_used = m.get('MonthlyEmailUsed')
        if m.get('MonthlySmsQuota') is not None:
            self.monthly_sms_quota = m.get('MonthlySmsQuota')
        if m.get('MonthlySmsUsed') is not None:
            self.monthly_sms_used = m.get('MonthlySmsUsed')
        if m.get('MonthlyWebhookUsed') is not None:
            self.monthly_webhook_used = m.get('MonthlyWebhookUsed')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class ListCloudGtmInstancesResponseBodyInstances(TeaModel):
    def __init__(
        self,
        instance: List[ListCloudGtmInstancesResponseBodyInstancesInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = ListCloudGtmInstancesResponseBodyInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class ListCloudGtmInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instances: ListCloudGtmInstancesResponseBodyInstances = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The instances.
        self.instances = instances
        # Current page number, starting with **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Total number of instance entries.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Instances') is not None:
            temp_model = ListCloudGtmInstancesResponseBodyInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class ListCloudGtmInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudGtmInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudGtmInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudGtmMonitorNodesRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US** (default): English
        self.accept_language = accept_language

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        return self


class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps(TeaModel):
    def __init__(
        self,
        ip: List[str] = None,
    ):
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        return self


class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        country_code: str = None,
        country_name: str = None,
        default_selected: bool = None,
        group_name: str = None,
        group_type: str = None,
        ips: ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps = None,
        isp_code: str = None,
        isp_name: str = None,
        node_id: str = None,
    ):
        # City code.
        self.city_code = city_code
        # City name.
        self.city_name = city_name
        # Country code.
        self.country_code = country_code
        # Country name.
        self.country_name = country_name
        # Monitor node default selection:
        # - true: Selected by default
        # - false: Not selected by default
        self.default_selected = default_selected
        # Monitor probe group name.
        self.group_name = group_name
        # Monitoring node group type, currently supported:
        # - BGP: BGP node
        # - OVERSEAS: International node
        # - ISP: Carrier node
        self.group_type = group_type
        # List of node IP addresses.
        self.ips = ips
        # Operator code.
        self.isp_code = isp_code
        # Operator name.
        self.isp_name = isp_name
        # Unique identifier ID of the probe node.
        self.node_id = node_id

    def validate(self):
        if self.ips:
            self.ips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.country_code is not None:
            result['CountryCode'] = self.country_code
        if self.country_name is not None:
            result['CountryName'] = self.country_name
        if self.default_selected is not None:
            result['DefaultSelected'] = self.default_selected
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.ips is not None:
            result['Ips'] = self.ips.to_map()
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('CountryCode') is not None:
            self.country_code = m.get('CountryCode')
        if m.get('CountryName') is not None:
            self.country_name = m.get('CountryName')
        if m.get('DefaultSelected') is not None:
            self.default_selected = m.get('DefaultSelected')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('Ips') is not None:
            temp_model = ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps()
            self.ips = temp_model.from_map(m['Ips'])
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes(TeaModel):
    def __init__(
        self,
        ipv_4isp_city_node: List[ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode] = None,
    ):
        self.ipv_4isp_city_node = ipv_4isp_city_node

    def validate(self):
        if self.ipv_4isp_city_node:
            for k in self.ipv_4isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv4IspCityNode'] = []
        if self.ipv_4isp_city_node is not None:
            for k in self.ipv_4isp_city_node:
                result['Ipv4IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ipv_4isp_city_node = []
        if m.get('Ipv4IspCityNode') is not None:
            for k in m.get('Ipv4IspCityNode'):
                temp_model = ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode()
                self.ipv_4isp_city_node.append(temp_model.from_map(k))
        return self


class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps(TeaModel):
    def __init__(
        self,
        ip: List[str] = None,
    ):
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        return self


class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        country_code: str = None,
        country_name: str = None,
        default_selected: bool = None,
        group_name: str = None,
        group_type: str = None,
        ips: ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps = None,
        isp_code: str = None,
        isp_name: str = None,
        node_id: str = None,
    ):
        # City code.
        self.city_code = city_code
        # City name.
        self.city_name = city_name
        # Country code.
        self.country_code = country_code
        # Country name.
        self.country_name = country_name
        # Monitor node default selection:
        # - true: Selected by default
        # - false: Not selected by default
        self.default_selected = default_selected
        # Monitoring probe group name.
        self.group_name = group_name
        # Monitoring node group type, currently supported:
        # - BGP: BGP node
        # - OVERSEAS: International node
        # - ISP: Carrier node
        self.group_type = group_type
        # List of node IP addresses.
        self.ips = ips
        # Operator code.
        self.isp_code = isp_code
        # Operator name.
        self.isp_name = isp_name
        # Unique identifier ID of the probe node.
        self.node_id = node_id

    def validate(self):
        if self.ips:
            self.ips.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.country_code is not None:
            result['CountryCode'] = self.country_code
        if self.country_name is not None:
            result['CountryName'] = self.country_name
        if self.default_selected is not None:
            result['DefaultSelected'] = self.default_selected
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.ips is not None:
            result['Ips'] = self.ips.to_map()
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('CountryCode') is not None:
            self.country_code = m.get('CountryCode')
        if m.get('CountryName') is not None:
            self.country_name = m.get('CountryName')
        if m.get('DefaultSelected') is not None:
            self.default_selected = m.get('DefaultSelected')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('Ips') is not None:
            temp_model = ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps()
            self.ips = temp_model.from_map(m['Ips'])
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes(TeaModel):
    def __init__(
        self,
        ipv_6isp_city_node: List[ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode] = None,
    ):
        self.ipv_6isp_city_node = ipv_6isp_city_node

    def validate(self):
        if self.ipv_6isp_city_node:
            for k in self.ipv_6isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6IspCityNode'] = []
        if self.ipv_6isp_city_node is not None:
            for k in self.ipv_6isp_city_node:
                result['Ipv6IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ipv_6isp_city_node = []
        if m.get('Ipv6IspCityNode') is not None:
            for k in m.get('Ipv6IspCityNode'):
                temp_model = ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode()
                self.ipv_6isp_city_node.append(temp_model.from_map(k))
        return self


class ListCloudGtmMonitorNodesResponseBody(TeaModel):
    def __init__(
        self,
        ipv_4isp_city_nodes: ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes = None,
        ipv_6isp_city_nodes: ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes = None,
        request_id: str = None,
    ):
        # Public IPv4 monitoring node list.
        self.ipv_4isp_city_nodes = ipv_4isp_city_nodes
        # List of public IPv6 monitoring nodes.
        self.ipv_6isp_city_nodes = ipv_6isp_city_nodes
        # Unique request identification code.
        self.request_id = request_id

    def validate(self):
        if self.ipv_4isp_city_nodes:
            self.ipv_4isp_city_nodes.validate()
        if self.ipv_6isp_city_nodes:
            self.ipv_6isp_city_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4isp_city_nodes is not None:
            result['Ipv4IspCityNodes'] = self.ipv_4isp_city_nodes.to_map()
        if self.ipv_6isp_city_nodes is not None:
            result['Ipv6IspCityNodes'] = self.ipv_6isp_city_nodes.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ipv4IspCityNodes') is not None:
            temp_model = ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes()
            self.ipv_4isp_city_nodes = temp_model.from_map(m['Ipv4IspCityNodes'])
        if m.get('Ipv6IspCityNodes') is not None:
            temp_model = ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes()
            self.ipv_6isp_city_nodes = temp_model.from_map(m['Ipv6IspCityNodes'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCloudGtmMonitorNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudGtmMonitorNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudGtmMonitorNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCloudGtmMonitorTemplatesRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        ip_version: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        protocol: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The IP address type of health check nodes. Valid values:
        # 
        # *   IPv4: applicable when health checks are performed on IPv4 addresses.
        # *   IPv6: applicable when health checks are performed on IPv6 addresses.
        self.ip_version = ip_version
        # The name of the health check probe template, which is recommended to be distinguishable for configuration personnel to differentiate and remember, ideally indicating the health check protocol.
        self.name = name
        # Current page number, starting from **1**, default is **1**.
        # 
        # This parameter is required.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        # 
        # This parameter is required.
        self.page_size = page_size
        # Protocol types for initiating probes to the target IP address:
        # - ping
        # - tcp
        # - http
        # - https
        self.protocol = protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.ip_version is not None:
            result['IpVersion'] = self.ip_version
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('IpVersion') is not None:
            self.ip_version = m.get('IpVersion')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        country_code: str = None,
        country_name: str = None,
        group_name: str = None,
        group_type: str = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        # City code.
        self.city_code = city_code
        # City name.
        self.city_name = city_name
        # Country code.
        self.country_code = country_code
        # Country name.
        self.country_name = country_name
        # Probe node group name.
        self.group_name = group_name
        # Probe node group types:
        # - BGP: BGP nodes
        # - OVERSEAS: International nodes
        # - ISP: Carrier nodes
        self.group_type = group_type
        # Operator code.
        self.isp_code = isp_code
        # Operator name.
        self.isp_name = isp_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.country_code is not None:
            result['CountryCode'] = self.country_code
        if self.country_name is not None:
            result['CountryName'] = self.country_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('CountryCode') is not None:
            self.country_code = m.get('CountryCode')
        if m.get('CountryName') is not None:
            self.country_name = m.get('CountryName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes(TeaModel):
    def __init__(
        self,
        isp_city_node: List[ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode] = None,
    ):
        self.isp_city_node = isp_city_node

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        return self


class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        evaluation_count: int = None,
        extend_info: str = None,
        failure_rate: int = None,
        interval: int = None,
        ip_version: str = None,
        isp_city_nodes: ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes = None,
        name: str = None,
        protocol: str = None,
        remark: str = None,
        template_id: str = None,
        timeout: int = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # Health check template creation time.
        self.create_time = create_time
        # Health check template creation time (timestamp).
        self.create_timestamp = create_timestamp
        # The number of retries. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry options are:
        # - 1 - 2 - 3
        self.evaluation_count = evaluation_count
        # The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.
        # 
        # *   HTTP or HTTPS:
        # 
        #     **host**: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.
        # 
        #     **path**: the URL for HTTP or HTTPS health checks. Default value: /.
        # 
        #     **code**: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:
        # 
        #     *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must specify an exact URL for path if you set code to 400.
        #     *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.
        # 
        #     **sni**: indicates whether Server Name Indication (SNI) is enabled. This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:
        # 
        #     *   true: SNI is enabled.
        #     *   false: SNI is disabled.
        # 
        #     **followRedirect**: indicates whether 3XX redirects are followed. Valid values:
        # 
        #     *   true: 3XX redirects are followed. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
        #     *   false: 3XX redirects are not followed.
        # 
        # *   ping:
        # 
        #     **packetNum**: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.
        # 
        #     **packetLossRate**: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.
        self.extend_info = extend_info
        # Percentage of selected node probe failures (%), that is, the percentage of unhealthy check points among total probe points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
        # - 20
        # - 50
        # - 80
        # - 100
        self.failure_rate = failure_rate
        # The time interval between each check (in seconds), with a default of probing once every minute. The minimum supported health check interval is 15 seconds, available for flagship edition instances.
        self.interval = interval
        # The IP address type of health check nodes. Valid values:
        # 
        # *   IPv4: applicable when health checks are performed on IPv4 addresses.
        # *   IPv6: applicable when health checks are performed on IPv6 addresses.
        self.ip_version = ip_version
        # The health check nodes. You can call the [ListCloudGtmMonitorNodes](~~ListCloudGtmMonitorNodes~~) operation to obtain the health check nodes.
        self.isp_city_nodes = isp_city_nodes
        # The name of the health check probe template, generally for the convenience of configuration personnel to distinguish and remember.
        self.name = name
        # Protocol types for initiating probes to the target IP address:
        # - ping
        # - tcp
        # - http
        # - https
        self.protocol = protocol
        # Remarks for the health check template.
        self.remark = remark
        # The ID of the health check template. This ID uniquely identifies the health check template.
        self.template_id = template_id
        # Probe timeout (in milliseconds), data packets not returned within the timeout period are deemed as health check timeouts:
        # - 2000
        # - 3000
        # - 5000
        # - 10000
        self.timeout = timeout
        # Last modification time of the health check template.
        self.update_time = update_time
        # Health check template configuration modification time (timestamp).
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.isp_city_nodes:
            self.isp_city_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.extend_info is not None:
            result['ExtendInfo'] = self.extend_info
        if self.failure_rate is not None:
            result['FailureRate'] = self.failure_rate
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.ip_version is not None:
            result['IpVersion'] = self.ip_version
        if self.isp_city_nodes is not None:
            result['IspCityNodes'] = self.isp_city_nodes.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('ExtendInfo') is not None:
            self.extend_info = m.get('ExtendInfo')
        if m.get('FailureRate') is not None:
            self.failure_rate = m.get('FailureRate')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IpVersion') is not None:
            self.ip_version = m.get('IpVersion')
        if m.get('IspCityNodes') is not None:
            temp_model = ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes()
            self.isp_city_nodes = temp_model.from_map(m['IspCityNodes'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class ListCloudGtmMonitorTemplatesResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        template: List[ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class ListCloudGtmMonitorTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        templates: ListCloudGtmMonitorTemplatesResponseBodyTemplates = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # Current page number, starting from 1, default is 1.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # The health check templates.
        self.templates = templates
        # Total number of health check template entries retrieved.
        self.total_items = total_items
        # Total number of pages after data pagination.
        self.total_pages = total_pages

    def validate(self):
        if self.templates:
            self.templates.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.templates is not None:
            result['Templates'] = self.templates.to_map()
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Templates') is not None:
            temp_model = ListCloudGtmMonitorTemplatesResponseBodyTemplates()
            self.templates = temp_model.from_map(m['Templates'])
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class ListCloudGtmMonitorTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCloudGtmMonitorTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCloudGtmMonitorTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTagResourcesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The key value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTagResourcesRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        next_token: str = None,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag: List[ListTagResourcesRequestTag] = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The ID of the resource.
        self.resource_id = resource_id
        # The type of the resource. Valid values:
        # 
        # *   **DOMAIN**: domain name
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ListTagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBodyTagResources(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The ID of the resource.
        self.resource_id = resource_id
        # The type of the resource. Only DOMAIN is returned.
        self.resource_type = resource_type
        # The tag key.
        self.tag_key = tag_key
        # The tag value.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListTagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        request_id: str = None,
        tag_resources: List[ListTagResourcesResponseBodyTagResources] = None,
    ):
        # A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # An array that consists of the resource and the tags that are added to the resource, including information such as the resource ID, resource type, tag keys, and tag values.
        self.tag_resources = tag_resources

    def validate(self):
        if self.tag_resources:
            for k in self.tag_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TagResources'] = []
        if self.tag_resources is not None:
            for k in self.tag_resources:
                result['TagResources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tag_resources = []
        if m.get('TagResources') is not None:
            for k in m.get('TagResources'):
                temp_model = ListTagResourcesResponseBodyTagResources()
                self.tag_resources.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHichinaDomainDNSRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        user_client_ip: str = None,
    ):
        # The domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en
        self.lang = lang
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class ModifyHichinaDomainDNSResponseBodyNewDnsServers(TeaModel):
    def __init__(
        self,
        dns_server: List[str] = None,
    ):
        self.dns_server = dns_server

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server is not None:
            result['DnsServer'] = self.dns_server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServer') is not None:
            self.dns_server = m.get('DnsServer')
        return self


class ModifyHichinaDomainDNSResponseBodyOriginalDnsServers(TeaModel):
    def __init__(
        self,
        dns_server: List[str] = None,
    ):
        self.dns_server = dns_server

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server is not None:
            result['DnsServer'] = self.dns_server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServer') is not None:
            self.dns_server = m.get('DnsServer')
        return self


class ModifyHichinaDomainDNSResponseBody(TeaModel):
    def __init__(
        self,
        new_dns_servers: ModifyHichinaDomainDNSResponseBodyNewDnsServers = None,
        original_dns_servers: ModifyHichinaDomainDNSResponseBodyOriginalDnsServers = None,
        request_id: str = None,
    ):
        # The DNS server names after modification.
        self.new_dns_servers = new_dns_servers
        # The DNS server names before modification.
        self.original_dns_servers = original_dns_servers
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.new_dns_servers:
            self.new_dns_servers.validate()
        if self.original_dns_servers:
            self.original_dns_servers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.new_dns_servers is not None:
            result['NewDnsServers'] = self.new_dns_servers.to_map()
        if self.original_dns_servers is not None:
            result['OriginalDnsServers'] = self.original_dns_servers.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NewDnsServers') is not None:
            temp_model = ModifyHichinaDomainDNSResponseBodyNewDnsServers()
            self.new_dns_servers = temp_model.from_map(m['NewDnsServers'])
        if m.get('OriginalDnsServers') is not None:
            temp_model = ModifyHichinaDomainDNSResponseBodyOriginalDnsServers()
            self.original_dns_servers = temp_model.from_map(m['OriginalDnsServers'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyHichinaDomainDNSResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyHichinaDomainDNSResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHichinaDomainDNSResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveDomainResourceGroupRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        new_resource_group_id: str = None,
        resource_id: str = None,
    ):
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The ID of the new resource group.
        # 
        # You can view the resource group ID in the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?).
        # 
        # This parameter is required.
        self.new_resource_group_id = new_resource_group_id
        # The domain name.
        # 
        # This parameter is required.
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.new_resource_group_id is not None:
            result['NewResourceGroupId'] = self.new_resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NewResourceGroupId') is not None:
            self.new_resource_group_id = m.get('NewResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class MoveDomainResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class MoveDomainResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveDomainResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveDomainResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveGtmResourceGroupRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        new_resource_group_id: str = None,
        resource_id: str = None,
    ):
        self.lang = lang
        # This parameter is required.
        self.new_resource_group_id = new_resource_group_id
        # This parameter is required.
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.new_resource_group_id is not None:
            result['NewResourceGroupId'] = self.new_resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NewResourceGroupId') is not None:
            self.new_resource_group_id = m.get('NewResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class MoveGtmResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class MoveGtmResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveGtmResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveGtmResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateBatchDomainRequestDomainRecordInfo(TeaModel):
    def __init__(
        self,
        domain: str = None,
        line: str = None,
        new_rr: str = None,
        new_type: str = None,
        new_value: str = None,
        priority: int = None,
        rr: str = None,
        ttl: int = None,
        type: str = None,
        value: str = None,
    ):
        # The domain name.
        # 
        # >  You can submit 1 to 1,000 domain names. Due to the limit on the length of HTTP request headers, excessive domain names are ignored. Do not enter more than 1,000 domain names.
        # 
        # This parameter is required.
        self.domain = domain
        # The DNS request source. Default value: default.
        self.line = line
        # The new hostname (used only for modification operations, not for external users).
        self.new_rr = new_rr
        # The new type of the DNS record (used only for modification operations, not for external users).
        self.new_type = new_type
        # The new value of the DNS record (used only for modification operations, not for external users).
        self.new_value = new_value
        # The priority of the mail exchanger (MX) record.
        # 
        # This parameter is required if the type of the DNS record is MX. Default value: 10.
        self.priority = priority
        # The hostname.
        # 
        # >  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.
        self.rr = rr
        # The time-to-live (TTL) value of the cached DNS record. Unit: seconds. Default value: ***600***.
        self.ttl = ttl
        # The type of the DNS record. Valid values: A, AAAA, TXT, MX, and CNAME.
        # 
        # >  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.
        self.type = type
        # The value of the DNS record.
        # 
        # >  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.line is not None:
            result['Line'] = self.line
        if self.new_rr is not None:
            result['NewRr'] = self.new_rr
        if self.new_type is not None:
            result['NewType'] = self.new_type
        if self.new_value is not None:
            result['NewValue'] = self.new_value
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.rr is not None:
            result['Rr'] = self.rr
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('NewRr') is not None:
            self.new_rr = m.get('NewRr')
        if m.get('NewType') is not None:
            self.new_type = m.get('NewType')
        if m.get('NewValue') is not None:
            self.new_value = m.get('NewValue')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Rr') is not None:
            self.rr = m.get('Rr')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class OperateBatchDomainRequest(TeaModel):
    def __init__(
        self,
        domain_record_info: List[OperateBatchDomainRequestDomainRecordInfo] = None,
        lang: str = None,
        type: str = None,
    ):
        # The DNS records. You can submit up to 1,000 DNS records.
        # 
        # This parameter is required.
        self.domain_record_info = domain_record_info
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: zh
        self.lang = lang
        # The type of the batch operation. Valid values:
        # 
        # *   **DOMAIN_ADD**: adds domain names in batches.
        # *   **DOMAIN_DEL**: deletes domain names in batches.
        # *   **RR_ADD**: adds DNS records in batches.
        # *   **RR_DEL**: deletes DNS records in batches. This operation deletes the DNS records with the specified hostname or record value. If you do not specify the Rr and Value parameters, this operation deletes the DNS records that are added for the specified domain names.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.domain_record_info:
            for k in self.domain_record_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainRecordInfo'] = []
        if self.domain_record_info is not None:
            for k in self.domain_record_info:
                result['DomainRecordInfo'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_record_info = []
        if m.get('DomainRecordInfo') is not None:
            for k in m.get('DomainRecordInfo'):
                temp_model = OperateBatchDomainRequestDomainRecordInfo()
                self.domain_record_info.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OperateBatchDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class OperateBatchDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateBatchDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateBatchDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PausePdnsServiceRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        service_type: str = None,
    ):
        self.lang = lang
        self.service_type = service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        return self


class PausePdnsServiceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PausePdnsServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PausePdnsServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PausePdnsServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PreviewGtmRecoveryPlanRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        page_number: int = None,
        page_size: int = None,
        recovery_plan_id: int = None,
    ):
        # The language used by the user.
        self.lang = lang
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on per page. Maximum value: **20**. Default value: **5**.
        self.page_size = page_size
        # The ID of the disaster recovery plan that you want to preview.
        # 
        # This parameter is required.
        self.recovery_plan_id = recovery_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        return self


class PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo(TeaModel):
    def __init__(
        self,
        content: str = None,
        strategy_name: str = None,
    ):
        # The formatted message content.
        self.content = content
        # The name of the switching policy for address pools.
        self.strategy_name = strategy_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos(TeaModel):
    def __init__(
        self,
        switch_info: List[PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo] = None,
    ):
        self.switch_info = switch_info

    def validate(self):
        if self.switch_info:
            for k in self.switch_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SwitchInfo'] = []
        if self.switch_info is not None:
            for k in self.switch_info:
                result['SwitchInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.switch_info = []
        if m.get('SwitchInfo') is not None:
            for k in m.get('SwitchInfo'):
                temp_model = PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo()
                self.switch_info.append(temp_model.from_map(k))
        return self


class PreviewGtmRecoveryPlanResponseBodyPreviewsPreview(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        name: str = None,
        switch_infos: PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos = None,
        user_domain_name: str = None,
    ):
        # The ID of the GTM instance to which the previewed disaster recovery plan belongs.
        self.instance_id = instance_id
        # The name of the GTM instance to which the previewed disaster recovery plan belongs.
        self.name = name
        # The returned information of the switching policies for address pools.
        self.switch_infos = switch_infos
        # The user\\"s domain name or domain name list.
        self.user_domain_name = user_domain_name

    def validate(self):
        if self.switch_infos:
            self.switch_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.switch_infos is not None:
            result['SwitchInfos'] = self.switch_infos.to_map()
        if self.user_domain_name is not None:
            result['UserDomainName'] = self.user_domain_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SwitchInfos') is not None:
            temp_model = PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos()
            self.switch_infos = temp_model.from_map(m['SwitchInfos'])
        if m.get('UserDomainName') is not None:
            self.user_domain_name = m.get('UserDomainName')
        return self


class PreviewGtmRecoveryPlanResponseBodyPreviews(TeaModel):
    def __init__(
        self,
        preview: List[PreviewGtmRecoveryPlanResponseBodyPreviewsPreview] = None,
    ):
        self.preview = preview

    def validate(self):
        if self.preview:
            for k in self.preview:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Preview'] = []
        if self.preview is not None:
            for k in self.preview:
                result['Preview'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.preview = []
        if m.get('Preview') is not None:
            for k in m.get('Preview'):
                temp_model = PreviewGtmRecoveryPlanResponseBodyPreviewsPreview()
                self.preview.append(temp_model.from_map(k))
        return self


class PreviewGtmRecoveryPlanResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        previews: PreviewGtmRecoveryPlanResponseBodyPreviews = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The returned preview information of the disaster recovery plan.
        self.previews = previews
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned on all pages.
        self.total_items = total_items
        # The total number of pages returned.
        self.total_pages = total_pages

    def validate(self):
        if self.previews:
            self.previews.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.previews is not None:
            result['Previews'] = self.previews.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Previews') is not None:
            temp_model = PreviewGtmRecoveryPlanResponseBodyPreviews()
            self.previews = temp_model.from_map(m['Previews'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class PreviewGtmRecoveryPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PreviewGtmRecoveryPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PreviewGtmRecoveryPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemovePdnsAppKeyRequest(TeaModel):
    def __init__(
        self,
        app_key_id: str = None,
        lang: str = None,
    ):
        self.app_key_id = app_key_id
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key_id is not None:
            result['AppKeyId'] = self.app_key_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppKeyId') is not None:
            self.app_key_id = m.get('AppKeyId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class RemovePdnsAppKeyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemovePdnsAppKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemovePdnsAppKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemovePdnsAppKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemovePdnsUdpIpSegmentRequest(TeaModel):
    def __init__(
        self,
        ip: str = None,
        lang: str = None,
    ):
        self.ip = ip
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class RemovePdnsUdpIpSegmentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemovePdnsUdpIpSegmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemovePdnsUdpIpSegmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemovePdnsUdpIpSegmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReplaceCloudGtmAddressPoolAddressRequestAddresses(TeaModel):
    def __init__(
        self,
        address_id: str = None,
        request_source: List[str] = None,
        serial_number: int = None,
        weight_value: int = None,
    ):
        # The ID of the new address. This ID uniquely identifies the address.
        # 
        # *   If you specify this parameter, the original addresses in the address pool will be deleted and replaced with new addresses.
        # *   If you do not specify this parameter, all addresses in the address pool will be deleted and the address pool will be left empty.
        self.address_id = address_id
        # The DNS request sources.
        self.request_source = request_source
        # The sequence number that specifies the priority for returning the new address. A smaller sequence number specifies a higher priority. This setting takes effect for new addresses.
        self.serial_number = serial_number
        # The weight value of the new address. You can set a different weight value for each address. This way, addresses are returned based on the weight values for Domain Name System (DNS) requests. A weight value must be an integer that ranges from 1 to 100. This setting takes effect for new addresses.
        self.weight_value = weight_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class ReplaceCloudGtmAddressPoolAddressRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_id: str = None,
        addresses: List[ReplaceCloudGtmAddressPoolAddressRequestAddresses] = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US (default)**: English
        self.accept_language = accept_language
        # The ID of the address pool for which you want to replace addresses. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # The addresses.
        self.addresses = addresses
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        if self.addresses:
            for k in self.addresses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        result['Addresses'] = []
        if self.addresses is not None:
            for k in self.addresses:
                result['Addresses'].append(k.to_map() if k else None)
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        self.addresses = []
        if m.get('Addresses') is not None:
            for k in m.get('Addresses'):
                temp_model = ReplaceCloudGtmAddressPoolAddressRequestAddresses()
                self.addresses.append(temp_model.from_map(k))
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class ReplaceCloudGtmAddressPoolAddressShrinkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_id: str = None,
        addresses_shrink: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US (default)**: English
        self.accept_language = accept_language
        # The ID of the address pool for which you want to replace addresses. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # The addresses.
        self.addresses_shrink = addresses_shrink
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.addresses_shrink is not None:
            result['Addresses'] = self.addresses_shrink
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('Addresses') is not None:
            self.addresses_shrink = m.get('Addresses')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class ReplaceCloudGtmAddressPoolAddressResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the operation was successful:
        # - true: Successful. - false: Failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReplaceCloudGtmAddressPoolAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReplaceCloudGtmAddressPoolAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReplaceCloudGtmAddressPoolAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        request_source: List[str] = None,
        serial_number: int = None,
        weight_value: int = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        # 
        # *   If you specify this parameter, the address pools that are associated with the desired instance are removed and the instance is associated with new address pools.
        # *   If this parameter is left empty, the address pools that are associated with the desired instance are removed and no address pool is associated with the instance.
        self.address_pool_id = address_pool_id
        # The DNS request sources.
        self.request_source = request_source
        # The sequence number of the new address pool. The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number specifies the priority for returning the address pool. A smaller sequence number specifies a higher priority.
        self.serial_number = serial_number
        # The weight value of the new address pool. You can set a different weight value for each address pool. This way, address pools are returned based on the weight values for Domain Name System (DNS) requests. A weight value must be an integer that ranges from 1 to 100.
        self.weight_value = weight_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class ReplaceCloudGtmInstanceConfigAddressPoolRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pools: List[ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools] = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The address pools.
        self.address_pools = address_pools
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        # 
        # You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.
        self.config_id = config_id
        # The ID of the GTM 3.0 instance for which you want to change address pools.
        self.instance_id = instance_id

    def validate(self):
        if self.address_pools:
            for k in self.address_pools:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        result['AddressPools'] = []
        if self.address_pools is not None:
            for k in self.address_pools:
                result['AddressPools'].append(k.to_map() if k else None)
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        self.address_pools = []
        if m.get('AddressPools') is not None:
            for k in m.get('AddressPools'):
                temp_model = ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools()
                self.address_pools.append(temp_model.from_map(k))
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pools_shrink: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The address pools.
        self.address_pools_shrink = address_pools_shrink
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        # 
        # You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.
        self.config_id = config_id
        # The ID of the GTM 3.0 instance for which you want to change address pools.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pools_shrink is not None:
            result['AddressPools'] = self.address_pools_shrink
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPools') is not None:
            self.address_pools_shrink = m.get('AddressPools')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ReplaceCloudGtmInstanceConfigAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the operation was successful, with values: 
        # - true: Success. 
        # - false: Failure.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReplaceCloudGtmInstanceConfigAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReplaceCloudGtmInstanceConfigAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReplaceCloudGtmInstanceConfigAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumePdnsServiceRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        service_type: str = None,
    ):
        self.lang = lang
        self.service_type = service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        return self


class ResumePdnsServiceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResumePdnsServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResumePdnsServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumePdnsServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetrieveDomainRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
    ):
        # The domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class RetrieveDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RetrieveDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetrieveDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetrieveDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackGtmRecoveryPlanRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        recovery_plan_id: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang
        # The ID of the disaster recovery plan.
        # 
        # This parameter is required.
        self.recovery_plan_id = recovery_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        return self


class RollbackGtmRecoveryPlanResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RollbackGtmRecoveryPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RollbackGtmRecoveryPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackGtmRecoveryPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchCloudGtmAddressPoolsRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        available_status: str = None,
        client_token: str = None,
        enable_status: str = None,
        health_status: str = None,
        page_number: int = None,
        page_size: int = None,
        remark: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # Address pool name, supports fuzzy search for the entered address pool name.
        self.address_pool_name = address_pool_name
        # Address pool type, supports precise query for address pool types:
        # - IPv4
        # - IPv6
        # - domain
        self.address_pool_type = address_pool_type
        # Address pool availability status, supporting precise queries for address pool availability:
        # - available: Available
        # - unavailable: Unavailable
        self.available_status = available_status
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # Address pool enable status, supports precise query of address pool enable status:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The health state of the address pool. You can enter a health state for exact search. Valid values:
        # 
        # ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
        # 
        # ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for Domain Name System (DNS) requests.
        # 
        # exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.
        self.health_status = health_status
        # Current page number, starting from 1, default is 1.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Address pool remarks, supporting fuzzy search for the input remarks.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask(TeaModel):
    def __init__(
        self,
        port: int = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The target service port for health checks. When the Ping protocol is selected for health checks, configuration of the service port is not supported.
        self.port = port
        # The ID of the health check template associated with the address.
        self.template_id = template_id
        # Health check template name.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['Port'] = self.port
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks(TeaModel):
    def __init__(
        self,
        health_task: List[SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask] = None,
    ):
        self.health_task = health_task

    def validate(self):
        if self.health_task:
            for k in self.health_task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HealthTask'] = []
        if self.health_task is not None:
            for k in self.health_task:
                result['HealthTask'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.health_task = []
        if m.get('HealthTask') is not None:
            for k in m.get('HealthTask'):
                temp_model = SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask()
                self.health_task.append(temp_model.from_map(k))
        return self


class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        health_tasks: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        request_source: str = None,
        serial_number: int = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
        weight_value: int = None,
    ):
        # IP address or domain name.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # Address ownership information, not supported in the current version.
        self.attribute_info = attribute_info
        # The failover method that is used if the address fails health checks. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        self.available_mode = available_mode
        # Address availability status:
        # - available: Address is available
        # - unavailable: Address is unavailable
        self.available_status = available_status
        # Address creation time.
        self.create_time = create_time
        # Address creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Address enable status, indicating whether the address is currently available:
        # - enable: Enabled status 
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check state of the address. Valid values:
        # 
        # *   ok: The address passes all health checks of the referenced health check templates.
        # *   ok_alert: The address fails some health checks of the referenced health check templates but the address is deemed normal.
        # *   ok_no_monitor: The address does not reference a health check template and is normal.
        # *   exceptional: The address fails some or all health checks of the referenced health check templates and the address is deemed abnormal.
        self.health_status = health_status
        # The health check tasks.
        self.health_tasks = health_tasks
        # The availability state of the address when AvailableMode is set to manual. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        self.name = name
        # Remarks.
        self.remark = remark
        # Request source, referring to the source of the request. GTM schedules based on the exit IP of the LocalDNS used by the terminal. If the LocalDNS supports ECS (edns-client-subnet), intelligent scheduling can also be performed based on the IP of the visiting terminal.
        self.request_source = request_source
        # Sequence number, indicating the priority of address return, where smaller numbers have higher priority.
        self.serial_number = serial_number
        # Address type:
        # - IPv4: ipv4 address - IPv6: ipv6 address - domain: domain name
        self.type = type
        # The last time the address was modified.
        self.update_time = update_time
        # The last modification time of the address (timestamp).
        self.update_timestamp = update_timestamp
        # Weight value (an integer between 1 and 100), allowing different weight values to be set for each address, enabling resolution queries to return addresses according to the weighted ratio.
        self.weight_value = weight_value

    def validate(self):
        if self.health_tasks:
            self.health_tasks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.health_tasks is not None:
            result['HealthTasks'] = self.health_tasks.to_map()
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('HealthTasks') is not None:
            temp_model = SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks()
            self.health_tasks = temp_model.from_map(m['HealthTasks'])
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses(TeaModel):
    def __init__(
        self,
        address: List[SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress] = None,
    ):
        self.address = address

    def validate(self):
        if self.address:
            for k in self.address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Address'] = []
        if self.address is not None:
            for k in self.address:
                result['Address'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address = []
        if m.get('Address') is not None:
            for k in m.get('Address'):
                temp_model = SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress()
                self.address.append(temp_model.from_map(k))
        return self


class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool(TeaModel):
    def __init__(
        self,
        address_lb_strategy: str = None,
        address_pool_id: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        addresses: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        remark: str = None,
        sequence_lb_strategy_mode: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # Load balancing policy among addresses in the address pool:
        # - round_robin: Round-robin, for any source of DNS resolution requests, returns all addresses and rotates the order of all addresses each time.
        # - sequence: Sequential, for any source of DNS resolution requests, returns the address with the smaller sequence number (the sequence number indicates the priority of the address return, the smaller the higher the priority). If the address with the smaller sequence number is unavailable, return the next address with a smaller sequence number.
        # - weight: Weighted, supports setting different weight values for each address to realize returning addresses according to the weight ratio for resolution queries.
        # - source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.
        self.address_lb_strategy = address_lb_strategy
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name.
        self.address_pool_name = address_pool_name
        # Address pool type:
        # - IPv4
        # - IPv6
        # - domain
        self.address_pool_type = address_pool_type
        # The IP addresses or domain names.
        self.addresses = addresses
        # Address pool availability status:
        # - available: Available
        # - unavailable: Unavailable
        self.available_status = available_status
        # Address pool creation time.
        self.create_time = create_time
        # Address pool creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Address pool status:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address pool. Valid values:
        # 
        # *   any_ok: At least one address in the address pool is available.
        # *   p30_ok: At least 30% of the addresses in the address pool are available.
        # *   p50_ok: At least 50% of the addresses in the address pool are available.
        # *   p70_ok: At least 70% of the addresses in the address pool are available.
        # *   all_ok: All addresses in the address pool are available.
        self.health_judgement = health_judgement
        # The health state of the address pool. Valid values:
        # 
        # *   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
        # *   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
        # *   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.
        self.health_status = health_status
        # Address remarks.
        self.remark = remark
        # The mode used if the address with the smallest sequence number is recovered. This parameter is returned only when the policy for load balancing between addresses is sequence. Valid values:
        # 
        # *   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
        # *   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Last modification time of the address pool.
        self.update_time = update_time
        # Last modification time of the address pool (timestamp).
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.addresses:
            self.addresses.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_lb_strategy is not None:
            result['AddressLbStrategy'] = self.address_lb_strategy
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.addresses is not None:
            result['Addresses'] = self.addresses.to_map()
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressLbStrategy') is not None:
            self.address_lb_strategy = m.get('AddressLbStrategy')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('Addresses') is not None:
            temp_model = SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses()
            self.addresses = temp_model.from_map(m['Addresses'])
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class SearchCloudGtmAddressPoolsResponseBodyAddressPools(TeaModel):
    def __init__(
        self,
        address_pool: List[SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool] = None,
    ):
        self.address_pool = address_pool

    def validate(self):
        if self.address_pool:
            for k in self.address_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddressPool'] = []
        if self.address_pool is not None:
            for k in self.address_pool:
                result['AddressPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address_pool = []
        if m.get('AddressPool') is not None:
            for k in m.get('AddressPool'):
                temp_model = SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool()
                self.address_pool.append(temp_model.from_map(k))
        return self


class SearchCloudGtmAddressPoolsResponseBody(TeaModel):
    def __init__(
        self,
        address_pools: SearchCloudGtmAddressPoolsResponseBodyAddressPools = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The address pools.
        self.address_pools = address_pools
        # Current page number, starting from 1, default is 1.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Total number of address pools matching the query conditions.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.address_pools:
            self.address_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pools is not None:
            result['AddressPools'] = self.address_pools.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPools') is not None:
            temp_model = SearchCloudGtmAddressPoolsResponseBodyAddressPools()
            self.address_pools = temp_model.from_map(m['AddressPools'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class SearchCloudGtmAddressPoolsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchCloudGtmAddressPoolsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchCloudGtmAddressPoolsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchCloudGtmAddressesRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address: str = None,
        address_id: str = None,
        available_status: str = None,
        enable_status: str = None,
        health_status: str = None,
        monitor_template_name: str = None,
        name_search_condition: str = None,
        names: List[str] = None,
        page_number: int = None,
        page_size: int = None,
        remark_search_condition: str = None,
        remarks: List[str] = None,
        type: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # Query by service address with precise conditions, supporting IP addresses or domain names.
        self.address = address
        # The address ID. This ID uniquely identifies the address.
        self.address_id = address_id
        # Search by address availability status with precise conditions:
        # - available
        # - unavailable
        self.available_status = available_status
        # Query by exact address enable status:
        # - enable: enabled status
        # - disable: disabled status
        self.enable_status = enable_status
        # The health state of the addresses that you want to query. Valid values:
        # 
        # *   ok: The addresses pass all health checks of the referenced health check templates.
        # *   ok_alert: The addresses fail some health checks of the referenced health check templates, but the addresses are deemed available.
        # *   ok_no_monitor: The addresses do not reference any health check template.
        # *   exceptional: The addresses fail some or all health checks of the referenced health check templates, and the addresses are deemed unavailable.
        self.health_status = health_status
        # Health check template name.
        self.monitor_template_name = monitor_template_name
        # The logical condition for querying addresses by name. This parameter is required if you want to query addresses by name. Valid values:
        # 
        # *   and: displays the results that match all search conditions.
        # *   or: displays the results that match some or all search conditions.
        self.name_search_condition = name_search_condition
        # Address name, usually for users to distinguish between different addresses.
        self.names = names
        # Current page number, starting from 1, default is 1.
        # 
        # This parameter is required.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The logical condition for querying addresses by additional description. This parameter is required if you want to query addresses by additional description. Valid values:
        # 
        # and: displays the results that match all search conditions.
        # 
        # or: displays the results that match some or all search conditions.
        self.remark_search_condition = remark_search_condition
        # Remarks for the address.
        self.remarks = remarks
        # Search precisely by address type conditions:
        # - IPv4
        # - IPv6
        # - domain
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.monitor_template_name is not None:
            result['MonitorTemplateName'] = self.monitor_template_name
        if self.name_search_condition is not None:
            result['NameSearchCondition'] = self.name_search_condition
        if self.names is not None:
            result['Names'] = self.names
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark_search_condition is not None:
            result['RemarkSearchCondition'] = self.remark_search_condition
        if self.remarks is not None:
            result['Remarks'] = self.remarks
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('MonitorTemplateName') is not None:
            self.monitor_template_name = m.get('MonitorTemplateName')
        if m.get('NameSearchCondition') is not None:
            self.name_search_condition = m.get('NameSearchCondition')
        if m.get('Names') is not None:
            self.names = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RemarkSearchCondition') is not None:
            self.remark_search_condition = m.get('RemarkSearchCondition')
        if m.get('Remarks') is not None:
            self.remarks = m.get('Remarks')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask(TeaModel):
    def __init__(
        self,
        monitor_status: str = None,
        port: int = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The state of the health check task. Valid values:
        # 
        # *   ok: The task is normal.
        # *   alert: The task has an alert.
        # *   no_data: No data is available. In most cases, the health check task is newly created and no data is collected.
        self.monitor_status = monitor_status
        # The target service port for health check probes. When the health check protocol is set to Ping, configuration of the service port is not supported.
        self.port = port
        # The ID of the health check template associated with the address.
        self.template_id = template_id
        # Health check template name.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_status is not None:
            result['MonitorStatus'] = self.monitor_status
        if self.port is not None:
            result['Port'] = self.port
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorStatus') is not None:
            self.monitor_status = m.get('MonitorStatus')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks(TeaModel):
    def __init__(
        self,
        health_task: List[SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask] = None,
    ):
        self.health_task = health_task

    def validate(self):
        if self.health_task:
            for k in self.health_task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HealthTask'] = []
        if self.health_task is not None:
            for k in self.health_task:
                result['HealthTask'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.health_task = []
        if m.get('HealthTask') is not None:
            for k in m.get('HealthTask'):
                temp_model = SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask()
                self.health_task.append(temp_model.from_map(k))
        return self


class SearchCloudGtmAddressesResponseBodyAddressesAddress(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        available_mode: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        health_tasks: SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks = None,
        manual_available_status: str = None,
        name: str = None,
        remark: str = None,
        type: str = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        # IP address or domain name.
        self.address = address
        # ID of the address, unique identifier for the address.
        self.address_id = address_id
        # Address ownership information, not supported in the current version.
        self.attribute_info = attribute_info
        # The failover method that is used if the address fails health checks. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on the health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for Domain Name System (DNS) requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        self.available_mode = available_mode
        # The availability state of the address when AvailableMode is set to manual. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.available_status = available_status
        # Creation time of the address.
        self.create_time = create_time
        # Creation time of the address (timestamp).
        self.create_timestamp = create_timestamp
        # Current activation status of the address:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check state of the address. Valid values:
        # 
        # *   ok: The address passes all health checks of the referenced health check templates.
        # *   ok_alert: The address fails some health checks of the referenced health check templates, but the address is deemed available.
        # *   ok_no_monitor: The address does not reference any health check template.
        # *   exceptional: The address fails some or all health checks of the referenced health check templates, and the address is deemed unavailable.
        self.health_status = health_status
        # The health check tasks.
        self.health_tasks = health_tasks
        # The availability state of the address when AvailableMode is set to manual. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status
        # Address name.
        self.name = name
        # Remarks.
        self.remark = remark
        # Address type:
        # - IPv4: ipv4 address - IPv6: ipv6 address - domain: domain name
        self.type = type
        # The last modification time of the address.
        self.update_time = update_time
        # The last modification time of the address (timestamp).
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.health_tasks:
            self.health_tasks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.health_tasks is not None:
            result['HealthTasks'] = self.health_tasks.to_map()
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('HealthTasks') is not None:
            temp_model = SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks()
            self.health_tasks = temp_model.from_map(m['HealthTasks'])
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class SearchCloudGtmAddressesResponseBodyAddresses(TeaModel):
    def __init__(
        self,
        address: List[SearchCloudGtmAddressesResponseBodyAddressesAddress] = None,
    ):
        self.address = address

    def validate(self):
        if self.address:
            for k in self.address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Address'] = []
        if self.address is not None:
            for k in self.address:
                result['Address'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address = []
        if m.get('Address') is not None:
            for k in m.get('Address'):
                temp_model = SearchCloudGtmAddressesResponseBodyAddressesAddress()
                self.address.append(temp_model.from_map(k))
        return self


class SearchCloudGtmAddressesResponseBody(TeaModel):
    def __init__(
        self,
        addresses: SearchCloudGtmAddressesResponseBodyAddresses = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The addresses.
        self.addresses = addresses
        # Current page number, starting from **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of **100** and a default of **20**.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Total number of address entries that meet the query conditions.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.addresses:
            self.addresses.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addresses is not None:
            result['Addresses'] = self.addresses.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Addresses') is not None:
            temp_model = SearchCloudGtmAddressesResponseBodyAddresses()
            self.addresses = temp_model.from_map(m['Addresses'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class SearchCloudGtmAddressesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchCloudGtmAddressesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchCloudGtmAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchCloudGtmInstanceConfigsRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        available_status: str = None,
        client_token: str = None,
        enable_status: str = None,
        health_status: str = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        remark: str = None,
        schedule_domain_name: str = None,
        schedule_zone_name: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The availability state of the access domain name. Valid values:
        # 
        # *   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
        # *   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.
        self.available_status = available_status
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
        # *   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.
        self.enable_status = enable_status
        # The health state of the access domain name. Valid values:
        # 
        # *   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
        # *   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for Domain Name System (DNS) requests.
        # *   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.
        self.health_status = health_status
        # The ID of the Global Traffic Manager (GTM) 3.0 instance.
        self.instance_id = instance_id
        # Current page number, starting from 1, default is 1.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.
        self.page_size = page_size
        # Remarks for the domain instance.
        self.remark = remark
        # The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.
        self.schedule_domain_name = schedule_domain_name
        # The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.
        self.schedule_zone_name = schedule_zone_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        return self


class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource(TeaModel):
    def __init__(
        self,
        request_source: List[str] = None,
    ):
        self.request_source = request_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_source is not None:
            result['RequestSource'] = self.request_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestSource') is not None:
            self.request_source = m.get('RequestSource')
        return self


class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool(TeaModel):
    def __init__(
        self,
        address_lb_strategy: str = None,
        address_pool_id: str = None,
        address_pool_name: str = None,
        address_pool_type: str = None,
        available_status: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_judgement: str = None,
        health_status: str = None,
        request_source: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource = None,
        seq_non_preemptive_schedule: bool = None,
        sequence_lb_strategy_mode: str = None,
        serial_number: int = None,
        update_time: str = None,
        update_timestamp: int = None,
        weight_value: int = None,
    ):
        # Load balancing policy among addresses in the address pool:
        # - round_robin: Round-robin, where for any source of DNS resolution requests, all addresses are returned, with a rotation of the order for every request.
        # - sequence: Sequential, where for any source of DNS resolution requests, the address with the lower sequence number (indicating a higher priority, the smaller the number, the higher the priority) is returned. If the address with the lower sequence number is unavailable, the next address with a lower sequence number is returned.
        # - weight: Weighted, supporting the setting of different weight values for each address to realize returning addresses according to the ratio of weights in DNS query resolutions.
        # - source_nearest: Source-nearest, referring to the intelligent resolution feature, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing the nearest server.
        self.address_lb_strategy = address_lb_strategy
        # Address pool ID, uniquely identifying the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name.
        self.address_pool_name = address_pool_name
        # Address pool type:
        # - IPv4
        # - IPv6
        # - domain
        self.address_pool_type = address_pool_type
        # Address pool availability status:
        # - available: Available
        # - unavailable: Unavailable
        self.available_status = available_status
        # Address pool creation time.
        self.create_time = create_time
        # Address pool creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Address pool status:
        # - enable: Enabled status
        # - disable: Disabled status
        self.enable_status = enable_status
        # The condition for determining the health status of the address pool. Valid values:
        # 
        # *   any_ok: At least one address in the address pool is available.
        # *   p30_ok: At least 30% of the addresses in the address pool are available.
        # *   p50_ok: At least 50% of the addresses in the address pool are available.
        # *   p70_ok: At least 70% of the addresses in the address pool are available.
        # *   all_ok: All addresses in the address pool are available.
        self.health_judgement = health_judgement
        # The health state of the address pool. Valid values:
        # 
        # *   ok: The health state of the address pool is normal and all addresses that are referenced by the address pool are available.
        # *   ok_alert: The health state of the address pool is warning and some of the addresses that are referenced by the address pool are unavailable. However, the address pool is deemed normal. In this case, only the available addresses are returned for DNS requests.
        # *   exceptional: The health state of the address pool is abnormal and some or all of the addresses that are referenced by the address pool are unavailable. In this case, the address pool is deemed abnormal.
        self.health_status = health_status
        # Parse the request source list.
        self.request_source = request_source
        # Indicates whether it is a sequential (non-preemptive) scheduling object for hybrid cloud management scenarios: 
        # - true: yes 
        # - false: no
        self.seq_non_preemptive_schedule = seq_non_preemptive_schedule
        # The mode used if the address with the smallest sequence number is recovered. This parameter is required only when the policy for load balancing between addresses is sequence. Valid values:
        # 
        # *   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
        # *   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Sequence number. For any parsing request, the address pool with the smaller sequence number (indicating the priority of the address pool returned, with smaller numbers having higher priority) will be returned.
        self.serial_number = serial_number
        # Last modification time of the address pool.
        self.update_time = update_time
        # Update time (timestamp).
        self.update_timestamp = update_timestamp
        # Weight value (an integer between 1 and 100, inclusive), allowing different weight values to be set for each address pool, implementing the return of address pools according to weight ratios in resolution queries.
        self.weight_value = weight_value

    def validate(self):
        if self.request_source:
            self.request_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_lb_strategy is not None:
            result['AddressLbStrategy'] = self.address_lb_strategy
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.address_pool_type is not None:
            result['AddressPoolType'] = self.address_pool_type
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.request_source is not None:
            result['RequestSource'] = self.request_source.to_map()
        if self.seq_non_preemptive_schedule is not None:
            result['SeqNonPreemptiveSchedule'] = self.seq_non_preemptive_schedule
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.weight_value is not None:
            result['WeightValue'] = self.weight_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressLbStrategy') is not None:
            self.address_lb_strategy = m.get('AddressLbStrategy')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('AddressPoolType') is not None:
            self.address_pool_type = m.get('AddressPoolType')
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('RequestSource') is not None:
            temp_model = SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource()
            self.request_source = temp_model.from_map(m['RequestSource'])
        if m.get('SeqNonPreemptiveSchedule') is not None:
            self.seq_non_preemptive_schedule = m.get('SeqNonPreemptiveSchedule')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('WeightValue') is not None:
            self.weight_value = m.get('WeightValue')
        return self


class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools(TeaModel):
    def __init__(
        self,
        address_pool: List[SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool] = None,
    ):
        self.address_pool = address_pool

    def validate(self):
        if self.address_pool:
            for k in self.address_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddressPool'] = []
        if self.address_pool is not None:
            for k in self.address_pool:
                result['AddressPool'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.address_pool = []
        if m.get('AddressPool') is not None:
            for k in m.get('AddressPool'):
                temp_model = SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool()
                self.address_pool.append(temp_model.from_map(k))
        return self


class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig(TeaModel):
    def __init__(
        self,
        address_pool_lb_strategy: str = None,
        address_pools: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools = None,
        available_status: str = None,
        commodity_code: str = None,
        config_id: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        enable_status: str = None,
        health_status: str = None,
        instance_id: str = None,
        remark: str = None,
        schedule_domain_name: str = None,
        schedule_hostname: str = None,
        schedule_rr_type: str = None,
        schedule_zone_mode: str = None,
        schedule_zone_name: str = None,
        sequence_lb_strategy_mode: str = None,
        ttl: int = None,
        update_time: str = None,
        update_timestamp: int = None,
        version_code: str = None,
    ):
        # The policy for load balancing between address pools. Valid values:
        # 
        # *   round_robin: All address pools are returned for DNS requests from any source. All address pools are sorted in round-robin mode each time they are returned.
        # *   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
        # *   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
        # *   source_nearest: Different address pools are returned based on the sources of DNS requests. This way, users can access nearby address pools.
        self.address_pool_lb_strategy = address_pool_lb_strategy
        # The address pools.
        self.address_pools = address_pools
        # The availability state of the access domain name. Valid values:
        # 
        # *   available: If the access domain name is **enabled** and the health state is **normal**, the access domain name is deemed **available**.
        # *   unavailable: If the access domain name is **disabled** or the health state is **abnormal**, the access domain name is deemed **unavailable**.
        self.available_status = available_status
        # The commodity code. Valid values:
        # 
        # *   dns_gtm_public_cn: the commodity code on the China site (aliyun.com)
        # *   dns_gtm_public_intl: the commodity code on the international site (alibabacloud.com)
        self.commodity_code = commodity_code
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        self.config_id = config_id
        # Domain instance creation time.
        self.create_time = create_time
        # Domain instance creation time (timestamp).
        self.create_timestamp = create_timestamp
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable: The access domain name is enabled and the intelligent scheduling policy of the corresponding GTM instance takes effect.
        # *   disable: The access domain name is disabled and the intelligent scheduling policy of the corresponding GTM instance does not take effect.
        self.enable_status = enable_status
        # The health state of the access domain name. Valid values:
        # 
        # *   ok: The health state of the access domain name is normal and all address pools that are referenced by the access domain name are available.
        # *   ok_alert: The health state of the access domain name is warning and some of the address pools that are referenced by the access domain name are unavailable. In this case, only the available address pools are returned for DNS requests.
        # *   exceptional: The health state of the access domain name is abnormal and all address pools that are referenced by the access domain name are unavailable. In this case, addresses in the non-empty address pool with the smallest sequence number are preferentially used for fallback resolution. This returns DNS results for clients as much as possible.
        self.health_status = health_status
        # The ID of the GTM 3.0 instance.
        self.instance_id = instance_id
        # Remarks for the domain instance.
        self.remark = remark
        # The access domain name. The value of this parameter is composed of the value of ScheduleHostname and the value of ScheduleZoneName.
        self.schedule_domain_name = schedule_domain_name
        # Host record of the domain accessed by GTM.
        self.schedule_hostname = schedule_hostname
        # DNS record types for the scheduling domain:
        # - A: IPv4 address
        # - AAAA: IPv6 address
        # - CNAME: Domain name
        self.schedule_rr_type = schedule_rr_type
        # The allocation mode of the access domain name. Valid values:
        # 
        # *   custom: custom allocation. You must specify a custom hostname and associate the hostname with a zone that is hosted by the Public Authoritative DNS module within the account to which the GTM instance belongs to generate an access domain name.
        # *   sys_assign: system allocation. This mode is not supported. Do not set ScheduleZoneMode to sys_assign.
        self.schedule_zone_mode = schedule_zone_mode
        # The zone such as example.com or subzone such as a.example.com of the access domain name. In most cases, the zone or subzone is hosted by the Public Authoritative DNS module of Alibaba Cloud DNS. This zone belongs to the account to which the GTM instance belongs.
        self.schedule_zone_name = schedule_zone_name
        # The mode used if the address pool with the smallest sequence number is recovered. This parameter is returned when AddressPoolLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
        # *   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode
        # Global TTL (in seconds), the TTL value for resolving the access domain name to the address pool, which affects the caching time of DNS records in the operator\\"s LocalDNS. Supports custom TTL values.
        self.ttl = ttl
        # The last modification time of the domain instance.
        self.update_time = update_time
        # The last modification time of the domain instance (timestamp).
        self.update_timestamp = update_timestamp
        # Global Traffic Management version 3.0 instance types:
        # - standard: Standard Edition
        # - ultimate: Ultimate Edition
        self.version_code = version_code

    def validate(self):
        if self.address_pools:
            self.address_pools.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_lb_strategy is not None:
            result['AddressPoolLbStrategy'] = self.address_pool_lb_strategy
        if self.address_pools is not None:
            result['AddressPools'] = self.address_pools.to_map()
        if self.available_status is not None:
            result['AvailableStatus'] = self.available_status
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.schedule_hostname is not None:
            result['ScheduleHostname'] = self.schedule_hostname
        if self.schedule_rr_type is not None:
            result['ScheduleRrType'] = self.schedule_rr_type
        if self.schedule_zone_mode is not None:
            result['ScheduleZoneMode'] = self.schedule_zone_mode
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolLbStrategy') is not None:
            self.address_pool_lb_strategy = m.get('AddressPoolLbStrategy')
        if m.get('AddressPools') is not None:
            temp_model = SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools()
            self.address_pools = temp_model.from_map(m['AddressPools'])
        if m.get('AvailableStatus') is not None:
            self.available_status = m.get('AvailableStatus')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('ScheduleHostname') is not None:
            self.schedule_hostname = m.get('ScheduleHostname')
        if m.get('ScheduleRrType') is not None:
            self.schedule_rr_type = m.get('ScheduleRrType')
        if m.get('ScheduleZoneMode') is not None:
            self.schedule_zone_mode = m.get('ScheduleZoneMode')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs(TeaModel):
    def __init__(
        self,
        instance_config: List[SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig] = None,
    ):
        self.instance_config = instance_config

    def validate(self):
        if self.instance_config:
            for k in self.instance_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceConfig'] = []
        if self.instance_config is not None:
            for k in self.instance_config:
                result['InstanceConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_config = []
        if m.get('InstanceConfig') is not None:
            for k in m.get('InstanceConfig'):
                temp_model = SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig()
                self.instance_config.append(temp_model.from_map(k))
        return self


class SearchCloudGtmInstanceConfigsResponseBody(TeaModel):
    def __init__(
        self,
        instance_configs: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The instances list.
        self.instance_configs = instance_configs
        # Current page number, starting from 1, default is 1.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Total number of instance configuration entries.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.instance_configs:
            self.instance_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_configs is not None:
            result['InstanceConfigs'] = self.instance_configs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceConfigs') is not None:
            temp_model = SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs()
            self.instance_configs = temp_model.from_map(m['InstanceConfigs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class SearchCloudGtmInstanceConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchCloudGtmInstanceConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchCloudGtmInstanceConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchCloudGtmInstancesRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        instance_id: str = None,
        instance_name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The language of the return value. Options are:
        # - **zh-CN**: Chinese. 
        # - **en-US**: English.
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see How to ensure idempotence.
        self.client_token = client_token
        # The ID of the Global Traffic Manager (GTM) 3.0 instance.
        self.instance_id = instance_id
        # Schedule instance name, supports fuzzy search.
        self.instance_name = instance_name
        # Current page number, starting from 1, default is 1.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of **100**, and a default of **20**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class SearchCloudGtmInstancesResponseBodyInstancesInstance(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        create_time: str = None,
        create_timestamp: int = None,
        expire_time: int = None,
        expire_timestamp: str = None,
        instance_id: str = None,
        instance_name: str = None,
        monitor_task_quota: int = None,
        monthly_email_used: int = None,
        monthly_sms_quota: int = None,
        monthly_sms_used: int = None,
        monthly_webhook_used: int = None,
        schedule_domain_name: str = None,
        update_time: str = None,
        update_timestamp: int = None,
        version_code: str = None,
    ):
        # The commodity code. Valid values:
        # 
        # *   dns_gtm_public_cn: commodity code on the China site (aliyun.com)
        # *   dns_gtm_public_intl: commodity code on the international site (alibabacloud.com)
        self.commodity_code = commodity_code
        # Instance creation time.
        self.create_time = create_time
        # Instance creation time (timestamp).
        self.create_timestamp = create_timestamp
        # Instance expiration time.
        self.expire_time = expire_time
        # Instance expiration time (timestamp).
        self.expire_timestamp = expire_timestamp
        # The ID of the GTM 3.0 instance.
        self.instance_id = instance_id
        # Schedule instance name.
        self.instance_name = instance_name
        # Monitor probe task quota.
        self.monitor_task_quota = monitor_task_quota
        # Monthly email sending volume.
        self.monthly_email_used = monthly_email_used
        # SMS quota, only supported on the China site. International site does not support SMS.
        self.monthly_sms_quota = monthly_sms_quota
        # Monthly SMS sending volume, only supported by the China site as international sites do not support SMS.
        self.monthly_sms_used = monthly_sms_used
        # Monthly webhook dispatch volume.
        self.monthly_webhook_used = monthly_webhook_used
        # The access domain name, which consists of a hostname and a zone or a subzone.
        self.schedule_domain_name = schedule_domain_name
        # The last modified time of the instance.
        self.update_time = update_time
        # The last modified time of the instance (timestamp).
        self.update_timestamp = update_timestamp
        # Global Traffic Management version 3.0 instance types:
        # - standard: Standard Edition
        # - ultimate: Ultimate Edition
        self.version_code = version_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.expire_timestamp is not None:
            result['ExpireTimestamp'] = self.expire_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.monitor_task_quota is not None:
            result['MonitorTaskQuota'] = self.monitor_task_quota
        if self.monthly_email_used is not None:
            result['MonthlyEmailUsed'] = self.monthly_email_used
        if self.monthly_sms_quota is not None:
            result['MonthlySmsQuota'] = self.monthly_sms_quota
        if self.monthly_sms_used is not None:
            result['MonthlySmsUsed'] = self.monthly_sms_used
        if self.monthly_webhook_used is not None:
            result['MonthlyWebhookUsed'] = self.monthly_webhook_used
        if self.schedule_domain_name is not None:
            result['ScheduleDomainName'] = self.schedule_domain_name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        if self.version_code is not None:
            result['VersionCode'] = self.version_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('ExpireTimestamp') is not None:
            self.expire_timestamp = m.get('ExpireTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('MonitorTaskQuota') is not None:
            self.monitor_task_quota = m.get('MonitorTaskQuota')
        if m.get('MonthlyEmailUsed') is not None:
            self.monthly_email_used = m.get('MonthlyEmailUsed')
        if m.get('MonthlySmsQuota') is not None:
            self.monthly_sms_quota = m.get('MonthlySmsQuota')
        if m.get('MonthlySmsUsed') is not None:
            self.monthly_sms_used = m.get('MonthlySmsUsed')
        if m.get('MonthlyWebhookUsed') is not None:
            self.monthly_webhook_used = m.get('MonthlyWebhookUsed')
        if m.get('ScheduleDomainName') is not None:
            self.schedule_domain_name = m.get('ScheduleDomainName')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        if m.get('VersionCode') is not None:
            self.version_code = m.get('VersionCode')
        return self


class SearchCloudGtmInstancesResponseBodyInstances(TeaModel):
    def __init__(
        self,
        instance: List[SearchCloudGtmInstancesResponseBodyInstancesInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = SearchCloudGtmInstancesResponseBodyInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class SearchCloudGtmInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instances: SearchCloudGtmInstancesResponseBodyInstances = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        # The instances.
        self.instances = instances
        # Current page number, starting at **1**, default is **1**.
        self.page_number = page_number
        # The number of rows per page when paginating queries, with a maximum value of 100 and a default of 20.
        self.page_size = page_size
        # Unique request identification code.
        self.request_id = request_id
        # Total number of instances found from the search.
        self.total_items = total_items
        # Total number of pages.
        self.total_pages = total_pages

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Instances') is not None:
            temp_model = SearchCloudGtmInstancesResponseBodyInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class SearchCloudGtmInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchCloudGtmInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchCloudGtmInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchCloudGtmMonitorTemplatesRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        ip_version: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        protocol: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The IP address type of health check nodes. An exact search is performed based on the IP address type. Valid values:
        # 
        # *   IPv4: applicable when the destination address of health checks is an IPv4 address
        # *   IPv6: applicable when the destination address of health checks is an IPv6 address
        self.ip_version = ip_version
        self.name = name
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.protocol = protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.ip_version is not None:
            result['IpVersion'] = self.ip_version
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('IpVersion') is not None:
            self.ip_version = m.get('IpVersion')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        city_name: str = None,
        country_code: str = None,
        country_name: str = None,
        group_name: str = None,
        group_type: str = None,
        isp_code: str = None,
        isp_name: str = None,
    ):
        self.city_code = city_code
        self.city_name = city_name
        self.country_code = country_code
        self.country_name = country_name
        self.group_name = group_name
        # The group type of health check nodes. Valid values:
        # 
        # *   BGP: BGP node
        # *   OVERSEAS: node outside the Chinese mainland
        # *   ISP: Internet service provider (ISP) node
        self.group_type = group_type
        self.isp_code = isp_code
        self.isp_name = isp_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.country_code is not None:
            result['CountryCode'] = self.country_code
        if self.country_name is not None:
            result['CountryName'] = self.country_name
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('CountryCode') is not None:
            self.country_code = m.get('CountryCode')
        if m.get('CountryName') is not None:
            self.country_name = m.get('CountryName')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes(TeaModel):
    def __init__(
        self,
        isp_city_node: List[SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode] = None,
    ):
        self.isp_city_node = isp_city_node

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        return self


class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        evaluation_count: int = None,
        extend_info: str = None,
        failure_rate: int = None,
        interval: int = None,
        ip_version: str = None,
        isp_city_nodes: SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes = None,
        name: str = None,
        protocol: str = None,
        remark: str = None,
        template_id: str = None,
        timeout: int = None,
        update_time: str = None,
        update_timestamp: int = None,
    ):
        self.create_time = create_time
        self.create_timestamp = create_timestamp
        self.evaluation_count = evaluation_count
        # The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol. Valid values:
        # 
        # *   **http(s)**:
        # 
        #     **host**: indicates the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.
        # 
        #     **path**: the URL for HTTP or HTTPS health checks. Default value: /.
        # 
        #     **code**: indicates the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:
        # 
        #     *   400: indicates an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. If Verification Content is set to "The error code is greater than 400", you must specify an exact URL for the path parameter.
        #     *   500: indicates a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. The error code that is greater than 500 is used as the alert threshold by default.
        # 
        #     **sni**: indicates whether Server Name Indication (SNI) is enabled for HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:
        # 
        #     *   true: SNI is enabled.
        #     *   false: SNI is disabled.
        # 
        #     **followRedirect**: indicates whether 3XX redirection is followed. Valid values:
        # 
        #     *   true: You are redirected to the destination address if a status code 3XX, such as 301, 302, 303, 307, or 308, is returned.
        #     *   false: You are not redirected to the destination address.
        # 
        # *   **ping**:
        # 
        #     **packetNum**: The total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.
        # 
        #     **packetLossRate**: The packet loss rate for each ping-based health check. The packet loss rate in a check can be calculated by using the following formula: Packet loss rate = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.
        self.extend_info = extend_info
        self.failure_rate = failure_rate
        self.interval = interval
        # The IP address type of health check nodes. Valid values:
        # 
        # *   IPv4: applicable when the destination address of health checks is an IPv4 address
        # *   IPv6: applicable when the destination address of health checks is an IPv6 address
        self.ip_version = ip_version
        # The health check nodes.
        self.isp_city_nodes = isp_city_nodes
        self.name = name
        self.protocol = protocol
        self.remark = remark
        self.template_id = template_id
        self.timeout = timeout
        self.update_time = update_time
        self.update_timestamp = update_timestamp

    def validate(self):
        if self.isp_city_nodes:
            self.isp_city_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.extend_info is not None:
            result['ExtendInfo'] = self.extend_info
        if self.failure_rate is not None:
            result['FailureRate'] = self.failure_rate
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.ip_version is not None:
            result['IpVersion'] = self.ip_version
        if self.isp_city_nodes is not None:
            result['IspCityNodes'] = self.isp_city_nodes.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_timestamp is not None:
            result['UpdateTimestamp'] = self.update_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('ExtendInfo') is not None:
            self.extend_info = m.get('ExtendInfo')
        if m.get('FailureRate') is not None:
            self.failure_rate = m.get('FailureRate')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IpVersion') is not None:
            self.ip_version = m.get('IpVersion')
        if m.get('IspCityNodes') is not None:
            temp_model = SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes()
            self.isp_city_nodes = temp_model.from_map(m['IspCityNodes'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateTimestamp') is not None:
            self.update_timestamp = m.get('UpdateTimestamp')
        return self


class SearchCloudGtmMonitorTemplatesResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        template: List[SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class SearchCloudGtmMonitorTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        templates: SearchCloudGtmMonitorTemplatesResponseBodyTemplates = None,
        total_items: int = None,
        total_pages: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        # The health check templates.
        self.templates = templates
        self.total_items = total_items
        self.total_pages = total_pages

    def validate(self):
        if self.templates:
            self.templates.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.templates is not None:
            result['Templates'] = self.templates.to_map()
        if self.total_items is not None:
            result['TotalItems'] = self.total_items
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Templates') is not None:
            temp_model = SearchCloudGtmMonitorTemplatesResponseBodyTemplates()
            self.templates = temp_model.from_map(m['Templates'])
        if m.get('TotalItems') is not None:
            self.total_items = m.get('TotalItems')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class SearchCloudGtmMonitorTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchCloudGtmMonitorTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchCloudGtmMonitorTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDNSSLBStatusRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        line: str = None,
        open: bool = None,
        sub_domain: str = None,
        type: str = None,
        user_client_ip: str = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The language of the content within the request and response. Default: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The DNS resolution line. The line can be the default line, China Telecom, and China Mobile.
        self.line = line
        # Specifies whether to enable or disable weighted round-robin. Valid values:
        # 
        # *   **true** (default): enables weighted round-robin.
        # *   **false**: disables weighted round-robin.
        self.open = open
        # The subdomain name for which you want to enable weighted round-robin. Set the parameter to @.example.com instead of example.com.
        # 
        # This parameter is required.
        self.sub_domain = sub_domain
        # The type of the Domain Name System (DNS) record. Valid values: A and AAAA. Default value: A.
        self.type = type
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line is not None:
            result['Line'] = self.line
        if self.open is not None:
            result['Open'] = self.open
        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain
        if self.type is not None:
            result['Type'] = self.type
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Open') is not None:
            self.open = m.get('Open')
        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class SetDNSSLBStatusResponseBody(TeaModel):
    def __init__(
        self,
        open: bool = None,
        record_count: int = None,
        request_id: str = None,
    ):
        # Indicates whether weighted round-robin is enabled for the subdomain name.
        self.open = open
        # The number of A records that are matched.
        self.record_count = record_count
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.open is not None:
            result['Open'] = self.open
        if self.record_count is not None:
            result['RecordCount'] = self.record_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Open') is not None:
            self.open = m.get('Open')
        if m.get('RecordCount') is not None:
            self.record_count = m.get('RecordCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetDNSSLBStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDNSSLBStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDNSSLBStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDnsGtmAccessModeRequest(TeaModel):
    def __init__(
        self,
        access_mode: str = None,
        lang: str = None,
        strategy_id: str = None,
    ):
        # The switchover policy for primary and secondary address pool sets. Valid values:
        # 
        # *   AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.
        # *   DEFAULT: the primary address pool set
        # *   FAILOVER: the secondary address pool set
        # 
        # This parameter is required.
        self.access_mode = access_mode
        # The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The policy ID.
        # 
        # This parameter is required.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_mode is not None:
            result['AccessMode'] = self.access_mode
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessMode') is not None:
            self.access_mode = m.get('AccessMode')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class SetDnsGtmAccessModeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetDnsGtmAccessModeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDnsGtmAccessModeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDnsGtmAccessModeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDnsGtmMonitorStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        monitor_config_id: str = None,
        status: str = None,
    ):
        # The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The ID of the health check task.
        # 
        # This parameter is required.
        self.monitor_config_id = monitor_config_id
        # Specifies whether to enable the health check feature. Valid values:
        # 
        # *   OPEN: enables the health check feature.
        # *   CLOSE: disables the health check feature.
        # 
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class SetDnsGtmMonitorStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetDnsGtmMonitorStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDnsGtmMonitorStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDnsGtmMonitorStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDomainDnssecStatusRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        status: str = None,
    ):
        # The domain name for which you want to enable the DNSSEC. Only the users of the paid editions of Alibaba Cloud DNS can enable this feature.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang
        # The DNSSEC status. Valid values:
        # 
        # *   ON: enables DNSSEC for the domain name.
        # *   OFF: disables DNSSEC for the domain name.
        # 
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class SetDomainDnssecStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetDomainDnssecStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDomainDnssecStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDomainDnssecStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDomainRecordStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        record_id: str = None,
        status: str = None,
        user_client_ip: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.record_id = record_id
        # The state of the DNS record. Valid values:
        # 
        # *   **Enable**: enables the DNS record.
        # *   **Disable**: disables the DNS record.
        # 
        # This parameter is required.
        self.status = status
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class SetDomainRecordStatusResponseBody(TeaModel):
    def __init__(
        self,
        record_id: str = None,
        request_id: str = None,
        status: str = None,
    ):
        # The ID of the DNS record.
        self.record_id = record_id
        # The request ID.
        self.request_id = request_id
        # The status of the DNS record.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class SetDomainRecordStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDomainRecordStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDomainRecordStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetGtmAccessModeRequest(TeaModel):
    def __init__(
        self,
        access_mode: str = None,
        lang: str = None,
        strategy_id: str = None,
    ):
        # The desired access policy. Valid values:
        # 
        # *   **AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.**\
        # *   **DEFAULT: specifies the primary address pool set.**\
        # *   **FAILOVER: specifies the secondary address pool set.
        # 
        # This parameter is required.
        self.access_mode = access_mode
        # The language.
        self.lang = lang
        # The ID of the access policy.
        # 
        # This parameter is required.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_mode is not None:
            result['AccessMode'] = self.access_mode
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessMode') is not None:
            self.access_mode = m.get('AccessMode')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class SetGtmAccessModeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetGtmAccessModeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetGtmAccessModeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetGtmAccessModeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetGtmMonitorStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        monitor_config_id: str = None,
        status: str = None,
    ):
        # The language used by the user.
        self.lang = lang
        # The health check ID.
        # 
        # This parameter is required.
        self.monitor_config_id = monitor_config_id
        # Specifies whether health check is enabled for the address pool. Valid values:
        # 
        # *   **OPEN**: Enabled
        # *   **CLOSE**: Disabled
        # 
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class SetGtmMonitorStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetGtmMonitorStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetGtmMonitorStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetGtmMonitorStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitIspFlushCacheTaskRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        domain_name: str = None,
        isp: List[str] = None,
        lang: str = None,
    ):
        # This parameter is required.
        self.client_token = client_token
        # This parameter is required.
        self.domain_name = domain_name
        # This parameter is required.
        self.isp = isp
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class SubmitIspFlushCacheTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitIspFlushCacheTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitIspFlushCacheTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitIspFlushCacheTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchDnsGtmInstanceStrategyModeRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        lang: str = None,
        strategy_mode: str = None,
    ):
        # The ID of the GTM instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The access policy type. Valid values:
        # 
        # *   GEO: geographical location-based
        # *   LATENCY: latency-based
        # 
        # This parameter is required.
        self.strategy_mode = strategy_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_mode is not None:
            result['StrategyMode'] = self.strategy_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyMode') is not None:
            self.strategy_mode = m.get('StrategyMode')
        return self


class SwitchDnsGtmInstanceStrategyModeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SwitchDnsGtmInstanceStrategyModeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchDnsGtmInstanceStrategyModeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchDnsGtmInstanceStrategyModeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key. The tag key can be up to 20 characters in length and cannot start with `acs:` or`aliyun`.
        self.key = key
        # The tag value. The tag value can be up to 20 bytes in length.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TagResourcesRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag: List[TagResourcesRequestTag] = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the resource.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the resource. Valid values:
        # 
        # *   **DOMAIN**: domain name
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tags.
        # 
        # This parameter is required.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = TagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TransferDomainRequest(TeaModel):
    def __init__(
        self,
        domain_names: str = None,
        lang: str = None,
        remark: str = None,
        target_user_id: int = None,
    ):
        # The domain names. Separate multiple domain names with commas (,). Only domain names registered with Alibaba Cloud are supported.
        # 
        # This parameter is required.
        self.domain_names = domain_names
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The description of the domain name.
        self.remark = remark
        # The destination user ID. The domain names and their Domain Name System (DNS) records are transferred to the destination user ID.
        # 
        # This parameter is required.
        self.target_user_id = target_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_names is not None:
            result['DomainNames'] = self.domain_names
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainNames') is not None:
            self.domain_names = m.get('DomainNames')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        return self


class TransferDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class TransferDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TransferDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TransferDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindInstanceDomainsRequest(TeaModel):
    def __init__(
        self,
        domain_names: str = None,
        instance_id: str = None,
        lang: str = None,
    ):
        # The domain names.
        # 
        # Separate multiple domain names with commas (,). Up to 100 domain names can be entered.
        # 
        # This parameter is required.
        self.domain_names = domain_names
        # The instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The language.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_names is not None:
            result['DomainNames'] = self.domain_names
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainNames') is not None:
            self.domain_names = m.get('DomainNames')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class UnbindInstanceDomainsResponseBody(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        request_id: str = None,
        success_count: int = None,
    ):
        # The number of domain names that failed to be unbound from the instance.
        self.failed_count = failed_count
        # The request ID.
        self.request_id = request_id
        # The number of domain names that are unbound from the instance.
        self.success_count = success_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class UnbindInstanceDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindInstanceDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindInstanceDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(
        self,
        all: bool = None,
        lang: str = None,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag_key: List[str] = None,
    ):
        # Specifies whether to remove all tags. Default value: false. This parameter is valid only when TagKey is left empty. Valid values: true and false.
        self.all = all
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the resource.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the resource. Valid value: Valid values:
        # 
        # *   **DOMAIN**: domain name
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tags added to the resource.
        self.tag_key = tag_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all is not None:
            result['All'] = self.all
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('All') is not None:
            self.all = m.get('All')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UntagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAppKeyStateRequest(TeaModel):
    def __init__(
        self,
        app_key_id: str = None,
        lang: str = None,
        state: str = None,
    ):
        self.app_key_id = app_key_id
        self.lang = lang
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key_id is not None:
            result['AppKeyId'] = self.app_key_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppKeyId') is not None:
            self.app_key_id = m.get('AppKeyId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdateAppKeyStateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAppKeyStateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAppKeyStateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAppKeyStateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmAddressRequestHealthTasks(TeaModel):
    def __init__(
        self,
        port: int = None,
        template_id: str = None,
    ):
        # The service port of the address on which health check tasks are performed. If the ping protocol is used for health checks, the configuration of the service port is not supported.
        # 
        # *   If you leave this parameter empty, the existing service port is deleted.
        # *   If you specify this parameter, the existing service port is updated based on the value of this parameter.
        self.port = port
        # The ID of the health check template that is associated with the address. This parameter is required if you specify a service port of the address for health check tasks.
        # 
        # *   If you leave this parameter empty, the associated health check template is disassociated from the address.
        # *   If you specify this parameter, the associated health check template is updated based on the value of this parameter.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['Port'] = self.port
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateCloudGtmAddressRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        client_token: str = None,
        health_judgement: str = None,
        health_tasks: List[UpdateCloudGtmAddressRequestHealthTasks] = None,
        name: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The IP address or domain name.
        self.address = address
        # The ID of the address. This ID uniquely identifies the address.
        # 
        # This parameter is required.
        self.address_id = address_id
        # Address Attribution information.
        self.attribute_info = attribute_info
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The new condition for determining the health state of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check tasks.
        self.health_tasks = health_tasks
        # The name of the address.
        self.name = name

    def validate(self):
        if self.health_tasks:
            for k in self.health_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        result['HealthTasks'] = []
        if self.health_tasks is not None:
            for k in self.health_tasks:
                result['HealthTasks'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        self.health_tasks = []
        if m.get('HealthTasks') is not None:
            for k in m.get('HealthTasks'):
                temp_model = UpdateCloudGtmAddressRequestHealthTasks()
                self.health_tasks.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateCloudGtmAddressShrinkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address: str = None,
        address_id: str = None,
        attribute_info: str = None,
        client_token: str = None,
        health_judgement: str = None,
        health_tasks_shrink: str = None,
        name: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The IP address or domain name.
        self.address = address
        # The ID of the address. This ID uniquely identifies the address.
        # 
        # This parameter is required.
        self.address_id = address_id
        # Address Attribution information.
        self.attribute_info = attribute_info
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The new condition for determining the health state of the address. Valid values:
        # 
        # *   any_ok: The health check results of at least one health check template are normal.
        # *   p30_ok: The health check results of at least 30% of health check templates are normal.
        # *   p50_ok: The health check results of at least 50% of health check templates are normal.
        # *   p70_ok: The health check results of at least 70% of health check templates are normal.
        # *   all_ok: The health check results of all health check templates are normal.
        self.health_judgement = health_judgement
        # The health check tasks.
        self.health_tasks_shrink = health_tasks_shrink
        # The name of the address.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address is not None:
            result['Address'] = self.address
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        if self.health_tasks_shrink is not None:
            result['HealthTasks'] = self.health_tasks_shrink
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        if m.get('HealthTasks') is not None:
            self.health_tasks_shrink = m.get('HealthTasks')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateCloudGtmAddressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Modify address base configuration operation status:
        # - true: Operation was successful
        # - false: Operation was failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmAddressEnableStatusRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_id: str = None,
        client_token: str = None,
        enable_status: str = None,
    ):
        # 返回结果显示的语言。取值：
        # 
        # - zh-CN：中文
        # 
        # - en-US：英文
        self.accept_language = accept_language
        # The ID of the address. This ID uniquely identifies the address.
        # 
        # This parameter is required.
        self.address_id = address_id
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The enabling state of the address. Valid values:
        # 
        # *   enable: The address is enabled and the address can be used for Domain Name System (DNS) resolution if the address passes health checks.
        # *   disable: The address is disabled and the address cannot be used for DNS resolution regardless of whether the address passes health checks or not.
        # 
        # This parameter is required.
        self.enable_status = enable_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        return self


class UpdateCloudGtmAddressEnableStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the operation was successful. Valid values:
        # 
        # *   true: The operation was successful.
        # *   false: The operation was failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmAddressEnableStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmAddressEnableStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmAddressEnableStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmAddressManualAvailableStatusRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_id: str = None,
        available_mode: str = None,
        client_token: str = None,
        manual_available_status: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The ID of the address. This ID uniquely identifies the address.
        # 
        # This parameter is required.
        self.address_id = address_id
        # The failover mode that is used when address exceptions are identified. Valid values:
        # 
        # *   auto: the automatic mode. The system determines whether to return an address based on health check results. If the address fails health checks, the system does not return the address. If the address passes health checks, the system returns the address.
        # *   manual: the manual mode. If an address is in the unavailable state, the address is not returned for DNS requests even if the address passes health checks. If an address is in the available state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        self.available_mode = available_mode
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The availability state of the address when AvailableMode is set to manual. Valid values:
        # 
        # *   available: The address is normal. In this state, the address is returned for DNS requests even if an alert is triggered when the address fails health checks.
        # *   unavailable: The address is abnormal. In this state, the address is not returned for DNS requests even if the address passes health checks.
        self.manual_available_status = manual_available_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.available_mode is not None:
            result['AvailableMode'] = self.available_mode
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.manual_available_status is not None:
            result['ManualAvailableStatus'] = self.manual_available_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('AvailableMode') is not None:
            self.available_mode = m.get('AvailableMode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ManualAvailableStatus') is not None:
            self.manual_available_status = m.get('ManualAvailableStatus')
        return self


class UpdateCloudGtmAddressManualAvailableStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmAddressManualAvailableStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmAddressManualAvailableStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmAddressManualAvailableStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmAddressPoolBasicConfigRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_id: str = None,
        address_pool_name: str = None,
        client_token: str = None,
        health_judgement: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Address pool name, helping users distinguish the purpose of address pools.
        self.address_pool_name = address_pool_name
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The condition for determining the health status of the address pool. Valid values:
        # 
        # *   any_ok: At least one address in the address pool is available.
        # *   p30_ok: At least 30% of the addresses in the address pool are available.
        # *   p50_ok: At least 50% of the addresses in the address pool are available.
        # *   p70_ok: At least 70% of the addresses in the address pool are available.
        # *   all_ok: All addresses in the address pool are available.
        self.health_judgement = health_judgement

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.address_pool_name is not None:
            result['AddressPoolName'] = self.address_pool_name
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.health_judgement is not None:
            result['HealthJudgement'] = self.health_judgement
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('AddressPoolName') is not None:
            self.address_pool_name = m.get('AddressPoolName')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('HealthJudgement') is not None:
            self.health_judgement = m.get('HealthJudgement')
        return self


class UpdateCloudGtmAddressPoolBasicConfigResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Unique request identification code.
        self.request_id = request_id
        # Modify the basic configuration of the address pool operation success:
        # - true: Operation successful
        # - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmAddressPoolBasicConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmAddressPoolBasicConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmAddressPoolBasicConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmAddressPoolEnableStatusRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_id: str = None,
        client_token: str = None,
        enable_status: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The enabling state of the address pool. Valid values:
        # 
        # *   enable: The address pool is enabled, and the addresses in the address pool are returned for DNS resolution when the health check results are normal.
        # *   disable: The address pool is disabled, and the addresses in the address pool are not returned for DNS resolution regardless of whether the health check results are normal or not.
        self.enable_status = enable_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        return self


class UpdateCloudGtmAddressPoolEnableStatusResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the modification operation was successful:
        # - true: Operation was successful
        # - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmAddressPoolEnableStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmAddressPoolEnableStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmAddressPoolEnableStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmAddressPoolLbStrategyRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_lb_strategy: str = None,
        address_pool_id: str = None,
        client_token: str = None,
        sequence_lb_strategy_mode: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # Load balancing policy among addresses in the address pool:
        # - round_robin: Round-robin, for any source of DNS resolution requests, all addresses are returned. The order of all addresses is rotated each time.
        # - sequence: Sequential, for any source of DNS resolution requests, the address with the smaller sequence number (the sequence number indicates the priority of address returns, with smaller numbers having higher priority) is returned. If the address with the smaller sequence number is unavailable, the next address with a smaller sequence number is returned.
        # - weight: Weighted, supports setting different weight values for each address, realizing the return of addresses according to the weight ratio for resolution queries.
        # - source_nearest: Source-nearest, i.e., intelligent resolution function, where GTM can return different addresses based on the source of different DNS resolution requests, achieving the effect of users accessing nearby.
        self.address_lb_strategy = address_lb_strategy
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The mode used if the address with the smallest sequence number is recovered. This parameter is required only when AddressLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address with the smallest sequence number is preferentially used if this address is recovered.
        # *   non_preemptive: The current address is still used even if the address with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_lb_strategy is not None:
            result['AddressLbStrategy'] = self.address_lb_strategy
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressLbStrategy') is not None:
            self.address_lb_strategy = m.get('AddressLbStrategy')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        return self


class UpdateCloudGtmAddressPoolLbStrategyResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the modification operation was successful:
        # - true: Operation successful
        # - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmAddressPoolLbStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmAddressPoolLbStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmAddressPoolLbStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmAddressPoolRemarkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_id: str = None,
        client_token: str = None,
        remark: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The input parameter serves as the updated note; if an empty value is passed, the note will be deleted.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateCloudGtmAddressPoolRemarkResponseBody(TeaModel):
    def __init__(
        self,
        address_pool_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the address pool. This ID uniquely identifies the address pool.
        self.address_pool_id = address_pool_id
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the modification operation was successful:
        # - true: Operation successful
        # - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_pool_id is not None:
            result['AddressPoolId'] = self.address_pool_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressPoolId') is not None:
            self.address_pool_id = m.get('AddressPoolId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmAddressPoolRemarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmAddressPoolRemarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmAddressPoolRemarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmAddressRemarkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_id: str = None,
        client_token: str = None,
        remark: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The ID of the address. This ID uniquely identifies the address.
        # 
        # This parameter is required.
        self.address_id = address_id
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The input parameter serves as the updated note; if an empty value is passed, the note will be deleted.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_id is not None:
            result['AddressId'] = self.address_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressId') is not None:
            self.address_id = m.get('AddressId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateCloudGtmAddressRemarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the modification operation was successful:
        # - true: Operation was successful
        # - false: Operation was failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmAddressRemarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmAddressRemarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmAddressRemarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmGlobalAlertRequestAlertConfig(TeaModel):
    def __init__(
        self,
        dingtalk_notice: bool = None,
        email_notice: bool = None,
        notice_type: str = None,
        sms_notice: bool = None,
    ):
        # Specifies whether to configure DingTalk notifications. Valid values:
        # 
        # *   true: configures DingTalk notifications. DingTalk notifications are sent when alerts are triggered.
        # *   false: does not configure DingTalk notifications.
        self.dingtalk_notice = dingtalk_notice
        # Specifies whether to configure email notifications. Valid values:
        # 
        # *   true: configures email notifications. Emails are sent when alerts are triggered.
        # *   false｜null: does not configure email notifications.
        self.email_notice = email_notice
        # The type of the alert event. Valid values:
        # 
        # *   addr_alert: The address is unavailable.
        # *   addr_resume: The address becomes available.
        # *   addr_pool_unavailable: The address pool is unavailable.
        # *   addr_pool_available: The address pool becomes available.
        self.notice_type = notice_type
        # Specifies whether to configure text message notifications. Valid values:
        # 
        # *   true: configures text message notifications. Text messages are sent when alerts are triggered.
        # *   false｜null: does not configure text message notifications.
        # 
        # Only the China site (aliyun.com) supports text message notifications.
        self.sms_notice = sms_notice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_notice is not None:
            result['DingtalkNotice'] = self.dingtalk_notice
        if self.email_notice is not None:
            result['EmailNotice'] = self.email_notice
        if self.notice_type is not None:
            result['NoticeType'] = self.notice_type
        if self.sms_notice is not None:
            result['SmsNotice'] = self.sms_notice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkNotice') is not None:
            self.dingtalk_notice = m.get('DingtalkNotice')
        if m.get('EmailNotice') is not None:
            self.email_notice = m.get('EmailNotice')
        if m.get('NoticeType') is not None:
            self.notice_type = m.get('NoticeType')
        if m.get('SmsNotice') is not None:
            self.sms_notice = m.get('SmsNotice')
        return self


class UpdateCloudGtmGlobalAlertRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        alert_config: List[UpdateCloudGtmGlobalAlertRequestAlertConfig] = None,
        alert_group: List[str] = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language
        # The alert configurations.
        self.alert_config = alert_config
        # The alert contact groups.
        self.alert_group = alert_group
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = UpdateCloudGtmGlobalAlertRequestAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class UpdateCloudGtmGlobalAlertShrinkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        alert_config_shrink: str = None,
        alert_group_shrink: str = None,
        client_token: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language
        # The alert configurations.
        self.alert_config_shrink = alert_config_shrink
        # The alert contact groups.
        self.alert_group_shrink = alert_group_shrink
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.alert_config_shrink is not None:
            result['AlertConfig'] = self.alert_config_shrink
        if self.alert_group_shrink is not None:
            result['AlertGroup'] = self.alert_group_shrink
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AlertConfig') is not None:
            self.alert_config_shrink = m.get('AlertConfig')
        if m.get('AlertGroup') is not None:
            self.alert_group_shrink = m.get('AlertGroup')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class UpdateCloudGtmGlobalAlertResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmGlobalAlertResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmGlobalAlertResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmGlobalAlertResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmInstanceConfigAlertRequestAlertConfig(TeaModel):
    def __init__(
        self,
        dingtalk_notice: bool = None,
        email_notice: bool = None,
        notice_type: str = None,
        sms_notice: bool = None,
    ):
        # Specifies whether to configure DingTalk notifications. Valid values:
        # 
        # *   true: configures DingTalk notifications. DingTalk notifications are sent when alerts are triggered.
        # *   false: does not configure DingTalk notifications.
        self.dingtalk_notice = dingtalk_notice
        # Specifies whether to configure email notifications. Valid values:
        # 
        # *   true: configures email notifications. Emails are sent when alerts are triggered.
        # *   false: does not configure email notifications.
        self.email_notice = email_notice
        # The type of the alert event. Valid values:
        # 
        # *   addr_alert: The address is unavailable.
        # *   addr_resume: The address becomes available.
        # *   addr_pool_unavailable: The address pool is unavailable.
        # *   addr_pool_available: The address pool becomes available.
        self.notice_type = notice_type
        # Specifies whether to configure text message notifications. Valid values:
        # 
        # *   true: configures text message notifications. Text messages are sent when alerts are triggered.
        # *   false: does not configure text message notifications.
        # 
        # Only the China site (aliyun.com) supports text message notifications.
        self.sms_notice = sms_notice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_notice is not None:
            result['DingtalkNotice'] = self.dingtalk_notice
        if self.email_notice is not None:
            result['EmailNotice'] = self.email_notice
        if self.notice_type is not None:
            result['NoticeType'] = self.notice_type
        if self.sms_notice is not None:
            result['SmsNotice'] = self.sms_notice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkNotice') is not None:
            self.dingtalk_notice = m.get('DingtalkNotice')
        if m.get('EmailNotice') is not None:
            self.email_notice = m.get('EmailNotice')
        if m.get('NoticeType') is not None:
            self.notice_type = m.get('NoticeType')
        if m.get('SmsNotice') is not None:
            self.sms_notice = m.get('SmsNotice')
        return self


class UpdateCloudGtmInstanceConfigAlertRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        alert_config: List[UpdateCloudGtmInstanceConfigAlertRequestAlertConfig] = None,
        alert_group: List[str] = None,
        alert_mode: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language
        # The alert configurations.
        self.alert_config = alert_config
        # The alert contact groups.
        self.alert_group = alert_group
        # The alert configuration mode of the instance. Valid values:
        # 
        # *   global: global alert configuration
        # *   instance_config: custom alert configuration
        self.alert_mode = alert_mode
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when an A record and an AAAA record are configured for the access domain name that is bound to the GTM instance. This ID uniquely identifies a configuration.
        self.config_id = config_id
        # The ID of the Global Traffic Manager (GTM) 3.0 instance.
        self.instance_id = instance_id

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.alert_mode is not None:
            result['AlertMode'] = self.alert_mode
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = UpdateCloudGtmInstanceConfigAlertRequestAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('AlertMode') is not None:
            self.alert_mode = m.get('AlertMode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class UpdateCloudGtmInstanceConfigAlertShrinkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        alert_config_shrink: str = None,
        alert_group_shrink: str = None,
        alert_mode: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language
        # The alert configurations.
        self.alert_config_shrink = alert_config_shrink
        # The alert contact groups.
        self.alert_group_shrink = alert_group_shrink
        # The alert configuration mode of the instance. Valid values:
        # 
        # *   global: global alert configuration
        # *   instance_config: custom alert configuration
        self.alert_mode = alert_mode
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when an A record and an AAAA record are configured for the access domain name that is bound to the GTM instance. This ID uniquely identifies a configuration.
        self.config_id = config_id
        # The ID of the Global Traffic Manager (GTM) 3.0 instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.alert_config_shrink is not None:
            result['AlertConfig'] = self.alert_config_shrink
        if self.alert_group_shrink is not None:
            result['AlertGroup'] = self.alert_group_shrink
        if self.alert_mode is not None:
            result['AlertMode'] = self.alert_mode
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AlertConfig') is not None:
            self.alert_config_shrink = m.get('AlertConfig')
        if m.get('AlertGroup') is not None:
            self.alert_group_shrink = m.get('AlertGroup')
        if m.get('AlertMode') is not None:
            self.alert_mode = m.get('AlertMode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class UpdateCloudGtmInstanceConfigAlertResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmInstanceConfigAlertResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmInstanceConfigAlertResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmInstanceConfigAlertResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmInstanceConfigBasicRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
        schedule_hostname: str = None,
        schedule_zone_name: str = None,
        ttl: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US** (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        # 
        # You can call the [ListCloudGtmInstanceConfigs](https://help.aliyun.com/document_detail/2797349.html) operation to query the value of ConfigId for the access domain name.
        self.config_id = config_id
        # The ID of the GTM 3.0 instance for which you want to modify the TTL configuration.
        self.instance_id = instance_id
        # Host record of the domain accessed by GTM.
        self.schedule_hostname = schedule_hostname
        # The zone (such as example.com) or subzone (such as a.example.com) of the GTM access domain name. In most cases, the zone or subzone is hosted in Authoritative DNS Resolution of the Alibaba Cloud DNS console within the account to which the GTM instance belongs.
        self.schedule_zone_name = schedule_zone_name
        # The global TTL value, in seconds. The global TTL value affects how long the DNS records that map the access domain name to the addresses in the address pools are cached in the local DNS servers of Internet service providers (ISPs).
        self.ttl = ttl

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.schedule_hostname is not None:
            result['ScheduleHostname'] = self.schedule_hostname
        if self.schedule_zone_name is not None:
            result['ScheduleZoneName'] = self.schedule_zone_name
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ScheduleHostname') is not None:
            self.schedule_hostname = m.get('ScheduleHostname')
        if m.get('ScheduleZoneName') is not None:
            self.schedule_zone_name = m.get('ScheduleZoneName')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        return self


class UpdateCloudGtmInstanceConfigBasicResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the operation was successful: 
        # - **true**: The call succeeded. 
        # - **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmInstanceConfigBasicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmInstanceConfigBasicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmInstanceConfigBasicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmInstanceConfigEnableStatusRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        config_id: str = None,
        enable_status: str = None,
        instance_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US** (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        # 
        # You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.
        self.config_id = config_id
        # The enabling state of the access domain name. Valid values:
        # 
        # *   enable
        # *   disable
        self.enable_status = enable_status
        # The ID of the Global Traffic Manager (GTM) 3.0 instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.enable_status is not None:
            result['EnableStatus'] = self.enable_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('EnableStatus') is not None:
            self.enable_status = m.get('EnableStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class UpdateCloudGtmInstanceConfigEnableStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Indicates whether the operation was successful: 
        # - **true**: The call succeeded. 
        # - **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmInstanceConfigEnableStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmInstanceConfigEnableStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmInstanceConfigEnableStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmInstanceConfigLbStrategyRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        address_pool_lb_strategy: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
        sequence_lb_strategy_mode: str = None,
    ):
        # The language in which the returned results are displayed. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US** (default): English
        self.accept_language = accept_language
        # The new policy for load balancing between address pools. Valid values:
        # 
        # *   round_robin: All address pools are returned for Domain Name System (DNS) requests from any source. All address pools are sorted in round-robin mode each time they are returned.
        # *   sequence: The address pool with the smallest sequence number is preferentially returned for DNS requests from any source. The sequence number indicates the priority for returning the address pool. A smaller sequence number indicates a higher priority. If the address pool with the smallest sequence number is unavailable, the address pool with the second smallest sequence number is returned.
        # *   weight: You can set a different weight value for each address pool. This way, address pools are returned based on the weight values.
        # *   source_nearest: GTM returns different address pools based on the sources of DNS requests. This way, users can access nearby address pools.
        self.address_pool_lb_strategy = address_pool_lb_strategy
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        # 
        # You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the desired access domain name.
        self.config_id = config_id
        # The ID of the GTM 3.0 instance for which you want to modify the load balancing policy.
        self.instance_id = instance_id
        # The mode used if the address pool with the smallest sequence number is recovered. This parameter is required when AddressPoolLbStrategy is set to sequence. Valid values:
        # 
        # *   preemptive: The address pool with the smallest sequence number is preferentially used if this address pool is recovered.
        # *   non_preemptive: The current address pool is still used even if the address pool with the smallest sequence number is recovered.
        self.sequence_lb_strategy_mode = sequence_lb_strategy_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.address_pool_lb_strategy is not None:
            result['AddressPoolLbStrategy'] = self.address_pool_lb_strategy
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.sequence_lb_strategy_mode is not None:
            result['SequenceLbStrategyMode'] = self.sequence_lb_strategy_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('AddressPoolLbStrategy') is not None:
            self.address_pool_lb_strategy = m.get('AddressPoolLbStrategy')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SequenceLbStrategyMode') is not None:
            self.sequence_lb_strategy_mode = m.get('SequenceLbStrategyMode')
        return self


class UpdateCloudGtmInstanceConfigLbStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmInstanceConfigLbStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmInstanceConfigLbStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmInstanceConfigLbStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmInstanceConfigRemarkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        config_id: str = None,
        instance_id: str = None,
        remark: str = None,
    ):
        # The language in which the returned results are displayed. Valid values:
        # 
        # *   **zh-CN**: Chinese
        # *   **en-US** (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The configuration ID of the access domain name. Two configuration IDs exist when the access domain name is bound to the same GTM instance but an A record and an AAAA record are configured for the access domain name. The configuration ID uniquely identifies a configuration.
        # 
        # You can call the [ListCloudGtmInstanceConfigs](~~ListCloudGtmInstanceConfigs~~) operation to query the configuration ID of the access domain name.
        self.config_id = config_id
        # The ID of the GTM 3.0 instance for which you want to modify the description.
        self.instance_id = instance_id
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateCloudGtmInstanceConfigRemarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmInstanceConfigRemarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmInstanceConfigRemarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmInstanceConfigRemarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmInstanceNameRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        instance_id: str = None,
        instance_name: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can specify a custom value for this parameter, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The ID of the Global Traffic Manager (GTM) instance.
        self.instance_id = instance_id
        # The name of the instance. You cannot leave this parameter empty.
        self.instance_name = instance_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        return self


class UpdateCloudGtmInstanceNameResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmInstanceNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmInstanceNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmInstanceNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmMonitorTemplateRequestIspCityNodes(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        isp_code: str = None,
    ):
        # The city code of the health check node.
        self.city_code = city_code
        # The Internet service provider (ISP) code of the health check node.
        self.isp_code = isp_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        return self


class UpdateCloudGtmMonitorTemplateRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        evaluation_count: int = None,
        extend_info: str = None,
        failure_rate: int = None,
        interval: int = None,
        isp_city_nodes: List[UpdateCloudGtmMonitorTemplateRequestIspCityNodes] = None,
        name: str = None,
        template_id: str = None,
        timeout: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The number of retries. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry options are:
        # - 1 
        # - 2 
        # - 3
        self.evaluation_count = evaluation_count
        # The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.
        # 
        # *   HTTP or HTTPS:
        # 
        #     host: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.
        # 
        #     path: the URL for HTTP or HTTPS health checks. Default value: /.
        # 
        #     code: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:
        # 
        #     *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
        #     *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.
        # 
        #     sni: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:
        # 
        #     *   true: enables SNI.
        #     *   false: disables SNI.
        # 
        #     followRedirect: specifies whether to follow 3XX redirects. Valid values:
        # 
        #     *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
        #     *   false: does not follow 3XX redirects.
        # 
        # *   ping:
        # 
        #     packetNum: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.
        # 
        #     packetLossRate: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.
        self.extend_info = extend_info
        # Percentage of selected node probe failures (%), that is, the percentage of abnormal detection points among the total detection points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
        # - 20
        # - 50
        # - 80
        # - 100
        self.failure_rate = failure_rate
        # The time interval (in seconds) for each health check probe. By default, it probes every 60 seconds. The minimum supported interval for health checks is 15 seconds, available for flagship edition instances.
        self.interval = interval
        # The health check nodes. You can call the [ListCloudGtmMonitorNodes](https://help.aliyun.com/document_detail/2797327.html) operation to obtain the health check nodes.
        self.isp_city_nodes = isp_city_nodes
        # The name of the health check probe template, which is generally recommended to be distinguishable and memorable for configuration personnel, ideally indicating the health check protocol for easier identification.
        self.name = name
        # The ID of the health check template that you want to modify. This ID uniquely identifies the health check template.
        # 
        # This parameter is required.
        self.template_id = template_id
        # Probe timeout (in milliseconds), data packets not returned within the timeout period are considered as health check timeouts:
        # - 2000
        # - 3000
        # - 5000
        # - 10000
        self.timeout = timeout

    def validate(self):
        if self.isp_city_nodes:
            for k in self.isp_city_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.extend_info is not None:
            result['ExtendInfo'] = self.extend_info
        if self.failure_rate is not None:
            result['FailureRate'] = self.failure_rate
        if self.interval is not None:
            result['Interval'] = self.interval
        result['IspCityNodes'] = []
        if self.isp_city_nodes is not None:
            for k in self.isp_city_nodes:
                result['IspCityNodes'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('ExtendInfo') is not None:
            self.extend_info = m.get('ExtendInfo')
        if m.get('FailureRate') is not None:
            self.failure_rate = m.get('FailureRate')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.isp_city_nodes = []
        if m.get('IspCityNodes') is not None:
            for k in m.get('IspCityNodes'):
                temp_model = UpdateCloudGtmMonitorTemplateRequestIspCityNodes()
                self.isp_city_nodes.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpdateCloudGtmMonitorTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        evaluation_count: int = None,
        extend_info: str = None,
        failure_rate: int = None,
        interval: int = None,
        isp_city_nodes_shrink: str = None,
        name: str = None,
        template_id: str = None,
        timeout: int = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US (default): English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The number of retries. The system will only judge the application service as abnormal after consecutive monitoring failures to prevent inaccurate monitoring results due to momentary network fluctuations or other reasons. Available retry options are:
        # - 1 
        # - 2 
        # - 3
        self.evaluation_count = evaluation_count
        # The extended information. The value of this parameter is a JSON string. The required parameters vary based on the health check protocol.
        # 
        # *   HTTP or HTTPS:
        # 
        #     host: the Host field of an HTTP or HTTPS request header during an HTTP or HTTPS health check. The parameter value indicates the HTTP website that you want to visit. By default, the value is the primary domain name. You can change the value based on your business requirements.
        # 
        #     path: the URL for HTTP or HTTPS health checks. Default value: /.
        # 
        #     code: the alert threshold. During an HTTP or HTTPS health check, the system checks whether a web server functions as expected based on the status code that is returned from the web server. If the returned status code is greater than the specified threshold, the corresponding application service address is deemed abnormal. Valid values:
        # 
        #     *   400: specifies an invalid request. If an HTTP or HTTPS request contains invalid request parameters, a web server returns a status code that is greater than 400. You must set path to an exact URL if you set code to 400.
        #     *   500: specifies a server error. If some exceptions occur on a web server, the web server returns a status code that is greater than 500. This value is used by default.
        # 
        #     sni: specifies whether to enable Server Name Indication (SNI). This parameter is used only when the health check protocol is HTTPS. SNI is an extension to the Transport Layer Security (TLS) protocol, which allows a client to specify the host to be connected when the client sends a TLS handshake request. TLS handshakes occur before any data of HTTP requests is sent. Therefore, SNI enables servers to identify the services that clients are attempting to access before certificates are sent. This allows the servers to present correct certificates to the clients. Valid values:
        # 
        #     *   true: enables SNI.
        #     *   false: disables SNI.
        # 
        #     followRedirect: specifies whether to follow 3XX redirects. Valid values:
        # 
        #     *   true: follows 3XX redirects. You are redirected to the destination address if a 3XX status code such as 301, 302, 303, 307, or 308 is returned.
        #     *   false: does not follow 3XX redirects.
        # 
        # *   ping:
        # 
        #     packetNum: the total number of Internet Control Message Protocol (ICMP) packets that are sent to the address for each ping-based health check. Valid values: 20, 50, and 100.
        # 
        #     packetLossRate: the ICMP packet loss rate for each ping-based health check. The packet loss rate in a health check can be calculated by using the following formula: Packet loss rate in a health check = (Number of lost packets/Total number of sent ICMP packets) × 100%. If the packet loss rate reaches the threshold, an alert is triggered. Valid values: 10, 30, 40, 80, 90, and 100.
        self.extend_info = extend_info
        # Percentage of selected node probe failures (%), that is, the percentage of abnormal detection points among the total detection points. When the failure ratio exceeds the set threshold, the service address is judged as abnormal. The available failure ratio thresholds are:
        # - 20
        # - 50
        # - 80
        # - 100
        self.failure_rate = failure_rate
        # The time interval (in seconds) for each health check probe. By default, it probes every 60 seconds. The minimum supported interval for health checks is 15 seconds, available for flagship edition instances.
        self.interval = interval
        # The health check nodes. You can call the [ListCloudGtmMonitorNodes](https://help.aliyun.com/document_detail/2797327.html) operation to obtain the health check nodes.
        self.isp_city_nodes_shrink = isp_city_nodes_shrink
        # The name of the health check probe template, which is generally recommended to be distinguishable and memorable for configuration personnel, ideally indicating the health check protocol for easier identification.
        self.name = name
        # The ID of the health check template that you want to modify. This ID uniquely identifies the health check template.
        # 
        # This parameter is required.
        self.template_id = template_id
        # Probe timeout (in milliseconds), data packets not returned within the timeout period are considered as health check timeouts:
        # - 2000
        # - 3000
        # - 5000
        # - 10000
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.extend_info is not None:
            result['ExtendInfo'] = self.extend_info
        if self.failure_rate is not None:
            result['FailureRate'] = self.failure_rate
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_city_nodes_shrink is not None:
            result['IspCityNodes'] = self.isp_city_nodes_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('ExtendInfo') is not None:
            self.extend_info = m.get('ExtendInfo')
        if m.get('FailureRate') is not None:
            self.failure_rate = m.get('FailureRate')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspCityNodes') is not None:
            self.isp_city_nodes_shrink = m.get('IspCityNodes')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpdateCloudGtmMonitorTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Unique request identification code.
        self.request_id = request_id
        # Modify the health check template operation status:
        # - true: Operation successful
        # - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmMonitorTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmMonitorTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmMonitorTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudGtmMonitorTemplateRemarkRequest(TeaModel):
    def __init__(
        self,
        accept_language: str = None,
        client_token: str = None,
        remark: str = None,
        template_id: str = None,
    ):
        # The language of the response. Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        self.accept_language = accept_language
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        self.client_token = client_token
        # The new description of the template. If you do not specify this parameter, the original description is deleted.
        self.remark = remark
        # The ID of the health check template. This ID uniquely identifies a health check template.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateCloudGtmMonitorTemplateRemarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Modify the health check template remark operation status:
        # - true: Operation successful
        # - false: Operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCloudGtmMonitorTemplateRemarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudGtmMonitorTemplateRemarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudGtmMonitorTemplateRemarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCustomLineRequestIpSegment(TeaModel):
    def __init__(
        self,
        end_ip: str = None,
        start_ip: str = None,
    ):
        # The end IP address of the CIDR block.
        self.end_ip = end_ip
        # The start IP address of the CIDR block.
        self.start_ip = start_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ip is not None:
            result['EndIp'] = self.end_ip
        if self.start_ip is not None:
            result['StartIp'] = self.start_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndIp') is not None:
            self.end_ip = m.get('EndIp')
        if m.get('StartIp') is not None:
            self.start_ip = m.get('StartIp')
        return self


class UpdateCustomLineRequest(TeaModel):
    def __init__(
        self,
        ip_segment: List[UpdateCustomLineRequestIpSegment] = None,
        lang: str = None,
        line_id: int = None,
        line_name: str = None,
    ):
        # The CIDR blocks. Separate IP addresses with a hyphen (-). Enter a CIDR block in each row. You can enter 1 to 50 CIDR blocks at a time. If a CIDR block contains only one IP address, enter the IP address in the format of IP1-IP1. Different CIDR blocks cannot be overlapped.
        self.ip_segment = ip_segment
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The unique ID of the custom line. You can call the [DescribeCustomLines](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describecustomlines?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the unique ID.
        # 
        # This parameter is required.
        self.line_id = line_id
        # The name of the custom line. The name must be 1 to 20 characters in length and can contain letters, digits, hyphens (-), and underscores (_).
        self.line_name = line_name

    def validate(self):
        if self.ip_segment:
            for k in self.ip_segment:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IpSegment'] = []
        if self.ip_segment is not None:
            for k in self.ip_segment:
                result['IpSegment'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line_id is not None:
            result['LineId'] = self.line_id
        if self.line_name is not None:
            result['LineName'] = self.line_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ip_segment = []
        if m.get('IpSegment') is not None:
            for k in m.get('IpSegment'):
                temp_model = UpdateCustomLineRequestIpSegment()
                self.ip_segment.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LineId') is not None:
            self.line_id = m.get('LineId')
        if m.get('LineName') is not None:
            self.line_name = m.get('LineName')
        return self


class UpdateCustomLineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCustomLineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCustomLineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCustomLineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDNSSLBWeightRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        record_id: str = None,
        user_client_ip: str = None,
        weight: int = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/en/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.record_id = record_id
        # The IP address of the client.
        self.user_client_ip = user_client_ip
        # The weight of the DNS record that you want to specify. Valid values: `1 to 100`.
        # 
        # This parameter is required.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class UpdateDNSSLBWeightResponseBody(TeaModel):
    def __init__(
        self,
        record_id: str = None,
        request_id: str = None,
        weight: int = None,
    ):
        # The ID of the DNS record.
        self.record_id = record_id
        # The request ID.
        self.request_id = request_id
        # The updated weight.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class UpdateDNSSLBWeightResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDNSSLBWeightResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDNSSLBWeightResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDnsCacheDomainRequestSourceDnsServer(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: str = None,
    ):
        # The domain name or IP address of the origin DNS server.
        self.host = host
        # The port of the origin DNS server.
        self.port = port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        return self


class UpdateDnsCacheDomainRequest(TeaModel):
    def __init__(
        self,
        cache_ttl_max: int = None,
        cache_ttl_min: int = None,
        domain_name: str = None,
        instance_id: str = None,
        lang: str = None,
        source_dns_server: List[UpdateDnsCacheDomainRequestSourceDnsServer] = None,
        source_edns: str = None,
        source_protocol: str = None,
    ):
        # The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.
        self.cache_ttl_max = cache_ttl_max
        # The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.
        self.cache_ttl_min = cache_ttl_min
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtian the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The instance ID of the cache-accelerated domain name. You can call the [ListCloudGtmInstances](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-listcloudgtminstances?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        self.instance_id = instance_id
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English Default: **zh**\
        self.lang = lang
        # The origin DNS servers. A maximum of 10 origin DNS servers are supported.
        self.source_dns_server = source_dns_server
        # Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.
        self.source_edns = source_edns
        # The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.
        self.source_protocol = source_protocol

    def validate(self):
        if self.source_dns_server:
            for k in self.source_dns_server:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cache_ttl_max is not None:
            result['CacheTtlMax'] = self.cache_ttl_max
        if self.cache_ttl_min is not None:
            result['CacheTtlMin'] = self.cache_ttl_min
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        result['SourceDnsServer'] = []
        if self.source_dns_server is not None:
            for k in self.source_dns_server:
                result['SourceDnsServer'].append(k.to_map() if k else None)
        if self.source_edns is not None:
            result['SourceEdns'] = self.source_edns
        if self.source_protocol is not None:
            result['SourceProtocol'] = self.source_protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CacheTtlMax') is not None:
            self.cache_ttl_max = m.get('CacheTtlMax')
        if m.get('CacheTtlMin') is not None:
            self.cache_ttl_min = m.get('CacheTtlMin')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        self.source_dns_server = []
        if m.get('SourceDnsServer') is not None:
            for k in m.get('SourceDnsServer'):
                temp_model = UpdateDnsCacheDomainRequestSourceDnsServer()
                self.source_dns_server.append(temp_model.from_map(k))
        if m.get('SourceEdns') is not None:
            self.source_edns = m.get('SourceEdns')
        if m.get('SourceProtocol') is not None:
            self.source_protocol = m.get('SourceProtocol')
        return self


class UpdateDnsCacheDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDnsCacheDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDnsCacheDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDnsCacheDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDnsCacheDomainRemarkRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        remark: str = None,
    ):
        # The domain name. You can call the [DescribeDomains](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the content within the request and response. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        # 
        # Default: **zh**\
        self.lang = lang
        # The remarks. The remarks can be up to 50 characters in length and can contain only letters, digits, periods (.), underscores (_), and hyphens (-).
        # 
        # Delete the original remarks when it is empty.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateDnsCacheDomainRemarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDnsCacheDomainRemarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDnsCacheDomainRemarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDnsCacheDomainRemarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDnsGtmAccessStrategyRequestDefaultAddrPool(TeaModel):
    def __init__(
        self,
        id: str = None,
        lba_weight: int = None,
    ):
        # The ID of the address pool in the primary address pool set.
        self.id = id
        # The weight of the address pool in the primary address pool set.
        self.lba_weight = lba_weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        return self


class UpdateDnsGtmAccessStrategyRequestFailoverAddrPool(TeaModel):
    def __init__(
        self,
        id: str = None,
        lba_weight: int = None,
    ):
        # The ID of the address pool in the secondary address pool set.
        self.id = id
        # The weight of the address pool in the secondary address pool set.
        self.lba_weight = lba_weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        return self


class UpdateDnsGtmAccessStrategyRequest(TeaModel):
    def __init__(
        self,
        access_mode: str = None,
        default_addr_pool: List[UpdateDnsGtmAccessStrategyRequestDefaultAddrPool] = None,
        default_addr_pool_type: str = None,
        default_latency_optimization: str = None,
        default_lba_strategy: str = None,
        default_max_return_addr_num: int = None,
        default_min_available_addr_num: int = None,
        failover_addr_pool: List[UpdateDnsGtmAccessStrategyRequestFailoverAddrPool] = None,
        failover_addr_pool_type: str = None,
        failover_latency_optimization: str = None,
        failover_lba_strategy: str = None,
        failover_max_return_addr_num: int = None,
        failover_min_available_addr_num: int = None,
        lang: str = None,
        lines: str = None,
        strategy_id: str = None,
        strategy_name: str = None,
    ):
        # The primary/secondary switchover policy for address pool sets. Valid values:
        # 
        # *   AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.
        # *   DEFAULT: the primary address pool set
        # *   FAILOVER: the secondary address pool set
        self.access_mode = access_mode
        # The address pools in the primary address pool set.
        # 
        # This parameter is required.
        self.default_addr_pool = default_addr_pool
        # The type of the primary address pool. Valid values:
        # 
        # *   IPV4
        # *   IPV6
        # *   DOMAIN
        # 
        # This parameter is required.
        self.default_addr_pool_type = default_addr_pool_type
        # Specifies whether to enable Domain Name System (DNS) resolution with optimal latency for the primary address pool set. Valid values:
        # 
        # *   OPEN
        # *   CLOSE
        self.default_latency_optimization = default_latency_optimization
        # The load balancing policy of the primary address pool set. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        self.default_lba_strategy = default_lba_strategy
        # The maximum number of addresses returned from the primary address pool set.
        self.default_max_return_addr_num = default_max_return_addr_num
        # The minimum number of available addresses in the primary address pool set.
        # 
        # This parameter is required.
        self.default_min_available_addr_num = default_min_available_addr_num
        # The address pools in the secondary address pool set. If no address pool exists in the secondary address pool set, set this parameter to EMPTY.
        self.failover_addr_pool = failover_addr_pool
        # The type of the secondary address pool. Valid values:
        # 
        # *   IPV4
        # *   IPV6
        # *   DOMAIN
        self.failover_addr_pool_type = failover_addr_pool_type
        # Specifies whether to enable DNS resolution with optimal latency for the secondary address pool set. Valid values:
        # 
        # *   OPEN
        # *   CLOSE
        self.failover_latency_optimization = failover_latency_optimization
        # The load balancing policy of the secondary address pool set. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        self.failover_lba_strategy = failover_lba_strategy
        # The maximum number of addresses returned from the secondary address pool set.
        self.failover_max_return_addr_num = failover_max_return_addr_num
        # The minimum number of available addresses in the secondary address pool set.
        self.failover_min_available_addr_num = failover_min_available_addr_num
        # The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The line codes of the source regions. Example: `["default", "drpeng"]`, which indicates the global line and Dr. Peng Group line.
        self.lines = lines
        # The ID of the access policy.
        # 
        # This parameter is required.
        self.strategy_id = strategy_id
        # The name of the access policy.
        # 
        # This parameter is required.
        self.strategy_name = strategy_name

    def validate(self):
        if self.default_addr_pool:
            for k in self.default_addr_pool:
                if k:
                    k.validate()
        if self.failover_addr_pool:
            for k in self.failover_addr_pool:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_mode is not None:
            result['AccessMode'] = self.access_mode
        result['DefaultAddrPool'] = []
        if self.default_addr_pool is not None:
            for k in self.default_addr_pool:
                result['DefaultAddrPool'].append(k.to_map() if k else None)
        if self.default_addr_pool_type is not None:
            result['DefaultAddrPoolType'] = self.default_addr_pool_type
        if self.default_latency_optimization is not None:
            result['DefaultLatencyOptimization'] = self.default_latency_optimization
        if self.default_lba_strategy is not None:
            result['DefaultLbaStrategy'] = self.default_lba_strategy
        if self.default_max_return_addr_num is not None:
            result['DefaultMaxReturnAddrNum'] = self.default_max_return_addr_num
        if self.default_min_available_addr_num is not None:
            result['DefaultMinAvailableAddrNum'] = self.default_min_available_addr_num
        result['FailoverAddrPool'] = []
        if self.failover_addr_pool is not None:
            for k in self.failover_addr_pool:
                result['FailoverAddrPool'].append(k.to_map() if k else None)
        if self.failover_addr_pool_type is not None:
            result['FailoverAddrPoolType'] = self.failover_addr_pool_type
        if self.failover_latency_optimization is not None:
            result['FailoverLatencyOptimization'] = self.failover_latency_optimization
        if self.failover_lba_strategy is not None:
            result['FailoverLbaStrategy'] = self.failover_lba_strategy
        if self.failover_max_return_addr_num is not None:
            result['FailoverMaxReturnAddrNum'] = self.failover_max_return_addr_num
        if self.failover_min_available_addr_num is not None:
            result['FailoverMinAvailableAddrNum'] = self.failover_min_available_addr_num
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessMode') is not None:
            self.access_mode = m.get('AccessMode')
        self.default_addr_pool = []
        if m.get('DefaultAddrPool') is not None:
            for k in m.get('DefaultAddrPool'):
                temp_model = UpdateDnsGtmAccessStrategyRequestDefaultAddrPool()
                self.default_addr_pool.append(temp_model.from_map(k))
        if m.get('DefaultAddrPoolType') is not None:
            self.default_addr_pool_type = m.get('DefaultAddrPoolType')
        if m.get('DefaultLatencyOptimization') is not None:
            self.default_latency_optimization = m.get('DefaultLatencyOptimization')
        if m.get('DefaultLbaStrategy') is not None:
            self.default_lba_strategy = m.get('DefaultLbaStrategy')
        if m.get('DefaultMaxReturnAddrNum') is not None:
            self.default_max_return_addr_num = m.get('DefaultMaxReturnAddrNum')
        if m.get('DefaultMinAvailableAddrNum') is not None:
            self.default_min_available_addr_num = m.get('DefaultMinAvailableAddrNum')
        self.failover_addr_pool = []
        if m.get('FailoverAddrPool') is not None:
            for k in m.get('FailoverAddrPool'):
                temp_model = UpdateDnsGtmAccessStrategyRequestFailoverAddrPool()
                self.failover_addr_pool.append(temp_model.from_map(k))
        if m.get('FailoverAddrPoolType') is not None:
            self.failover_addr_pool_type = m.get('FailoverAddrPoolType')
        if m.get('FailoverLatencyOptimization') is not None:
            self.failover_latency_optimization = m.get('FailoverLatencyOptimization')
        if m.get('FailoverLbaStrategy') is not None:
            self.failover_lba_strategy = m.get('FailoverLbaStrategy')
        if m.get('FailoverMaxReturnAddrNum') is not None:
            self.failover_max_return_addr_num = m.get('FailoverMaxReturnAddrNum')
        if m.get('FailoverMinAvailableAddrNum') is not None:
            self.failover_min_available_addr_num = m.get('FailoverMinAvailableAddrNum')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class UpdateDnsGtmAccessStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        strategy_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the access policy.
        self.strategy_id = strategy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        return self


class UpdateDnsGtmAccessStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDnsGtmAccessStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDnsGtmAccessStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDnsGtmAddressPoolRequestAddr(TeaModel):
    def __init__(
        self,
        addr: str = None,
        attribute_info: str = None,
        lba_weight: int = None,
        mode: str = None,
        remark: str = None,
    ):
        # The address in the address pool.
        # 
        # This parameter is required.
        self.addr = addr
        # The information about the source region of the address. The value of the parameter is a string in the JSON format. Valid values:
        # 
        # *   LineCode: the line code of the source region. This parameter is deprecated. Use lineCodes instead.
        # 
        # *   lineCodes: the line codes of the source region
        # 
        # *   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:
        # 
        #     *   NO_NEED: no need for rectification
        #     *   RECTIFIED: rectified
        #     *   AUTO: automatic rectification
        self.attribute_info = attribute_info
        # The weight of the address.
        self.lba_weight = lba_weight
        # The return mode of the addresses. Valid values:
        # 
        # *   SMART: smart return
        # *   ONLINE: always online
        # *   OFFLINE: always offline
        # 
        # This parameter is required.
        self.mode = mode
        # The description of the address pool.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addr is not None:
            result['Addr'] = self.addr
        if self.attribute_info is not None:
            result['AttributeInfo'] = self.attribute_info
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Addr') is not None:
            self.addr = m.get('Addr')
        if m.get('AttributeInfo') is not None:
            self.attribute_info = m.get('AttributeInfo')
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateDnsGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        addr: List[UpdateDnsGtmAddressPoolRequestAddr] = None,
        addr_pool_id: str = None,
        lang: str = None,
        lba_strategy: str = None,
        name: str = None,
    ):
        # The address pools.
        # 
        # This parameter is required.
        self.addr = addr
        # The ID of the address pool.
        # 
        # This parameter is required.
        self.addr_pool_id = addr_pool_id
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The load balancing policy of the address pool. Valid values:
        # 
        # *   ALL_RR: returns all addresses.
        # *   RATIO: returns addresses by weight.
        # 
        # This parameter is required.
        self.lba_strategy = lba_strategy
        # The name of the address pool.
        self.name = name

    def validate(self):
        if self.addr:
            for k in self.addr:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addr'] = []
        if self.addr is not None:
            for k in self.addr:
                result['Addr'].append(k.to_map() if k else None)
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.lba_strategy is not None:
            result['LbaStrategy'] = self.lba_strategy
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr = []
        if m.get('Addr') is not None:
            for k in m.get('Addr'):
                temp_model = UpdateDnsGtmAddressPoolRequestAddr()
                self.addr.append(temp_model.from_map(k))
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LbaStrategy') is not None:
            self.lba_strategy = m.get('LbaStrategy')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateDnsGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDnsGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDnsGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDnsGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig(TeaModel):
    def __init__(
        self,
        dingtalk_notice: bool = None,
        email_notice: bool = None,
        notice_type: str = None,
        sms_notice: bool = None,
    ):
        self.dingtalk_notice = dingtalk_notice
        self.email_notice = email_notice
        self.notice_type = notice_type
        self.sms_notice = sms_notice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dingtalk_notice is not None:
            result['DingtalkNotice'] = self.dingtalk_notice
        if self.email_notice is not None:
            result['EmailNotice'] = self.email_notice
        if self.notice_type is not None:
            result['NoticeType'] = self.notice_type
        if self.sms_notice is not None:
            result['SmsNotice'] = self.sms_notice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DingtalkNotice') is not None:
            self.dingtalk_notice = m.get('DingtalkNotice')
        if m.get('EmailNotice') is not None:
            self.email_notice = m.get('EmailNotice')
        if m.get('NoticeType') is not None:
            self.notice_type = m.get('NoticeType')
        if m.get('SmsNotice') is not None:
            self.sms_notice = m.get('SmsNotice')
        return self


class UpdateDnsGtmInstanceGlobalConfigRequest(TeaModel):
    def __init__(
        self,
        alert_config: List[UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig] = None,
        alert_group: str = None,
        cname_type: str = None,
        force_update: bool = None,
        instance_id: str = None,
        instance_name: str = None,
        lang: str = None,
        public_cname_mode: str = None,
        public_rr: str = None,
        public_user_domain_name: str = None,
        public_zone_name: str = None,
        ttl: int = None,
    ):
        self.alert_config = alert_config
        # The name of the alert group in the JSON format.
        self.alert_group = alert_group
        # The type of the canonical name (CNAME).
        # 
        # *   Set the value to PUBLIC.
        self.cname_type = cname_type
        # Specifies whether to enable force updates. Valid values:
        # 
        # *   true: enables force update without a conflict alert.
        # *   false: disables force update. If a conflict occurs, the system displays an alert. null: This valid value of ForceUpdate provides the same information as the false value.
        self.force_update = force_update
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The name of the instance. This parameter is required only for the first update.
        self.instance_name = instance_name
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # Specifies whether to use a custom CNAME domain name or a CNAME domain name assigned by the system to access the instance over the Internet. Valid values:
        # 
        # *   SYSTEM_ASSIGN: a CNAME domain name assigned by the system
        # *   CUSTOM: a custom CNAME domain name
        self.public_cname_mode = public_cname_mode
        # The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.
        self.public_rr = public_rr
        # The service domain name that is used over the Internet.
        self.public_user_domain_name = public_user_domain_name
        # The CNAME domain name that is used to access the instance over the Internet, which is the primary domain name. This parameter is required when the PublicCnameMode parameter is set to CUSTOM.
        # 
        # >  You must use the primary domain name. Do not include the hostname specified by the PublicRr parameter.
        self.public_zone_name = public_zone_name
        # The global time to live (TTL).
        self.ttl = ttl

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.cname_type is not None:
            result['CnameType'] = self.cname_type
        if self.force_update is not None:
            result['ForceUpdate'] = self.force_update
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.public_cname_mode is not None:
            result['PublicCnameMode'] = self.public_cname_mode
        if self.public_rr is not None:
            result['PublicRr'] = self.public_rr
        if self.public_user_domain_name is not None:
            result['PublicUserDomainName'] = self.public_user_domain_name
        if self.public_zone_name is not None:
            result['PublicZoneName'] = self.public_zone_name
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('CnameType') is not None:
            self.cname_type = m.get('CnameType')
        if m.get('ForceUpdate') is not None:
            self.force_update = m.get('ForceUpdate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PublicCnameMode') is not None:
            self.public_cname_mode = m.get('PublicCnameMode')
        if m.get('PublicRr') is not None:
            self.public_rr = m.get('PublicRr')
        if m.get('PublicUserDomainName') is not None:
            self.public_user_domain_name = m.get('PublicUserDomainName')
        if m.get('PublicZoneName') is not None:
            self.public_zone_name = m.get('PublicZoneName')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        return self


class UpdateDnsGtmInstanceGlobalConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDnsGtmInstanceGlobalConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDnsGtmInstanceGlobalConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDnsGtmInstanceGlobalConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDnsGtmMonitorRequestIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        isp_code: str = None,
    ):
        # The code of the city where the monitored node is deployed.
        self.city_code = city_code
        # The code of the Internet service provider (ISP) to which the monitored node belongs.
        self.isp_code = isp_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        return self


class UpdateDnsGtmMonitorRequest(TeaModel):
    def __init__(
        self,
        evaluation_count: int = None,
        interval: int = None,
        isp_city_node: List[UpdateDnsGtmMonitorRequestIspCityNode] = None,
        lang: str = None,
        monitor_config_id: str = None,
        monitor_extend_info: str = None,
        protocol_type: str = None,
        timeout: int = None,
    ):
        # The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
        self.evaluation_count = evaluation_count
        # The health check interval. Unit: seconds.
        self.interval = interval
        # The monitored nodes.
        # 
        # This parameter is required.
        self.isp_city_node = isp_city_node
        # The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
        self.lang = lang
        # The ID of the health check configuration.
        # 
        # This parameter is required.
        self.monitor_config_id = monitor_config_id
        # The extended information. The required parameters vary based on the health check protocol.
        # 
        # *   HTTP or HTTPS
        # 
        #     *   port: the port that you want to check
        # 
        #     *   host: the host settings
        # 
        #     *   path: the URL path
        # 
        #     *   code: the return code. If the return value of code is greater than the specified value, the health check result is deemed abnormal. For example, if code is set to 400 and the code 404 is returned, the health check result is deemed abnormal.
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:
        # 
        #         *   true: enables SNI.
        #         *   false: disables SNI.
        # 
        #     *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # *   PING
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   packetNum: the number of ping packets
        # 
        #     *   packetLossRate: the loss rate of ping packets
        # 
        #     *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # *   TCP
        # 
        #     *   port: the port that you want to check
        # 
        #     *   failureRate: the failure rate
        # 
        #     *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:
        # 
        #         *   IPV4
        #         *   IPV6
        # 
        # This parameter is required.
        self.monitor_extend_info = monitor_extend_info
        # The protocol used for the health check. Valid values:
        # 
        # *   HTTP
        # *   HTTPS
        # *   PING
        # *   TCP
        # 
        # This parameter is required.
        self.protocol_type = protocol_type
        # The timeout period. Unit: milliseconds.
        self.timeout = timeout

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.interval is not None:
            result['Interval'] = self.interval
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.monitor_extend_info is not None:
            result['MonitorExtendInfo'] = self.monitor_extend_info
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = UpdateDnsGtmMonitorRequestIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('MonitorExtendInfo') is not None:
            self.monitor_extend_info = m.get('MonitorExtendInfo')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpdateDnsGtmMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDnsGtmMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDnsGtmMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDnsGtmMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDomainGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_name: str = None,
        lang: str = None,
    ):
        # The ID of the domain name group whose name you want to modify. You can call the [DescribeDomainGroups ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomaingroups?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The new name of the domain name group.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class UpdateDomainGroupResponseBody(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_name: str = None,
        request_id: str = None,
    ):
        # The ID of the domain name group.
        self.group_id = group_id
        # The new name of the domain name group.
        self.group_name = group_name
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDomainGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDomainGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDomainGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDomainRecordRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        line: str = None,
        priority: int = None,
        rr: str = None,
        record_id: str = None,
        ttl: int = None,
        type: str = None,
        user_client_ip: str = None,
        value: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The resolution line. Default value: **default**.
        # 
        # For more information, see
        # 
        # [DNS resolution lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).
        self.line = line
        # The priority of the mail exchanger (MX) record. Valid values: `1 to 50`.
        # 
        # This parameter is required if the type of the DNS record is MX.
        self.priority = priority
        # The hostname.
        # 
        # For example, if you want to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it empty.
        # 
        # This parameter is required.
        self.rr = rr
        # The ID of the Domain Name System (DNS) record.
        # 
        # You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.record_id = record_id
        # The time to live (TTL) period of the Alibaba Cloud DNS (DNS) record. Default value: 600. Unit: seconds.
        # 
        # For more information, see
        # 
        # [TTL definition](https://www.alibabacloud.com/help/zh/doc-detail/29806.htm).
        self.ttl = ttl
        # The type of the DNS record. For more information, see
        # 
        # [DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).
        # 
        # This parameter is required.
        self.type = type
        # The IP address of the client.
        self.user_client_ip = user_client_ip
        # The value of the DNS record.
        # 
        # This parameter is required.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.line is not None:
            result['Line'] = self.line
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.rr is not None:
            result['RR'] = self.rr
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.ttl is not None:
            result['TTL'] = self.ttl
        if self.type is not None:
            result['Type'] = self.type
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RR') is not None:
            self.rr = m.get('RR')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('TTL') is not None:
            self.ttl = m.get('TTL')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDomainRecordResponseBody(TeaModel):
    def __init__(
        self,
        record_id: str = None,
        request_id: str = None,
    ):
        # The ID of the DNS record.
        self.record_id = record_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDomainRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDomainRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDomainRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDomainRecordRemarkRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        record_id: str = None,
        remark: str = None,
        user_client_ip: str = None,
    ):
        # The language of the content within the request and response. Default value: **zh**. Valid values:
        # 
        # *   **zh**: Chinese
        # *   **en**: English
        self.lang = lang
        # The ID of the DNS record. You can call the [DescribeDomainRecords](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomainrecords?spm=a2c63.p38356.help-menu-search-29697.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.record_id = record_id
        # The description of the DNS record. This parameter is empty by default. If this parameter is empty, the original remarks are deleted.
        self.remark = remark
        # The IP address of the client.
        self.user_client_ip = user_client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.user_client_ip is not None:
            result['UserClientIp'] = self.user_client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('UserClientIp') is not None:
            self.user_client_ip = m.get('UserClientIp')
        return self


class UpdateDomainRecordRemarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDomainRecordRemarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDomainRecordRemarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDomainRecordRemarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDomainRemarkRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        lang: str = None,
        remark: str = None,
    ):
        # The domain name that already exists in Alibaba Cloud Domain Name System (DNS). You can call the [DescribeDomains ](https://www.alibabacloud.com/help/zh/dns/api-alidns-2015-01-09-describedomains?spm=a2c63.p38356.help-menu-search-29697.d_0)operation to obtain the domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The language of the response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        # 
        # Default value: en
        self.lang = lang
        # The description of the domain name.
        # 
        # It can be up to 50 characters in length and can contain digits, letters, and the following special characters: _ - , .
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateDomainRemarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateDomainRemarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDomainRemarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDomainRemarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGtmAccessStrategyRequest(TeaModel):
    def __init__(
        self,
        access_lines: str = None,
        default_addr_pool_id: str = None,
        failover_addr_pool_id: str = None,
        lang: str = None,
        strategy_id: str = None,
        strategy_name: str = None,
    ):
        # The line codes of access regions.
        self.access_lines = access_lines
        # The ID of the default address pool.
        self.default_addr_pool_id = default_addr_pool_id
        # The ID of the failover address pool.
        self.failover_addr_pool_id = failover_addr_pool_id
        # The language used by the user.
        self.lang = lang
        # The ID of the access policy that you want to query for the GTM instance.
        # 
        # This parameter is required.
        self.strategy_id = strategy_id
        # The name of the access policy.
        self.strategy_name = strategy_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_lines is not None:
            result['AccessLines'] = self.access_lines
        if self.default_addr_pool_id is not None:
            result['DefaultAddrPoolId'] = self.default_addr_pool_id
        if self.failover_addr_pool_id is not None:
            result['FailoverAddrPoolId'] = self.failover_addr_pool_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessLines') is not None:
            self.access_lines = m.get('AccessLines')
        if m.get('DefaultAddrPoolId') is not None:
            self.default_addr_pool_id = m.get('DefaultAddrPoolId')
        if m.get('FailoverAddrPoolId') is not None:
            self.failover_addr_pool_id = m.get('FailoverAddrPoolId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        return self


class UpdateGtmAccessStrategyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateGtmAccessStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGtmAccessStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGtmAccessStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGtmAddressPoolRequestAddr(TeaModel):
    def __init__(
        self,
        lba_weight: int = None,
        mode: str = None,
        value: str = None,
    ):
        # The weight of the address pool that you want to modify.
        self.lba_weight = lba_weight
        # The mode of the address pool that you want to modify.
        # 
        # *   **SMART**: Intelligent return
        # *   **ONLINE**: Always online
        # *   **OFFLINE**: Always offline
        self.mode = mode
        # The addresses in the address pool.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lba_weight is not None:
            result['LbaWeight'] = self.lba_weight
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LbaWeight') is not None:
            self.lba_weight = m.get('LbaWeight')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateGtmAddressPoolRequest(TeaModel):
    def __init__(
        self,
        addr: List[UpdateGtmAddressPoolRequestAddr] = None,
        addr_pool_id: str = None,
        lang: str = None,
        min_available_addr_num: int = None,
        name: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.addr = addr
        # The ID of the address pool that you want to modify.
        # 
        # This parameter is required.
        self.addr_pool_id = addr_pool_id
        # The language used by the user.
        self.lang = lang
        # The minimum number of available addresses in the address pool.
        self.min_available_addr_num = min_available_addr_num
        # The name of the address pool that you want to modify.
        self.name = name
        # The type of the address pool that you want to modify.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.addr:
            for k in self.addr:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addr'] = []
        if self.addr is not None:
            for k in self.addr:
                result['Addr'].append(k.to_map() if k else None)
        if self.addr_pool_id is not None:
            result['AddrPoolId'] = self.addr_pool_id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.min_available_addr_num is not None:
            result['MinAvailableAddrNum'] = self.min_available_addr_num
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addr = []
        if m.get('Addr') is not None:
            for k in m.get('Addr'):
                temp_model = UpdateGtmAddressPoolRequestAddr()
                self.addr.append(temp_model.from_map(k))
        if m.get('AddrPoolId') is not None:
            self.addr_pool_id = m.get('AddrPoolId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MinAvailableAddrNum') is not None:
            self.min_available_addr_num = m.get('MinAvailableAddrNum')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateGtmAddressPoolResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateGtmAddressPoolResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGtmAddressPoolResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGtmAddressPoolResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGtmInstanceGlobalConfigRequest(TeaModel):
    def __init__(
        self,
        alert_group: str = None,
        cname_custom_domain_name: str = None,
        cname_mode: str = None,
        instance_id: str = None,
        instance_name: str = None,
        lang: str = None,
        lba_strategy: str = None,
        ttl: int = None,
        user_domain_name: str = None,
    ):
        # The alert group. Only one alert group is supported.
        # 
        # >  This parameter is required only for the first modification.
        self.alert_group = alert_group
        # If you set **CnameMode** to **CUSTOM**, you must specify the CnameCustomDomainName parameter, which must be set to a primary domain name.
        self.cname_custom_domain_name = cname_custom_domain_name
        # Specifies whether to use a system-assigned canonical name (CNAME) or a custom CNAME to access GTM. Valid values:
        # 
        # *   **SYSTEM_ASSIGN**: system-assigned CNAME
        # *   **CUSTOM**: custom CNAME
        self.cname_mode = cname_mode
        # The ID of the GTM instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The name of the GTM instance.
        # 
        # >  This parameter is required only for the first modification.
        self.instance_name = instance_name
        # The language.
        self.lang = lang
        # The balancing policy. Valid values:
        # 
        # *   **ALL_RR**: load balancing
        # *   **RATIO**: weighted round-robin
        # 
        # >  This parameter is required only for the first modification.
        self.lba_strategy = lba_strategy
        # The global time-to-live (TTL).
        self.ttl = ttl
        # The primary domain name.
        # 
        # >  This parameter is required only for the first modification.
        self.user_domain_name = user_domain_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.cname_custom_domain_name is not None:
            result['CnameCustomDomainName'] = self.cname_custom_domain_name
        if self.cname_mode is not None:
            result['CnameMode'] = self.cname_mode
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.lba_strategy is not None:
            result['LbaStrategy'] = self.lba_strategy
        if self.ttl is not None:
            result['Ttl'] = self.ttl
        if self.user_domain_name is not None:
            result['UserDomainName'] = self.user_domain_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('CnameCustomDomainName') is not None:
            self.cname_custom_domain_name = m.get('CnameCustomDomainName')
        if m.get('CnameMode') is not None:
            self.cname_mode = m.get('CnameMode')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('LbaStrategy') is not None:
            self.lba_strategy = m.get('LbaStrategy')
        if m.get('Ttl') is not None:
            self.ttl = m.get('Ttl')
        if m.get('UserDomainName') is not None:
            self.user_domain_name = m.get('UserDomainName')
        return self


class UpdateGtmInstanceGlobalConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateGtmInstanceGlobalConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGtmInstanceGlobalConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGtmInstanceGlobalConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGtmMonitorRequestIspCityNode(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        isp_code: str = None,
    ):
        # The code of the city where the monitored node is deployed.
        self.city_code = city_code
        # *   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
        # *   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
        # *   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.
        self.isp_code = isp_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.isp_code is not None:
            result['IspCode'] = self.isp_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('IspCode') is not None:
            self.isp_code = m.get('IspCode')
        return self


class UpdateGtmMonitorRequest(TeaModel):
    def __init__(
        self,
        evaluation_count: int = None,
        interval: int = None,
        isp_city_node: List[UpdateGtmMonitorRequestIspCityNode] = None,
        lang: str = None,
        monitor_config_id: str = None,
        monitor_extend_info: str = None,
        protocol_type: str = None,
        timeout: int = None,
    ):
        # The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
        self.evaluation_count = evaluation_count
        # The health check interval. Unit: seconds. Set the value to 60.
        self.interval = interval
        # The monitored nodes.
        # 
        # This parameter is required.
        self.isp_city_node = isp_city_node
        # The language of the values of specific response parameters.
        self.lang = lang
        # The ID of the health check configuration.
        # 
        # This parameter is required.
        self.monitor_config_id = monitor_config_id
        # The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
        # 
        # HTTP or HTTPS:
        # 
        # *   port: the port to check.
        # *   failureRate: the failure rate.
        # *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
        # *   host: the host configuration.
        # *   path: the health check URL.
        # 
        # PING:
        # 
        # *   packetNum: the number of ping packets.
        # *   packetLossRate: the loss rate of ping packets.
        # *   failureRate: the failure rate.
        # 
        # TCP:
        # 
        # *   port: the port to check.
        # *   failureRate: the failure rate.
        # 
        # This parameter is required.
        self.monitor_extend_info = monitor_extend_info
        # The protocol used for the health check.
        # 
        # This parameter is required.
        self.protocol_type = protocol_type
        # The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
        self.timeout = timeout

    def validate(self):
        if self.isp_city_node:
            for k in self.isp_city_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.interval is not None:
            result['Interval'] = self.interval
        result['IspCityNode'] = []
        if self.isp_city_node is not None:
            for k in self.isp_city_node:
                result['IspCityNode'].append(k.to_map() if k else None)
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.monitor_config_id is not None:
            result['MonitorConfigId'] = self.monitor_config_id
        if self.monitor_extend_info is not None:
            result['MonitorExtendInfo'] = self.monitor_extend_info
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.isp_city_node = []
        if m.get('IspCityNode') is not None:
            for k in m.get('IspCityNode'):
                temp_model = UpdateGtmMonitorRequestIspCityNode()
                self.isp_city_node.append(temp_model.from_map(k))
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('MonitorConfigId') is not None:
            self.monitor_config_id = m.get('MonitorConfigId')
        if m.get('MonitorExtendInfo') is not None:
            self.monitor_extend_info = m.get('MonitorExtendInfo')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpdateGtmMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateGtmMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGtmMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGtmMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGtmRecoveryPlanRequest(TeaModel):
    def __init__(
        self,
        fault_addr_pool: str = None,
        lang: str = None,
        name: str = None,
        recovery_plan_id: int = None,
        remark: str = None,
    ):
        # The list of faulty address pools.
        self.fault_addr_pool = fault_addr_pool
        # The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
        self.lang = lang
        # The name of the disaster recovery plan.
        self.name = name
        # The ID of the disaster recovery plan.
        # 
        # This parameter is required.
        self.recovery_plan_id = recovery_plan_id
        # The remarks about the disaster recovery plan.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fault_addr_pool is not None:
            result['FaultAddrPool'] = self.fault_addr_pool
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.recovery_plan_id is not None:
            result['RecoveryPlanId'] = self.recovery_plan_id
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FaultAddrPool') is not None:
            self.fault_addr_pool = m.get('FaultAddrPool')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RecoveryPlanId') is not None:
            self.recovery_plan_id = m.get('RecoveryPlanId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateGtmRecoveryPlanResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateGtmRecoveryPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGtmRecoveryPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGtmRecoveryPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIspFlushCacheInstanceConfigRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        instance_name: str = None,
        lang: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.instance_name = instance_name
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class UpdateIspFlushCacheInstanceConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateIspFlushCacheInstanceConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIspFlushCacheInstanceConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIspFlushCacheInstanceConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ValidateDnsGtmCnameRrCanUseRequest(TeaModel):
    def __init__(
        self,
        cname_mode: str = None,
        cname_rr: str = None,
        cname_type: str = None,
        cname_zone: str = None,
        instance_id: str = None,
        lang: str = None,
    ):
        # This parameter is required.
        self.cname_mode = cname_mode
        # This parameter is required.
        self.cname_rr = cname_rr
        # This parameter is required.
        self.cname_type = cname_type
        # This parameter is required.
        self.cname_zone = cname_zone
        # This parameter is required.
        self.instance_id = instance_id
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cname_mode is not None:
            result['CnameMode'] = self.cname_mode
        if self.cname_rr is not None:
            result['CnameRr'] = self.cname_rr
        if self.cname_type is not None:
            result['CnameType'] = self.cname_type
        if self.cname_zone is not None:
            result['CnameZone'] = self.cname_zone
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CnameMode') is not None:
            self.cname_mode = m.get('CnameMode')
        if m.get('CnameRr') is not None:
            self.cname_rr = m.get('CnameRr')
        if m.get('CnameType') is not None:
            self.cname_type = m.get('CnameType')
        if m.get('CnameZone') is not None:
            self.cname_zone = m.get('CnameZone')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class ValidateDnsGtmCnameRrCanUseResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ValidateDnsGtmCnameRrCanUseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ValidateDnsGtmCnameRrCanUseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ValidateDnsGtmCnameRrCanUseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ValidatePdnsUdpIpSegmentRequest(TeaModel):
    def __init__(
        self,
        ip: str = None,
        ip_token: str = None,
        lang: str = None,
    ):
        self.ip = ip
        self.ip_token = ip_token
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.ip_token is not None:
            result['IpToken'] = self.ip_token
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('IpToken') is not None:
            self.ip_token = m.get('IpToken')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class ValidatePdnsUdpIpSegmentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ValidatePdnsUdpIpSegmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ValidatePdnsUdpIpSegmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ValidatePdnsUdpIpSegmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


