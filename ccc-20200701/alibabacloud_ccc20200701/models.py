# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import Dict, List, Any


class DataPropertiesValue(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        description: str = None,
        name: str = None,
        data_type: str = None,
        pattern: str = None,
        pattern_error_message: str = None,
        min_length: int = None,
        max_length: int = None,
        minimum: float = None,
        maximum: float = None,
        required: bool = None,
        system: bool = None,
        disabled: bool = None,
        array: bool = None,
        read_only: bool = None,
        editor_type: str = None,
        attributes: str = None,
        display_order: int = None,
        created_time: int = None,
        updated_time: int = None,
        creator: str = None,
    ):
        self.display_name = display_name
        self.description = description
        self.name = name
        self.data_type = data_type
        self.pattern = pattern
        self.pattern_error_message = pattern_error_message
        self.min_length = min_length
        self.max_length = max_length
        self.minimum = minimum
        self.maximum = maximum
        self.required = required
        self.system = system
        self.disabled = disabled
        self.array = array
        self.read_only = read_only
        self.editor_type = editor_type
        self.attributes = attributes
        self.display_order = display_order
        self.created_time = created_time
        self.updated_time = updated_time
        self.creator = creator

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.pattern_error_message is not None:
            result['PatternErrorMessage'] = self.pattern_error_message
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.required is not None:
            result['Required'] = self.required
        if self.system is not None:
            result['System'] = self.system
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.array is not None:
            result['Array'] = self.array
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.editor_type is not None:
            result['EditorType'] = self.editor_type
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.display_order is not None:
            result['DisplayOrder'] = self.display_order
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.creator is not None:
            result['Creator'] = self.creator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('PatternErrorMessage') is not None:
            self.pattern_error_message = m.get('PatternErrorMessage')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('System') is not None:
            self.system = m.get('System')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('Array') is not None:
            self.array = m.get('Array')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('EditorType') is not None:
            self.editor_type = m.get('EditorType')
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('DisplayOrder') is not None:
            self.display_order = m.get('DisplayOrder')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        return self


class DataSchemaPropertiesValue(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        description: str = None,
        name: str = None,
        data_type: str = None,
        pattern: str = None,
        pattern_error_message: str = None,
        min_length: int = None,
        max_length: int = None,
        minimum: float = None,
        maximum: float = None,
        required: bool = None,
        system: bool = None,
        disabled: bool = None,
        array: bool = None,
        read_only: bool = None,
        editor_type: str = None,
        attributes: str = None,
        display_order: int = None,
        created_time: int = None,
        updated_time: int = None,
        creator: str = None,
    ):
        self.display_name = display_name
        self.description = description
        self.name = name
        self.data_type = data_type
        self.pattern = pattern
        self.pattern_error_message = pattern_error_message
        self.min_length = min_length
        self.max_length = max_length
        self.minimum = minimum
        self.maximum = maximum
        self.required = required
        self.system = system
        self.disabled = disabled
        self.array = array
        self.read_only = read_only
        self.editor_type = editor_type
        self.attributes = attributes
        self.display_order = display_order
        self.created_time = created_time
        self.updated_time = updated_time
        self.creator = creator

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.pattern_error_message is not None:
            result['PatternErrorMessage'] = self.pattern_error_message
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.required is not None:
            result['Required'] = self.required
        if self.system is not None:
            result['System'] = self.system
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.array is not None:
            result['Array'] = self.array
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.editor_type is not None:
            result['EditorType'] = self.editor_type
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.display_order is not None:
            result['DisplayOrder'] = self.display_order
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.creator is not None:
            result['Creator'] = self.creator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('PatternErrorMessage') is not None:
            self.pattern_error_message = m.get('PatternErrorMessage')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('System') is not None:
            self.system = m.get('System')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('Array') is not None:
            self.array = m.get('Array')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('EditorType') is not None:
            self.editor_type = m.get('EditorType')
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('DisplayOrder') is not None:
            self.display_order = m.get('DisplayOrder')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        return self


class AbortCampaignRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class AbortCampaignResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AbortCampaignResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbortCampaignResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbortCampaignResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AcceptChatRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class AcceptChatResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AcceptChatResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AcceptChatResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AcceptChatResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddBlacklistCallTaggingRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
        number: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.job_id = job_id
        # This parameter is required.
        self.number = number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.number is not None:
            result['Number'] = self.number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        return self


class AddBlacklistCallTaggingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddBlacklistCallTaggingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddBlacklistCallTaggingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddBlacklistCallTaggingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCasesRequestCaseList(TeaModel):
    def __init__(
        self,
        caller: str = None,
        custom_variables: str = None,
        masked_callee: str = None,
        phone_number: str = None,
        reference_id: str = None,
    ):
        self.caller = caller
        self.custom_variables = custom_variables
        self.masked_callee = masked_callee
        self.phone_number = phone_number
        self.reference_id = reference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.custom_variables is not None:
            result['CustomVariables'] = self.custom_variables
        if self.masked_callee is not None:
            result['MaskedCallee'] = self.masked_callee
        if self.phone_number is not None:
            result['PhoneNumber'] = self.phone_number
        if self.reference_id is not None:
            result['ReferenceId'] = self.reference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('CustomVariables') is not None:
            self.custom_variables = m.get('CustomVariables')
        if m.get('MaskedCallee') is not None:
            self.masked_callee = m.get('MaskedCallee')
        if m.get('PhoneNumber') is not None:
            self.phone_number = m.get('PhoneNumber')
        if m.get('ReferenceId') is not None:
            self.reference_id = m.get('ReferenceId')
        return self


class AddCasesRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        case_list: List[AddCasesRequestCaseList] = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        self.case_list = case_list
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        if self.case_list:
            for k in self.case_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        result['CaseList'] = []
        if self.case_list is not None:
            for k in self.case_list:
                result['CaseList'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        self.case_list = []
        if m.get('CaseList') is not None:
            for k in m.get('CaseList'):
                temp_model = AddCasesRequestCaseList()
                self.case_list.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class AddCasesShrinkRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        case_list_shrink: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        self.case_list_shrink = case_list_shrink
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.case_list_shrink is not None:
            result['CaseList'] = self.case_list_shrink
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('CaseList') is not None:
            self.case_list_shrink = m.get('CaseList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class AddCasesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddFeedbackRequest(TeaModel):
    def __init__(
        self,
        feedback: str = None,
        instance_id: str = None,
        rating: int = None,
        task_id: str = None,
        task_name: str = None,
    ):
        self.feedback = feedback
        # This parameter is required.
        self.instance_id = instance_id
        self.rating = rating
        self.task_id = task_id
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.feedback is not None:
            result['Feedback'] = self.feedback
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.rating is not None:
            result['Rating'] = self.rating
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Feedback') is not None:
            self.feedback = m.get('Feedback')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Rating') is not None:
            self.rating = m.get('Rating')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class AddFeedbackResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddFeedbackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddFeedbackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddFeedbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddNumbersToSkillGroupRequest(TeaModel):
    def __init__(
        self,
        inst_number_group_id_list: str = None,
        instance_id: str = None,
        number_list: str = None,
        skill_group_id: str = None,
    ):
        self.inst_number_group_id_list = inst_number_group_id_list
        # This parameter is required.
        self.instance_id = instance_id
        self.number_list = number_list
        # This parameter is required.
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inst_number_group_id_list is not None:
            result['InstNumberGroupIdList'] = self.inst_number_group_id_list
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstNumberGroupIdList') is not None:
            self.inst_number_group_id_list = m.get('InstNumberGroupIdList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class AddNumbersToSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddNumbersToSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddNumbersToSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddNumbersToSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPersonalNumbersToUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number_list: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number_list = number_list
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AddPersonalNumbersToUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[str] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPersonalNumbersToUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPersonalNumbersToUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPersonalNumbersToUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPhoneNumberToSkillGroupsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number: str = None,
        skill_group_id_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number = number
        # This parameter is required.
        self.skill_group_id_list = skill_group_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        return self


class AddPhoneNumberToSkillGroupsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPhoneNumberToSkillGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPhoneNumberToSkillGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPhoneNumberToSkillGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPhoneNumbersRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        instance_id: str = None,
        number_group_id: str = None,
        number_list: str = None,
        usage: str = None,
    ):
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.instance_id = instance_id
        self.number_group_id = number_group_id
        self.number_list = number_list
        # This parameter is required.
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_group_id is not None:
            result['NumberGroupId'] = self.number_group_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberGroupId') is not None:
            self.number_group_id = m.get('NumberGroupId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class AddPhoneNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[str] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPhoneNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPhoneNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPhoneNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddSchemaPropertyRequestProperty(TeaModel):
    def __init__(
        self,
        array: bool = None,
        attributes: str = None,
        data_type: str = None,
        description: str = None,
        disabled: bool = None,
        display_name: str = None,
        display_order: int = None,
        editor_type: str = None,
        max_length: int = None,
        maximum: float = None,
        min_length: int = None,
        minimum: float = None,
        name: str = None,
        pattern: str = None,
        pattern_error_message: str = None,
        read_only: bool = None,
        required: bool = None,
    ):
        self.array = array
        self.attributes = attributes
        # This parameter is required.
        self.data_type = data_type
        self.description = description
        self.disabled = disabled
        self.display_name = display_name
        self.display_order = display_order
        self.editor_type = editor_type
        self.max_length = max_length
        self.maximum = maximum
        self.min_length = min_length
        self.minimum = minimum
        # This parameter is required.
        self.name = name
        self.pattern = pattern
        self.pattern_error_message = pattern_error_message
        self.read_only = read_only
        self.required = required

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.array is not None:
            result['Array'] = self.array
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.description is not None:
            result['Description'] = self.description
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.display_order is not None:
            result['DisplayOrder'] = self.display_order
        if self.editor_type is not None:
            result['EditorType'] = self.editor_type
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.pattern_error_message is not None:
            result['PatternErrorMessage'] = self.pattern_error_message
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.required is not None:
            result['Required'] = self.required
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Array') is not None:
            self.array = m.get('Array')
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('DisplayOrder') is not None:
            self.display_order = m.get('DisplayOrder')
        if m.get('EditorType') is not None:
            self.editor_type = m.get('EditorType')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('PatternErrorMessage') is not None:
            self.pattern_error_message = m.get('PatternErrorMessage')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        return self


class AddSchemaPropertyRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        property: AddSchemaPropertyRequestProperty = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.property = property
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        if self.property:
            self.property.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.property is not None:
            result['Property'] = self.property.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Property') is not None:
            temp_model = AddSchemaPropertyRequestProperty()
            self.property = temp_model.from_map(m['Property'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class AddSchemaPropertyShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        property_shrink: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.property_shrink = property_shrink
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.property_shrink is not None:
            result['Property'] = self.property_shrink
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Property') is not None:
            self.property_shrink = m.get('Property')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class AddSchemaPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddSchemaPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddSchemaPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddSchemaPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddSkillGroupsToUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        skill_level_list: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_level_list = skill_level_list
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_level_list is not None:
            result['SkillLevelList'] = self.skill_level_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillLevelList') is not None:
            self.skill_level_list = m.get('SkillLevelList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AddSkillGroupsToUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddSkillGroupsToUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddSkillGroupsToUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddSkillGroupsToUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTicketTaskRequest(TeaModel):
    def __init__(
        self,
        assignee: str = None,
        comment: str = None,
        instance_id: str = None,
        position: str = None,
        task_id: str = None,
        ticket_id: str = None,
    ):
        # This parameter is required.
        self.assignee = assignee
        # This parameter is required.
        self.comment = comment
        # This parameter is required.
        self.instance_id = instance_id
        self.position = position
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assignee is not None:
            result['Assignee'] = self.assignee
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.position is not None:
            result['Position'] = self.position
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assignee') is not None:
            self.assignee = m.get('Assignee')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class AddTicketTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddTicketTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTicketTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTicketTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddUsersToSkillGroupRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        skill_group_id: str = None,
        user_skill_level_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_group_id = skill_group_id
        # This parameter is required.
        self.user_skill_level_list = user_skill_level_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.user_skill_level_list is not None:
            result['UserSkillLevelList'] = self.user_skill_level_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('UserSkillLevelList') is not None:
            self.user_skill_level_list = m.get('UserSkillLevelList')
        return self


class AddUsersToSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddUsersToSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddUsersToSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddUsersToSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AnalyzeConversationRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        field_list_json: str = None,
        instance_id: str = None,
        task_list_json: str = None,
    ):
        self.contact_id = contact_id
        self.field_list_json = field_list_json
        # This parameter is required.
        self.instance_id = instance_id
        self.task_list_json = task_list_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.field_list_json is not None:
            result['FieldListJson'] = self.field_list_json
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.task_list_json is not None:
            result['TaskListJson'] = self.task_list_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('FieldListJson') is not None:
            self.field_list_json = m.get('FieldListJson')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TaskListJson') is not None:
            self.task_list_json = m.get('TaskListJson')
        return self


class AnalyzeConversationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AnalyzeConversationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AnalyzeConversationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AnalyzeConversationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AnswerCallRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AnswerCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_id: str = None,
        channel_state: str = None,
        channel_variables: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.channel_variables = channel_variables
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.channel_variables is not None:
            result['ChannelVariables'] = self.channel_variables
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('ChannelVariables') is not None:
            self.channel_variables = m.get('ChannelVariables')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AnswerCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[AnswerCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = AnswerCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class AnswerCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class AnswerCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: AnswerCallResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: AnswerCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = AnswerCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = AnswerCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class AnswerCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AnswerCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AnswerCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AnswerCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AnswerCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AnswerCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AppendCasesRequestBody(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        caller: str = None,
        custom_variables: str = None,
        masked_callee: str = None,
        phone_number: str = None,
        reference_id: str = None,
    ):
        self.agent_id = agent_id
        self.caller = caller
        self.custom_variables = custom_variables
        self.masked_callee = masked_callee
        self.phone_number = phone_number
        self.reference_id = reference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.custom_variables is not None:
            result['CustomVariables'] = self.custom_variables
        if self.masked_callee is not None:
            result['MaskedCallee'] = self.masked_callee
        if self.phone_number is not None:
            result['PhoneNumber'] = self.phone_number
        if self.reference_id is not None:
            result['ReferenceId'] = self.reference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('CustomVariables') is not None:
            self.custom_variables = m.get('CustomVariables')
        if m.get('MaskedCallee') is not None:
            self.masked_callee = m.get('MaskedCallee')
        if m.get('PhoneNumber') is not None:
            self.phone_number = m.get('PhoneNumber')
        if m.get('ReferenceId') is not None:
            self.reference_id = m.get('ReferenceId')
        return self


class AppendCasesRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
        body: List[AppendCasesRequestBody] = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id
        self.body = body

    def validate(self):
        if self.body:
            for k in self.body:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['body'] = []
        if self.body is not None:
            for k in self.body:
                result['body'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.body = []
        if m.get('body') is not None:
            for k in m.get('body'):
                temp_model = AppendCasesRequestBody()
                self.body.append(temp_model.from_map(k))
        return self


class AppendCasesShrinkRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
        body_shrink: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id
        self.body_shrink = body_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.body_shrink is not None:
            result['body'] = self.body_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('body') is not None:
            self.body_shrink = m.get('body')
        return self


class AppendCasesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AppendCasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AppendCasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AppendCasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssignUsersRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        ram_id_list: str = None,
        role_id: str = None,
        skill_level_list: str = None,
        work_mode: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.ram_id_list = ram_id_list
        # This parameter is required.
        self.role_id = role_id
        self.skill_level_list = skill_level_list
        # This parameter is required.
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ram_id_list is not None:
            result['RamIdList'] = self.ram_id_list
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.skill_level_list is not None:
            result['SkillLevelList'] = self.skill_level_list
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RamIdList') is not None:
            self.ram_id_list = m.get('RamIdList')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('SkillLevelList') is not None:
            self.skill_level_list = m.get('SkillLevelList')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class AssignUsersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        workflow_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class AssignUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AssignUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssignUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BargeInCallRequest(TeaModel):
    def __init__(
        self,
        barged_user_id: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        timeout_seconds: int = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.barged_user_id = barged_user_id
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.timeout_seconds = timeout_seconds
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barged_user_id is not None:
            result['BargedUserId'] = self.barged_user_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BargedUserId') is not None:
            self.barged_user_id = m.get('BargedUserId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class BargeInCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class BargeInCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[BargeInCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = BargeInCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class BargeInCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class BargeInCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: BargeInCallResponseBodyDataCallContext = None,
        user_context: BargeInCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = BargeInCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = BargeInCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class BargeInCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BargeInCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BargeInCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BargeInCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BargeInCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BargeInCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BlindTransferRequest(TeaModel):
    def __init__(
        self,
        call_priority: int = None,
        contact_flow_variables: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        queuing_overflow_threshold: int = None,
        queuing_timeout_seconds: int = None,
        routing_type: str = None,
        skill_group_id: str = None,
        strategy_name: str = None,
        strategy_params: str = None,
        tags: str = None,
        timeout_seconds: int = None,
        transferee: str = None,
        transferee_type: str = None,
        transferor: str = None,
        user_id: str = None,
    ):
        self.call_priority = call_priority
        self.contact_flow_variables = contact_flow_variables
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.queuing_overflow_threshold = queuing_overflow_threshold
        self.queuing_timeout_seconds = queuing_timeout_seconds
        self.routing_type = routing_type
        self.skill_group_id = skill_group_id
        self.strategy_name = strategy_name
        self.strategy_params = strategy_params
        self.tags = tags
        self.timeout_seconds = timeout_seconds
        # This parameter is required.
        self.transferee = transferee
        self.transferee_type = transferee_type
        self.transferor = transferor
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_priority is not None:
            result['CallPriority'] = self.call_priority
        if self.contact_flow_variables is not None:
            result['ContactFlowVariables'] = self.contact_flow_variables
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.queuing_overflow_threshold is not None:
            result['QueuingOverflowThreshold'] = self.queuing_overflow_threshold
        if self.queuing_timeout_seconds is not None:
            result['QueuingTimeoutSeconds'] = self.queuing_timeout_seconds
        if self.routing_type is not None:
            result['RoutingType'] = self.routing_type
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        if self.strategy_params is not None:
            result['StrategyParams'] = self.strategy_params
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.transferee is not None:
            result['Transferee'] = self.transferee
        if self.transferee_type is not None:
            result['TransfereeType'] = self.transferee_type
        if self.transferor is not None:
            result['Transferor'] = self.transferor
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallPriority') is not None:
            self.call_priority = m.get('CallPriority')
        if m.get('ContactFlowVariables') is not None:
            self.contact_flow_variables = m.get('ContactFlowVariables')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('QueuingOverflowThreshold') is not None:
            self.queuing_overflow_threshold = m.get('QueuingOverflowThreshold')
        if m.get('QueuingTimeoutSeconds') is not None:
            self.queuing_timeout_seconds = m.get('QueuingTimeoutSeconds')
        if m.get('RoutingType') is not None:
            self.routing_type = m.get('RoutingType')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        if m.get('StrategyParams') is not None:
            self.strategy_params = m.get('StrategyParams')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('Transferee') is not None:
            self.transferee = m.get('Transferee')
        if m.get('TransfereeType') is not None:
            self.transferee_type = m.get('TransfereeType')
        if m.get('Transferor') is not None:
            self.transferor = m.get('Transferor')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class BlindTransferResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class BlindTransferResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[BlindTransferResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = BlindTransferResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class BlindTransferResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class BlindTransferResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: BlindTransferResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: BlindTransferResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = BlindTransferResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = BlindTransferResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class BlindTransferResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BlindTransferResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BlindTransferResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BlindTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BlindTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BlindTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BridgeRtcCallRequest(TeaModel):
    def __init__(
        self,
        callee: str = None,
        caller: str = None,
        device_id: str = None,
        instance_id: str = None,
        service_provider: str = None,
        tags: str = None,
        timeout_seconds: int = None,
        user_id: str = None,
        video_enabled: bool = None,
    ):
        # This parameter is required.
        self.callee = callee
        self.caller = caller
        # This parameter is required.
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.service_provider = service_provider
        self.tags = tags
        self.timeout_seconds = timeout_seconds
        self.user_id = user_id
        self.video_enabled = video_enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.service_provider is not None:
            result['ServiceProvider'] = self.service_provider
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.video_enabled is not None:
            result['VideoEnabled'] = self.video_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ServiceProvider') is not None:
            self.service_provider = m.get('ServiceProvider')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VideoEnabled') is not None:
            self.video_enabled = m.get('VideoEnabled')
        return self


class BridgeRtcCallResponseBodyData(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
        token_info: str = None,
    ):
        self.instance_id = instance_id
        self.job_id = job_id
        self.token_info = token_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.token_info is not None:
            result['TokenInfo'] = self.token_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('TokenInfo') is not None:
            self.token_info = m.get('TokenInfo')
        return self


class BridgeRtcCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BridgeRtcCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BridgeRtcCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BridgeRtcCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BridgeRtcCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BridgeRtcCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelAttendedTransferRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CancelAttendedTransferResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CancelAttendedTransferResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[CancelAttendedTransferResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = CancelAttendedTransferResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class CancelAttendedTransferResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class CancelAttendedTransferResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: CancelAttendedTransferResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: CancelAttendedTransferResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = CancelAttendedTransferResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = CancelAttendedTransferResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class CancelAttendedTransferResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CancelAttendedTransferResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CancelAttendedTransferResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelAttendedTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelAttendedTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelAttendedTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeVisibilityRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        invisible: bool = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.invisible = invisible
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invisible is not None:
            result['Invisible'] = self.invisible
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Invisible') is not None:
            self.invisible = m.get('Invisible')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ChangeVisibilityResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ChangeVisibilityResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ChangeVisibilityResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ChangeVisibilityResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeVisibilityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeVisibilityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeVisibilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeWorkModeRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        mobile: str = None,
        signed_skill_group_id_list: str = None,
        user_id: str = None,
        work_mode: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.mobile = mobile
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        # This parameter is required.
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ChangeWorkModeResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ChangeWorkModeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ChangeWorkModeResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ChangeWorkModeResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeWorkModeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeWorkModeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeWorkModeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ClaimChatRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
        skill_group_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        # This parameter is required.
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class ClaimChatResponseBodyDataChatContexts(TeaModel):
    def __init__(
        self,
        access_channel_id: str = None,
        access_channel_name: str = None,
        access_channel_type: str = None,
        being_assigned: bool = None,
        call_variables: str = None,
        chat_type: str = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.access_channel_id = access_channel_id
        self.access_channel_name = access_channel_name
        self.access_channel_type = access_channel_type
        self.being_assigned = being_assigned
        self.call_variables = call_variables
        self.chat_type = chat_type
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_id is not None:
            result['AccessChannelId'] = self.access_channel_id
        if self.access_channel_name is not None:
            result['AccessChannelName'] = self.access_channel_name
        if self.access_channel_type is not None:
            result['AccessChannelType'] = self.access_channel_type
        if self.being_assigned is not None:
            result['BeingAssigned'] = self.being_assigned
        if self.call_variables is not None:
            result['CallVariables'] = self.call_variables
        if self.chat_type is not None:
            result['ChatType'] = self.chat_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelId') is not None:
            self.access_channel_id = m.get('AccessChannelId')
        if m.get('AccessChannelName') is not None:
            self.access_channel_name = m.get('AccessChannelName')
        if m.get('AccessChannelType') is not None:
            self.access_channel_type = m.get('AccessChannelType')
        if m.get('BeingAssigned') is not None:
            self.being_assigned = m.get('BeingAssigned')
        if m.get('CallVariables') is not None:
            self.call_variables = m.get('CallVariables')
        if m.get('ChatType') is not None:
            self.chat_type = m.get('ChatType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class ClaimChatResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        device_state: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.device_state = device_state
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ClaimChatResponseBodyData(TeaModel):
    def __init__(
        self,
        chat_contexts: List[ClaimChatResponseBodyDataChatContexts] = None,
        context_id: int = None,
        user_context: ClaimChatResponseBodyDataUserContext = None,
    ):
        self.chat_contexts = chat_contexts
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.chat_contexts:
            for k in self.chat_contexts:
                if k:
                    k.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChatContexts'] = []
        if self.chat_contexts is not None:
            for k in self.chat_contexts:
                result['ChatContexts'].append(k.to_map() if k else None)
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.chat_contexts = []
        if m.get('ChatContexts') is not None:
            for k in m.get('ChatContexts'):
                temp_model = ClaimChatResponseBodyDataChatContexts()
                self.chat_contexts.append(temp_model.from_map(k))
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = ClaimChatResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class ClaimChatResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ClaimChatResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ClaimChatResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ClaimChatResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ClaimChatResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ClaimChatResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CoachCallRequest(TeaModel):
    def __init__(
        self,
        coached_user_id: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        timeout_seconds: int = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.coached_user_id = coached_user_id
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.timeout_seconds = timeout_seconds
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.coached_user_id is not None:
            result['CoachedUserId'] = self.coached_user_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoachedUserId') is not None:
            self.coached_user_id = m.get('CoachedUserId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CoachCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CoachCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[CoachCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = CoachCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class CoachCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        device_state: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.device_state = device_state
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class CoachCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: CoachCallResponseBodyDataCallContext = None,
        user_context: CoachCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = CoachCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = CoachCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class CoachCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CoachCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CoachCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CoachCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CoachCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CoachCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CommitContactFlowRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        definition: str = None,
        description: str = None,
        draft_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.definition = definition
        # This parameter is required.
        self.description = description
        # This parameter is required.
        self.draft_id = draft_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.description is not None:
            result['Description'] = self.description
        if self.draft_id is not None:
            result['DraftId'] = self.draft_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DraftId') is not None:
            self.draft_id = m.get('DraftId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CommitContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CommitContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CommitContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CommitContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CompleteAttendedTransferRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CompleteAttendedTransferResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CompleteAttendedTransferResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[CompleteAttendedTransferResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = CompleteAttendedTransferResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class CompleteAttendedTransferResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class CompleteAttendedTransferResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: CompleteAttendedTransferResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: CompleteAttendedTransferResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = CompleteAttendedTransferResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = CompleteAttendedTransferResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class CompleteAttendedTransferResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CompleteAttendedTransferResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CompleteAttendedTransferResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CompleteAttendedTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CompleteAttendedTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CompleteAttendedTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAudioFileRequest(TeaModel):
    def __init__(
        self,
        audio_file_name: str = None,
        instance_id: str = None,
        name: str = None,
        oss_file_key: str = None,
        usage: str = None,
    ):
        # This parameter is required.
        self.audio_file_name = audio_file_name
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.oss_file_key = oss_file_key
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_file_name is not None:
            result['AudioFileName'] = self.audio_file_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_file_key is not None:
            result['OssFileKey'] = self.oss_file_key
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFileName') is not None:
            self.audio_file_name = m.get('AudioFileName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssFileKey') is not None:
            self.oss_file_key = m.get('OssFileKey')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class CreateAudioFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAudioFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAudioFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAudioFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCallSummaryRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        context: str = None,
        customer_id: str = None,
        instance_id: str = None,
    ):
        self.contact_id = contact_id
        self.context = context
        self.customer_id = customer_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.context is not None:
            result['Context'] = self.context
        if self.customer_id is not None:
            result['CustomerId'] = self.customer_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('CustomerId') is not None:
            self.customer_id = m.get('CustomerId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CreateCallSummaryResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCallSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCallSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCallSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCallTagsRequest(TeaModel):
    def __init__(
        self,
        call_tag_name_list: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.call_tag_name_list = call_tag_name_list
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_tag_name_list is not None:
            result['CallTagNameList'] = self.call_tag_name_list
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallTagNameList') is not None:
            self.call_tag_name_list = m.get('CallTagNameList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CreateCallTagsResponseBodyData(TeaModel):
    def __init__(
        self,
        item: str = None,
        reason: str = None,
    ):
        self.item = item
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item is not None:
            result['Item'] = self.item
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class CreateCallTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[CreateCallTagsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = CreateCallTagsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCallTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCallTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCallTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCampaignRequestCaseList(TeaModel):
    def __init__(
        self,
        custom_variables: str = None,
        phone_number: str = None,
        reference_id: str = None,
    ):
        self.custom_variables = custom_variables
        self.phone_number = phone_number
        self.reference_id = reference_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_variables is not None:
            result['CustomVariables'] = self.custom_variables
        if self.phone_number is not None:
            result['PhoneNumber'] = self.phone_number
        if self.reference_id is not None:
            result['ReferenceId'] = self.reference_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomVariables') is not None:
            self.custom_variables = m.get('CustomVariables')
        if m.get('PhoneNumber') is not None:
            self.phone_number = m.get('PhoneNumber')
        if m.get('ReferenceId') is not None:
            self.reference_id = m.get('ReferenceId')
        return self


class CreateCampaignRequest(TeaModel):
    def __init__(
        self,
        callable_time: str = None,
        case_file_key: str = None,
        case_list: List[CreateCampaignRequestCaseList] = None,
        contact_flow_id: str = None,
        end_time: str = None,
        executing_until_timeout: bool = None,
        instance_id: str = None,
        max_attempt_count: int = None,
        min_attempt_interval: int = None,
        name: str = None,
        queue_id: str = None,
        simulation: bool = None,
        simulation_parameters: str = None,
        start_time: str = None,
        strategy_parameters: str = None,
        strategy_type: str = None,
    ):
        # This parameter is required.
        self.callable_time = callable_time
        self.case_file_key = case_file_key
        self.case_list = case_list
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.end_time = end_time
        self.executing_until_timeout = executing_until_timeout
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.max_attempt_count = max_attempt_count
        # This parameter is required.
        self.min_attempt_interval = min_attempt_interval
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.queue_id = queue_id
        self.simulation = simulation
        self.simulation_parameters = simulation_parameters
        # This parameter is required.
        self.start_time = start_time
        # This parameter is required.
        self.strategy_parameters = strategy_parameters
        # This parameter is required.
        self.strategy_type = strategy_type

    def validate(self):
        if self.case_list:
            for k in self.case_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callable_time is not None:
            result['CallableTime'] = self.callable_time
        if self.case_file_key is not None:
            result['CaseFileKey'] = self.case_file_key
        result['CaseList'] = []
        if self.case_list is not None:
            for k in self.case_list:
                result['CaseList'].append(k.to_map() if k else None)
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.executing_until_timeout is not None:
            result['ExecutingUntilTimeout'] = self.executing_until_timeout
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.max_attempt_count is not None:
            result['MaxAttemptCount'] = self.max_attempt_count
        if self.min_attempt_interval is not None:
            result['MinAttemptInterval'] = self.min_attempt_interval
        if self.name is not None:
            result['Name'] = self.name
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        if self.simulation is not None:
            result['Simulation'] = self.simulation
        if self.simulation_parameters is not None:
            result['SimulationParameters'] = self.simulation_parameters
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.strategy_parameters is not None:
            result['StrategyParameters'] = self.strategy_parameters
        if self.strategy_type is not None:
            result['StrategyType'] = self.strategy_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallableTime') is not None:
            self.callable_time = m.get('CallableTime')
        if m.get('CaseFileKey') is not None:
            self.case_file_key = m.get('CaseFileKey')
        self.case_list = []
        if m.get('CaseList') is not None:
            for k in m.get('CaseList'):
                temp_model = CreateCampaignRequestCaseList()
                self.case_list.append(temp_model.from_map(k))
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecutingUntilTimeout') is not None:
            self.executing_until_timeout = m.get('ExecutingUntilTimeout')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MaxAttemptCount') is not None:
            self.max_attempt_count = m.get('MaxAttemptCount')
        if m.get('MinAttemptInterval') is not None:
            self.min_attempt_interval = m.get('MinAttemptInterval')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        if m.get('Simulation') is not None:
            self.simulation = m.get('Simulation')
        if m.get('SimulationParameters') is not None:
            self.simulation_parameters = m.get('SimulationParameters')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StrategyParameters') is not None:
            self.strategy_parameters = m.get('StrategyParameters')
        if m.get('StrategyType') is not None:
            self.strategy_type = m.get('StrategyType')
        return self


class CreateCampaignShrinkRequest(TeaModel):
    def __init__(
        self,
        callable_time: str = None,
        case_file_key: str = None,
        case_list_shrink: str = None,
        contact_flow_id: str = None,
        end_time: str = None,
        executing_until_timeout: bool = None,
        instance_id: str = None,
        max_attempt_count: int = None,
        min_attempt_interval: int = None,
        name: str = None,
        queue_id: str = None,
        simulation: bool = None,
        simulation_parameters: str = None,
        start_time: str = None,
        strategy_parameters: str = None,
        strategy_type: str = None,
    ):
        # This parameter is required.
        self.callable_time = callable_time
        self.case_file_key = case_file_key
        self.case_list_shrink = case_list_shrink
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.end_time = end_time
        self.executing_until_timeout = executing_until_timeout
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.max_attempt_count = max_attempt_count
        # This parameter is required.
        self.min_attempt_interval = min_attempt_interval
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.queue_id = queue_id
        self.simulation = simulation
        self.simulation_parameters = simulation_parameters
        # This parameter is required.
        self.start_time = start_time
        # This parameter is required.
        self.strategy_parameters = strategy_parameters
        # This parameter is required.
        self.strategy_type = strategy_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callable_time is not None:
            result['CallableTime'] = self.callable_time
        if self.case_file_key is not None:
            result['CaseFileKey'] = self.case_file_key
        if self.case_list_shrink is not None:
            result['CaseList'] = self.case_list_shrink
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.executing_until_timeout is not None:
            result['ExecutingUntilTimeout'] = self.executing_until_timeout
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.max_attempt_count is not None:
            result['MaxAttemptCount'] = self.max_attempt_count
        if self.min_attempt_interval is not None:
            result['MinAttemptInterval'] = self.min_attempt_interval
        if self.name is not None:
            result['Name'] = self.name
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        if self.simulation is not None:
            result['Simulation'] = self.simulation
        if self.simulation_parameters is not None:
            result['SimulationParameters'] = self.simulation_parameters
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.strategy_parameters is not None:
            result['StrategyParameters'] = self.strategy_parameters
        if self.strategy_type is not None:
            result['StrategyType'] = self.strategy_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallableTime') is not None:
            self.callable_time = m.get('CallableTime')
        if m.get('CaseFileKey') is not None:
            self.case_file_key = m.get('CaseFileKey')
        if m.get('CaseList') is not None:
            self.case_list_shrink = m.get('CaseList')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecutingUntilTimeout') is not None:
            self.executing_until_timeout = m.get('ExecutingUntilTimeout')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MaxAttemptCount') is not None:
            self.max_attempt_count = m.get('MaxAttemptCount')
        if m.get('MinAttemptInterval') is not None:
            self.min_attempt_interval = m.get('MinAttemptInterval')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        if m.get('Simulation') is not None:
            self.simulation = m.get('Simulation')
        if m.get('SimulationParameters') is not None:
            self.simulation_parameters = m.get('SimulationParameters')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StrategyParameters') is not None:
            self.strategy_parameters = m.get('StrategyParameters')
        if m.get('StrategyType') is not None:
            self.strategy_type = m.get('StrategyType')
        return self


class CreateCampaignResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCampaignResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCampaignResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCampaignResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateChatMediaUrlRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        mime_type: str = None,
        request_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # media id
        # 
        # This parameter is required.
        self.mime_type = mime_type
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.mime_type is not None:
            result['MimeType'] = self.mime_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MimeType') is not None:
            self.mime_type = m.get('MimeType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateChatMediaUrlResponseBodyData(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        url: str = None,
    ):
        self.media_id = media_id
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateChatMediaUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateChatMediaUrlResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateChatMediaUrlResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateChatMediaUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateChatMediaUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateChatMediaUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateContactFlowRequest(TeaModel):
    def __init__(
        self,
        definition: str = None,
        description: str = None,
        instance_id: str = None,
        name: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.definition = definition
        # This parameter is required.
        self.description = description
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomCallTaggingRequest(TeaModel):
    def __init__(
        self,
        custom_number_list: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.custom_number_list = custom_number_list
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_number_list is not None:
            result['CustomNumberList'] = self.custom_number_list
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomNumberList') is not None:
            self.custom_number_list = m.get('CustomNumberList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CreateCustomCallTaggingResponseBodyData(TeaModel):
    def __init__(
        self,
        item: str = None,
        reason: str = None,
    ):
        self.item = item
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item is not None:
            result['Item'] = self.item
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class CreateCustomCallTaggingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[CreateCustomCallTaggingResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = CreateCustomCallTaggingResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCustomCallTaggingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCustomCallTaggingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomCallTaggingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateInstanceRequest(TeaModel):
    def __init__(
        self,
        admin_ram_id_list: str = None,
        description: str = None,
        domain_name: str = None,
        name: str = None,
        number_list: str = None,
    ):
        # This parameter is required.
        self.admin_ram_id_list = admin_ram_id_list
        self.description = description
        # This parameter is required.
        self.domain_name = domain_name
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.number_list = number_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_ram_id_list is not None:
            result['AdminRamIdList'] = self.admin_ram_id_list
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.name is not None:
            result['Name'] = self.name
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminRamIdList') is not None:
            self.admin_ram_id_list = m.get('AdminRamIdList')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        return self


class CreateInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSchemaRequestProperties(TeaModel):
    def __init__(
        self,
        array: bool = None,
        attributes: str = None,
        data_type: str = None,
        description: str = None,
        disabled: bool = None,
        display_name: str = None,
        display_order: int = None,
        editor_type: str = None,
        max_length: int = None,
        maximum: float = None,
        min_length: int = None,
        minimum: float = None,
        name: str = None,
        pattern: str = None,
        pattern_error_message: str = None,
        read_only: bool = None,
        required: bool = None,
    ):
        self.array = array
        self.attributes = attributes
        # This parameter is required.
        self.data_type = data_type
        self.description = description
        self.disabled = disabled
        self.display_name = display_name
        self.display_order = display_order
        self.editor_type = editor_type
        self.max_length = max_length
        self.maximum = maximum
        self.min_length = min_length
        self.minimum = minimum
        # This parameter is required.
        self.name = name
        self.pattern = pattern
        self.pattern_error_message = pattern_error_message
        self.read_only = read_only
        self.required = required

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.array is not None:
            result['Array'] = self.array
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.description is not None:
            result['Description'] = self.description
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.display_order is not None:
            result['DisplayOrder'] = self.display_order
        if self.editor_type is not None:
            result['EditorType'] = self.editor_type
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.pattern_error_message is not None:
            result['PatternErrorMessage'] = self.pattern_error_message
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.required is not None:
            result['Required'] = self.required
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Array') is not None:
            self.array = m.get('Array')
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('DisplayOrder') is not None:
            self.display_order = m.get('DisplayOrder')
        if m.get('EditorType') is not None:
            self.editor_type = m.get('EditorType')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('PatternErrorMessage') is not None:
            self.pattern_error_message = m.get('PatternErrorMessage')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        return self


class CreateSchemaRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: str = None,
        instance_id: str = None,
        properties: List[CreateSchemaRequestProperties] = None,
        request_id: str = None,
    ):
        self.description = description
        # schema id
        self.id = id
        # This parameter is required.
        self.instance_id = instance_id
        self.properties = properties
        self.request_id = request_id

    def validate(self):
        if self.properties:
            for k in self.properties:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['Properties'] = []
        if self.properties is not None:
            for k in self.properties:
                result['Properties'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.properties = []
        if m.get('Properties') is not None:
            for k in m.get('Properties'):
                temp_model = CreateSchemaRequestProperties()
                self.properties.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSchemaShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: str = None,
        instance_id: str = None,
        properties_shrink: str = None,
        request_id: str = None,
    ):
        self.description = description
        # schema id
        self.id = id
        # This parameter is required.
        self.instance_id = instance_id
        self.properties_shrink = properties_shrink
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.properties_shrink is not None:
            result['Properties'] = self.properties_shrink
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Properties') is not None:
            self.properties_shrink = m.get('Properties')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSchemaResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSchemaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSchemaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSchemaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSkillGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        instance_id: str = None,
        media_type: str = None,
        name: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.display_name = display_name
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateSkillGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        description: str = None,
        instance_id: str = None,
        media_type: str = None,
        name: str = None,
        skill_group_id: str = None,
    ):
        self.description = description
        self.instance_id = instance_id
        self.media_type = media_type
        self.name = name
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.name is not None:
            result['Name'] = self.name
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class CreateSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateSkillGroupResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateSkillGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTicketRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        context: str = None,
        customer_id: str = None,
        instance_id: str = None,
        source: str = None,
        template_id: str = None,
        title: str = None,
    ):
        self.contact_id = contact_id
        self.context = context
        self.customer_id = customer_id
        # This parameter is required.
        self.instance_id = instance_id
        self.source = source
        self.template_id = template_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.context is not None:
            result['Context'] = self.context
        if self.customer_id is not None:
            result['CustomerId'] = self.customer_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.source is not None:
            result['Source'] = self.source
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('CustomerId') is not None:
            self.customer_id = m.get('CustomerId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateTicketResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUserRequest(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        display_id: str = None,
        display_name: str = None,
        email: str = None,
        instance_id: str = None,
        login_name: str = None,
        mobile: str = None,
        nickname: str = None,
        reset_password: bool = None,
        role_id: str = None,
        skill_level_list: str = None,
        work_mode: str = None,
    ):
        self.avatar_url = avatar_url
        self.display_id = display_id
        # This parameter is required.
        self.display_name = display_name
        # This parameter is required.
        self.email = email
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.login_name = login_name
        self.mobile = mobile
        self.nickname = nickname
        self.reset_password = reset_password
        # This parameter is required.
        self.role_id = role_id
        self.skill_level_list = skill_level_list
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.display_id is not None:
            result['DisplayId'] = self.display_id
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.email is not None:
            result['Email'] = self.email
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.reset_password is not None:
            result['ResetPassword'] = self.reset_password
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.skill_level_list is not None:
            result['SkillLevelList'] = self.skill_level_list
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('DisplayId') is not None:
            self.display_id = m.get('DisplayId')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('ResetPassword') is not None:
            self.reset_password = m.get('ResetPassword')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('SkillLevelList') is not None:
            self.skill_level_list = m.get('SkillLevelList')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class CreateUserResponseBodyData(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        display_name: str = None,
        email: str = None,
        extension: str = None,
        login_name: str = None,
        mobile: str = None,
        nickname: str = None,
        user_id: str = None,
        work_mode: str = None,
    ):
        self.avatar_url = avatar_url
        self.display_name = display_name
        self.email = email
        self.extension = extension
        self.login_name = login_name
        self.mobile = mobile
        self.nickname = nickname
        self.user_id = user_id
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.email is not None:
            result['Email'] = self.email
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class CreateUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateUserResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateUserResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAudioFileRequest(TeaModel):
    def __init__(
        self,
        audio_resource_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.audio_resource_id = audio_resource_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_resource_id is not None:
            result['AudioResourceId'] = self.audio_resource_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioResourceId') is not None:
            self.audio_resource_id = m.get('AudioResourceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DeleteAudioFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAudioFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAudioFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAudioFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCallTagRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        tag_name: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.tag_name = tag_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        return self


class DeleteCallTagResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCallTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCallTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCallTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactFlowRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        force: bool = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        self.force = force
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DeleteContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomCallTaggingRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number = number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        return self


class DeleteCustomCallTaggingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomCallTaggingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomCallTaggingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomCallTaggingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDocumentRequest(TeaModel):
    def __init__(
        self,
        document_id: str = None,
        instance_id: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.document_id = document_id
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.document_id is not None:
            result['DocumentId'] = self.document_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocumentId') is not None:
            self.document_id = m.get('DocumentId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class DeleteDocumentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDocumentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDocumentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDocumentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDocumentsRequest(TeaModel):
    def __init__(
        self,
        document_ids: List[str] = None,
        instance_id: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        self.document_ids = document_ids
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.document_ids is not None:
            result['DocumentIds'] = self.document_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocumentIds') is not None:
            self.document_ids = m.get('DocumentIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class DeleteDocumentsShrinkRequest(TeaModel):
    def __init__(
        self,
        document_ids_shrink: str = None,
        instance_id: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        self.document_ids_shrink = document_ids_shrink
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.document_ids_shrink is not None:
            result['DocumentIds'] = self.document_ids_shrink
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocumentIds') is not None:
            self.document_ids_shrink = m.get('DocumentIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class DeleteDocumentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDocumentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDocumentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDocumentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DeleteInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSchemaRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class DeleteSchemaResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSchemaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSchemaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSchemaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSchemaPropertyRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        property_name: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.property_name = property_name
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.property_name is not None:
            result['PropertyName'] = self.property_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PropertyName') is not None:
            self.property_name = m.get('PropertyName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class DeleteSchemaPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSchemaPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSchemaPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSchemaPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSkillGroupRequest(TeaModel):
    def __init__(
        self,
        force: bool = None,
        instance_id: str = None,
        skill_group_id: str = None,
    ):
        self.force = force
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class DeleteSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTicketRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        ticket_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class DeleteTicketResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTicketTemplateRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        template_id: str = None,
    ):
        self.instance_id = instance_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteTicketTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteTicketTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTicketTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTicketTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableSchemaPropertyRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        property_name: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.property_name = property_name
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.property_name is not None:
            result['PropertyName'] = self.property_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PropertyName') is not None:
            self.property_name = m.get('PropertyName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class DisableSchemaPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableSchemaPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableSchemaPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableSchemaPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableTicketTemplateRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        template_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DisableTicketTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableTicketTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableTicketTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableTicketTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DiscardEditingContactFlowRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        draft_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.draft_id = draft_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.draft_id is not None:
            result['DraftId'] = self.draft_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('DraftId') is not None:
            self.draft_id = m.get('DraftId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DiscardEditingContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DiscardEditingContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DiscardEditingContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DiscardEditingContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableSchemaPropertyRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        property_name: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.property_name = property_name
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.property_name is not None:
            result['PropertyName'] = self.property_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PropertyName') is not None:
            self.property_name = m.get('PropertyName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class EnableSchemaPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableSchemaPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableSchemaPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableSchemaPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableTicketTemplateRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        template_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class EnableTicketTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableTicketTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableTicketTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableTicketTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EndConferenceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class EndConferenceResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class EndConferenceResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        channel_contexts: List[EndConferenceResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = EndConferenceResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class EndConferenceResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        device_state: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.device_state = device_state
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class EndConferenceResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: EndConferenceResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: EndConferenceResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = EndConferenceResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = EndConferenceResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class EndConferenceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: EndConferenceResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = EndConferenceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EndConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EndConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EndConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportContactFlowRequest(TeaModel):
    def __init__(
        self,
        flow_id: str = None,
        instance_id: str = None,
        request_id: str = None,
    ):
        # This parameter is required.
        self.flow_id = flow_id
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        flow_package_data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.flow_package_data = flow_package_data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.flow_package_data is not None:
            result['FlowPackageData'] = self.flow_package_data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FlowPackageData') is not None:
            self.flow_package_data = m.get('FlowPackageData')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportCustomCallTaggingRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ExportCustomCallTaggingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportCustomCallTaggingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportCustomCallTaggingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportCustomCallTaggingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportDoNotCallNumbersRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        scope: str = None,
        search_pattern: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.scope = scope
        self.search_pattern = search_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        return self


class ExportDoNotCallNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportDoNotCallNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportDoNotCallNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportDoNotCallNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FinishTicketTaskRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        instance_id: str = None,
        task_id: str = None,
        ticket_id: str = None,
    ):
        # This parameter is required.
        self.comment = comment
        # This parameter is required.
        self.instance_id = instance_id
        self.task_id = task_id
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class FinishTicketTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class FinishTicketTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FinishTicketTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FinishTicketTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAccessChannelOfStagingRequest(TeaModel):
    def __init__(
        self,
        search_pattern: str = None,
    ):
        self.search_pattern = search_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        return self


class GetAccessChannelOfStagingResponseBodyData(TeaModel):
    def __init__(
        self,
        token: str = None,
    ):
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class GetAccessChannelOfStagingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetAccessChannelOfStagingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAccessChannelOfStagingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAccessChannelOfStagingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAccessChannelOfStagingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAccessChannelOfStagingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAudioFileRequest(TeaModel):
    def __init__(
        self,
        audio_resource_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.audio_resource_id = audio_resource_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_resource_id is not None:
            result['AudioResourceId'] = self.audio_resource_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioResourceId') is not None:
            self.audio_resource_id = m.get('AudioResourceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetAudioFileResponseBodyData(TeaModel):
    def __init__(
        self,
        audio_file_name: str = None,
        audio_resource_id: str = None,
        created_time: str = None,
        instance_id: str = None,
        name: str = None,
        oss_file_key: str = None,
        updated_time: str = None,
    ):
        self.audio_file_name = audio_file_name
        self.audio_resource_id = audio_resource_id
        self.created_time = created_time
        self.instance_id = instance_id
        self.name = name
        self.oss_file_key = oss_file_key
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_file_name is not None:
            result['AudioFileName'] = self.audio_file_name
        if self.audio_resource_id is not None:
            result['AudioResourceId'] = self.audio_resource_id
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_file_key is not None:
            result['OssFileKey'] = self.oss_file_key
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFileName') is not None:
            self.audio_file_name = m.get('AudioFileName')
        if m.get('AudioResourceId') is not None:
            self.audio_resource_id = m.get('AudioResourceId')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssFileKey') is not None:
            self.oss_file_key = m.get('OssFileKey')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class GetAudioFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetAudioFileResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAudioFileResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAudioFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAudioFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAudioFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAudioFileDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        audio_resource_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.audio_resource_id = audio_resource_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_resource_id is not None:
            result['AudioResourceId'] = self.audio_resource_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioResourceId') is not None:
            self.audio_resource_id = m.get('AudioResourceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetAudioFileDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAudioFileDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAudioFileDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAudioFileDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAudioFileUploadParametersRequest(TeaModel):
    def __init__(
        self,
        audio_file_name: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.audio_file_name = audio_file_name
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_file_name is not None:
            result['AudioFileName'] = self.audio_file_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFileName') is not None:
            self.audio_file_name = m.get('AudioFileName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetAudioFileUploadParametersResponseBodyData(TeaModel):
    def __init__(
        self,
        access_key_id: str = None,
        expire_time: int = None,
        file_path: str = None,
        host: str = None,
        policy: str = None,
        signature: str = None,
    ):
        self.access_key_id = access_key_id
        self.expire_time = expire_time
        self.file_path = file_path
        self.host = host
        self.policy = policy
        self.signature = signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['AccessKeyId'] = self.access_key_id
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.host is not None:
            result['Host'] = self.host
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKeyId') is not None:
            self.access_key_id = m.get('AccessKeyId')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        return self


class GetAudioFileUploadParametersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetAudioFileUploadParametersResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAudioFileUploadParametersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAudioFileUploadParametersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAudioFileUploadParametersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAudioFileUploadParametersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCallDetailRecordRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetCallDetailRecordResponseBodyDataAgentEventsEventSequence(TeaModel):
    def __init__(
        self,
        duration: int = None,
        event: str = None,
        event_time: int = None,
    ):
        self.duration = duration
        self.event = event
        self.event_time = event_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.event is not None:
            result['Event'] = self.event
        if self.event_time is not None:
            result['EventTime'] = self.event_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventTime') is not None:
            self.event_time = m.get('EventTime')
        return self


class GetCallDetailRecordResponseBodyDataAgentEvents(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        agent_name: str = None,
        event_sequence: List[GetCallDetailRecordResponseBodyDataAgentEventsEventSequence] = None,
        skill_group_id: str = None,
    ):
        self.agent_id = agent_id
        self.agent_name = agent_name
        self.event_sequence = event_sequence
        self.skill_group_id = skill_group_id

    def validate(self):
        if self.event_sequence:
            for k in self.event_sequence:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        result['EventSequence'] = []
        if self.event_sequence is not None:
            for k in self.event_sequence:
                result['EventSequence'].append(k.to_map() if k else None)
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        self.event_sequence = []
        if m.get('EventSequence') is not None:
            for k in m.get('EventSequence'):
                temp_model = GetCallDetailRecordResponseBodyDataAgentEventsEventSequence()
                self.event_sequence.append(temp_model.from_map(k))
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class GetCallDetailRecordResponseBodyDataAnalyticsReportEmotion(TeaModel):
    def __init__(
        self,
        confidence: int = None,
        remark: str = None,
        success: bool = None,
        task_id: str = None,
        type: str = None,
    ):
        self.confidence = confidence
        self.remark = remark
        self.success = success
        self.task_id = task_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.confidence is not None:
            result['Confidence'] = self.confidence
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Confidence') is not None:
            self.confidence = m.get('Confidence')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCallDetailRecordResponseBodyDataAnalyticsReportProblemSolving(TeaModel):
    def __init__(
        self,
        problem: str = None,
        solution: str = None,
        solved: bool = None,
        success: bool = None,
        task_id: str = None,
    ):
        self.problem = problem
        self.solution = solution
        self.solved = solved
        self.success = success
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.problem is not None:
            result['Problem'] = self.problem
        if self.solution is not None:
            result['Solution'] = self.solution
        if self.solved is not None:
            result['Solved'] = self.solved
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Problem') is not None:
            self.problem = m.get('Problem')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        if m.get('Solved') is not None:
            self.solved = m.get('Solved')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetCallDetailRecordResponseBodyDataAnalyticsReportSatisfaction(TeaModel):
    def __init__(
        self,
        remark: str = None,
        satisfaction_description: str = None,
        success: bool = None,
        task_id: str = None,
    ):
        self.remark = remark
        self.satisfaction_description = satisfaction_description
        self.success = success
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.satisfaction_description is not None:
            result['SatisfactionDescription'] = self.satisfaction_description
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SatisfactionDescription') is not None:
            self.satisfaction_description = m.get('SatisfactionDescription')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetCallDetailRecordResponseBodyDataAnalyticsReportTodoList(TeaModel):
    def __init__(
        self,
        success: bool = None,
        task_id: str = None,
        tasks: List[str] = None,
    ):
        self.success = success
        self.task_id = task_id
        self.tasks = tasks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.tasks is not None:
            result['Tasks'] = self.tasks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Tasks') is not None:
            self.tasks = m.get('Tasks')
        return self


class GetCallDetailRecordResponseBodyDataAnalyticsReport(TeaModel):
    def __init__(
        self,
        emotion: GetCallDetailRecordResponseBodyDataAnalyticsReportEmotion = None,
        problem_solving: GetCallDetailRecordResponseBodyDataAnalyticsReportProblemSolving = None,
        satisfaction: GetCallDetailRecordResponseBodyDataAnalyticsReportSatisfaction = None,
        todo_list: GetCallDetailRecordResponseBodyDataAnalyticsReportTodoList = None,
    ):
        self.emotion = emotion
        self.problem_solving = problem_solving
        self.satisfaction = satisfaction
        self.todo_list = todo_list

    def validate(self):
        if self.emotion:
            self.emotion.validate()
        if self.problem_solving:
            self.problem_solving.validate()
        if self.satisfaction:
            self.satisfaction.validate()
        if self.todo_list:
            self.todo_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.emotion is not None:
            result['Emotion'] = self.emotion.to_map()
        if self.problem_solving is not None:
            result['ProblemSolving'] = self.problem_solving.to_map()
        if self.satisfaction is not None:
            result['Satisfaction'] = self.satisfaction.to_map()
        if self.todo_list is not None:
            result['TodoList'] = self.todo_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Emotion') is not None:
            temp_model = GetCallDetailRecordResponseBodyDataAnalyticsReportEmotion()
            self.emotion = temp_model.from_map(m['Emotion'])
        if m.get('ProblemSolving') is not None:
            temp_model = GetCallDetailRecordResponseBodyDataAnalyticsReportProblemSolving()
            self.problem_solving = temp_model.from_map(m['ProblemSolving'])
        if m.get('Satisfaction') is not None:
            temp_model = GetCallDetailRecordResponseBodyDataAnalyticsReportSatisfaction()
            self.satisfaction = temp_model.from_map(m['Satisfaction'])
        if m.get('TodoList') is not None:
            temp_model = GetCallDetailRecordResponseBodyDataAnalyticsReportTodoList()
            self.todo_list = temp_model.from_map(m['TodoList'])
        return self


class GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence(TeaModel):
    def __init__(
        self,
        event: str = None,
        event_time: int = None,
    ):
        self.event = event
        self.event_time = event_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event is not None:
            result['Event'] = self.event
        if self.event_time is not None:
            result['EventTime'] = self.event_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventTime') is not None:
            self.event_time = m.get('EventTime')
        return self


class GetCallDetailRecordResponseBodyDataCustomerEvents(TeaModel):
    def __init__(
        self,
        customer_id: str = None,
        event_sequence: List[GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence] = None,
    ):
        self.customer_id = customer_id
        self.event_sequence = event_sequence

    def validate(self):
        if self.event_sequence:
            for k in self.event_sequence:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.customer_id is not None:
            result['CustomerId'] = self.customer_id
        result['EventSequence'] = []
        if self.event_sequence is not None:
            for k in self.event_sequence:
                result['EventSequence'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomerId') is not None:
            self.customer_id = m.get('CustomerId')
        self.event_sequence = []
        if m.get('EventSequence') is not None:
            for k in m.get('EventSequence'):
                temp_model = GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence()
                self.event_sequence.append(temp_model.from_map(k))
        return self


class GetCallDetailRecordResponseBodyDataIvrEventsEventSequence(TeaModel):
    def __init__(
        self,
        event: str = None,
        event_time: int = None,
    ):
        self.event = event
        self.event_time = event_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event is not None:
            result['Event'] = self.event
        if self.event_time is not None:
            result['EventTime'] = self.event_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventTime') is not None:
            self.event_time = m.get('EventTime')
        return self


class GetCallDetailRecordResponseBodyDataIvrEvents(TeaModel):
    def __init__(
        self,
        event_sequence: List[GetCallDetailRecordResponseBodyDataIvrEventsEventSequence] = None,
        flow_id: str = None,
        flow_type: str = None,
    ):
        self.event_sequence = event_sequence
        self.flow_id = flow_id
        self.flow_type = flow_type

    def validate(self):
        if self.event_sequence:
            for k in self.event_sequence:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventSequence'] = []
        if self.event_sequence is not None:
            for k in self.event_sequence:
                result['EventSequence'].append(k.to_map() if k else None)
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.flow_type is not None:
            result['FlowType'] = self.flow_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_sequence = []
        if m.get('EventSequence') is not None:
            for k in m.get('EventSequence'):
                temp_model = GetCallDetailRecordResponseBodyDataIvrEventsEventSequence()
                self.event_sequence.append(temp_model.from_map(k))
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('FlowType') is not None:
            self.flow_type = m.get('FlowType')
        return self


class GetCallDetailRecordResponseBodyDataQueueEventsEventSequence(TeaModel):
    def __init__(
        self,
        event: str = None,
        event_time: int = None,
    ):
        self.event = event
        self.event_time = event_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event is not None:
            result['Event'] = self.event
        if self.event_time is not None:
            result['EventTime'] = self.event_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventTime') is not None:
            self.event_time = m.get('EventTime')
        return self


class GetCallDetailRecordResponseBodyDataQueueEvents(TeaModel):
    def __init__(
        self,
        event_sequence: List[GetCallDetailRecordResponseBodyDataQueueEventsEventSequence] = None,
        flow_id: str = None,
        queue_id: str = None,
        queue_name: str = None,
        queue_type: int = None,
    ):
        self.event_sequence = event_sequence
        self.flow_id = flow_id
        self.queue_id = queue_id
        self.queue_name = queue_name
        self.queue_type = queue_type

    def validate(self):
        if self.event_sequence:
            for k in self.event_sequence:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventSequence'] = []
        if self.event_sequence is not None:
            for k in self.event_sequence:
                result['EventSequence'].append(k.to_map() if k else None)
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.queue_type is not None:
            result['QueueType'] = self.queue_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_sequence = []
        if m.get('EventSequence') is not None:
            for k in m.get('EventSequence'):
                temp_model = GetCallDetailRecordResponseBodyDataQueueEventsEventSequence()
                self.event_sequence.append(temp_model.from_map(k))
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('QueueType') is not None:
            self.queue_type = m.get('QueueType')
        return self


class GetCallDetailRecordResponseBodyData(TeaModel):
    def __init__(
        self,
        agent_events: List[GetCallDetailRecordResponseBodyDataAgentEvents] = None,
        agent_ids: str = None,
        agent_names: str = None,
        analytics_report: GetCallDetailRecordResponseBodyDataAnalyticsReport = None,
        analytics_report_ready: bool = None,
        call_duration: int = None,
        called_number: str = None,
        callee_location: str = None,
        caller_location: str = None,
        calling_number: str = None,
        contact_disposition: str = None,
        contact_id: str = None,
        contact_type: str = None,
        customer_events: List[GetCallDetailRecordResponseBodyDataCustomerEvents] = None,
        early_media_state: str = None,
        established_time: int = None,
        instance_id: str = None,
        ivr_events: List[GetCallDetailRecordResponseBodyDataIvrEvents] = None,
        outside_number_release_reason: str = None,
        queue_events: List[GetCallDetailRecordResponseBodyDataQueueEvents] = None,
        recording_ready: bool = None,
        release_initiator: str = None,
        release_reason: str = None,
        release_time: int = None,
        satisfaction: int = None,
        satisfaction_survey_channel: str = None,
        satisfaction_survey_offered: bool = None,
        skill_group_ids: str = None,
        skill_group_names: str = None,
        start_time: int = None,
    ):
        self.agent_events = agent_events
        self.agent_ids = agent_ids
        self.agent_names = agent_names
        self.analytics_report = analytics_report
        self.analytics_report_ready = analytics_report_ready
        self.call_duration = call_duration
        self.called_number = called_number
        self.callee_location = callee_location
        self.caller_location = caller_location
        self.calling_number = calling_number
        self.contact_disposition = contact_disposition
        self.contact_id = contact_id
        self.contact_type = contact_type
        self.customer_events = customer_events
        self.early_media_state = early_media_state
        self.established_time = established_time
        self.instance_id = instance_id
        self.ivr_events = ivr_events
        self.outside_number_release_reason = outside_number_release_reason
        self.queue_events = queue_events
        self.recording_ready = recording_ready
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.release_time = release_time
        self.satisfaction = satisfaction
        self.satisfaction_survey_channel = satisfaction_survey_channel
        self.satisfaction_survey_offered = satisfaction_survey_offered
        self.skill_group_ids = skill_group_ids
        self.skill_group_names = skill_group_names
        self.start_time = start_time

    def validate(self):
        if self.agent_events:
            for k in self.agent_events:
                if k:
                    k.validate()
        if self.analytics_report:
            self.analytics_report.validate()
        if self.customer_events:
            for k in self.customer_events:
                if k:
                    k.validate()
        if self.ivr_events:
            for k in self.ivr_events:
                if k:
                    k.validate()
        if self.queue_events:
            for k in self.queue_events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AgentEvents'] = []
        if self.agent_events is not None:
            for k in self.agent_events:
                result['AgentEvents'].append(k.to_map() if k else None)
        if self.agent_ids is not None:
            result['AgentIds'] = self.agent_ids
        if self.agent_names is not None:
            result['AgentNames'] = self.agent_names
        if self.analytics_report is not None:
            result['AnalyticsReport'] = self.analytics_report.to_map()
        if self.analytics_report_ready is not None:
            result['AnalyticsReportReady'] = self.analytics_report_ready
        if self.call_duration is not None:
            result['CallDuration'] = self.call_duration
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.callee_location is not None:
            result['CalleeLocation'] = self.callee_location
        if self.caller_location is not None:
            result['CallerLocation'] = self.caller_location
        if self.calling_number is not None:
            result['CallingNumber'] = self.calling_number
        if self.contact_disposition is not None:
            result['ContactDisposition'] = self.contact_disposition
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_type is not None:
            result['ContactType'] = self.contact_type
        result['CustomerEvents'] = []
        if self.customer_events is not None:
            for k in self.customer_events:
                result['CustomerEvents'].append(k.to_map() if k else None)
        if self.early_media_state is not None:
            result['EarlyMediaState'] = self.early_media_state
        if self.established_time is not None:
            result['EstablishedTime'] = self.established_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['IvrEvents'] = []
        if self.ivr_events is not None:
            for k in self.ivr_events:
                result['IvrEvents'].append(k.to_map() if k else None)
        if self.outside_number_release_reason is not None:
            result['OutsideNumberReleaseReason'] = self.outside_number_release_reason
        result['QueueEvents'] = []
        if self.queue_events is not None:
            for k in self.queue_events:
                result['QueueEvents'].append(k.to_map() if k else None)
        if self.recording_ready is not None:
            result['RecordingReady'] = self.recording_ready
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.satisfaction is not None:
            result['Satisfaction'] = self.satisfaction
        if self.satisfaction_survey_channel is not None:
            result['SatisfactionSurveyChannel'] = self.satisfaction_survey_channel
        if self.satisfaction_survey_offered is not None:
            result['SatisfactionSurveyOffered'] = self.satisfaction_survey_offered
        if self.skill_group_ids is not None:
            result['SkillGroupIds'] = self.skill_group_ids
        if self.skill_group_names is not None:
            result['SkillGroupNames'] = self.skill_group_names
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.agent_events = []
        if m.get('AgentEvents') is not None:
            for k in m.get('AgentEvents'):
                temp_model = GetCallDetailRecordResponseBodyDataAgentEvents()
                self.agent_events.append(temp_model.from_map(k))
        if m.get('AgentIds') is not None:
            self.agent_ids = m.get('AgentIds')
        if m.get('AgentNames') is not None:
            self.agent_names = m.get('AgentNames')
        if m.get('AnalyticsReport') is not None:
            temp_model = GetCallDetailRecordResponseBodyDataAnalyticsReport()
            self.analytics_report = temp_model.from_map(m['AnalyticsReport'])
        if m.get('AnalyticsReportReady') is not None:
            self.analytics_report_ready = m.get('AnalyticsReportReady')
        if m.get('CallDuration') is not None:
            self.call_duration = m.get('CallDuration')
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('CalleeLocation') is not None:
            self.callee_location = m.get('CalleeLocation')
        if m.get('CallerLocation') is not None:
            self.caller_location = m.get('CallerLocation')
        if m.get('CallingNumber') is not None:
            self.calling_number = m.get('CallingNumber')
        if m.get('ContactDisposition') is not None:
            self.contact_disposition = m.get('ContactDisposition')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactType') is not None:
            self.contact_type = m.get('ContactType')
        self.customer_events = []
        if m.get('CustomerEvents') is not None:
            for k in m.get('CustomerEvents'):
                temp_model = GetCallDetailRecordResponseBodyDataCustomerEvents()
                self.customer_events.append(temp_model.from_map(k))
        if m.get('EarlyMediaState') is not None:
            self.early_media_state = m.get('EarlyMediaState')
        if m.get('EstablishedTime') is not None:
            self.established_time = m.get('EstablishedTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.ivr_events = []
        if m.get('IvrEvents') is not None:
            for k in m.get('IvrEvents'):
                temp_model = GetCallDetailRecordResponseBodyDataIvrEvents()
                self.ivr_events.append(temp_model.from_map(k))
        if m.get('OutsideNumberReleaseReason') is not None:
            self.outside_number_release_reason = m.get('OutsideNumberReleaseReason')
        self.queue_events = []
        if m.get('QueueEvents') is not None:
            for k in m.get('QueueEvents'):
                temp_model = GetCallDetailRecordResponseBodyDataQueueEvents()
                self.queue_events.append(temp_model.from_map(k))
        if m.get('RecordingReady') is not None:
            self.recording_ready = m.get('RecordingReady')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('Satisfaction') is not None:
            self.satisfaction = m.get('Satisfaction')
        if m.get('SatisfactionSurveyChannel') is not None:
            self.satisfaction_survey_channel = m.get('SatisfactionSurveyChannel')
        if m.get('SatisfactionSurveyOffered') is not None:
            self.satisfaction_survey_offered = m.get('SatisfactionSurveyOffered')
        if m.get('SkillGroupIds') is not None:
            self.skill_group_ids = m.get('SkillGroupIds')
        if m.get('SkillGroupNames') is not None:
            self.skill_group_names = m.get('SkillGroupNames')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetCallDetailRecordResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetCallDetailRecordResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetCallDetailRecordResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCallDetailRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCallDetailRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCallDetailRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCampaignRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetCampaignResponseBodyData(TeaModel):
    def __init__(
        self,
        actual_end_time: int = None,
        actual_start_time: int = None,
        campaign_id: str = None,
        cases_aborted: int = None,
        cases_connected: int = None,
        cases_uncompleted: int = None,
        cases_uncompleted_after_attempt: str = None,
        cases_uncompleted_after_attempted: int = None,
        completion_rate: float = None,
        contact_flow_id: str = None,
        max_attempt_count: int = None,
        min_attempt_interval: int = None,
        name: str = None,
        planed_end_time: int = None,
        planed_start_time: int = None,
        queue_id: str = None,
        queue_name: str = None,
        simulation: bool = None,
        simulation_parameters: str = None,
        state: str = None,
        strategy_parameters: str = None,
        strategy_type: str = None,
        total_cases: int = None,
    ):
        self.actual_end_time = actual_end_time
        self.actual_start_time = actual_start_time
        self.campaign_id = campaign_id
        self.cases_aborted = cases_aborted
        self.cases_connected = cases_connected
        self.cases_uncompleted = cases_uncompleted
        self.cases_uncompleted_after_attempt = cases_uncompleted_after_attempt
        self.cases_uncompleted_after_attempted = cases_uncompleted_after_attempted
        self.completion_rate = completion_rate
        self.contact_flow_id = contact_flow_id
        self.max_attempt_count = max_attempt_count
        self.min_attempt_interval = min_attempt_interval
        self.name = name
        self.planed_end_time = planed_end_time
        self.planed_start_time = planed_start_time
        self.queue_id = queue_id
        self.queue_name = queue_name
        self.simulation = simulation
        self.simulation_parameters = simulation_parameters
        self.state = state
        self.strategy_parameters = strategy_parameters
        self.strategy_type = strategy_type
        self.total_cases = total_cases

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_end_time is not None:
            result['ActualEndTime'] = self.actual_end_time
        if self.actual_start_time is not None:
            result['ActualStartTime'] = self.actual_start_time
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.cases_aborted is not None:
            result['CasesAborted'] = self.cases_aborted
        if self.cases_connected is not None:
            result['CasesConnected'] = self.cases_connected
        if self.cases_uncompleted is not None:
            result['CasesUncompleted'] = self.cases_uncompleted
        if self.cases_uncompleted_after_attempt is not None:
            result['CasesUncompletedAfterAttempt'] = self.cases_uncompleted_after_attempt
        if self.cases_uncompleted_after_attempted is not None:
            result['CasesUncompletedAfterAttempted'] = self.cases_uncompleted_after_attempted
        if self.completion_rate is not None:
            result['CompletionRate'] = self.completion_rate
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.max_attempt_count is not None:
            result['MaxAttemptCount'] = self.max_attempt_count
        if self.min_attempt_interval is not None:
            result['MinAttemptInterval'] = self.min_attempt_interval
        if self.name is not None:
            result['Name'] = self.name
        if self.planed_end_time is not None:
            result['PlanedEndTime'] = self.planed_end_time
        if self.planed_start_time is not None:
            result['PlanedStartTime'] = self.planed_start_time
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.simulation is not None:
            result['Simulation'] = self.simulation
        if self.simulation_parameters is not None:
            result['SimulationParameters'] = self.simulation_parameters
        if self.state is not None:
            result['State'] = self.state
        if self.strategy_parameters is not None:
            result['StrategyParameters'] = self.strategy_parameters
        if self.strategy_type is not None:
            result['StrategyType'] = self.strategy_type
        if self.total_cases is not None:
            result['TotalCases'] = self.total_cases
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualEndTime') is not None:
            self.actual_end_time = m.get('ActualEndTime')
        if m.get('ActualStartTime') is not None:
            self.actual_start_time = m.get('ActualStartTime')
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('CasesAborted') is not None:
            self.cases_aborted = m.get('CasesAborted')
        if m.get('CasesConnected') is not None:
            self.cases_connected = m.get('CasesConnected')
        if m.get('CasesUncompleted') is not None:
            self.cases_uncompleted = m.get('CasesUncompleted')
        if m.get('CasesUncompletedAfterAttempt') is not None:
            self.cases_uncompleted_after_attempt = m.get('CasesUncompletedAfterAttempt')
        if m.get('CasesUncompletedAfterAttempted') is not None:
            self.cases_uncompleted_after_attempted = m.get('CasesUncompletedAfterAttempted')
        if m.get('CompletionRate') is not None:
            self.completion_rate = m.get('CompletionRate')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('MaxAttemptCount') is not None:
            self.max_attempt_count = m.get('MaxAttemptCount')
        if m.get('MinAttemptInterval') is not None:
            self.min_attempt_interval = m.get('MinAttemptInterval')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PlanedEndTime') is not None:
            self.planed_end_time = m.get('PlanedEndTime')
        if m.get('PlanedStartTime') is not None:
            self.planed_start_time = m.get('PlanedStartTime')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Simulation') is not None:
            self.simulation = m.get('Simulation')
        if m.get('SimulationParameters') is not None:
            self.simulation_parameters = m.get('SimulationParameters')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('StrategyParameters') is not None:
            self.strategy_parameters = m.get('StrategyParameters')
        if m.get('StrategyType') is not None:
            self.strategy_type = m.get('StrategyType')
        if m.get('TotalCases') is not None:
            self.total_cases = m.get('TotalCases')
        return self


class GetCampaignResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetCampaignResponseBodyData = None,
        http_status_code: int = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetCampaignResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCampaignResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCampaignResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCampaignResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCaseFileUploadUrlRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.file_name = file_name
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetCaseFileUploadUrlResponseBodyData(TeaModel):
    def __init__(
        self,
        case_file_key: str = None,
        url: str = None,
    ):
        self.case_file_key = case_file_key
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.case_file_key is not None:
            result['CaseFileKey'] = self.case_file_key
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CaseFileKey') is not None:
            self.case_file_key = m.get('CaseFileKey')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetCaseFileUploadUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetCaseFileUploadUrlResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetCaseFileUploadUrlResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCaseFileUploadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCaseFileUploadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCaseFileUploadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetChatMediaUrlRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        media_id: str = None,
        request_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # media id
        # 
        # This parameter is required.
        self.media_id = media_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetChatMediaUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetChatMediaUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetChatMediaUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetChatMediaUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetChatRoutingProfileRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetChatRoutingProfileResponseBodyData(TeaModel):
    def __init__(
        self,
        agent_concurrency_settings: str = None,
        chat_settings: str = None,
        distribution_settings: str = None,
        routing_type: str = None,
    ):
        self.agent_concurrency_settings = agent_concurrency_settings
        self.chat_settings = chat_settings
        self.distribution_settings = distribution_settings
        self.routing_type = routing_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_concurrency_settings is not None:
            result['AgentConcurrencySettings'] = self.agent_concurrency_settings
        if self.chat_settings is not None:
            result['ChatSettings'] = self.chat_settings
        if self.distribution_settings is not None:
            result['DistributionSettings'] = self.distribution_settings
        if self.routing_type is not None:
            result['RoutingType'] = self.routing_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentConcurrencySettings') is not None:
            self.agent_concurrency_settings = m.get('AgentConcurrencySettings')
        if m.get('ChatSettings') is not None:
            self.chat_settings = m.get('ChatSettings')
        if m.get('DistributionSettings') is not None:
            self.distribution_settings = m.get('DistributionSettings')
        if m.get('RoutingType') is not None:
            self.routing_type = m.get('RoutingType')
        return self


class GetChatRoutingProfileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetChatRoutingProfileResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetChatRoutingProfileResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetChatRoutingProfileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetChatRoutingProfileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetChatRoutingProfileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetContactFlowRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        draft_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.draft_id = draft_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.draft_id is not None:
            result['DraftId'] = self.draft_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('DraftId') is not None:
            self.draft_id = m.get('DraftId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetContactFlowResponseBodyData(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        created_time: str = None,
        definition: str = None,
        description: str = None,
        draft_id: str = None,
        editor: str = None,
        instance_id: str = None,
        name: str = None,
        published: bool = None,
        type: str = None,
        updated_time: str = None,
    ):
        self.contact_flow_id = contact_flow_id
        self.created_time = created_time
        self.definition = definition
        self.description = description
        self.draft_id = draft_id
        self.editor = editor
        self.instance_id = instance_id
        self.name = name
        self.published = published
        self.type = type
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.description is not None:
            result['Description'] = self.description
        if self.draft_id is not None:
            result['DraftId'] = self.draft_id
        if self.editor is not None:
            result['Editor'] = self.editor
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.published is not None:
            result['Published'] = self.published
        if self.type is not None:
            result['Type'] = self.type
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DraftId') is not None:
            self.draft_id = m.get('DraftId')
        if m.get('Editor') is not None:
            self.editor = m.get('Editor')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Published') is not None:
            self.published = m.get('Published')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class GetContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetContactFlowResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetContactFlowResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetConversationDetailRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetConversationDetailResponseBodyPhrases(TeaModel):
    def __init__(
        self,
        begin: int = None,
        end: int = None,
        finished: bool = None,
        identity: str = None,
        role: str = None,
        words: str = None,
    ):
        self.begin = begin
        self.end = end
        self.finished = finished
        self.identity = identity
        self.role = role
        self.words = words

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin is not None:
            result['Begin'] = self.begin
        if self.end is not None:
            result['End'] = self.end
        if self.finished is not None:
            result['Finished'] = self.finished
        if self.identity is not None:
            result['Identity'] = self.identity
        if self.role is not None:
            result['Role'] = self.role
        if self.words is not None:
            result['Words'] = self.words
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Begin') is not None:
            self.begin = m.get('Begin')
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Finished') is not None:
            self.finished = m.get('Finished')
        if m.get('Identity') is not None:
            self.identity = m.get('Identity')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Words') is not None:
            self.words = m.get('Words')
        return self


class GetConversationDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        phrases: List[GetConversationDetailResponseBodyPhrases] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.phrases = phrases
        self.request_id = request_id

    def validate(self):
        if self.phrases:
            for k in self.phrases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        result['Phrases'] = []
        if self.phrases is not None:
            for k in self.phrases:
                result['Phrases'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        self.phrases = []
        if m.get('Phrases') is not None:
            for k in m.get('Phrases'):
                temp_model = GetConversationDetailResponseBodyPhrases()
                self.phrases.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetConversationDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetConversationDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetConversationDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataChannelCredentialsRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetDataChannelCredentialsResponseBodyData(TeaModel):
    def __init__(
        self,
        client_id: str = None,
        device_id: str = None,
        endpoint: str = None,
        expired_time: int = None,
        password: str = None,
        topic: str = None,
        user_name: str = None,
    ):
        self.client_id = client_id
        self.device_id = device_id
        self.endpoint = endpoint
        self.expired_time = expired_time
        self.password = password
        self.topic = topic
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.password is not None:
            result['Password'] = self.password
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class GetDataChannelCredentialsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDataChannelCredentialsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDataChannelCredentialsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDataChannelCredentialsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataChannelCredentialsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataChannelCredentialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoNotCallFileUploadParametersRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.file_name = file_name
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetDoNotCallFileUploadParametersResponseBodyData(TeaModel):
    def __init__(
        self,
        access_key_id: str = None,
        expire_time: int = None,
        file_path: str = None,
        host: str = None,
        policy: str = None,
        signature: str = None,
    ):
        self.access_key_id = access_key_id
        self.expire_time = expire_time
        self.file_path = file_path
        self.host = host
        self.policy = policy
        self.signature = signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['AccessKeyId'] = self.access_key_id
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.host is not None:
            result['Host'] = self.host
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKeyId') is not None:
            self.access_key_id = m.get('AccessKeyId')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        return self


class GetDoNotCallFileUploadParametersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDoNotCallFileUploadParametersResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDoNotCallFileUploadParametersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDoNotCallFileUploadParametersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoNotCallFileUploadParametersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoNotCallFileUploadParametersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDocumentUploadParametersRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        instance_id: str = None,
        request_id: str = None,
    ):
        # This parameter is required.
        self.file_name = file_name
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDocumentUploadParametersResponseBodyData(TeaModel):
    def __init__(
        self,
        access_key_id: str = None,
        expire_time: int = None,
        file_path: str = None,
        host: str = None,
        policy: str = None,
        signature: str = None,
    ):
        self.access_key_id = access_key_id
        self.expire_time = expire_time
        self.file_path = file_path
        # oss host
        self.host = host
        self.policy = policy
        self.signature = signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['AccessKeyId'] = self.access_key_id
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.host is not None:
            result['Host'] = self.host
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKeyId') is not None:
            self.access_key_id = m.get('AccessKeyId')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        return self


class GetDocumentUploadParametersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDocumentUploadParametersResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDocumentUploadParametersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDocumentUploadParametersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDocumentUploadParametersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDocumentUploadParametersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEarlyMediaRecordingRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetEarlyMediaRecordingResponseBodyData(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_url: str = None,
    ):
        self.file_name = file_name
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetEarlyMediaRecordingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetEarlyMediaRecordingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetEarlyMediaRecordingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEarlyMediaRecordingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEarlyMediaRecordingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEarlyMediaRecordingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHistoricalCallerReportRequest(TeaModel):
    def __init__(
        self,
        calling_number: str = None,
        instance_id: str = None,
        start_time: int = None,
        stop_time: int = None,
    ):
        # This parameter is required.
        self.calling_number = calling_number
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.start_time = start_time
        # This parameter is required.
        self.stop_time = stop_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calling_number is not None:
            result['CallingNumber'] = self.calling_number
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallingNumber') is not None:
            self.calling_number = m.get('CallingNumber')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        return self


class GetHistoricalCallerReportResponseBodyData(TeaModel):
    def __init__(
        self,
        last_calling_time: int = None,
        total_calls: int = None,
    ):
        self.last_calling_time = last_calling_time
        self.total_calls = total_calls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.last_calling_time is not None:
            result['LastCallingTime'] = self.last_calling_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LastCallingTime') is not None:
            self.last_calling_time = m.get('LastCallingTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        return self


class GetHistoricalCallerReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetHistoricalCallerReportResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetHistoricalCallerReportResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetHistoricalCallerReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHistoricalCallerReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHistoricalCallerReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHistoricalCampaignReportRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetHistoricalCampaignReportResponseBodyData(TeaModel):
    def __init__(
        self,
        abandon_rate: float = None,
        abandoned_rate: float = None,
        answer_rate: float = None,
        calls_abandoned: int = None,
        calls_connected: int = None,
        calls_dialed: int = None,
        connected_rate: float = None,
        occupancy_rate: float = None,
    ):
        self.abandon_rate = abandon_rate
        self.abandoned_rate = abandoned_rate
        self.answer_rate = answer_rate
        self.calls_abandoned = calls_abandoned
        self.calls_connected = calls_connected
        self.calls_dialed = calls_dialed
        self.connected_rate = connected_rate
        self.occupancy_rate = occupancy_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abandon_rate is not None:
            result['AbandonRate'] = self.abandon_rate
        if self.abandoned_rate is not None:
            result['AbandonedRate'] = self.abandoned_rate
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.calls_abandoned is not None:
            result['CallsAbandoned'] = self.calls_abandoned
        if self.calls_connected is not None:
            result['CallsConnected'] = self.calls_connected
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.connected_rate is not None:
            result['ConnectedRate'] = self.connected_rate
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbandonRate') is not None:
            self.abandon_rate = m.get('AbandonRate')
        if m.get('AbandonedRate') is not None:
            self.abandoned_rate = m.get('AbandonedRate')
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('CallsAbandoned') is not None:
            self.calls_abandoned = m.get('CallsAbandoned')
        if m.get('CallsConnected') is not None:
            self.calls_connected = m.get('CallsConnected')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('ConnectedRate') is not None:
            self.connected_rate = m.get('ConnectedRate')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        return self


class GetHistoricalCampaignReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetHistoricalCampaignReportResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetHistoricalCampaignReportResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetHistoricalCampaignReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHistoricalCampaignReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHistoricalCampaignReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHistoricalInstanceReportRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_id: str = None,
        media_type: str = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList(TeaModel):
    def __init__(
        self,
        access_channel_type: str = None,
        calls_offered: int = None,
    ):
        self.access_channel_type = access_channel_type
        self.calls_offered = calls_offered

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_type is not None:
            result['AccessChannelType'] = self.access_channel_type
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelType') is not None:
            self.access_channel_type = m.get('AccessChannelType')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        return self


class GetHistoricalInstanceReportResponseBodyDataInbound(TeaModel):
    def __init__(
        self,
        abandon_rate: float = None,
        access_channel_type_detail_list: List[GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList] = None,
        average_abandon_time: float = None,
        average_abandoned_in_ivrtime: float = None,
        average_abandoned_in_queue_time: float = None,
        average_abandoned_in_ring_time: float = None,
        average_first_response_time: float = None,
        average_hold_time: float = None,
        average_response_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_wait_time: float = None,
        average_work_time: float = None,
        calls_abandoned: int = None,
        calls_abandoned_in_ivr: int = None,
        calls_abandoned_in_queue: int = None,
        calls_abandoned_in_ring: int = None,
        calls_abandoned_in_voice_navigator: int = None,
        calls_attended_transferred: int = None,
        calls_blind_transferred: int = None,
        calls_caused_ivrexception: int = None,
        calls_forward_to_outside_number: int = None,
        calls_handled: int = None,
        calls_hold: int = None,
        calls_ivrexception: int = None,
        calls_offered: int = None,
        calls_queued: int = None,
        calls_queuing_failed: int = None,
        calls_queuing_overflow: int = None,
        calls_queuing_timeout: int = None,
        calls_ringed: int = None,
        calls_to_voicemail: int = None,
        calls_voicemail: int = None,
        handle_rate: float = None,
        max_abandon_time: int = None,
        max_abandoned_in_ivrtime: int = None,
        max_abandoned_in_queue_time: int = None,
        max_abandoned_in_ring_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_wait_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        service_level_15: float = None,
        service_level_20: float = None,
        service_level_30: float = None,
        total_abandon_time: int = None,
        total_abandoned_in_ivrtime: int = None,
        total_abandoned_in_queue_time: int = None,
        total_abandoned_in_ring_time: int = None,
        total_hold_time: int = None,
        total_messages_sent: int = None,
        total_messages_sent_by_agent: int = None,
        total_messages_sent_by_customer: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_wait_time: int = None,
        total_work_time: int = None,
    ):
        self.abandon_rate = abandon_rate
        self.access_channel_type_detail_list = access_channel_type_detail_list
        self.average_abandon_time = average_abandon_time
        self.average_abandoned_in_ivrtime = average_abandoned_in_ivrtime
        self.average_abandoned_in_queue_time = average_abandoned_in_queue_time
        self.average_abandoned_in_ring_time = average_abandoned_in_ring_time
        self.average_first_response_time = average_first_response_time
        self.average_hold_time = average_hold_time
        self.average_response_time = average_response_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_wait_time = average_wait_time
        self.average_work_time = average_work_time
        self.calls_abandoned = calls_abandoned
        self.calls_abandoned_in_ivr = calls_abandoned_in_ivr
        self.calls_abandoned_in_queue = calls_abandoned_in_queue
        self.calls_abandoned_in_ring = calls_abandoned_in_ring
        self.calls_abandoned_in_voice_navigator = calls_abandoned_in_voice_navigator
        self.calls_attended_transferred = calls_attended_transferred
        self.calls_blind_transferred = calls_blind_transferred
        self.calls_caused_ivrexception = calls_caused_ivrexception
        self.calls_forward_to_outside_number = calls_forward_to_outside_number
        self.calls_handled = calls_handled
        self.calls_hold = calls_hold
        self.calls_ivrexception = calls_ivrexception
        self.calls_offered = calls_offered
        self.calls_queued = calls_queued
        self.calls_queuing_failed = calls_queuing_failed
        self.calls_queuing_overflow = calls_queuing_overflow
        self.calls_queuing_timeout = calls_queuing_timeout
        self.calls_ringed = calls_ringed
        self.calls_to_voicemail = calls_to_voicemail
        self.calls_voicemail = calls_voicemail
        self.handle_rate = handle_rate
        self.max_abandon_time = max_abandon_time
        self.max_abandoned_in_ivrtime = max_abandoned_in_ivrtime
        self.max_abandoned_in_queue_time = max_abandoned_in_queue_time
        self.max_abandoned_in_ring_time = max_abandoned_in_ring_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_wait_time = max_wait_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.service_level_15 = service_level_15
        self.service_level_20 = service_level_20
        self.service_level_30 = service_level_30
        self.total_abandon_time = total_abandon_time
        self.total_abandoned_in_ivrtime = total_abandoned_in_ivrtime
        self.total_abandoned_in_queue_time = total_abandoned_in_queue_time
        self.total_abandoned_in_ring_time = total_abandoned_in_ring_time
        self.total_hold_time = total_hold_time
        self.total_messages_sent = total_messages_sent
        self.total_messages_sent_by_agent = total_messages_sent_by_agent
        self.total_messages_sent_by_customer = total_messages_sent_by_customer
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_wait_time = total_wait_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.access_channel_type_detail_list:
            for k in self.access_channel_type_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abandon_rate is not None:
            result['AbandonRate'] = self.abandon_rate
        result['AccessChannelTypeDetailList'] = []
        if self.access_channel_type_detail_list is not None:
            for k in self.access_channel_type_detail_list:
                result['AccessChannelTypeDetailList'].append(k.to_map() if k else None)
        if self.average_abandon_time is not None:
            result['AverageAbandonTime'] = self.average_abandon_time
        if self.average_abandoned_in_ivrtime is not None:
            result['AverageAbandonedInIVRTime'] = self.average_abandoned_in_ivrtime
        if self.average_abandoned_in_queue_time is not None:
            result['AverageAbandonedInQueueTime'] = self.average_abandoned_in_queue_time
        if self.average_abandoned_in_ring_time is not None:
            result['AverageAbandonedInRingTime'] = self.average_abandoned_in_ring_time
        if self.average_first_response_time is not None:
            result['AverageFirstResponseTime'] = self.average_first_response_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_response_time is not None:
            result['AverageResponseTime'] = self.average_response_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_wait_time is not None:
            result['AverageWaitTime'] = self.average_wait_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_abandoned is not None:
            result['CallsAbandoned'] = self.calls_abandoned
        if self.calls_abandoned_in_ivr is not None:
            result['CallsAbandonedInIVR'] = self.calls_abandoned_in_ivr
        if self.calls_abandoned_in_queue is not None:
            result['CallsAbandonedInQueue'] = self.calls_abandoned_in_queue
        if self.calls_abandoned_in_ring is not None:
            result['CallsAbandonedInRing'] = self.calls_abandoned_in_ring
        if self.calls_abandoned_in_voice_navigator is not None:
            result['CallsAbandonedInVoiceNavigator'] = self.calls_abandoned_in_voice_navigator
        if self.calls_attended_transferred is not None:
            result['CallsAttendedTransferred'] = self.calls_attended_transferred
        if self.calls_blind_transferred is not None:
            result['CallsBlindTransferred'] = self.calls_blind_transferred
        if self.calls_caused_ivrexception is not None:
            result['CallsCausedIVRException'] = self.calls_caused_ivrexception
        if self.calls_forward_to_outside_number is not None:
            result['CallsForwardToOutsideNumber'] = self.calls_forward_to_outside_number
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ivrexception is not None:
            result['CallsIVRException'] = self.calls_ivrexception
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_queued is not None:
            result['CallsQueued'] = self.calls_queued
        if self.calls_queuing_failed is not None:
            result['CallsQueuingFailed'] = self.calls_queuing_failed
        if self.calls_queuing_overflow is not None:
            result['CallsQueuingOverflow'] = self.calls_queuing_overflow
        if self.calls_queuing_timeout is not None:
            result['CallsQueuingTimeout'] = self.calls_queuing_timeout
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.calls_to_voicemail is not None:
            result['CallsToVoicemail'] = self.calls_to_voicemail
        if self.calls_voicemail is not None:
            result['CallsVoicemail'] = self.calls_voicemail
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_abandon_time is not None:
            result['MaxAbandonTime'] = self.max_abandon_time
        if self.max_abandoned_in_ivrtime is not None:
            result['MaxAbandonedInIVRTime'] = self.max_abandoned_in_ivrtime
        if self.max_abandoned_in_queue_time is not None:
            result['MaxAbandonedInQueueTime'] = self.max_abandoned_in_queue_time
        if self.max_abandoned_in_ring_time is not None:
            result['MaxAbandonedInRingTime'] = self.max_abandoned_in_ring_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.service_level_15 is not None:
            result['ServiceLevel15'] = self.service_level_15
        if self.service_level_20 is not None:
            result['ServiceLevel20'] = self.service_level_20
        if self.service_level_30 is not None:
            result['ServiceLevel30'] = self.service_level_30
        if self.total_abandon_time is not None:
            result['TotalAbandonTime'] = self.total_abandon_time
        if self.total_abandoned_in_ivrtime is not None:
            result['TotalAbandonedInIVRTime'] = self.total_abandoned_in_ivrtime
        if self.total_abandoned_in_queue_time is not None:
            result['TotalAbandonedInQueueTime'] = self.total_abandoned_in_queue_time
        if self.total_abandoned_in_ring_time is not None:
            result['TotalAbandonedInRingTime'] = self.total_abandoned_in_ring_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_messages_sent is not None:
            result['TotalMessagesSent'] = self.total_messages_sent
        if self.total_messages_sent_by_agent is not None:
            result['TotalMessagesSentByAgent'] = self.total_messages_sent_by_agent
        if self.total_messages_sent_by_customer is not None:
            result['TotalMessagesSentByCustomer'] = self.total_messages_sent_by_customer
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbandonRate') is not None:
            self.abandon_rate = m.get('AbandonRate')
        self.access_channel_type_detail_list = []
        if m.get('AccessChannelTypeDetailList') is not None:
            for k in m.get('AccessChannelTypeDetailList'):
                temp_model = GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList()
                self.access_channel_type_detail_list.append(temp_model.from_map(k))
        if m.get('AverageAbandonTime') is not None:
            self.average_abandon_time = m.get('AverageAbandonTime')
        if m.get('AverageAbandonedInIVRTime') is not None:
            self.average_abandoned_in_ivrtime = m.get('AverageAbandonedInIVRTime')
        if m.get('AverageAbandonedInQueueTime') is not None:
            self.average_abandoned_in_queue_time = m.get('AverageAbandonedInQueueTime')
        if m.get('AverageAbandonedInRingTime') is not None:
            self.average_abandoned_in_ring_time = m.get('AverageAbandonedInRingTime')
        if m.get('AverageFirstResponseTime') is not None:
            self.average_first_response_time = m.get('AverageFirstResponseTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageResponseTime') is not None:
            self.average_response_time = m.get('AverageResponseTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWaitTime') is not None:
            self.average_wait_time = m.get('AverageWaitTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAbandoned') is not None:
            self.calls_abandoned = m.get('CallsAbandoned')
        if m.get('CallsAbandonedInIVR') is not None:
            self.calls_abandoned_in_ivr = m.get('CallsAbandonedInIVR')
        if m.get('CallsAbandonedInQueue') is not None:
            self.calls_abandoned_in_queue = m.get('CallsAbandonedInQueue')
        if m.get('CallsAbandonedInRing') is not None:
            self.calls_abandoned_in_ring = m.get('CallsAbandonedInRing')
        if m.get('CallsAbandonedInVoiceNavigator') is not None:
            self.calls_abandoned_in_voice_navigator = m.get('CallsAbandonedInVoiceNavigator')
        if m.get('CallsAttendedTransferred') is not None:
            self.calls_attended_transferred = m.get('CallsAttendedTransferred')
        if m.get('CallsBlindTransferred') is not None:
            self.calls_blind_transferred = m.get('CallsBlindTransferred')
        if m.get('CallsCausedIVRException') is not None:
            self.calls_caused_ivrexception = m.get('CallsCausedIVRException')
        if m.get('CallsForwardToOutsideNumber') is not None:
            self.calls_forward_to_outside_number = m.get('CallsForwardToOutsideNumber')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsIVRException') is not None:
            self.calls_ivrexception = m.get('CallsIVRException')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsQueued') is not None:
            self.calls_queued = m.get('CallsQueued')
        if m.get('CallsQueuingFailed') is not None:
            self.calls_queuing_failed = m.get('CallsQueuingFailed')
        if m.get('CallsQueuingOverflow') is not None:
            self.calls_queuing_overflow = m.get('CallsQueuingOverflow')
        if m.get('CallsQueuingTimeout') is not None:
            self.calls_queuing_timeout = m.get('CallsQueuingTimeout')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('CallsToVoicemail') is not None:
            self.calls_to_voicemail = m.get('CallsToVoicemail')
        if m.get('CallsVoicemail') is not None:
            self.calls_voicemail = m.get('CallsVoicemail')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxAbandonTime') is not None:
            self.max_abandon_time = m.get('MaxAbandonTime')
        if m.get('MaxAbandonedInIVRTime') is not None:
            self.max_abandoned_in_ivrtime = m.get('MaxAbandonedInIVRTime')
        if m.get('MaxAbandonedInQueueTime') is not None:
            self.max_abandoned_in_queue_time = m.get('MaxAbandonedInQueueTime')
        if m.get('MaxAbandonedInRingTime') is not None:
            self.max_abandoned_in_ring_time = m.get('MaxAbandonedInRingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('ServiceLevel15') is not None:
            self.service_level_15 = m.get('ServiceLevel15')
        if m.get('ServiceLevel20') is not None:
            self.service_level_20 = m.get('ServiceLevel20')
        if m.get('ServiceLevel30') is not None:
            self.service_level_30 = m.get('ServiceLevel30')
        if m.get('TotalAbandonTime') is not None:
            self.total_abandon_time = m.get('TotalAbandonTime')
        if m.get('TotalAbandonedInIVRTime') is not None:
            self.total_abandoned_in_ivrtime = m.get('TotalAbandonedInIVRTime')
        if m.get('TotalAbandonedInQueueTime') is not None:
            self.total_abandoned_in_queue_time = m.get('TotalAbandonedInQueueTime')
        if m.get('TotalAbandonedInRingTime') is not None:
            self.total_abandoned_in_ring_time = m.get('TotalAbandonedInRingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalMessagesSent') is not None:
            self.total_messages_sent = m.get('TotalMessagesSent')
        if m.get('TotalMessagesSentByAgent') is not None:
            self.total_messages_sent_by_agent = m.get('TotalMessagesSentByAgent')
        if m.get('TotalMessagesSentByCustomer') is not None:
            self.total_messages_sent_by_customer = m.get('TotalMessagesSentByCustomer')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class GetHistoricalInstanceReportResponseBodyDataInternal(TeaModel):
    def __init__(
        self,
        calls_answered: int = None,
        calls_dialed: int = None,
    ):
        self.calls_answered = calls_answered
        self.calls_dialed = calls_dialed

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        return self


class GetHistoricalInstanceReportResponseBodyDataOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: float = None,
        average_hold_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_answered: int = None,
        calls_attended_transferred: int = None,
        calls_blind_transferred: int = None,
        calls_dialed: int = None,
        calls_hold: int = None,
        calls_ringed: int = None,
        max_dialing_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_hold_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_hold_time = average_hold_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_attended_transferred = calls_attended_transferred
        self.calls_blind_transferred = calls_blind_transferred
        self.calls_dialed = calls_dialed
        self.calls_hold = calls_hold
        self.calls_ringed = calls_ringed
        self.max_dialing_time = max_dialing_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_hold_time = total_hold_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_attended_transferred is not None:
            result['CallsAttendedTransferred'] = self.calls_attended_transferred
        if self.calls_blind_transferred is not None:
            result['CallsBlindTransferred'] = self.calls_blind_transferred
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsAttendedTransferred') is not None:
            self.calls_attended_transferred = m.get('CallsAttendedTransferred')
        if m.get('CallsBlindTransferred') is not None:
            self.calls_blind_transferred = m.get('CallsBlindTransferred')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class GetHistoricalInstanceReportResponseBodyDataOverall(TeaModel):
    def __init__(
        self,
        average_break_time: float = None,
        average_hold_time: float = None,
        average_ready_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        max_break_time: int = None,
        max_hold_time: int = None,
        max_logged_in_agents: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_hold_time: int = None,
        total_logged_in_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_break_time = average_break_time
        self.average_hold_time = average_hold_time
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.max_break_time = max_break_time
        self.max_hold_time = max_hold_time
        self.max_logged_in_agents = max_logged_in_agents
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_hold_time = total_hold_time
        self.total_logged_in_time = total_logged_in_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_break_time is not None:
            result['AverageBreakTime'] = self.average_break_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.max_break_time is not None:
            result['MaxBreakTime'] = self.max_break_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_logged_in_agents is not None:
            result['MaxLoggedInAgents'] = self.max_logged_in_agents
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageBreakTime') is not None:
            self.average_break_time = m.get('AverageBreakTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('MaxBreakTime') is not None:
            self.max_break_time = m.get('MaxBreakTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxLoggedInAgents') is not None:
            self.max_logged_in_agents = m.get('MaxLoggedInAgents')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class GetHistoricalInstanceReportResponseBodyData(TeaModel):
    def __init__(
        self,
        inbound: GetHistoricalInstanceReportResponseBodyDataInbound = None,
        internal: GetHistoricalInstanceReportResponseBodyDataInternal = None,
        outbound: GetHistoricalInstanceReportResponseBodyDataOutbound = None,
        overall: GetHistoricalInstanceReportResponseBodyDataOverall = None,
    ):
        self.inbound = inbound
        self.internal = internal
        self.outbound = outbound
        self.overall = overall

    def validate(self):
        if self.inbound:
            self.inbound.validate()
        if self.internal:
            self.internal.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.internal is not None:
            result['Internal'] = self.internal.to_map()
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Inbound') is not None:
            temp_model = GetHistoricalInstanceReportResponseBodyDataInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('Internal') is not None:
            temp_model = GetHistoricalInstanceReportResponseBodyDataInternal()
            self.internal = temp_model.from_map(m['Internal'])
        if m.get('Outbound') is not None:
            temp_model = GetHistoricalInstanceReportResponseBodyDataOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = GetHistoricalInstanceReportResponseBodyDataOverall()
            self.overall = temp_model.from_map(m['Overall'])
        return self


class GetHistoricalInstanceReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetHistoricalInstanceReportResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetHistoricalInstanceReportResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetHistoricalInstanceReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHistoricalInstanceReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHistoricalInstanceReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetInstanceResponseBodyDataAdminList(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        email: str = None,
        extension: str = None,
        instance_id: str = None,
        login_name: str = None,
        mobile: str = None,
        role_id: str = None,
        role_name: str = None,
        user_id: str = None,
        work_mode: str = None,
    ):
        self.display_name = display_name
        self.email = email
        self.extension = extension
        self.instance_id = instance_id
        self.login_name = login_name
        self.mobile = mobile
        self.role_id = role_id
        self.role_name = role_name
        self.user_id = user_id
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.email is not None:
            result['Email'] = self.email
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class GetInstanceResponseBodyDataNumberListSkillGroups(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        instance_id: str = None,
        name: str = None,
        phone_number_count: int = None,
        skill_group_id: str = None,
        user_count: int = None,
    ):
        self.description = description
        self.display_name = display_name
        self.instance_id = instance_id
        self.name = name
        self.phone_number_count = phone_number_count
        self.skill_group_id = skill_group_id
        self.user_count = user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.phone_number_count is not None:
            result['PhoneNumberCount'] = self.phone_number_count
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.user_count is not None:
            result['UserCount'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PhoneNumberCount') is not None:
            self.phone_number_count = m.get('PhoneNumberCount')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('UserCount') is not None:
            self.user_count = m.get('UserCount')
        return self


class GetInstanceResponseBodyDataNumberList(TeaModel):
    def __init__(
        self,
        active: bool = None,
        city: str = None,
        contact_flow_id: str = None,
        instance_id: str = None,
        number: str = None,
        province: str = None,
        skill_groups: List[GetInstanceResponseBodyDataNumberListSkillGroups] = None,
        usage: str = None,
        user_id: str = None,
    ):
        self.active = active
        self.city = city
        self.contact_flow_id = contact_flow_id
        self.instance_id = instance_id
        self.number = number
        self.province = province
        self.skill_groups = skill_groups
        self.usage = usage
        self.user_id = user_id

    def validate(self):
        if self.skill_groups:
            for k in self.skill_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.city is not None:
            result['City'] = self.city
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        result['SkillGroups'] = []
        if self.skill_groups is not None:
            for k in self.skill_groups:
                result['SkillGroups'].append(k.to_map() if k else None)
        if self.usage is not None:
            result['Usage'] = self.usage
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        self.skill_groups = []
        if m.get('SkillGroups') is not None:
            for k in m.get('SkillGroups'):
                temp_model = GetInstanceResponseBodyDataNumberListSkillGroups()
                self.skill_groups.append(temp_model.from_map(k))
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetInstanceResponseBodyData(TeaModel):
    def __init__(
        self,
        admin_list: List[GetInstanceResponseBodyDataAdminList] = None,
        aliyun_uid: str = None,
        console_url: str = None,
        description: str = None,
        domain_name: str = None,
        id: str = None,
        name: str = None,
        number_list: List[GetInstanceResponseBodyDataNumberList] = None,
        status: str = None,
    ):
        self.admin_list = admin_list
        self.aliyun_uid = aliyun_uid
        self.console_url = console_url
        self.description = description
        self.domain_name = domain_name
        self.id = id
        self.name = name
        self.number_list = number_list
        self.status = status

    def validate(self):
        if self.admin_list:
            for k in self.admin_list:
                if k:
                    k.validate()
        if self.number_list:
            for k in self.number_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdminList'] = []
        if self.admin_list is not None:
            for k in self.admin_list:
                result['AdminList'].append(k.to_map() if k else None)
        if self.aliyun_uid is not None:
            result['AliyunUid'] = self.aliyun_uid
        if self.console_url is not None:
            result['ConsoleUrl'] = self.console_url
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['NumberList'] = []
        if self.number_list is not None:
            for k in self.number_list:
                result['NumberList'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.admin_list = []
        if m.get('AdminList') is not None:
            for k in m.get('AdminList'):
                temp_model = GetInstanceResponseBodyDataAdminList()
                self.admin_list.append(temp_model.from_map(k))
        if m.get('AliyunUid') is not None:
            self.aliyun_uid = m.get('AliyunUid')
        if m.get('ConsoleUrl') is not None:
            self.console_url = m.get('ConsoleUrl')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.number_list = []
        if m.get('NumberList') is not None:
            for k in m.get('NumberList'):
                temp_model = GetInstanceResponseBodyDataNumberList()
                self.number_list.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetInstanceResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceTrendingReportRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_id: str = None,
        media_type: str = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetInstanceTrendingReportResponseBodyDataInbound(TeaModel):
    def __init__(
        self,
        calls_abandoned_in_ivr: int = None,
        calls_abandoned_in_queue: int = None,
        calls_abandoned_in_ring: int = None,
        calls_handled: int = None,
        calls_queued: int = None,
        stats_time: int = None,
        total_calls: int = None,
    ):
        self.calls_abandoned_in_ivr = calls_abandoned_in_ivr
        self.calls_abandoned_in_queue = calls_abandoned_in_queue
        self.calls_abandoned_in_ring = calls_abandoned_in_ring
        self.calls_handled = calls_handled
        self.calls_queued = calls_queued
        self.stats_time = stats_time
        self.total_calls = total_calls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calls_abandoned_in_ivr is not None:
            result['CallsAbandonedInIVR'] = self.calls_abandoned_in_ivr
        if self.calls_abandoned_in_queue is not None:
            result['CallsAbandonedInQueue'] = self.calls_abandoned_in_queue
        if self.calls_abandoned_in_ring is not None:
            result['CallsAbandonedInRing'] = self.calls_abandoned_in_ring
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_queued is not None:
            result['CallsQueued'] = self.calls_queued
        if self.stats_time is not None:
            result['StatsTime'] = self.stats_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallsAbandonedInIVR') is not None:
            self.calls_abandoned_in_ivr = m.get('CallsAbandonedInIVR')
        if m.get('CallsAbandonedInQueue') is not None:
            self.calls_abandoned_in_queue = m.get('CallsAbandonedInQueue')
        if m.get('CallsAbandonedInRing') is not None:
            self.calls_abandoned_in_ring = m.get('CallsAbandonedInRing')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsQueued') is not None:
            self.calls_queued = m.get('CallsQueued')
        if m.get('StatsTime') is not None:
            self.stats_time = m.get('StatsTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        return self


class GetInstanceTrendingReportResponseBodyDataOutbound(TeaModel):
    def __init__(
        self,
        calls_answered: int = None,
        stats_time: int = None,
        total_calls: int = None,
    ):
        self.calls_answered = calls_answered
        self.stats_time = stats_time
        self.total_calls = total_calls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.stats_time is not None:
            result['StatsTime'] = self.stats_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('StatsTime') is not None:
            self.stats_time = m.get('StatsTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        return self


class GetInstanceTrendingReportResponseBodyDataOverall(TeaModel):
    def __init__(
        self,
        max_logged_in_agents: int = None,
        stats_time: int = None,
    ):
        self.max_logged_in_agents = max_logged_in_agents
        self.stats_time = stats_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_logged_in_agents is not None:
            result['MaxLoggedInAgents'] = self.max_logged_in_agents
        if self.stats_time is not None:
            result['StatsTime'] = self.stats_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxLoggedInAgents') is not None:
            self.max_logged_in_agents = m.get('MaxLoggedInAgents')
        if m.get('StatsTime') is not None:
            self.stats_time = m.get('StatsTime')
        return self


class GetInstanceTrendingReportResponseBodyData(TeaModel):
    def __init__(
        self,
        inbound: List[GetInstanceTrendingReportResponseBodyDataInbound] = None,
        outbound: List[GetInstanceTrendingReportResponseBodyDataOutbound] = None,
        overall: List[GetInstanceTrendingReportResponseBodyDataOverall] = None,
    ):
        self.inbound = inbound
        self.outbound = outbound
        self.overall = overall

    def validate(self):
        if self.inbound:
            for k in self.inbound:
                if k:
                    k.validate()
        if self.outbound:
            for k in self.outbound:
                if k:
                    k.validate()
        if self.overall:
            for k in self.overall:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Inbound'] = []
        if self.inbound is not None:
            for k in self.inbound:
                result['Inbound'].append(k.to_map() if k else None)
        result['Outbound'] = []
        if self.outbound is not None:
            for k in self.outbound:
                result['Outbound'].append(k.to_map() if k else None)
        result['Overall'] = []
        if self.overall is not None:
            for k in self.overall:
                result['Overall'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.inbound = []
        if m.get('Inbound') is not None:
            for k in m.get('Inbound'):
                temp_model = GetInstanceTrendingReportResponseBodyDataInbound()
                self.inbound.append(temp_model.from_map(k))
        self.outbound = []
        if m.get('Outbound') is not None:
            for k in m.get('Outbound'):
                temp_model = GetInstanceTrendingReportResponseBodyDataOutbound()
                self.outbound.append(temp_model.from_map(k))
        self.overall = []
        if m.get('Overall') is not None:
            for k in m.get('Overall'):
                temp_model = GetInstanceTrendingReportResponseBodyDataOverall()
                self.overall.append(temp_model.from_map(k))
        return self


class GetInstanceTrendingReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetInstanceTrendingReportResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetInstanceTrendingReportResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetInstanceTrendingReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInstanceTrendingReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceTrendingReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIvrTrackingSummaryRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetIvrTrackingSummaryResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetIvrTrackingSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIvrTrackingSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIvrTrackingSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLoginDetailsRequest(TeaModel):
    def __init__(
        self,
        chat_device_id: str = None,
        instance_id: str = None,
        user_id: str = None,
    ):
        self.chat_device_id = chat_device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_device_id is not None:
            result['ChatDeviceId'] = self.chat_device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatDeviceId') is not None:
            self.chat_device_id = m.get('ChatDeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetLoginDetailsResponseBodyData(TeaModel):
    def __init__(
        self,
        agent_server_url: str = None,
        avatar_url: str = None,
        chat_app_id: str = None,
        chat_app_key: str = None,
        chat_device_id: str = None,
        chat_login_token: str = None,
        chat_server_url: str = None,
        chat_user_id: str = None,
        device_ext: str = None,
        device_id: str = None,
        device_state: str = None,
        display_name: str = None,
        extension: str = None,
        nickname: str = None,
        signature: str = None,
        signature_2: str = None,
        sip_server_url: str = None,
        user_id: str = None,
        user_key: str = None,
        user_key_2: str = None,
        work_mode: str = None,
    ):
        self.agent_server_url = agent_server_url
        self.avatar_url = avatar_url
        self.chat_app_id = chat_app_id
        self.chat_app_key = chat_app_key
        self.chat_device_id = chat_device_id
        self.chat_login_token = chat_login_token
        self.chat_server_url = chat_server_url
        self.chat_user_id = chat_user_id
        self.device_ext = device_ext
        self.device_id = device_id
        self.device_state = device_state
        self.display_name = display_name
        self.extension = extension
        self.nickname = nickname
        self.signature = signature
        self.signature_2 = signature_2
        self.sip_server_url = sip_server_url
        self.user_id = user_id
        self.user_key = user_key
        self.user_key_2 = user_key_2
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_server_url is not None:
            result['AgentServerUrl'] = self.agent_server_url
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.chat_app_id is not None:
            result['ChatAppId'] = self.chat_app_id
        if self.chat_app_key is not None:
            result['ChatAppKey'] = self.chat_app_key
        if self.chat_device_id is not None:
            result['ChatDeviceId'] = self.chat_device_id
        if self.chat_login_token is not None:
            result['ChatLoginToken'] = self.chat_login_token
        if self.chat_server_url is not None:
            result['ChatServerUrl'] = self.chat_server_url
        if self.chat_user_id is not None:
            result['ChatUserId'] = self.chat_user_id
        if self.device_ext is not None:
            result['DeviceExt'] = self.device_ext
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.signature_2 is not None:
            result['Signature2'] = self.signature_2
        if self.sip_server_url is not None:
            result['SipServerUrl'] = self.sip_server_url
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_key is not None:
            result['UserKey'] = self.user_key
        if self.user_key_2 is not None:
            result['UserKey2'] = self.user_key_2
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentServerUrl') is not None:
            self.agent_server_url = m.get('AgentServerUrl')
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('ChatAppId') is not None:
            self.chat_app_id = m.get('ChatAppId')
        if m.get('ChatAppKey') is not None:
            self.chat_app_key = m.get('ChatAppKey')
        if m.get('ChatDeviceId') is not None:
            self.chat_device_id = m.get('ChatDeviceId')
        if m.get('ChatLoginToken') is not None:
            self.chat_login_token = m.get('ChatLoginToken')
        if m.get('ChatServerUrl') is not None:
            self.chat_server_url = m.get('ChatServerUrl')
        if m.get('ChatUserId') is not None:
            self.chat_user_id = m.get('ChatUserId')
        if m.get('DeviceExt') is not None:
            self.device_ext = m.get('DeviceExt')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('Signature2') is not None:
            self.signature_2 = m.get('Signature2')
        if m.get('SipServerUrl') is not None:
            self.sip_server_url = m.get('SipServerUrl')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserKey') is not None:
            self.user_key = m.get('UserKey')
        if m.get('UserKey2') is not None:
            self.user_key_2 = m.get('UserKey2')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class GetLoginDetailsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetLoginDetailsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetLoginDetailsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLoginDetailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLoginDetailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLoginDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMonoRecordingRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        expire_seconds: int = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        self.expire_seconds = expire_seconds
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.expire_seconds is not None:
            result['ExpireSeconds'] = self.expire_seconds
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ExpireSeconds') is not None:
            self.expire_seconds = m.get('ExpireSeconds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetMonoRecordingResponseBodyData(TeaModel):
    def __init__(
        self,
        duration: int = None,
        file_name: str = None,
        file_url: str = None,
    ):
        self.duration = duration
        self.file_name = file_name
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetMonoRecordingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetMonoRecordingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetMonoRecordingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMonoRecordingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMonoRecordingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMonoRecordingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMultiChannelRecordingRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetMultiChannelRecordingResponseBodyData(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_url: str = None,
    ):
        self.file_name = file_name
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetMultiChannelRecordingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetMultiChannelRecordingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetMultiChannelRecordingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMultiChannelRecordingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMultiChannelRecordingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMultiChannelRecordingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNumberLocationRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number = number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        return self


class GetNumberLocationResponseBodyData(TeaModel):
    def __init__(
        self,
        city: str = None,
        number: str = None,
        province: str = None,
    ):
        self.city = city
        self.number = number
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city is not None:
            result['City'] = self.city
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class GetNumberLocationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetNumberLocationResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetNumberLocationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetNumberLocationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNumberLocationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNumberLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRealtimeCampaignStatsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        queue_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.queue_id = queue_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        return self


class GetRealtimeCampaignStatsResponseBodyData(TeaModel):
    def __init__(
        self,
        breaking_agents: int = None,
        caps: int = None,
        logged_in_agents: int = None,
        outbound_scenario_breaking_agents: int = None,
        outbound_scenario_ready_agents: int = None,
        outbound_scenario_talking_agents: int = None,
        outbound_scenario_working_agents: int = None,
        ready_agents: int = None,
        talking_agents: int = None,
        total_agents: int = None,
        working_agents: int = None,
    ):
        self.breaking_agents = breaking_agents
        self.caps = caps
        self.logged_in_agents = logged_in_agents
        self.outbound_scenario_breaking_agents = outbound_scenario_breaking_agents
        self.outbound_scenario_ready_agents = outbound_scenario_ready_agents
        self.outbound_scenario_talking_agents = outbound_scenario_talking_agents
        self.outbound_scenario_working_agents = outbound_scenario_working_agents
        self.ready_agents = ready_agents
        self.talking_agents = talking_agents
        self.total_agents = total_agents
        self.working_agents = working_agents

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.breaking_agents is not None:
            result['BreakingAgents'] = self.breaking_agents
        if self.caps is not None:
            result['Caps'] = self.caps
        if self.logged_in_agents is not None:
            result['LoggedInAgents'] = self.logged_in_agents
        if self.outbound_scenario_breaking_agents is not None:
            result['OutboundScenarioBreakingAgents'] = self.outbound_scenario_breaking_agents
        if self.outbound_scenario_ready_agents is not None:
            result['OutboundScenarioReadyAgents'] = self.outbound_scenario_ready_agents
        if self.outbound_scenario_talking_agents is not None:
            result['OutboundScenarioTalkingAgents'] = self.outbound_scenario_talking_agents
        if self.outbound_scenario_working_agents is not None:
            result['OutboundScenarioWorkingAgents'] = self.outbound_scenario_working_agents
        if self.ready_agents is not None:
            result['ReadyAgents'] = self.ready_agents
        if self.talking_agents is not None:
            result['TalkingAgents'] = self.talking_agents
        if self.total_agents is not None:
            result['TotalAgents'] = self.total_agents
        if self.working_agents is not None:
            result['WorkingAgents'] = self.working_agents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakingAgents') is not None:
            self.breaking_agents = m.get('BreakingAgents')
        if m.get('Caps') is not None:
            self.caps = m.get('Caps')
        if m.get('LoggedInAgents') is not None:
            self.logged_in_agents = m.get('LoggedInAgents')
        if m.get('OutboundScenarioBreakingAgents') is not None:
            self.outbound_scenario_breaking_agents = m.get('OutboundScenarioBreakingAgents')
        if m.get('OutboundScenarioReadyAgents') is not None:
            self.outbound_scenario_ready_agents = m.get('OutboundScenarioReadyAgents')
        if m.get('OutboundScenarioTalkingAgents') is not None:
            self.outbound_scenario_talking_agents = m.get('OutboundScenarioTalkingAgents')
        if m.get('OutboundScenarioWorkingAgents') is not None:
            self.outbound_scenario_working_agents = m.get('OutboundScenarioWorkingAgents')
        if m.get('ReadyAgents') is not None:
            self.ready_agents = m.get('ReadyAgents')
        if m.get('TalkingAgents') is not None:
            self.talking_agents = m.get('TalkingAgents')
        if m.get('TotalAgents') is not None:
            self.total_agents = m.get('TotalAgents')
        if m.get('WorkingAgents') is not None:
            self.working_agents = m.get('WorkingAgents')
        return self


class GetRealtimeCampaignStatsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetRealtimeCampaignStatsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetRealtimeCampaignStatsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetRealtimeCampaignStatsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRealtimeCampaignStatsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRealtimeCampaignStatsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRealtimeInstanceStatesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        media_type: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        count: int = None,
    ):
        self.break_code = break_code
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class GetRealtimeInstanceStatesResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code_detail_list: List[GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList] = None,
        breaking_agents: int = None,
        instance_id: str = None,
        interactive_calls: int = None,
        logged_in_agents: int = None,
        longest_waiting_time: int = None,
        ready_agents: int = None,
        talking_agents: int = None,
        total_agents: int = None,
        waiting_calls: int = None,
        working_agents: int = None,
    ):
        self.break_code_detail_list = break_code_detail_list
        self.breaking_agents = breaking_agents
        self.instance_id = instance_id
        self.interactive_calls = interactive_calls
        self.logged_in_agents = logged_in_agents
        self.longest_waiting_time = longest_waiting_time
        self.ready_agents = ready_agents
        self.talking_agents = talking_agents
        self.total_agents = total_agents
        self.waiting_calls = waiting_calls
        self.working_agents = working_agents

    def validate(self):
        if self.break_code_detail_list:
            for k in self.break_code_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BreakCodeDetailList'] = []
        if self.break_code_detail_list is not None:
            for k in self.break_code_detail_list:
                result['BreakCodeDetailList'].append(k.to_map() if k else None)
        if self.breaking_agents is not None:
            result['BreakingAgents'] = self.breaking_agents
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.interactive_calls is not None:
            result['InteractiveCalls'] = self.interactive_calls
        if self.logged_in_agents is not None:
            result['LoggedInAgents'] = self.logged_in_agents
        if self.longest_waiting_time is not None:
            result['LongestWaitingTime'] = self.longest_waiting_time
        if self.ready_agents is not None:
            result['ReadyAgents'] = self.ready_agents
        if self.talking_agents is not None:
            result['TalkingAgents'] = self.talking_agents
        if self.total_agents is not None:
            result['TotalAgents'] = self.total_agents
        if self.waiting_calls is not None:
            result['WaitingCalls'] = self.waiting_calls
        if self.working_agents is not None:
            result['WorkingAgents'] = self.working_agents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.break_code_detail_list = []
        if m.get('BreakCodeDetailList') is not None:
            for k in m.get('BreakCodeDetailList'):
                temp_model = GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList()
                self.break_code_detail_list.append(temp_model.from_map(k))
        if m.get('BreakingAgents') is not None:
            self.breaking_agents = m.get('BreakingAgents')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InteractiveCalls') is not None:
            self.interactive_calls = m.get('InteractiveCalls')
        if m.get('LoggedInAgents') is not None:
            self.logged_in_agents = m.get('LoggedInAgents')
        if m.get('LongestWaitingTime') is not None:
            self.longest_waiting_time = m.get('LongestWaitingTime')
        if m.get('ReadyAgents') is not None:
            self.ready_agents = m.get('ReadyAgents')
        if m.get('TalkingAgents') is not None:
            self.talking_agents = m.get('TalkingAgents')
        if m.get('TotalAgents') is not None:
            self.total_agents = m.get('TotalAgents')
        if m.get('WaitingCalls') is not None:
            self.waiting_calls = m.get('WaitingCalls')
        if m.get('WorkingAgents') is not None:
            self.working_agents = m.get('WorkingAgents')
        return self


class GetRealtimeInstanceStatesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetRealtimeInstanceStatesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetRealtimeInstanceStatesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetRealtimeInstanceStatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRealtimeInstanceStatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRealtimeInstanceStatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSchemaRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class GetSchemaResponseBodyData(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        deleted: bool = None,
        description: str = None,
        id: str = None,
        instance_id: str = None,
        properties: Dict[str, DataPropertiesValue] = None,
        updated_time: str = None,
    ):
        self.created_time = created_time
        self.deleted = deleted
        self.description = description
        # schema id
        self.id = id
        self.instance_id = instance_id
        self.properties = properties
        self.updated_time = updated_time

    def validate(self):
        if self.properties:
            for v in self.properties.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.deleted is not None:
            result['Deleted'] = self.deleted
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['Properties'] = {}
        if self.properties is not None:
            for k, v in self.properties.items():
                result['Properties'][k] = v.to_map()
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Deleted') is not None:
            self.deleted = m.get('Deleted')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.properties = {}
        if m.get('Properties') is not None:
            for k, v in m.get('Properties').items():
                temp_model = DataPropertiesValue()
                self.properties[k] = temp_model.from_map(v)
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class GetSchemaResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSchemaResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSchemaResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetSchemaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSchemaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSchemaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSkillGroupRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        skill_group_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class GetSkillGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        instance_id: str = None,
        media_type: str = None,
        name: str = None,
        skill_group_id: str = None,
    ):
        self.description = description
        self.display_name = display_name
        self.instance_id = instance_id
        self.media_type = media_type
        self.name = name
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.name is not None:
            result['Name'] = self.name
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class GetSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSkillGroupResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSkillGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSummaryTemplateRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        template_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetSummaryTemplateResponseBodyDataPropertyList(TeaModel):
    def __init__(
        self,
        array: bool = None,
        attributes: str = None,
        created_time: int = None,
        creator: str = None,
        data_type: str = None,
        description: str = None,
        disabled: bool = None,
        display_name: str = None,
        display_order: int = None,
        editor_type: str = None,
        max_length: int = None,
        maximum: float = None,
        min_length: int = None,
        minimum: float = None,
        name: str = None,
        pattern: str = None,
        pattern_error_message: str = None,
        read_only: bool = None,
        required: bool = None,
        system: bool = None,
        updated_time: int = None,
    ):
        self.array = array
        self.attributes = attributes
        self.created_time = created_time
        self.creator = creator
        self.data_type = data_type
        self.description = description
        self.disabled = disabled
        self.display_name = display_name
        self.display_order = display_order
        self.editor_type = editor_type
        self.max_length = max_length
        self.maximum = maximum
        self.min_length = min_length
        self.minimum = minimum
        self.name = name
        self.pattern = pattern
        self.pattern_error_message = pattern_error_message
        self.read_only = read_only
        self.required = required
        self.system = system
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.array is not None:
            result['Array'] = self.array
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.description is not None:
            result['Description'] = self.description
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.display_order is not None:
            result['DisplayOrder'] = self.display_order
        if self.editor_type is not None:
            result['EditorType'] = self.editor_type
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.pattern_error_message is not None:
            result['PatternErrorMessage'] = self.pattern_error_message
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.required is not None:
            result['Required'] = self.required
        if self.system is not None:
            result['System'] = self.system
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Array') is not None:
            self.array = m.get('Array')
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('DisplayOrder') is not None:
            self.display_order = m.get('DisplayOrder')
        if m.get('EditorType') is not None:
            self.editor_type = m.get('EditorType')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('PatternErrorMessage') is not None:
            self.pattern_error_message = m.get('PatternErrorMessage')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('System') is not None:
            self.system = m.get('System')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class GetSummaryTemplateResponseBodyData(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        editor: str = None,
        instance_id: str = None,
        name: str = None,
        property_list: List[GetSummaryTemplateResponseBodyDataPropertyList] = None,
        state: str = None,
        template_id: str = None,
    ):
        self.category_id = category_id
        self.editor = editor
        self.instance_id = instance_id
        self.name = name
        self.property_list = property_list
        self.state = state
        self.template_id = template_id

    def validate(self):
        if self.property_list:
            for k in self.property_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.editor is not None:
            result['Editor'] = self.editor
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        result['PropertyList'] = []
        if self.property_list is not None:
            for k in self.property_list:
                result['PropertyList'].append(k.to_map() if k else None)
        if self.state is not None:
            result['State'] = self.state
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Editor') is not None:
            self.editor = m.get('Editor')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.property_list = []
        if m.get('PropertyList') is not None:
            for k in m.get('PropertyList'):
                temp_model = GetSummaryTemplateResponseBodyDataPropertyList()
                self.property_list.append(temp_model.from_map(k))
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetSummaryTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSummaryTemplateResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSummaryTemplateResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetSummaryTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSummaryTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSummaryTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTicketRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        ticket_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class GetTicketResponseBodyData(TeaModel):
    def __init__(
        self,
        assignee: str = None,
        assignee_name: str = None,
        category_id: str = None,
        category_name: str = None,
        close_code: str = None,
        comment: str = None,
        context: str = None,
        created_time: int = None,
        creator: str = None,
        creator_name: str = None,
        current_task_id: str = None,
        current_task_name: str = None,
        current_task_start_time: int = None,
        customer_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        job_id: str = None,
        source: str = None,
        start_time: int = None,
        state: str = None,
        template_id: str = None,
        template_version: str = None,
        ticket_id: str = None,
        title: str = None,
        updated_time: int = None,
    ):
        self.assignee = assignee
        self.assignee_name = assignee_name
        self.category_id = category_id
        self.category_name = category_name
        self.close_code = close_code
        self.comment = comment
        self.context = context
        self.created_time = created_time
        self.creator = creator
        self.creator_name = creator_name
        self.current_task_id = current_task_id
        self.current_task_name = current_task_name
        self.current_task_start_time = current_task_start_time
        self.customer_id = customer_id
        self.end_time = end_time
        self.instance_id = instance_id
        self.job_id = job_id
        self.source = source
        self.start_time = start_time
        self.state = state
        self.template_id = template_id
        self.template_version = template_version
        self.ticket_id = ticket_id
        self.title = title
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assignee is not None:
            result['Assignee'] = self.assignee
        if self.assignee_name is not None:
            result['AssigneeName'] = self.assignee_name
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.category_name is not None:
            result['CategoryName'] = self.category_name
        if self.close_code is not None:
            result['CloseCode'] = self.close_code
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.context is not None:
            result['Context'] = self.context
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.current_task_id is not None:
            result['CurrentTaskId'] = self.current_task_id
        if self.current_task_name is not None:
            result['CurrentTaskName'] = self.current_task_name
        if self.current_task_start_time is not None:
            result['CurrentTaskStartTime'] = self.current_task_start_time
        if self.customer_id is not None:
            result['CustomerId'] = self.customer_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_version is not None:
            result['TemplateVersion'] = self.template_version
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        if self.title is not None:
            result['Title'] = self.title
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assignee') is not None:
            self.assignee = m.get('Assignee')
        if m.get('AssigneeName') is not None:
            self.assignee_name = m.get('AssigneeName')
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('CategoryName') is not None:
            self.category_name = m.get('CategoryName')
        if m.get('CloseCode') is not None:
            self.close_code = m.get('CloseCode')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('CurrentTaskId') is not None:
            self.current_task_id = m.get('CurrentTaskId')
        if m.get('CurrentTaskName') is not None:
            self.current_task_name = m.get('CurrentTaskName')
        if m.get('CurrentTaskStartTime') is not None:
            self.current_task_start_time = m.get('CurrentTaskStartTime')
        if m.get('CustomerId') is not None:
            self.customer_id = m.get('CustomerId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateVersion') is not None:
            self.template_version = m.get('TemplateVersion')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class GetTicketResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetTicketResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetTicketResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTicketSummaryReportRequest(TeaModel):
    def __init__(
        self,
        assignee: str = None,
        assignee_type: str = None,
        category_id: str = None,
        creator: str = None,
        end_time: int = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        participant: str = None,
        start_time: int = None,
        state: str = None,
    ):
        self.assignee = assignee
        self.assignee_type = assignee_type
        self.category_id = category_id
        self.creator = creator
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.participant = participant
        self.start_time = start_time
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assignee is not None:
            result['Assignee'] = self.assignee
        if self.assignee_type is not None:
            result['AssigneeType'] = self.assignee_type
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.participant is not None:
            result['Participant'] = self.participant
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assignee') is not None:
            self.assignee = m.get('Assignee')
        if m.get('AssigneeType') is not None:
            self.assignee_type = m.get('AssigneeType')
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Participant') is not None:
            self.participant = m.get('Participant')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class GetTicketSummaryReportResponseBodyData(TeaModel):
    def __init__(
        self,
        tickets_assigned: str = None,
        tickets_created: str = None,
        tickets_participated: str = None,
    ):
        self.tickets_assigned = tickets_assigned
        self.tickets_created = tickets_created
        self.tickets_participated = tickets_participated

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tickets_assigned is not None:
            result['TicketsAssigned'] = self.tickets_assigned
        if self.tickets_created is not None:
            result['TicketsCreated'] = self.tickets_created
        if self.tickets_participated is not None:
            result['TicketsParticipated'] = self.tickets_participated
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TicketsAssigned') is not None:
            self.tickets_assigned = m.get('TicketsAssigned')
        if m.get('TicketsCreated') is not None:
            self.tickets_created = m.get('TicketsCreated')
        if m.get('TicketsParticipated') is not None:
            self.tickets_participated = m.get('TicketsParticipated')
        return self


class GetTicketSummaryReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetTicketSummaryReportResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetTicketSummaryReportResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTicketSummaryReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTicketSummaryReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTicketSummaryReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTicketTemplateRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        template_id: str = None,
        template_version: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.template_id = template_id
        self.template_version = template_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_version is not None:
            result['TemplateVersion'] = self.template_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateVersion') is not None:
            self.template_version = m.get('TemplateVersion')
        return self


class GetTicketTemplateResponseBodyDataTicketFields(TeaModel):
    def __init__(
        self,
        array: bool = None,
        attributes: str = None,
        created_time: int = None,
        creator: str = None,
        data_type: str = None,
        description: str = None,
        disabled: bool = None,
        display_name: str = None,
        display_order: int = None,
        editor_type: str = None,
        max_length: int = None,
        maximum: float = None,
        min_length: int = None,
        minimum: float = None,
        name: str = None,
        pattern: str = None,
        pattern_error_message: str = None,
        read_only: bool = None,
        required: bool = None,
        system: bool = None,
        updated_time: int = None,
    ):
        self.array = array
        self.attributes = attributes
        self.created_time = created_time
        self.creator = creator
        self.data_type = data_type
        self.description = description
        self.disabled = disabled
        self.display_name = display_name
        self.display_order = display_order
        self.editor_type = editor_type
        self.max_length = max_length
        self.maximum = maximum
        self.min_length = min_length
        self.minimum = minimum
        self.name = name
        self.pattern = pattern
        self.pattern_error_message = pattern_error_message
        self.read_only = read_only
        self.required = required
        self.system = system
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.array is not None:
            result['Array'] = self.array
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.description is not None:
            result['Description'] = self.description
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.display_order is not None:
            result['DisplayOrder'] = self.display_order
        if self.editor_type is not None:
            result['EditorType'] = self.editor_type
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.pattern_error_message is not None:
            result['PatternErrorMessage'] = self.pattern_error_message
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.required is not None:
            result['Required'] = self.required
        if self.system is not None:
            result['System'] = self.system
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Array') is not None:
            self.array = m.get('Array')
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('DisplayOrder') is not None:
            self.display_order = m.get('DisplayOrder')
        if m.get('EditorType') is not None:
            self.editor_type = m.get('EditorType')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('PatternErrorMessage') is not None:
            self.pattern_error_message = m.get('PatternErrorMessage')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('System') is not None:
            self.system = m.get('System')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class GetTicketTemplateResponseBodyData(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        editor: str = None,
        instance_id: str = None,
        name: str = None,
        process_definition: str = None,
        state: str = None,
        template_id: str = None,
        ticket_fields: List[GetTicketTemplateResponseBodyDataTicketFields] = None,
        updated_time: int = None,
    ):
        self.category_id = category_id
        self.editor = editor
        self.instance_id = instance_id
        self.name = name
        self.process_definition = process_definition
        self.state = state
        self.template_id = template_id
        self.ticket_fields = ticket_fields
        self.updated_time = updated_time

    def validate(self):
        if self.ticket_fields:
            for k in self.ticket_fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.editor is not None:
            result['Editor'] = self.editor
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.process_definition is not None:
            result['ProcessDefinition'] = self.process_definition
        if self.state is not None:
            result['State'] = self.state
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['TicketFields'] = []
        if self.ticket_fields is not None:
            for k in self.ticket_fields:
                result['TicketFields'].append(k.to_map() if k else None)
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Editor') is not None:
            self.editor = m.get('Editor')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProcessDefinition') is not None:
            self.process_definition = m.get('ProcessDefinition')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.ticket_fields = []
        if m.get('TicketFields') is not None:
            for k in m.get('TicketFields'):
                temp_model = GetTicketTemplateResponseBodyDataTicketFields()
                self.ticket_fields.append(temp_model.from_map(k))
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class GetTicketTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetTicketTemplateResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetTicketTemplateResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTicketTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTicketTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTicketTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTurnCredentialsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetTurnCredentialsResponseBodyData(TeaModel):
    def __init__(
        self,
        password: str = None,
        user_name: str = None,
    ):
        self.password = password
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.password is not None:
            result['Password'] = self.password
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class GetTurnCredentialsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetTurnCredentialsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetTurnCredentialsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTurnCredentialsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTurnCredentialsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTurnCredentialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTurnServerListRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetTurnServerListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTurnServerListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTurnServerListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTurnServerListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUploadAudioDataParamsRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetUploadAudioDataParamsResponseBodyData(TeaModel):
    def __init__(
        self,
        params_str: str = None,
    ):
        self.params_str = params_str

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.params_str is not None:
            result['ParamsStr'] = self.params_str
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ParamsStr') is not None:
            self.params_str = m.get('ParamsStr')
        return self


class GetUploadAudioDataParamsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetUploadAudioDataParamsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetUploadAudioDataParamsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetUploadAudioDataParamsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUploadAudioDataParamsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUploadAudioDataParamsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserRequest(TeaModel):
    def __init__(
        self,
        extension: str = None,
        instance_id: str = None,
        user_id: str = None,
    ):
        self.extension = extension
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetUserResponseBodyData(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        device_ext: str = None,
        device_id: str = None,
        device_state: str = None,
        display_id: str = None,
        display_name: str = None,
        email: str = None,
        extension: str = None,
        instance_id: str = None,
        login_name: str = None,
        mobile: str = None,
        nickname: str = None,
        role_id: str = None,
        role_name: str = None,
        user_id: str = None,
        work_mode: str = None,
    ):
        self.avatar_url = avatar_url
        self.device_ext = device_ext
        self.device_id = device_id
        self.device_state = device_state
        self.display_id = display_id
        self.display_name = display_name
        self.email = email
        self.extension = extension
        self.instance_id = instance_id
        self.login_name = login_name
        self.mobile = mobile
        self.nickname = nickname
        self.role_id = role_id
        self.role_name = role_name
        self.user_id = user_id
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.device_ext is not None:
            result['DeviceExt'] = self.device_ext
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.display_id is not None:
            result['DisplayId'] = self.display_id
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.email is not None:
            result['Email'] = self.email
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('DeviceExt') is not None:
            self.device_ext = m.get('DeviceExt')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('DisplayId') is not None:
            self.display_id = m.get('DisplayId')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class GetUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetUserResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetUserResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVideoRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetVideoResponseBodyData(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_url: str = None,
    ):
        self.file_name = file_name
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetVideoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetVideoResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetVideoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetVideoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVideoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVideoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVisitorLoginDetailsRequest(TeaModel):
    def __init__(
        self,
        chat_device_id: str = None,
        instance_id: str = None,
        token: str = None,
        visitor_id: str = None,
    ):
        # This parameter is required.
        self.chat_device_id = chat_device_id
        self.instance_id = instance_id
        self.token = token
        # This parameter is required.
        self.visitor_id = visitor_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_device_id is not None:
            result['ChatDeviceId'] = self.chat_device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.token is not None:
            result['Token'] = self.token
        if self.visitor_id is not None:
            result['VisitorId'] = self.visitor_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatDeviceId') is not None:
            self.chat_device_id = m.get('ChatDeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('VisitorId') is not None:
            self.visitor_id = m.get('VisitorId')
        return self


class GetVisitorLoginDetailsResponseBodyData(TeaModel):
    def __init__(
        self,
        chat_app_id: str = None,
        chat_app_key: str = None,
        chat_device_id: str = None,
        chat_login_token: str = None,
        chat_server_url: str = None,
        chat_user_id: str = None,
    ):
        self.chat_app_id = chat_app_id
        self.chat_app_key = chat_app_key
        self.chat_device_id = chat_device_id
        self.chat_login_token = chat_login_token
        self.chat_server_url = chat_server_url
        self.chat_user_id = chat_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_app_id is not None:
            result['ChatAppId'] = self.chat_app_id
        if self.chat_app_key is not None:
            result['ChatAppKey'] = self.chat_app_key
        if self.chat_device_id is not None:
            result['ChatDeviceId'] = self.chat_device_id
        if self.chat_login_token is not None:
            result['ChatLoginToken'] = self.chat_login_token
        if self.chat_server_url is not None:
            result['ChatServerUrl'] = self.chat_server_url
        if self.chat_user_id is not None:
            result['ChatUserId'] = self.chat_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatAppId') is not None:
            self.chat_app_id = m.get('ChatAppId')
        if m.get('ChatAppKey') is not None:
            self.chat_app_key = m.get('ChatAppKey')
        if m.get('ChatDeviceId') is not None:
            self.chat_device_id = m.get('ChatDeviceId')
        if m.get('ChatLoginToken') is not None:
            self.chat_login_token = m.get('ChatLoginToken')
        if m.get('ChatServerUrl') is not None:
            self.chat_server_url = m.get('ChatServerUrl')
        if m.get('ChatUserId') is not None:
            self.chat_user_id = m.get('ChatUserId')
        return self


class GetVisitorLoginDetailsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetVisitorLoginDetailsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetVisitorLoginDetailsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetVisitorLoginDetailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVisitorLoginDetailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVisitorLoginDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVoicemailRecordingRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetVoicemailRecordingResponseBodyData(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_url: str = None,
    ):
        self.file_name = file_name
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetVoicemailRecordingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetVoicemailRecordingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetVoicemailRecordingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetVoicemailRecordingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVoicemailRecordingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVoicemailRecordingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class HoldCallRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        music: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.channel_id = channel_id
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.music = music
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.music is not None:
            result['Music'] = self.music
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Music') is not None:
            self.music = m.get('Music')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class HoldCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class HoldCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[HoldCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = HoldCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class HoldCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class HoldCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: HoldCallResponseBodyDataCallContext = None,
        user_context: HoldCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = HoldCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = HoldCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class HoldCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: HoldCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = HoldCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class HoldCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: HoldCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = HoldCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportAdminsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        ram_id_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.ram_id_list = ram_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ram_id_list is not None:
            result['RamIdList'] = self.ram_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RamIdList') is not None:
            self.ram_id_list = m.get('RamIdList')
        return self


class ImportAdminsResponseBodyData(TeaModel):
    def __init__(
        self,
        extension: str = None,
        instance_id: str = None,
        ram_id: str = None,
        role_id: str = None,
        user_id: str = None,
    ):
        self.extension = extension
        self.instance_id = instance_id
        self.ram_id = ram_id
        self.role_id = role_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ram_id is not None:
            result['RamId'] = self.ram_id
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RamId') is not None:
            self.ram_id = m.get('RamId')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ImportAdminsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ImportAdminsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ImportAdminsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportAdminsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportAdminsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportAdminsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportContactFlowRequest(TeaModel):
    def __init__(
        self,
        flow_package_data: str = None,
        instance_id: str = None,
        request_id: str = None,
    ):
        # This parameter is required.
        self.flow_package_data = flow_package_data
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow_package_data is not None:
            result['FlowPackageData'] = self.flow_package_data
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlowPackageData') is not None:
            self.flow_package_data = m.get('FlowPackageData')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportCorpNumbersRequest(TeaModel):
    def __init__(
        self,
        city: str = None,
        corp_name: str = None,
        number_list: str = None,
        provider: str = None,
        province: str = None,
        tag_list: str = None,
    ):
        self.city = city
        self.corp_name = corp_name
        # This parameter is required.
        self.number_list = number_list
        # This parameter is required.
        self.provider = provider
        self.province = province
        self.tag_list = tag_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city is not None:
            result['City'] = self.city
        if self.corp_name is not None:
            result['CorpName'] = self.corp_name
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        if self.provider is not None:
            result['Provider'] = self.provider
        if self.province is not None:
            result['Province'] = self.province
        if self.tag_list is not None:
            result['TagList'] = self.tag_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('CorpName') is not None:
            self.corp_name = m.get('CorpName')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        if m.get('Provider') is not None:
            self.provider = m.get('Provider')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        if m.get('TagList') is not None:
            self.tag_list = m.get('TagList')
        return self


class ImportCorpNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportCorpNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportCorpNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportCorpNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportCustomCallTaggingRequest(TeaModel):
    def __init__(
        self,
        file_path: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.file_path = file_path
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ImportCustomCallTaggingResponseBodyData(TeaModel):
    def __init__(
        self,
        item: str = None,
        reason: str = None,
    ):
        self.item = item
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item is not None:
            result['Item'] = self.item
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Item') is not None:
            self.item = m.get('Item')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class ImportCustomCallTaggingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ImportCustomCallTaggingResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ImportCustomCallTaggingResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportCustomCallTaggingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportCustomCallTaggingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportCustomCallTaggingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportDoNotCallNumbersRequest(TeaModel):
    def __init__(
        self,
        file_path: str = None,
        instance_id: str = None,
        number_list: str = None,
        remark: str = None,
    ):
        self.file_path = file_path
        # This parameter is required.
        self.instance_id = instance_id
        self.number_list = number_list
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class ImportDoNotCallNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportDoNotCallNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportDoNotCallNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportDoNotCallNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportDocumentsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        oss_file_key: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.oss_file_key = oss_file_key
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.oss_file_key is not None:
            result['OssFileKey'] = self.oss_file_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OssFileKey') is not None:
            self.oss_file_key = m.get('OssFileKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class ImportDocumentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportDocumentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportDocumentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportDocumentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InitiateAttendedTransferRequest(TeaModel):
    def __init__(
        self,
        call_priority: int = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        queuing_overflow_threshold: int = None,
        queuing_timeout_seconds: int = None,
        routing_type: str = None,
        strategy_name: str = None,
        strategy_params: str = None,
        tags: str = None,
        timeout_seconds: int = None,
        transferee: str = None,
        transferee_type: str = None,
        transferor: str = None,
        user_id: str = None,
    ):
        self.call_priority = call_priority
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.queuing_overflow_threshold = queuing_overflow_threshold
        self.queuing_timeout_seconds = queuing_timeout_seconds
        self.routing_type = routing_type
        self.strategy_name = strategy_name
        self.strategy_params = strategy_params
        self.tags = tags
        self.timeout_seconds = timeout_seconds
        # This parameter is required.
        self.transferee = transferee
        self.transferee_type = transferee_type
        self.transferor = transferor
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_priority is not None:
            result['CallPriority'] = self.call_priority
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.queuing_overflow_threshold is not None:
            result['QueuingOverflowThreshold'] = self.queuing_overflow_threshold
        if self.queuing_timeout_seconds is not None:
            result['QueuingTimeoutSeconds'] = self.queuing_timeout_seconds
        if self.routing_type is not None:
            result['RoutingType'] = self.routing_type
        if self.strategy_name is not None:
            result['StrategyName'] = self.strategy_name
        if self.strategy_params is not None:
            result['StrategyParams'] = self.strategy_params
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.transferee is not None:
            result['Transferee'] = self.transferee
        if self.transferee_type is not None:
            result['TransfereeType'] = self.transferee_type
        if self.transferor is not None:
            result['Transferor'] = self.transferor
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallPriority') is not None:
            self.call_priority = m.get('CallPriority')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('QueuingOverflowThreshold') is not None:
            self.queuing_overflow_threshold = m.get('QueuingOverflowThreshold')
        if m.get('QueuingTimeoutSeconds') is not None:
            self.queuing_timeout_seconds = m.get('QueuingTimeoutSeconds')
        if m.get('RoutingType') is not None:
            self.routing_type = m.get('RoutingType')
        if m.get('StrategyName') is not None:
            self.strategy_name = m.get('StrategyName')
        if m.get('StrategyParams') is not None:
            self.strategy_params = m.get('StrategyParams')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('Transferee') is not None:
            self.transferee = m.get('Transferee')
        if m.get('TransfereeType') is not None:
            self.transferee_type = m.get('TransfereeType')
        if m.get('Transferor') is not None:
            self.transferor = m.get('Transferor')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class InitiateAttendedTransferResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class InitiateAttendedTransferResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[InitiateAttendedTransferResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = InitiateAttendedTransferResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class InitiateAttendedTransferResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class InitiateAttendedTransferResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: InitiateAttendedTransferResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: InitiateAttendedTransferResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = InitiateAttendedTransferResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = InitiateAttendedTransferResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class InitiateAttendedTransferResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: InitiateAttendedTransferResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InitiateAttendedTransferResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InitiateAttendedTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InitiateAttendedTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InitiateAttendedTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InterceptCallRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        intercepted_user_id: str = None,
        job_id: str = None,
        timeout_seconds: int = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.intercepted_user_id = intercepted_user_id
        # This parameter is required.
        self.job_id = job_id
        self.timeout_seconds = timeout_seconds
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.intercepted_user_id is not None:
            result['InterceptedUserId'] = self.intercepted_user_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InterceptedUserId') is not None:
            self.intercepted_user_id = m.get('InterceptedUserId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class InterceptCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class InterceptCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[InterceptCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = InterceptCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class InterceptCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class InterceptCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: InterceptCallResponseBodyDataCallContext = None,
        user_context: InterceptCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = InterceptCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = InterceptCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class InterceptCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: InterceptCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InterceptCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InterceptCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InterceptCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InterceptCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LaunchAuthenticationRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        contact_flow_variables: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        self.contact_flow_variables = contact_flow_variables
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.contact_flow_variables is not None:
            result['ContactFlowVariables'] = self.contact_flow_variables
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('ContactFlowVariables') is not None:
            self.contact_flow_variables = m.get('ContactFlowVariables')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class LaunchAuthenticationResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class LaunchAuthenticationResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[LaunchAuthenticationResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = LaunchAuthenticationResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class LaunchAuthenticationResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class LaunchAuthenticationResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: LaunchAuthenticationResponseBodyDataCallContext = None,
        user_context: LaunchAuthenticationResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = LaunchAuthenticationResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = LaunchAuthenticationResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class LaunchAuthenticationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: LaunchAuthenticationResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = LaunchAuthenticationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class LaunchAuthenticationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: LaunchAuthenticationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LaunchAuthenticationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LaunchSurveyRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        contact_flow_variables: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        sms_metadata_id: str = None,
        survey_channel: str = None,
        survey_template_id: str = None,
        survey_template_variables: str = None,
        user_id: str = None,
    ):
        self.contact_flow_id = contact_flow_id
        self.contact_flow_variables = contact_flow_variables
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.sms_metadata_id = sms_metadata_id
        self.survey_channel = survey_channel
        self.survey_template_id = survey_template_id
        self.survey_template_variables = survey_template_variables
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.contact_flow_variables is not None:
            result['ContactFlowVariables'] = self.contact_flow_variables
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.sms_metadata_id is not None:
            result['SmsMetadataId'] = self.sms_metadata_id
        if self.survey_channel is not None:
            result['SurveyChannel'] = self.survey_channel
        if self.survey_template_id is not None:
            result['SurveyTemplateId'] = self.survey_template_id
        if self.survey_template_variables is not None:
            result['SurveyTemplateVariables'] = self.survey_template_variables
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('ContactFlowVariables') is not None:
            self.contact_flow_variables = m.get('ContactFlowVariables')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('SmsMetadataId') is not None:
            self.sms_metadata_id = m.get('SmsMetadataId')
        if m.get('SurveyChannel') is not None:
            self.survey_channel = m.get('SurveyChannel')
        if m.get('SurveyTemplateId') is not None:
            self.survey_template_id = m.get('SurveyTemplateId')
        if m.get('SurveyTemplateVariables') is not None:
            self.survey_template_variables = m.get('SurveyTemplateVariables')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class LaunchSurveyResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class LaunchSurveyResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[LaunchSurveyResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = LaunchSurveyResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class LaunchSurveyResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class LaunchSurveyResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: LaunchSurveyResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: LaunchSurveyResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = LaunchSurveyResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = LaunchSurveyResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class LaunchSurveyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: LaunchSurveyResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = LaunchSurveyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class LaunchSurveyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: LaunchSurveyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LaunchSurveyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAgentStateLogsRequest(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        start_time: int = None,
    ):
        # This parameter is required.
        self.agent_id = agent_id
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListAgentStateLogsResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        duration: int = None,
        outbound_scenario: bool = None,
        start_time: int = None,
        state: str = None,
        state_code: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.duration = duration
        self.outbound_scenario = outbound_scenario
        self.start_time = start_time
        self.state = state
        self.state_code = state_code
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.state_code is not None:
            result['StateCode'] = self.state_code
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('StateCode') is not None:
            self.state_code = m.get('StateCode')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ListAgentStateLogsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAgentStateLogsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAgentStateLogsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAgentStateLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAgentStateLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAgentStateLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAgentStatesRequest(TeaModel):
    def __init__(
        self,
        agent_ids: str = None,
        exclude_offline_users: bool = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_id: str = None,
        state: str = None,
    ):
        self.agent_ids = agent_ids
        self.exclude_offline_users = exclude_offline_users
        # This parameter is required.
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.skill_group_id = skill_group_id
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_ids is not None:
            result['AgentIds'] = self.agent_ids
        if self.exclude_offline_users is not None:
            result['ExcludeOfflineUsers'] = self.exclude_offline_users
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentIds') is not None:
            self.agent_ids = m.get('AgentIds')
        if m.get('ExcludeOfflineUsers') is not None:
            self.exclude_offline_users = m.get('ExcludeOfflineUsers')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListAgentStatesResponseBodyDataList(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        agent_name: str = None,
        break_code: str = None,
        dn: str = None,
        instance_id: str = None,
        login_name: str = None,
        outbound_scenario: bool = None,
        state: str = None,
        state_duration: str = None,
    ):
        self.agent_id = agent_id
        self.agent_name = agent_name
        self.break_code = break_code
        self.dn = dn
        self.instance_id = instance_id
        self.login_name = login_name
        self.outbound_scenario = outbound_scenario
        self.state = state
        self.state_duration = state_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.dn is not None:
            result['Dn'] = self.dn
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.state is not None:
            result['State'] = self.state
        if self.state_duration is not None:
            result['StateDuration'] = self.state_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Dn') is not None:
            self.dn = m.get('Dn')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('StateDuration') is not None:
            self.state_duration = m.get('StateDuration')
        return self


class ListAgentStatesResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListAgentStatesResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListAgentStatesResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAgentStatesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListAgentStatesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListAgentStatesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAgentStatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAgentStatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAgentStatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAgentSummaryReportsSinceMidnightRequest(TeaModel):
    def __init__(
        self,
        agent_ids: str = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_id: str = None,
    ):
        self.agent_ids = agent_ids
        # This parameter is required.
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_ids is not None:
            result['AgentIds'] = self.agent_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentIds') is not None:
            self.agent_ids = m.get('AgentIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound(TeaModel):
    def __init__(
        self,
        average_ring_time: int = None,
        average_talk_time: int = None,
        average_work_time: int = None,
        calls_handled: int = None,
        calls_offered: int = None,
        handle_rate: float = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        service_level_20: float = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_handled = calls_handled
        self.calls_offered = calls_offered
        self.handle_rate = handle_rate
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.service_level_20 = service_level_20
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.service_level_20 is not None:
            result['ServiceLevel20'] = self.service_level_20
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('ServiceLevel20') is not None:
            self.service_level_20 = m.get('ServiceLevel20')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: int = None,
        average_talk_time: int = None,
        average_work_time: int = None,
        calls_answered: int = None,
        calls_dialed: int = None,
        max_dialing_time: int = None,
        max_talk_time: int = None,
        max_work_time: str = None,
        satisfaction_index: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_dialed = calls_dialed
        self.max_dialing_time = max_dialing_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall(TeaModel):
    def __init__(
        self,
        average_ready_time: int = None,
        average_talk_time: int = None,
        average_work_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        one_transfer_calls: int = None,
        satisfaction_index: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_logged_in_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.one_transfer_calls = one_transfer_calls
        self.satisfaction_index = satisfaction_index
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_logged_in_time = total_logged_in_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.one_transfer_calls is not None:
            result['OneTransferCalls'] = self.one_transfer_calls
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('OneTransferCalls') is not None:
            self.one_transfer_calls = m.get('OneTransferCalls')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        agent_name: str = None,
        inbound: ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound = None,
        instance_id: str = None,
        login_name: str = None,
        outbound: ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound = None,
        overall: ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall = None,
        skill_group_ids: str = None,
        skill_group_names: str = None,
        timestamp: str = None,
    ):
        self.agent_id = agent_id
        self.agent_name = agent_name
        self.inbound = inbound
        self.instance_id = instance_id
        self.login_name = login_name
        self.outbound = outbound
        self.overall = overall
        self.skill_group_ids = skill_group_ids
        self.skill_group_names = skill_group_names
        self.timestamp = timestamp

    def validate(self):
        if self.inbound:
            self.inbound.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.skill_group_ids is not None:
            result['SkillGroupIds'] = self.skill_group_ids
        if self.skill_group_names is not None:
            result['SkillGroupNames'] = self.skill_group_names
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        if m.get('Inbound') is not None:
            temp_model = ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Outbound') is not None:
            temp_model = ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('SkillGroupIds') is not None:
            self.skill_group_ids = m.get('SkillGroupIds')
        if m.get('SkillGroupNames') is not None:
            self.skill_group_names = m.get('SkillGroupNames')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport(TeaModel):
    def __init__(
        self,
        list: List[ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAgentSummaryReportsSinceMidnightResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        paged_agent_summary_report: ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.paged_agent_summary_report = paged_agent_summary_report
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paged_agent_summary_report:
            self.paged_agent_summary_report.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.paged_agent_summary_report is not None:
            result['PagedAgentSummaryReport'] = self.paged_agent_summary_report.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PagedAgentSummaryReport') is not None:
            temp_model = ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport()
            self.paged_agent_summary_report = temp_model.from_map(m['PagedAgentSummaryReport'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAgentSummaryReportsSinceMidnightResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAgentSummaryReportsSinceMidnightResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAgentSummaryReportsSinceMidnightResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAttemptsRequest(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        attempt_id: str = None,
        callee: str = None,
        caller: str = None,
        campaign_id: str = None,
        case_id: str = None,
        contact_id: str = None,
        criteria: str = None,
        end_time: int = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        queue_id: str = None,
        start_time: int = None,
    ):
        self.agent_id = agent_id
        self.attempt_id = attempt_id
        self.callee = callee
        self.caller = caller
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.case_id = case_id
        self.contact_id = contact_id
        self.criteria = criteria
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.queue_id = queue_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.attempt_id is not None:
            result['AttemptId'] = self.attempt_id
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.case_id is not None:
            result['CaseId'] = self.case_id
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AttemptId') is not None:
            self.attempt_id = m.get('AttemptId')
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('CaseId') is not None:
            self.case_id = m.get('CaseId')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListAttemptsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        agent_established_time: int = None,
        agent_id: str = None,
        agent_ring_duration: int = None,
        assign_agent_time: int = None,
        attempt_id: str = None,
        callee: str = None,
        caller: str = None,
        campaign_id: str = None,
        case_id: str = None,
        contact_id: str = None,
        customer_established_time: int = None,
        customer_released_time: int = None,
        dial_duration: int = None,
        dial_time: int = None,
        enqueue_time: int = None,
        enter_ivr_time: int = None,
        instance_id: str = None,
        ivr_duration: int = None,
        queue_duration: int = None,
        queue_id: str = None,
    ):
        self.agent_established_time = agent_established_time
        self.agent_id = agent_id
        self.agent_ring_duration = agent_ring_duration
        self.assign_agent_time = assign_agent_time
        self.attempt_id = attempt_id
        self.callee = callee
        self.caller = caller
        self.campaign_id = campaign_id
        self.case_id = case_id
        self.contact_id = contact_id
        self.customer_established_time = customer_established_time
        self.customer_released_time = customer_released_time
        self.dial_duration = dial_duration
        self.dial_time = dial_time
        self.enqueue_time = enqueue_time
        self.enter_ivr_time = enter_ivr_time
        self.instance_id = instance_id
        self.ivr_duration = ivr_duration
        self.queue_duration = queue_duration
        self.queue_id = queue_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_established_time is not None:
            result['AgentEstablishedTime'] = self.agent_established_time
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_ring_duration is not None:
            result['AgentRingDuration'] = self.agent_ring_duration
        if self.assign_agent_time is not None:
            result['AssignAgentTime'] = self.assign_agent_time
        if self.attempt_id is not None:
            result['AttemptId'] = self.attempt_id
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.case_id is not None:
            result['CaseId'] = self.case_id
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.customer_established_time is not None:
            result['CustomerEstablishedTime'] = self.customer_established_time
        if self.customer_released_time is not None:
            result['CustomerReleasedTime'] = self.customer_released_time
        if self.dial_duration is not None:
            result['DialDuration'] = self.dial_duration
        if self.dial_time is not None:
            result['DialTime'] = self.dial_time
        if self.enqueue_time is not None:
            result['EnqueueTime'] = self.enqueue_time
        if self.enter_ivr_time is not None:
            result['EnterIvrTime'] = self.enter_ivr_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ivr_duration is not None:
            result['IvrDuration'] = self.ivr_duration
        if self.queue_duration is not None:
            result['QueueDuration'] = self.queue_duration
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentEstablishedTime') is not None:
            self.agent_established_time = m.get('AgentEstablishedTime')
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentRingDuration') is not None:
            self.agent_ring_duration = m.get('AgentRingDuration')
        if m.get('AssignAgentTime') is not None:
            self.assign_agent_time = m.get('AssignAgentTime')
        if m.get('AttemptId') is not None:
            self.attempt_id = m.get('AttemptId')
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('CaseId') is not None:
            self.case_id = m.get('CaseId')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('CustomerEstablishedTime') is not None:
            self.customer_established_time = m.get('CustomerEstablishedTime')
        if m.get('CustomerReleasedTime') is not None:
            self.customer_released_time = m.get('CustomerReleasedTime')
        if m.get('DialDuration') is not None:
            self.dial_duration = m.get('DialDuration')
        if m.get('DialTime') is not None:
            self.dial_time = m.get('DialTime')
        if m.get('EnqueueTime') is not None:
            self.enqueue_time = m.get('EnqueueTime')
        if m.get('EnterIvrTime') is not None:
            self.enter_ivr_time = m.get('EnterIvrTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IvrDuration') is not None:
            self.ivr_duration = m.get('IvrDuration')
        if m.get('QueueDuration') is not None:
            self.queue_duration = m.get('QueueDuration')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        return self


class ListAttemptsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListAttemptsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListAttemptsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAttemptsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListAttemptsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListAttemptsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAttemptsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAttemptsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAttemptsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAudioFilesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        status: str = None,
        usage: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.status = status
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class ListAudioFilesResponseBodyDataList(TeaModel):
    def __init__(
        self,
        audio_file_name: str = None,
        audio_resource_id: str = None,
        audit_result: str = None,
        created_time: str = None,
        instance_id: str = None,
        name: str = None,
        oss_file_key: str = None,
        status: str = None,
        updated_time: str = None,
        usage: str = None,
    ):
        self.audio_file_name = audio_file_name
        self.audio_resource_id = audio_resource_id
        self.audit_result = audit_result
        self.created_time = created_time
        self.instance_id = instance_id
        self.name = name
        self.oss_file_key = oss_file_key
        self.status = status
        self.updated_time = updated_time
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_file_name is not None:
            result['AudioFileName'] = self.audio_file_name
        if self.audio_resource_id is not None:
            result['AudioResourceId'] = self.audio_resource_id
        if self.audit_result is not None:
            result['AuditResult'] = self.audit_result
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_file_key is not None:
            result['OssFileKey'] = self.oss_file_key
        if self.status is not None:
            result['Status'] = self.status
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFileName') is not None:
            self.audio_file_name = m.get('AudioFileName')
        if m.get('AudioResourceId') is not None:
            self.audio_resource_id = m.get('AudioResourceId')
        if m.get('AuditResult') is not None:
            self.audit_result = m.get('AuditResult')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssFileKey') is not None:
            self.oss_file_key = m.get('OssFileKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class ListAudioFilesResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListAudioFilesResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListAudioFilesResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAudioFilesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListAudioFilesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListAudioFilesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAudioFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAudioFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAudioFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListBlacklistCallTaggingsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number_list = number_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        return self


class ListBlacklistCallTaggingsResponseBodyData(TeaModel):
    def __init__(
        self,
        blacklisted: bool = None,
        job_id: str = None,
        number: str = None,
    ):
        self.blacklisted = blacklisted
        self.job_id = job_id
        self.number = number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.blacklisted is not None:
            result['Blacklisted'] = self.blacklisted
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.number is not None:
            result['Number'] = self.number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Blacklisted') is not None:
            self.blacklisted = m.get('Blacklisted')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        return self


class ListBlacklistCallTaggingsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListBlacklistCallTaggingsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListBlacklistCallTaggingsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListBlacklistCallTaggingsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListBlacklistCallTaggingsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListBlacklistCallTaggingsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListBriefSkillGroupsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        media_type: str = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        return self


class ListBriefSkillGroupsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        instance_id: str = None,
        media_type: str = None,
        phone_number_count: int = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
        user_count: int = None,
    ):
        self.description = description
        self.display_name = display_name
        self.instance_id = instance_id
        self.media_type = media_type
        self.phone_number_count = phone_number_count
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name
        self.user_count = user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.phone_number_count is not None:
            result['PhoneNumberCount'] = self.phone_number_count
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        if self.user_count is not None:
            result['UserCount'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('PhoneNumberCount') is not None:
            self.phone_number_count = m.get('PhoneNumberCount')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        if m.get('UserCount') is not None:
            self.user_count = m.get('UserCount')
        return self


class ListBriefSkillGroupsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListBriefSkillGroupsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListBriefSkillGroupsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListBriefSkillGroupsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListBriefSkillGroupsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListBriefSkillGroupsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListBriefSkillGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListBriefSkillGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListBriefSkillGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCallDetailRecordsRequest(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        called_number: str = None,
        calling_number: str = None,
        contact_disposition: str = None,
        contact_disposition_list: str = None,
        contact_id: str = None,
        contact_type: str = None,
        contact_type_list: str = None,
        criteria: str = None,
        early_media_state_list: str = None,
        end_time: int = None,
        instance_id: str = None,
        order_by_field: str = None,
        page_number: int = None,
        page_size: int = None,
        satisfaction_description_list: str = None,
        satisfaction_list: str = None,
        satisfaction_survey_channel: str = None,
        skill_group_id: str = None,
        sort_order: str = None,
        start_time: int = None,
    ):
        self.agent_id = agent_id
        self.called_number = called_number
        self.calling_number = calling_number
        self.contact_disposition = contact_disposition
        self.contact_disposition_list = contact_disposition_list
        self.contact_id = contact_id
        self.contact_type = contact_type
        self.contact_type_list = contact_type_list
        self.criteria = criteria
        self.early_media_state_list = early_media_state_list
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.order_by_field = order_by_field
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.satisfaction_description_list = satisfaction_description_list
        self.satisfaction_list = satisfaction_list
        self.satisfaction_survey_channel = satisfaction_survey_channel
        self.skill_group_id = skill_group_id
        self.sort_order = sort_order
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.calling_number is not None:
            result['CallingNumber'] = self.calling_number
        if self.contact_disposition is not None:
            result['ContactDisposition'] = self.contact_disposition
        if self.contact_disposition_list is not None:
            result['ContactDispositionList'] = self.contact_disposition_list
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_type is not None:
            result['ContactType'] = self.contact_type
        if self.contact_type_list is not None:
            result['ContactTypeList'] = self.contact_type_list
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.early_media_state_list is not None:
            result['EarlyMediaStateList'] = self.early_media_state_list
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_by_field is not None:
            result['OrderByField'] = self.order_by_field
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.satisfaction_description_list is not None:
            result['SatisfactionDescriptionList'] = self.satisfaction_description_list
        if self.satisfaction_list is not None:
            result['SatisfactionList'] = self.satisfaction_list
        if self.satisfaction_survey_channel is not None:
            result['SatisfactionSurveyChannel'] = self.satisfaction_survey_channel
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('CallingNumber') is not None:
            self.calling_number = m.get('CallingNumber')
        if m.get('ContactDisposition') is not None:
            self.contact_disposition = m.get('ContactDisposition')
        if m.get('ContactDispositionList') is not None:
            self.contact_disposition_list = m.get('ContactDispositionList')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactType') is not None:
            self.contact_type = m.get('ContactType')
        if m.get('ContactTypeList') is not None:
            self.contact_type_list = m.get('ContactTypeList')
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('EarlyMediaStateList') is not None:
            self.early_media_state_list = m.get('EarlyMediaStateList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderByField') is not None:
            self.order_by_field = m.get('OrderByField')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SatisfactionDescriptionList') is not None:
            self.satisfaction_description_list = m.get('SatisfactionDescriptionList')
        if m.get('SatisfactionList') is not None:
            self.satisfaction_list = m.get('SatisfactionList')
        if m.get('SatisfactionSurveyChannel') is not None:
            self.satisfaction_survey_channel = m.get('SatisfactionSurveyChannel')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListCallDetailRecordsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        additional_broker: str = None,
        agent_ids: str = None,
        agent_names: str = None,
        broker: str = None,
        call_duration: str = None,
        call_ids: str = None,
        called_number: str = None,
        callee_location: str = None,
        caller_location: str = None,
        calling_number: str = None,
        contact_disposition: str = None,
        contact_id: str = None,
        contact_type: str = None,
        dialing_time: int = None,
        early_media_state: str = None,
        established_time: int = None,
        held_time: int = None,
        instance_id: str = None,
        ivr_time: int = None,
        queue_time: int = None,
        recording_duration: int = None,
        recording_ready: bool = None,
        release_initiator: str = None,
        release_reason: str = None,
        release_time: int = None,
        ring_time: int = None,
        satisfaction_description: str = None,
        satisfaction_index: int = None,
        satisfaction_survey_channel: str = None,
        satisfaction_survey_offered: bool = None,
        skill_group_ids: str = None,
        skill_group_names: str = None,
        start_time: int = None,
        talk_time: int = None,
        wait_time: int = None,
    ):
        self.additional_broker = additional_broker
        self.agent_ids = agent_ids
        self.agent_names = agent_names
        self.broker = broker
        self.call_duration = call_duration
        self.call_ids = call_ids
        self.called_number = called_number
        self.callee_location = callee_location
        self.caller_location = caller_location
        self.calling_number = calling_number
        self.contact_disposition = contact_disposition
        self.contact_id = contact_id
        self.contact_type = contact_type
        self.dialing_time = dialing_time
        self.early_media_state = early_media_state
        self.established_time = established_time
        self.held_time = held_time
        self.instance_id = instance_id
        self.ivr_time = ivr_time
        self.queue_time = queue_time
        self.recording_duration = recording_duration
        self.recording_ready = recording_ready
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.release_time = release_time
        self.ring_time = ring_time
        self.satisfaction_description = satisfaction_description
        self.satisfaction_index = satisfaction_index
        self.satisfaction_survey_channel = satisfaction_survey_channel
        self.satisfaction_survey_offered = satisfaction_survey_offered
        self.skill_group_ids = skill_group_ids
        self.skill_group_names = skill_group_names
        self.start_time = start_time
        self.talk_time = talk_time
        self.wait_time = wait_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_broker is not None:
            result['AdditionalBroker'] = self.additional_broker
        if self.agent_ids is not None:
            result['AgentIds'] = self.agent_ids
        if self.agent_names is not None:
            result['AgentNames'] = self.agent_names
        if self.broker is not None:
            result['Broker'] = self.broker
        if self.call_duration is not None:
            result['CallDuration'] = self.call_duration
        if self.call_ids is not None:
            result['CallIds'] = self.call_ids
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.callee_location is not None:
            result['CalleeLocation'] = self.callee_location
        if self.caller_location is not None:
            result['CallerLocation'] = self.caller_location
        if self.calling_number is not None:
            result['CallingNumber'] = self.calling_number
        if self.contact_disposition is not None:
            result['ContactDisposition'] = self.contact_disposition
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_type is not None:
            result['ContactType'] = self.contact_type
        if self.dialing_time is not None:
            result['DialingTime'] = self.dialing_time
        if self.early_media_state is not None:
            result['EarlyMediaState'] = self.early_media_state
        if self.established_time is not None:
            result['EstablishedTime'] = self.established_time
        if self.held_time is not None:
            result['HeldTime'] = self.held_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ivr_time is not None:
            result['IvrTime'] = self.ivr_time
        if self.queue_time is not None:
            result['QueueTime'] = self.queue_time
        if self.recording_duration is not None:
            result['RecordingDuration'] = self.recording_duration
        if self.recording_ready is not None:
            result['RecordingReady'] = self.recording_ready
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.ring_time is not None:
            result['RingTime'] = self.ring_time
        if self.satisfaction_description is not None:
            result['SatisfactionDescription'] = self.satisfaction_description
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_survey_channel is not None:
            result['SatisfactionSurveyChannel'] = self.satisfaction_survey_channel
        if self.satisfaction_survey_offered is not None:
            result['SatisfactionSurveyOffered'] = self.satisfaction_survey_offered
        if self.skill_group_ids is not None:
            result['SkillGroupIds'] = self.skill_group_ids
        if self.skill_group_names is not None:
            result['SkillGroupNames'] = self.skill_group_names
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.talk_time is not None:
            result['TalkTime'] = self.talk_time
        if self.wait_time is not None:
            result['WaitTime'] = self.wait_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdditionalBroker') is not None:
            self.additional_broker = m.get('AdditionalBroker')
        if m.get('AgentIds') is not None:
            self.agent_ids = m.get('AgentIds')
        if m.get('AgentNames') is not None:
            self.agent_names = m.get('AgentNames')
        if m.get('Broker') is not None:
            self.broker = m.get('Broker')
        if m.get('CallDuration') is not None:
            self.call_duration = m.get('CallDuration')
        if m.get('CallIds') is not None:
            self.call_ids = m.get('CallIds')
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('CalleeLocation') is not None:
            self.callee_location = m.get('CalleeLocation')
        if m.get('CallerLocation') is not None:
            self.caller_location = m.get('CallerLocation')
        if m.get('CallingNumber') is not None:
            self.calling_number = m.get('CallingNumber')
        if m.get('ContactDisposition') is not None:
            self.contact_disposition = m.get('ContactDisposition')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactType') is not None:
            self.contact_type = m.get('ContactType')
        if m.get('DialingTime') is not None:
            self.dialing_time = m.get('DialingTime')
        if m.get('EarlyMediaState') is not None:
            self.early_media_state = m.get('EarlyMediaState')
        if m.get('EstablishedTime') is not None:
            self.established_time = m.get('EstablishedTime')
        if m.get('HeldTime') is not None:
            self.held_time = m.get('HeldTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IvrTime') is not None:
            self.ivr_time = m.get('IvrTime')
        if m.get('QueueTime') is not None:
            self.queue_time = m.get('QueueTime')
        if m.get('RecordingDuration') is not None:
            self.recording_duration = m.get('RecordingDuration')
        if m.get('RecordingReady') is not None:
            self.recording_ready = m.get('RecordingReady')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('RingTime') is not None:
            self.ring_time = m.get('RingTime')
        if m.get('SatisfactionDescription') is not None:
            self.satisfaction_description = m.get('SatisfactionDescription')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionSurveyChannel') is not None:
            self.satisfaction_survey_channel = m.get('SatisfactionSurveyChannel')
        if m.get('SatisfactionSurveyOffered') is not None:
            self.satisfaction_survey_offered = m.get('SatisfactionSurveyOffered')
        if m.get('SkillGroupIds') is not None:
            self.skill_group_ids = m.get('SkillGroupIds')
        if m.get('SkillGroupNames') is not None:
            self.skill_group_names = m.get('SkillGroupNames')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TalkTime') is not None:
            self.talk_time = m.get('TalkTime')
        if m.get('WaitTime') is not None:
            self.wait_time = m.get('WaitTime')
        return self


class ListCallDetailRecordsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListCallDetailRecordsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCallDetailRecordsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCallDetailRecordsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListCallDetailRecordsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListCallDetailRecordsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCallDetailRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCallDetailRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCallDetailRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCallDetailRecordsV2Request(TeaModel):
    def __init__(
        self,
        access_channel_type_list: str = None,
        agent_id: str = None,
        analytics_report_ready: bool = None,
        broker: str = None,
        called_number: str = None,
        calling_number: str = None,
        contact_disposition_list: str = None,
        contact_id_list: str = None,
        contact_type_list: str = None,
        early_media_state_list: str = None,
        end_time: int = None,
        first_agent_id: str = None,
        instance_id: str = None,
        media_type: str = None,
        number: str = None,
        order_by_field: str = None,
        page_number: int = None,
        page_size: int = None,
        release_initiator_list: str = None,
        release_reason_list: str = None,
        satisfaction_description_list: str = None,
        satisfaction_rate_list: str = None,
        satisfaction_survey_channel: str = None,
        search_pattern: str = None,
        skill_group_id_list: str = None,
        sort_order: str = None,
        start_time: int = None,
    ):
        self.access_channel_type_list = access_channel_type_list
        self.agent_id = agent_id
        self.analytics_report_ready = analytics_report_ready
        self.broker = broker
        self.called_number = called_number
        self.calling_number = calling_number
        self.contact_disposition_list = contact_disposition_list
        self.contact_id_list = contact_id_list
        self.contact_type_list = contact_type_list
        self.early_media_state_list = early_media_state_list
        self.end_time = end_time
        self.first_agent_id = first_agent_id
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        self.number = number
        self.order_by_field = order_by_field
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.release_initiator_list = release_initiator_list
        self.release_reason_list = release_reason_list
        self.satisfaction_description_list = satisfaction_description_list
        self.satisfaction_rate_list = satisfaction_rate_list
        self.satisfaction_survey_channel = satisfaction_survey_channel
        self.search_pattern = search_pattern
        self.skill_group_id_list = skill_group_id_list
        self.sort_order = sort_order
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_type_list is not None:
            result['AccessChannelTypeList'] = self.access_channel_type_list
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.analytics_report_ready is not None:
            result['AnalyticsReportReady'] = self.analytics_report_ready
        if self.broker is not None:
            result['Broker'] = self.broker
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.calling_number is not None:
            result['CallingNumber'] = self.calling_number
        if self.contact_disposition_list is not None:
            result['ContactDispositionList'] = self.contact_disposition_list
        if self.contact_id_list is not None:
            result['ContactIdList'] = self.contact_id_list
        if self.contact_type_list is not None:
            result['ContactTypeList'] = self.contact_type_list
        if self.early_media_state_list is not None:
            result['EarlyMediaStateList'] = self.early_media_state_list
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.first_agent_id is not None:
            result['FirstAgentId'] = self.first_agent_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.number is not None:
            result['Number'] = self.number
        if self.order_by_field is not None:
            result['OrderByField'] = self.order_by_field
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.release_initiator_list is not None:
            result['ReleaseInitiatorList'] = self.release_initiator_list
        if self.release_reason_list is not None:
            result['ReleaseReasonList'] = self.release_reason_list
        if self.satisfaction_description_list is not None:
            result['SatisfactionDescriptionList'] = self.satisfaction_description_list
        if self.satisfaction_rate_list is not None:
            result['SatisfactionRateList'] = self.satisfaction_rate_list
        if self.satisfaction_survey_channel is not None:
            result['SatisfactionSurveyChannel'] = self.satisfaction_survey_channel
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelTypeList') is not None:
            self.access_channel_type_list = m.get('AccessChannelTypeList')
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AnalyticsReportReady') is not None:
            self.analytics_report_ready = m.get('AnalyticsReportReady')
        if m.get('Broker') is not None:
            self.broker = m.get('Broker')
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('CallingNumber') is not None:
            self.calling_number = m.get('CallingNumber')
        if m.get('ContactDispositionList') is not None:
            self.contact_disposition_list = m.get('ContactDispositionList')
        if m.get('ContactIdList') is not None:
            self.contact_id_list = m.get('ContactIdList')
        if m.get('ContactTypeList') is not None:
            self.contact_type_list = m.get('ContactTypeList')
        if m.get('EarlyMediaStateList') is not None:
            self.early_media_state_list = m.get('EarlyMediaStateList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FirstAgentId') is not None:
            self.first_agent_id = m.get('FirstAgentId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('OrderByField') is not None:
            self.order_by_field = m.get('OrderByField')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReleaseInitiatorList') is not None:
            self.release_initiator_list = m.get('ReleaseInitiatorList')
        if m.get('ReleaseReasonList') is not None:
            self.release_reason_list = m.get('ReleaseReasonList')
        if m.get('SatisfactionDescriptionList') is not None:
            self.satisfaction_description_list = m.get('SatisfactionDescriptionList')
        if m.get('SatisfactionRateList') is not None:
            self.satisfaction_rate_list = m.get('SatisfactionRateList')
        if m.get('SatisfactionSurveyChannel') is not None:
            self.satisfaction_survey_channel = m.get('SatisfactionSurveyChannel')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportEmotion(TeaModel):
    def __init__(
        self,
        confidence: int = None,
        remark: str = None,
        success: bool = None,
        task_id: str = None,
        type: str = None,
    ):
        self.confidence = confidence
        self.remark = remark
        self.success = success
        self.task_id = task_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.confidence is not None:
            result['Confidence'] = self.confidence
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Confidence') is not None:
            self.confidence = m.get('Confidence')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportProblemSolving(TeaModel):
    def __init__(
        self,
        problem: str = None,
        solution: str = None,
        solved: bool = None,
        success: bool = None,
        task_id: str = None,
    ):
        self.problem = problem
        self.solution = solution
        self.solved = solved
        self.success = success
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.problem is not None:
            result['Problem'] = self.problem
        if self.solution is not None:
            result['Solution'] = self.solution
        if self.solved is not None:
            result['Solved'] = self.solved
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Problem') is not None:
            self.problem = m.get('Problem')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        if m.get('Solved') is not None:
            self.solved = m.get('Solved')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportSatisfaction(TeaModel):
    def __init__(
        self,
        remark: str = None,
        satisfaction_description: str = None,
        success: bool = None,
        task_id: str = None,
    ):
        self.remark = remark
        self.satisfaction_description = satisfaction_description
        self.success = success
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.satisfaction_description is not None:
            result['SatisfactionDescription'] = self.satisfaction_description
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SatisfactionDescription') is not None:
            self.satisfaction_description = m.get('SatisfactionDescription')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportTodoList(TeaModel):
    def __init__(
        self,
        success: bool = None,
        task_id: str = None,
        tasks: List[str] = None,
    ):
        self.success = success
        self.task_id = task_id
        self.tasks = tasks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.tasks is not None:
            result['Tasks'] = self.tasks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Tasks') is not None:
            self.tasks = m.get('Tasks')
        return self


class ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReport(TeaModel):
    def __init__(
        self,
        emotion: ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportEmotion = None,
        problem_solving: ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportProblemSolving = None,
        satisfaction: ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportSatisfaction = None,
        todo_list: ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportTodoList = None,
    ):
        self.emotion = emotion
        self.problem_solving = problem_solving
        self.satisfaction = satisfaction
        self.todo_list = todo_list

    def validate(self):
        if self.emotion:
            self.emotion.validate()
        if self.problem_solving:
            self.problem_solving.validate()
        if self.satisfaction:
            self.satisfaction.validate()
        if self.todo_list:
            self.todo_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.emotion is not None:
            result['Emotion'] = self.emotion.to_map()
        if self.problem_solving is not None:
            result['ProblemSolving'] = self.problem_solving.to_map()
        if self.satisfaction is not None:
            result['Satisfaction'] = self.satisfaction.to_map()
        if self.todo_list is not None:
            result['TodoList'] = self.todo_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Emotion') is not None:
            temp_model = ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportEmotion()
            self.emotion = temp_model.from_map(m['Emotion'])
        if m.get('ProblemSolving') is not None:
            temp_model = ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportProblemSolving()
            self.problem_solving = temp_model.from_map(m['ProblemSolving'])
        if m.get('Satisfaction') is not None:
            temp_model = ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportSatisfaction()
            self.satisfaction = temp_model.from_map(m['Satisfaction'])
        if m.get('TodoList') is not None:
            temp_model = ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReportTodoList()
            self.todo_list = temp_model.from_map(m['TodoList'])
        return self


class ListCallDetailRecordsV2ResponseBodyDataListSummaryIndex(TeaModel):
    def __init__(
        self,
        keywords: str = None,
    ):
        self.keywords = keywords

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        return self


class ListCallDetailRecordsV2ResponseBodyDataList(TeaModel):
    def __init__(
        self,
        access_channel_name: str = None,
        access_channel_type: str = None,
        access_channel_user_id: str = None,
        access_channel_user_name: str = None,
        additional_broker: str = None,
        agent_ids: str = None,
        agent_names: str = None,
        analytics_report: ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReport = None,
        analytics_report_ready: bool = None,
        broker: str = None,
        call_duration: str = None,
        call_ids: str = None,
        called_number: str = None,
        callee_location: str = None,
        caller_location: str = None,
        calling_number: str = None,
        client_app_name: str = None,
        client_ip_address: str = None,
        client_location: str = None,
        client_user_agent: str = None,
        contact_disposition: str = None,
        contact_id: str = None,
        contact_type: str = None,
        dialing_time: int = None,
        early_media_state: str = None,
        early_media_text: str = None,
        established_time: int = None,
        first_response_time: int = None,
        held_time: int = None,
        instance_id: str = None,
        ivr_time: int = None,
        media_type: str = None,
        messages_sent: int = None,
        messages_sent_by_agent: int = None,
        messages_sent_by_customer: int = None,
        off_site_agent_ids: str = None,
        offsite_agent_destination_numbers: str = None,
        offsite_agent_originator_numbers: str = None,
        offsite_agent_release_reason: str = None,
        outside_number_release_reason: str = None,
        queue_time: int = None,
        recording_duration: int = None,
        recording_ready: bool = None,
        release_initiator: str = None,
        release_reason: str = None,
        release_time: int = None,
        ring_time: int = None,
        satisfaction_description: str = None,
        satisfaction_index: int = None,
        satisfaction_survey_channel: str = None,
        satisfaction_survey_offered: bool = None,
        skill_group_ids: str = None,
        skill_group_names: str = None,
        start_time: int = None,
        summary_index: ListCallDetailRecordsV2ResponseBodyDataListSummaryIndex = None,
        talk_time: int = None,
        transfer_count: int = None,
        voicebot_destination_number: str = None,
        voicebot_originator_number: str = None,
        wait_time: int = None,
    ):
        self.access_channel_name = access_channel_name
        self.access_channel_type = access_channel_type
        self.access_channel_user_id = access_channel_user_id
        self.access_channel_user_name = access_channel_user_name
        self.additional_broker = additional_broker
        self.agent_ids = agent_ids
        self.agent_names = agent_names
        self.analytics_report = analytics_report
        self.analytics_report_ready = analytics_report_ready
        self.broker = broker
        self.call_duration = call_duration
        self.call_ids = call_ids
        self.called_number = called_number
        self.callee_location = callee_location
        self.caller_location = caller_location
        self.calling_number = calling_number
        self.client_app_name = client_app_name
        self.client_ip_address = client_ip_address
        self.client_location = client_location
        self.client_user_agent = client_user_agent
        self.contact_disposition = contact_disposition
        self.contact_id = contact_id
        self.contact_type = contact_type
        self.dialing_time = dialing_time
        self.early_media_state = early_media_state
        self.early_media_text = early_media_text
        self.established_time = established_time
        self.first_response_time = first_response_time
        self.held_time = held_time
        self.instance_id = instance_id
        self.ivr_time = ivr_time
        self.media_type = media_type
        self.messages_sent = messages_sent
        self.messages_sent_by_agent = messages_sent_by_agent
        self.messages_sent_by_customer = messages_sent_by_customer
        self.off_site_agent_ids = off_site_agent_ids
        self.offsite_agent_destination_numbers = offsite_agent_destination_numbers
        self.offsite_agent_originator_numbers = offsite_agent_originator_numbers
        self.offsite_agent_release_reason = offsite_agent_release_reason
        self.outside_number_release_reason = outside_number_release_reason
        self.queue_time = queue_time
        self.recording_duration = recording_duration
        self.recording_ready = recording_ready
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.release_time = release_time
        self.ring_time = ring_time
        self.satisfaction_description = satisfaction_description
        self.satisfaction_index = satisfaction_index
        self.satisfaction_survey_channel = satisfaction_survey_channel
        self.satisfaction_survey_offered = satisfaction_survey_offered
        self.skill_group_ids = skill_group_ids
        self.skill_group_names = skill_group_names
        self.start_time = start_time
        self.summary_index = summary_index
        self.talk_time = talk_time
        self.transfer_count = transfer_count
        self.voicebot_destination_number = voicebot_destination_number
        self.voicebot_originator_number = voicebot_originator_number
        self.wait_time = wait_time

    def validate(self):
        if self.analytics_report:
            self.analytics_report.validate()
        if self.summary_index:
            self.summary_index.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_name is not None:
            result['AccessChannelName'] = self.access_channel_name
        if self.access_channel_type is not None:
            result['AccessChannelType'] = self.access_channel_type
        if self.access_channel_user_id is not None:
            result['AccessChannelUserId'] = self.access_channel_user_id
        if self.access_channel_user_name is not None:
            result['AccessChannelUserName'] = self.access_channel_user_name
        if self.additional_broker is not None:
            result['AdditionalBroker'] = self.additional_broker
        if self.agent_ids is not None:
            result['AgentIds'] = self.agent_ids
        if self.agent_names is not None:
            result['AgentNames'] = self.agent_names
        if self.analytics_report is not None:
            result['AnalyticsReport'] = self.analytics_report.to_map()
        if self.analytics_report_ready is not None:
            result['AnalyticsReportReady'] = self.analytics_report_ready
        if self.broker is not None:
            result['Broker'] = self.broker
        if self.call_duration is not None:
            result['CallDuration'] = self.call_duration
        if self.call_ids is not None:
            result['CallIds'] = self.call_ids
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.callee_location is not None:
            result['CalleeLocation'] = self.callee_location
        if self.caller_location is not None:
            result['CallerLocation'] = self.caller_location
        if self.calling_number is not None:
            result['CallingNumber'] = self.calling_number
        if self.client_app_name is not None:
            result['ClientAppName'] = self.client_app_name
        if self.client_ip_address is not None:
            result['ClientIpAddress'] = self.client_ip_address
        if self.client_location is not None:
            result['ClientLocation'] = self.client_location
        if self.client_user_agent is not None:
            result['ClientUserAgent'] = self.client_user_agent
        if self.contact_disposition is not None:
            result['ContactDisposition'] = self.contact_disposition
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_type is not None:
            result['ContactType'] = self.contact_type
        if self.dialing_time is not None:
            result['DialingTime'] = self.dialing_time
        if self.early_media_state is not None:
            result['EarlyMediaState'] = self.early_media_state
        if self.early_media_text is not None:
            result['EarlyMediaText'] = self.early_media_text
        if self.established_time is not None:
            result['EstablishedTime'] = self.established_time
        if self.first_response_time is not None:
            result['FirstResponseTime'] = self.first_response_time
        if self.held_time is not None:
            result['HeldTime'] = self.held_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ivr_time is not None:
            result['IvrTime'] = self.ivr_time
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.messages_sent is not None:
            result['MessagesSent'] = self.messages_sent
        if self.messages_sent_by_agent is not None:
            result['MessagesSentByAgent'] = self.messages_sent_by_agent
        if self.messages_sent_by_customer is not None:
            result['MessagesSentByCustomer'] = self.messages_sent_by_customer
        if self.off_site_agent_ids is not None:
            result['OffSiteAgentIds'] = self.off_site_agent_ids
        if self.offsite_agent_destination_numbers is not None:
            result['OffsiteAgentDestinationNumbers'] = self.offsite_agent_destination_numbers
        if self.offsite_agent_originator_numbers is not None:
            result['OffsiteAgentOriginatorNumbers'] = self.offsite_agent_originator_numbers
        if self.offsite_agent_release_reason is not None:
            result['OffsiteAgentReleaseReason'] = self.offsite_agent_release_reason
        if self.outside_number_release_reason is not None:
            result['OutsideNumberReleaseReason'] = self.outside_number_release_reason
        if self.queue_time is not None:
            result['QueueTime'] = self.queue_time
        if self.recording_duration is not None:
            result['RecordingDuration'] = self.recording_duration
        if self.recording_ready is not None:
            result['RecordingReady'] = self.recording_ready
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.ring_time is not None:
            result['RingTime'] = self.ring_time
        if self.satisfaction_description is not None:
            result['SatisfactionDescription'] = self.satisfaction_description
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_survey_channel is not None:
            result['SatisfactionSurveyChannel'] = self.satisfaction_survey_channel
        if self.satisfaction_survey_offered is not None:
            result['SatisfactionSurveyOffered'] = self.satisfaction_survey_offered
        if self.skill_group_ids is not None:
            result['SkillGroupIds'] = self.skill_group_ids
        if self.skill_group_names is not None:
            result['SkillGroupNames'] = self.skill_group_names
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.summary_index is not None:
            result['SummaryIndex'] = self.summary_index.to_map()
        if self.talk_time is not None:
            result['TalkTime'] = self.talk_time
        if self.transfer_count is not None:
            result['TransferCount'] = self.transfer_count
        if self.voicebot_destination_number is not None:
            result['VoicebotDestinationNumber'] = self.voicebot_destination_number
        if self.voicebot_originator_number is not None:
            result['VoicebotOriginatorNumber'] = self.voicebot_originator_number
        if self.wait_time is not None:
            result['WaitTime'] = self.wait_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelName') is not None:
            self.access_channel_name = m.get('AccessChannelName')
        if m.get('AccessChannelType') is not None:
            self.access_channel_type = m.get('AccessChannelType')
        if m.get('AccessChannelUserId') is not None:
            self.access_channel_user_id = m.get('AccessChannelUserId')
        if m.get('AccessChannelUserName') is not None:
            self.access_channel_user_name = m.get('AccessChannelUserName')
        if m.get('AdditionalBroker') is not None:
            self.additional_broker = m.get('AdditionalBroker')
        if m.get('AgentIds') is not None:
            self.agent_ids = m.get('AgentIds')
        if m.get('AgentNames') is not None:
            self.agent_names = m.get('AgentNames')
        if m.get('AnalyticsReport') is not None:
            temp_model = ListCallDetailRecordsV2ResponseBodyDataListAnalyticsReport()
            self.analytics_report = temp_model.from_map(m['AnalyticsReport'])
        if m.get('AnalyticsReportReady') is not None:
            self.analytics_report_ready = m.get('AnalyticsReportReady')
        if m.get('Broker') is not None:
            self.broker = m.get('Broker')
        if m.get('CallDuration') is not None:
            self.call_duration = m.get('CallDuration')
        if m.get('CallIds') is not None:
            self.call_ids = m.get('CallIds')
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('CalleeLocation') is not None:
            self.callee_location = m.get('CalleeLocation')
        if m.get('CallerLocation') is not None:
            self.caller_location = m.get('CallerLocation')
        if m.get('CallingNumber') is not None:
            self.calling_number = m.get('CallingNumber')
        if m.get('ClientAppName') is not None:
            self.client_app_name = m.get('ClientAppName')
        if m.get('ClientIpAddress') is not None:
            self.client_ip_address = m.get('ClientIpAddress')
        if m.get('ClientLocation') is not None:
            self.client_location = m.get('ClientLocation')
        if m.get('ClientUserAgent') is not None:
            self.client_user_agent = m.get('ClientUserAgent')
        if m.get('ContactDisposition') is not None:
            self.contact_disposition = m.get('ContactDisposition')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactType') is not None:
            self.contact_type = m.get('ContactType')
        if m.get('DialingTime') is not None:
            self.dialing_time = m.get('DialingTime')
        if m.get('EarlyMediaState') is not None:
            self.early_media_state = m.get('EarlyMediaState')
        if m.get('EarlyMediaText') is not None:
            self.early_media_text = m.get('EarlyMediaText')
        if m.get('EstablishedTime') is not None:
            self.established_time = m.get('EstablishedTime')
        if m.get('FirstResponseTime') is not None:
            self.first_response_time = m.get('FirstResponseTime')
        if m.get('HeldTime') is not None:
            self.held_time = m.get('HeldTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IvrTime') is not None:
            self.ivr_time = m.get('IvrTime')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('MessagesSent') is not None:
            self.messages_sent = m.get('MessagesSent')
        if m.get('MessagesSentByAgent') is not None:
            self.messages_sent_by_agent = m.get('MessagesSentByAgent')
        if m.get('MessagesSentByCustomer') is not None:
            self.messages_sent_by_customer = m.get('MessagesSentByCustomer')
        if m.get('OffSiteAgentIds') is not None:
            self.off_site_agent_ids = m.get('OffSiteAgentIds')
        if m.get('OffsiteAgentDestinationNumbers') is not None:
            self.offsite_agent_destination_numbers = m.get('OffsiteAgentDestinationNumbers')
        if m.get('OffsiteAgentOriginatorNumbers') is not None:
            self.offsite_agent_originator_numbers = m.get('OffsiteAgentOriginatorNumbers')
        if m.get('OffsiteAgentReleaseReason') is not None:
            self.offsite_agent_release_reason = m.get('OffsiteAgentReleaseReason')
        if m.get('OutsideNumberReleaseReason') is not None:
            self.outside_number_release_reason = m.get('OutsideNumberReleaseReason')
        if m.get('QueueTime') is not None:
            self.queue_time = m.get('QueueTime')
        if m.get('RecordingDuration') is not None:
            self.recording_duration = m.get('RecordingDuration')
        if m.get('RecordingReady') is not None:
            self.recording_ready = m.get('RecordingReady')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('RingTime') is not None:
            self.ring_time = m.get('RingTime')
        if m.get('SatisfactionDescription') is not None:
            self.satisfaction_description = m.get('SatisfactionDescription')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionSurveyChannel') is not None:
            self.satisfaction_survey_channel = m.get('SatisfactionSurveyChannel')
        if m.get('SatisfactionSurveyOffered') is not None:
            self.satisfaction_survey_offered = m.get('SatisfactionSurveyOffered')
        if m.get('SkillGroupIds') is not None:
            self.skill_group_ids = m.get('SkillGroupIds')
        if m.get('SkillGroupNames') is not None:
            self.skill_group_names = m.get('SkillGroupNames')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SummaryIndex') is not None:
            temp_model = ListCallDetailRecordsV2ResponseBodyDataListSummaryIndex()
            self.summary_index = temp_model.from_map(m['SummaryIndex'])
        if m.get('TalkTime') is not None:
            self.talk_time = m.get('TalkTime')
        if m.get('TransferCount') is not None:
            self.transfer_count = m.get('TransferCount')
        if m.get('VoicebotDestinationNumber') is not None:
            self.voicebot_destination_number = m.get('VoicebotDestinationNumber')
        if m.get('VoicebotOriginatorNumber') is not None:
            self.voicebot_originator_number = m.get('VoicebotOriginatorNumber')
        if m.get('WaitTime') is not None:
            self.wait_time = m.get('WaitTime')
        return self


class ListCallDetailRecordsV2ResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListCallDetailRecordsV2ResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCallDetailRecordsV2ResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCallDetailRecordsV2ResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListCallDetailRecordsV2ResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListCallDetailRecordsV2ResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCallDetailRecordsV2Response(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCallDetailRecordsV2ResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCallDetailRecordsV2ResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCallSummariesRequest(TeaModel):
    def __init__(
        self,
        contact_id_list: List[str] = None,
        instance_id: str = None,
    ):
        self.contact_id_list = contact_id_list
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id_list is not None:
            result['ContactIdList'] = self.contact_id_list
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactIdList') is not None:
            self.contact_id_list = m.get('ContactIdList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ListCallSummariesShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_id_list_shrink: str = None,
        instance_id: str = None,
    ):
        self.contact_id_list_shrink = contact_id_list_shrink
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id_list_shrink is not None:
            result['ContactIdList'] = self.contact_id_list_shrink
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactIdList') is not None:
            self.contact_id_list_shrink = m.get('ContactIdList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ListCallSummariesResponseBodyData(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        context: str = None,
        created_time: int = None,
        creator: str = None,
        editor: str = None,
        ticket_id: str = None,
    ):
        self.contact_id = contact_id
        self.context = context
        self.created_time = created_time
        self.creator = creator
        self.editor = editor
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.context is not None:
            result['Context'] = self.context
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.editor is not None:
            result['Editor'] = self.editor
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Editor') is not None:
            self.editor = m.get('Editor')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class ListCallSummariesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListCallSummariesResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListCallSummariesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCallSummariesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCallSummariesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCallSummariesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCallTagsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListCallTagsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        tag_name: str = None,
    ):
        self.instance_id = instance_id
        self.tag_name = tag_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        return self


class ListCallTagsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListCallTagsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCallTagsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCallTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListCallTagsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListCallTagsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCallTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCallTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCallTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCampaignTrendingReportRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        start_time: int = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListCampaignTrendingReportResponseBodyData(TeaModel):
    def __init__(
        self,
        break_agents: int = None,
        breaking_agents: int = None,
        concurrency: int = None,
        datetime: int = None,
        logged_in_agents: int = None,
        outbound_scenario_breaking_agents: int = None,
        outbound_scenario_ready_agents: int = None,
        outbound_scenario_talking_agents: int = None,
        outbound_scenario_working_agents: int = None,
        ready_agents: int = None,
        stats_time: int = None,
        talk_agents: int = None,
        talking_agents: int = None,
        work_agents: int = None,
        working_agents: int = None,
    ):
        self.break_agents = break_agents
        self.breaking_agents = breaking_agents
        self.concurrency = concurrency
        self.datetime = datetime
        self.logged_in_agents = logged_in_agents
        self.outbound_scenario_breaking_agents = outbound_scenario_breaking_agents
        self.outbound_scenario_ready_agents = outbound_scenario_ready_agents
        self.outbound_scenario_talking_agents = outbound_scenario_talking_agents
        self.outbound_scenario_working_agents = outbound_scenario_working_agents
        self.ready_agents = ready_agents
        self.stats_time = stats_time
        self.talk_agents = talk_agents
        self.talking_agents = talking_agents
        self.work_agents = work_agents
        self.working_agents = working_agents

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_agents is not None:
            result['BreakAgents'] = self.break_agents
        if self.breaking_agents is not None:
            result['BreakingAgents'] = self.breaking_agents
        if self.concurrency is not None:
            result['Concurrency'] = self.concurrency
        if self.datetime is not None:
            result['Datetime'] = self.datetime
        if self.logged_in_agents is not None:
            result['LoggedInAgents'] = self.logged_in_agents
        if self.outbound_scenario_breaking_agents is not None:
            result['OutboundScenarioBreakingAgents'] = self.outbound_scenario_breaking_agents
        if self.outbound_scenario_ready_agents is not None:
            result['OutboundScenarioReadyAgents'] = self.outbound_scenario_ready_agents
        if self.outbound_scenario_talking_agents is not None:
            result['OutboundScenarioTalkingAgents'] = self.outbound_scenario_talking_agents
        if self.outbound_scenario_working_agents is not None:
            result['OutboundScenarioWorkingAgents'] = self.outbound_scenario_working_agents
        if self.ready_agents is not None:
            result['ReadyAgents'] = self.ready_agents
        if self.stats_time is not None:
            result['StatsTime'] = self.stats_time
        if self.talk_agents is not None:
            result['TalkAgents'] = self.talk_agents
        if self.talking_agents is not None:
            result['TalkingAgents'] = self.talking_agents
        if self.work_agents is not None:
            result['WorkAgents'] = self.work_agents
        if self.working_agents is not None:
            result['WorkingAgents'] = self.working_agents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakAgents') is not None:
            self.break_agents = m.get('BreakAgents')
        if m.get('BreakingAgents') is not None:
            self.breaking_agents = m.get('BreakingAgents')
        if m.get('Concurrency') is not None:
            self.concurrency = m.get('Concurrency')
        if m.get('Datetime') is not None:
            self.datetime = m.get('Datetime')
        if m.get('LoggedInAgents') is not None:
            self.logged_in_agents = m.get('LoggedInAgents')
        if m.get('OutboundScenarioBreakingAgents') is not None:
            self.outbound_scenario_breaking_agents = m.get('OutboundScenarioBreakingAgents')
        if m.get('OutboundScenarioReadyAgents') is not None:
            self.outbound_scenario_ready_agents = m.get('OutboundScenarioReadyAgents')
        if m.get('OutboundScenarioTalkingAgents') is not None:
            self.outbound_scenario_talking_agents = m.get('OutboundScenarioTalkingAgents')
        if m.get('OutboundScenarioWorkingAgents') is not None:
            self.outbound_scenario_working_agents = m.get('OutboundScenarioWorkingAgents')
        if m.get('ReadyAgents') is not None:
            self.ready_agents = m.get('ReadyAgents')
        if m.get('StatsTime') is not None:
            self.stats_time = m.get('StatsTime')
        if m.get('TalkAgents') is not None:
            self.talk_agents = m.get('TalkAgents')
        if m.get('TalkingAgents') is not None:
            self.talking_agents = m.get('TalkingAgents')
        if m.get('WorkAgents') is not None:
            self.work_agents = m.get('WorkAgents')
        if m.get('WorkingAgents') is not None:
            self.working_agents = m.get('WorkingAgents')
        return self


class ListCampaignTrendingReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListCampaignTrendingReportResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListCampaignTrendingReportResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCampaignTrendingReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCampaignTrendingReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCampaignTrendingReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCampaignsRequest(TeaModel):
    def __init__(
        self,
        actual_start_time_from: str = None,
        actual_start_time_to: str = None,
        instance_id: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        planed_start_time_from: str = None,
        planed_start_time_to: str = None,
        queue_id: str = None,
        state: str = None,
    ):
        self.actual_start_time_from = actual_start_time_from
        self.actual_start_time_to = actual_start_time_to
        # This parameter is required.
        self.instance_id = instance_id
        self.name = name
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.planed_start_time_from = planed_start_time_from
        self.planed_start_time_to = planed_start_time_to
        self.queue_id = queue_id
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_start_time_from is not None:
            result['ActualStartTimeFrom'] = self.actual_start_time_from
        if self.actual_start_time_to is not None:
            result['ActualStartTimeTo'] = self.actual_start_time_to
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.planed_start_time_from is not None:
            result['PlanedStartTimeFrom'] = self.planed_start_time_from
        if self.planed_start_time_to is not None:
            result['PlanedStartTimeTo'] = self.planed_start_time_to
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualStartTimeFrom') is not None:
            self.actual_start_time_from = m.get('ActualStartTimeFrom')
        if m.get('ActualStartTimeTo') is not None:
            self.actual_start_time_to = m.get('ActualStartTimeTo')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PlanedStartTimeFrom') is not None:
            self.planed_start_time_from = m.get('PlanedStartTimeFrom')
        if m.get('PlanedStartTimeTo') is not None:
            self.planed_start_time_to = m.get('PlanedStartTimeTo')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListCampaignsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        actual_end_time: int = None,
        actual_start_time: int = None,
        campaign_id: str = None,
        cases_aborted: int = None,
        cases_connected: int = None,
        cases_uncompleted: int = None,
        completion_rate: float = None,
        contact_flow_id: str = None,
        max_attempt_count: int = None,
        min_attempt_interval: int = None,
        name: str = None,
        planed_end_time: int = None,
        planed_start_time: int = None,
        queue_id: str = None,
        queue_name: str = None,
        simulation: bool = None,
        state: str = None,
        strategy_parameters: str = None,
        strategy_type: str = None,
        total_cases: int = None,
    ):
        self.actual_end_time = actual_end_time
        self.actual_start_time = actual_start_time
        self.campaign_id = campaign_id
        self.cases_aborted = cases_aborted
        self.cases_connected = cases_connected
        self.cases_uncompleted = cases_uncompleted
        self.completion_rate = completion_rate
        self.contact_flow_id = contact_flow_id
        self.max_attempt_count = max_attempt_count
        self.min_attempt_interval = min_attempt_interval
        self.name = name
        self.planed_end_time = planed_end_time
        self.planed_start_time = planed_start_time
        self.queue_id = queue_id
        self.queue_name = queue_name
        self.simulation = simulation
        self.state = state
        self.strategy_parameters = strategy_parameters
        self.strategy_type = strategy_type
        self.total_cases = total_cases

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_end_time is not None:
            result['ActualEndTime'] = self.actual_end_time
        if self.actual_start_time is not None:
            result['ActualStartTime'] = self.actual_start_time
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.cases_aborted is not None:
            result['CasesAborted'] = self.cases_aborted
        if self.cases_connected is not None:
            result['CasesConnected'] = self.cases_connected
        if self.cases_uncompleted is not None:
            result['CasesUncompleted'] = self.cases_uncompleted
        if self.completion_rate is not None:
            result['CompletionRate'] = self.completion_rate
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.max_attempt_count is not None:
            result['MaxAttemptCount'] = self.max_attempt_count
        if self.min_attempt_interval is not None:
            result['MinAttemptInterval'] = self.min_attempt_interval
        if self.name is not None:
            result['Name'] = self.name
        if self.planed_end_time is not None:
            result['PlanedEndTime'] = self.planed_end_time
        if self.planed_start_time is not None:
            result['PlanedStartTime'] = self.planed_start_time
        if self.queue_id is not None:
            result['QueueId'] = self.queue_id
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.simulation is not None:
            result['Simulation'] = self.simulation
        if self.state is not None:
            result['State'] = self.state
        if self.strategy_parameters is not None:
            result['StrategyParameters'] = self.strategy_parameters
        if self.strategy_type is not None:
            result['StrategyType'] = self.strategy_type
        if self.total_cases is not None:
            result['TotalCases'] = self.total_cases
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualEndTime') is not None:
            self.actual_end_time = m.get('ActualEndTime')
        if m.get('ActualStartTime') is not None:
            self.actual_start_time = m.get('ActualStartTime')
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('CasesAborted') is not None:
            self.cases_aborted = m.get('CasesAborted')
        if m.get('CasesConnected') is not None:
            self.cases_connected = m.get('CasesConnected')
        if m.get('CasesUncompleted') is not None:
            self.cases_uncompleted = m.get('CasesUncompleted')
        if m.get('CompletionRate') is not None:
            self.completion_rate = m.get('CompletionRate')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('MaxAttemptCount') is not None:
            self.max_attempt_count = m.get('MaxAttemptCount')
        if m.get('MinAttemptInterval') is not None:
            self.min_attempt_interval = m.get('MinAttemptInterval')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PlanedEndTime') is not None:
            self.planed_end_time = m.get('PlanedEndTime')
        if m.get('PlanedStartTime') is not None:
            self.planed_start_time = m.get('PlanedStartTime')
        if m.get('QueueId') is not None:
            self.queue_id = m.get('QueueId')
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Simulation') is not None:
            self.simulation = m.get('Simulation')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('StrategyParameters') is not None:
            self.strategy_parameters = m.get('StrategyParameters')
        if m.get('StrategyType') is not None:
            self.strategy_type = m.get('StrategyType')
        if m.get('TotalCases') is not None:
            self.total_cases = m.get('TotalCases')
        return self


class ListCampaignsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListCampaignsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCampaignsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCampaignsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListCampaignsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListCampaignsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListCampaignsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCampaignsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCampaignsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCasesRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        phone_number: str = None,
        state: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.phone_number = phone_number
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.phone_number is not None:
            result['PhoneNumber'] = self.phone_number
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PhoneNumber') is not None:
            self.phone_number = m.get('PhoneNumber')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListCasesResponseBodyDataList(TeaModel):
    def __init__(
        self,
        abandon_phase: str = None,
        abandon_type: str = None,
        attempt_count: int = None,
        case_id: str = None,
        custom_variables: str = None,
        failure_reason: str = None,
        phone_number: str = None,
        state: str = None,
    ):
        self.abandon_phase = abandon_phase
        self.abandon_type = abandon_type
        self.attempt_count = attempt_count
        self.case_id = case_id
        self.custom_variables = custom_variables
        self.failure_reason = failure_reason
        self.phone_number = phone_number
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abandon_phase is not None:
            result['AbandonPhase'] = self.abandon_phase
        if self.abandon_type is not None:
            result['AbandonType'] = self.abandon_type
        if self.attempt_count is not None:
            result['AttemptCount'] = self.attempt_count
        if self.case_id is not None:
            result['CaseId'] = self.case_id
        if self.custom_variables is not None:
            result['CustomVariables'] = self.custom_variables
        if self.failure_reason is not None:
            result['FailureReason'] = self.failure_reason
        if self.phone_number is not None:
            result['PhoneNumber'] = self.phone_number
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbandonPhase') is not None:
            self.abandon_phase = m.get('AbandonPhase')
        if m.get('AbandonType') is not None:
            self.abandon_type = m.get('AbandonType')
        if m.get('AttemptCount') is not None:
            self.attempt_count = m.get('AttemptCount')
        if m.get('CaseId') is not None:
            self.case_id = m.get('CaseId')
        if m.get('CustomVariables') is not None:
            self.custom_variables = m.get('CustomVariables')
        if m.get('FailureReason') is not None:
            self.failure_reason = m.get('FailureReason')
        if m.get('PhoneNumber') is not None:
            self.phone_number = m.get('PhoneNumber')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListCasesResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListCasesResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCasesResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCasesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListCasesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListCasesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCategoriesRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        instance_id: str = None,
        type: str = None,
    ):
        self.category_id = category_id
        # This parameter is required.
        self.instance_id = instance_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCategoriesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCategoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCategoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCategoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCommonTicketFieldsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ListCommonTicketFieldsResponseBodyData(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        id: str = None,
        instance_id: str = None,
        properties: Dict[str, DataPropertiesValue] = None,
        updated_time: str = None,
    ):
        self.created_time = created_time
        # Schema ID。
        self.id = id
        self.instance_id = instance_id
        self.properties = properties
        self.updated_time = updated_time

    def validate(self):
        if self.properties:
            for v in self.properties.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['Properties'] = {}
        if self.properties is not None:
            for k, v in self.properties.items():
                result['Properties'][k] = v.to_map()
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.properties = {}
        if m.get('Properties') is not None:
            for k, v in m.get('Properties').items():
                temp_model = DataPropertiesValue()
                self.properties[k] = temp_model.from_map(v)
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class ListCommonTicketFieldsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListCommonTicketFieldsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListCommonTicketFieldsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCommonTicketFieldsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCommonTicketFieldsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCommonTicketFieldsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListConfigItemsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        object_id: str = None,
        object_type: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.object_id = object_id
        # This parameter is required.
        self.object_type = object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        return self


class ListConfigItemsResponseBodyData(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        name: str = None,
        object_id: str = None,
        object_type: str = None,
        value: str = None,
    ):
        self.instance_id = instance_id
        self.name = name
        self.object_id = object_id
        self.object_type = object_type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListConfigItemsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListConfigItemsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListConfigItemsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListConfigItemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListConfigItemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListConfigItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListContactFlowsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        order_by_field: str = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
        sort_order: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.order_by_field = order_by_field
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern
        self.sort_order = sort_order
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_by_field is not None:
            result['OrderByField'] = self.order_by_field
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderByField') is not None:
            self.order_by_field = m.get('OrderByField')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListContactFlowsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        created_time: str = None,
        definition: str = None,
        description: str = None,
        draft_id: str = None,
        editor: str = None,
        instance_id: str = None,
        name: str = None,
        number_list: List[str] = None,
        published: bool = None,
        type: str = None,
        updated_time: str = None,
    ):
        self.contact_flow_id = contact_flow_id
        self.created_time = created_time
        self.definition = definition
        self.description = description
        self.draft_id = draft_id
        self.editor = editor
        self.instance_id = instance_id
        self.name = name
        self.number_list = number_list
        self.published = published
        self.type = type
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.description is not None:
            result['Description'] = self.description
        if self.draft_id is not None:
            result['DraftId'] = self.draft_id
        if self.editor is not None:
            result['Editor'] = self.editor
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        if self.published is not None:
            result['Published'] = self.published
        if self.type is not None:
            result['Type'] = self.type
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DraftId') is not None:
            self.draft_id = m.get('DraftId')
        if m.get('Editor') is not None:
            self.editor = m.get('Editor')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        if m.get('Published') is not None:
            self.published = m.get('Published')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class ListContactFlowsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListContactFlowsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListContactFlowsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListContactFlowsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListContactFlowsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListContactFlowsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListContactFlowsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListContactFlowsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListContactFlowsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomCallTaggingRequest(TeaModel):
    def __init__(
        self,
        call_tag_name_list: str = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
    ):
        self.call_tag_name_list = call_tag_name_list
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_tag_name_list is not None:
            result['CallTagNameList'] = self.call_tag_name_list
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallTagNameList') is not None:
            self.call_tag_name_list = m.get('CallTagNameList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        return self


class ListCustomCallTaggingResponseBodyDataListCallTagList(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        tag_name: str = None,
    ):
        self.instance_id = instance_id
        self.tag_name = tag_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        return self


class ListCustomCallTaggingResponseBodyDataList(TeaModel):
    def __init__(
        self,
        call_tag_list: List[ListCustomCallTaggingResponseBodyDataListCallTagList] = None,
        creator: str = None,
        description: str = None,
        instance_id: str = None,
        number: str = None,
        update_time: str = None,
    ):
        self.call_tag_list = call_tag_list
        self.creator = creator
        self.description = description
        self.instance_id = instance_id
        self.number = number
        self.update_time = update_time

    def validate(self):
        if self.call_tag_list:
            for k in self.call_tag_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CallTagList'] = []
        if self.call_tag_list is not None:
            for k in self.call_tag_list:
                result['CallTagList'].append(k.to_map() if k else None)
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.call_tag_list = []
        if m.get('CallTagList') is not None:
            for k in m.get('CallTagList'):
                temp_model = ListCustomCallTaggingResponseBodyDataListCallTagList()
                self.call_tag_list.append(temp_model.from_map(k))
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListCustomCallTaggingResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListCustomCallTaggingResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListCustomCallTaggingResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCustomCallTaggingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListCustomCallTaggingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListCustomCallTaggingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCustomCallTaggingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomCallTaggingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomCallTaggingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDevicesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListDevicesResponseBodyData(TeaModel):
    def __init__(
        self,
        call_id: str = None,
        contact: str = None,
        device_id: str = None,
        device_type: str = None,
        expires: int = None,
        extension: str = None,
        instance_id: str = None,
        user_id: str = None,
    ):
        self.call_id = call_id
        self.contact = contact
        self.device_id = device_id
        self.device_type = device_type
        self.expires = expires
        self.extension = extension
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_id is not None:
            result['CallId'] = self.call_id
        if self.contact is not None:
            result['Contact'] = self.contact
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_type is not None:
            result['DeviceType'] = self.device_type
        if self.expires is not None:
            result['Expires'] = self.expires
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallId') is not None:
            self.call_id = m.get('CallId')
        if m.get('Contact') is not None:
            self.contact = m.get('Contact')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceType') is not None:
            self.device_type = m.get('DeviceType')
        if m.get('Expires') is not None:
            self.expires = m.get('Expires')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListDevicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListDevicesResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDevicesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDevicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDevicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDevicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoNotCallNumbersRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        scope: str = None,
        search_pattern: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.scope = scope
        self.search_pattern = search_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        return self


class ListDoNotCallNumbersResponseBodyDataList(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        created_time: int = None,
        creator: str = None,
        number: str = None,
        remark: str = None,
        scope: str = None,
    ):
        self.create_time = create_time
        self.created_time = created_time
        self.creator = creator
        self.number = number
        self.remark = remark
        self.scope = scope

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.number is not None:
            result['Number'] = self.number
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.scope is not None:
            result['Scope'] = self.scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        return self


class ListDoNotCallNumbersResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListDoNotCallNumbersResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListDoNotCallNumbersResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoNotCallNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListDoNotCallNumbersResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListDoNotCallNumbersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDoNotCallNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoNotCallNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoNotCallNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDocumentsRequestSorts(TeaModel):
    def __init__(
        self,
        order: str = None,
        property_name: str = None,
    ):
        self.order = order
        self.property_name = property_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order is not None:
            result['Order'] = self.order
        if self.property_name is not None:
            result['PropertyName'] = self.property_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PropertyName') is not None:
            self.property_name = m.get('PropertyName')
        return self


class ListDocumentsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        request_id: str = None,
        schema_id: str = None,
        search_pattern: str = None,
        sorts: List[ListDocumentsRequestSorts] = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.next_page_token = next_page_token
        self.page_size = page_size
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id
        self.search_pattern = search_pattern
        self.sorts = sorts

    def validate(self):
        if self.sorts:
            for k in self.sorts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        result['Sorts'] = []
        if self.sorts is not None:
            for k in self.sorts:
                result['Sorts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        self.sorts = []
        if m.get('Sorts') is not None:
            for k in m.get('Sorts'):
                temp_model = ListDocumentsRequestSorts()
                self.sorts.append(temp_model.from_map(k))
        return self


class ListDocumentsShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        request_id: str = None,
        schema_id: str = None,
        search_pattern: str = None,
        sorts_shrink: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.next_page_token = next_page_token
        self.page_size = page_size
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id
        self.search_pattern = search_pattern
        self.sorts_shrink = sorts_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.sorts_shrink is not None:
            result['Sorts'] = self.sorts_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('Sorts') is not None:
            self.sorts_shrink = m.get('Sorts')
        return self


class ListDocumentsResponseBodyDataSchema(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        deleted: bool = None,
        description: str = None,
        id: str = None,
        instance_id: str = None,
        properties: Dict[str, DataSchemaPropertiesValue] = None,
        updated_time: str = None,
    ):
        self.created_time = created_time
        self.deleted = deleted
        self.description = description
        # schame id
        self.id = id
        self.instance_id = instance_id
        self.properties = properties
        self.updated_time = updated_time

    def validate(self):
        if self.properties:
            for v in self.properties.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.deleted is not None:
            result['Deleted'] = self.deleted
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['Properties'] = {}
        if self.properties is not None:
            for k, v in self.properties.items():
                result['Properties'][k] = v.to_map()
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Deleted') is not None:
            self.deleted = m.get('Deleted')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.properties = {}
        if m.get('Properties') is not None:
            for k, v in m.get('Properties').items():
                temp_model = DataSchemaPropertiesValue()
                self.properties[k] = temp_model.from_map(v)
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class ListDocumentsResponseBodyData(TeaModel):
    def __init__(
        self,
        documents: List[Dict[str, Any]] = None,
        next_page_token: str = None,
        schema: ListDocumentsResponseBodyDataSchema = None,
        total_count: int = None,
    ):
        self.documents = documents
        self.next_page_token = next_page_token
        # scheme
        self.schema = schema
        self.total_count = total_count

    def validate(self):
        if self.schema:
            self.schema.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.documents is not None:
            result['Documents'] = self.documents
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.schema is not None:
            result['Schema'] = self.schema.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Documents') is not None:
            self.documents = m.get('Documents')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('Schema') is not None:
            temp_model = ListDocumentsResponseBodyDataSchema()
            self.schema = temp_model.from_map(m['Schema'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDocumentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListDocumentsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListDocumentsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDocumentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDocumentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDocumentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFlashSmsApplicationsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        provider_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.name = name
        self.page_number = page_number
        self.page_size = page_size
        self.provider_id = provider_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.provider_id is not None:
            result['ProviderId'] = self.provider_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProviderId') is not None:
            self.provider_id = m.get('ProviderId')
        return self


class ListFlashSmsApplicationsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        instance_id: str = None,
        name: str = None,
        provider_id: str = None,
        value: str = None,
    ):
        self.application_id = application_id
        self.instance_id = instance_id
        self.name = name
        self.provider_id = provider_id
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['ApplicationId'] = self.application_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.provider_id is not None:
            result['ProviderId'] = self.provider_id
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationId') is not None:
            self.application_id = m.get('ApplicationId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProviderId') is not None:
            self.provider_id = m.get('ProviderId')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListFlashSmsApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListFlashSmsApplicationsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListFlashSmsApplicationsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListFlashSmsApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListFlashSmsApplicationsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListFlashSmsApplicationsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListFlashSmsApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFlashSmsApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFlashSmsApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFlashSmsTemplatesRequest(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        instance_id: str = None,
        provider_id: str = None,
    ):
        self.application_id = application_id
        # This parameter is required.
        self.instance_id = instance_id
        self.provider_id = provider_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['ApplicationId'] = self.application_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.provider_id is not None:
            result['ProviderId'] = self.provider_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationId') is not None:
            self.application_id = m.get('ApplicationId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ProviderId') is not None:
            self.provider_id = m.get('ProviderId')
        return self


class ListFlashSmsTemplatesResponseBodyData(TeaModel):
    def __init__(
        self,
        template_details: str = None,
        template_id: str = None,
        template_name: str = None,
    ):
        self.template_details = template_details
        self.template_id = template_id
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_details is not None:
            result['TemplateDetails'] = self.template_details
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateDetails') is not None:
            self.template_details = m.get('TemplateDetails')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class ListFlashSmsTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListFlashSmsTemplatesResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListFlashSmsTemplatesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListFlashSmsTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFlashSmsTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFlashSmsTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListGroupChatMessagesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        sort_order: str = None,
    ):
        self.instance_id = instance_id
        self.job_id = job_id
        self.next_page_token = next_page_token
        self.page_size = page_size
        self.sort_order = sort_order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        return self


class ListGroupChatMessagesResponseBodyDataMessages(TeaModel):
    def __init__(
        self,
        content: str = None,
        job_id: str = None,
        recalled: bool = None,
        sender_avatar_url: str = None,
        sender_id: str = None,
        sender_name: str = None,
        sender_type: str = None,
        timestamp: int = None,
    ):
        self.content = content
        self.job_id = job_id
        self.recalled = recalled
        self.sender_avatar_url = sender_avatar_url
        self.sender_id = sender_id
        self.sender_name = sender_name
        self.sender_type = sender_type
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.recalled is not None:
            result['Recalled'] = self.recalled
        if self.sender_avatar_url is not None:
            result['SenderAvatarUrl'] = self.sender_avatar_url
        if self.sender_id is not None:
            result['SenderId'] = self.sender_id
        if self.sender_name is not None:
            result['SenderName'] = self.sender_name
        if self.sender_type is not None:
            result['SenderType'] = self.sender_type
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Recalled') is not None:
            self.recalled = m.get('Recalled')
        if m.get('SenderAvatarUrl') is not None:
            self.sender_avatar_url = m.get('SenderAvatarUrl')
        if m.get('SenderId') is not None:
            self.sender_id = m.get('SenderId')
        if m.get('SenderName') is not None:
            self.sender_name = m.get('SenderName')
        if m.get('SenderType') is not None:
            self.sender_type = m.get('SenderType')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class ListGroupChatMessagesResponseBodyData(TeaModel):
    def __init__(
        self,
        messages: List[ListGroupChatMessagesResponseBodyDataMessages] = None,
        next_page_token: str = None,
    ):
        self.messages = messages
        self.next_page_token = next_page_token

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['Messages'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.messages = []
        if m.get('Messages') is not None:
            for k in m.get('Messages'):
                temp_model = ListGroupChatMessagesResponseBodyDataMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        return self


class ListGroupChatMessagesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListGroupChatMessagesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListGroupChatMessagesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListGroupChatMessagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListGroupChatMessagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListGroupChatMessagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHistoricalAgentReportRequest(TeaModel):
    def __init__(
        self,
        agent_id_list: str = None,
        instance_id: str = None,
        media_type: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_id: str = None,
        start_time: int = None,
        stop_time: int = None,
    ):
        self.agent_id_list = agent_id_list
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.skill_group_id = skill_group_id
        self.start_time = start_time
        self.stop_time = stop_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id_list is not None:
            result['AgentIdList'] = self.agent_id_list
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentIdList') is not None:
            self.agent_id_list = m.get('AgentIdList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        return self


class ListHistoricalAgentReportResponseBodyDataListBack2Back(TeaModel):
    def __init__(
        self,
        agent_handle_rate: str = None,
        answer_rate: str = None,
        average_customer_ring_time: str = None,
        average_ring_time: str = None,
        average_talk_time: str = None,
        calls_agent_handled: str = None,
        calls_answered: str = None,
        calls_customer_answered: str = None,
        calls_dialed: str = None,
        customer_answer_rate: str = None,
        max_customer_ring_time: str = None,
        max_ring_time: str = None,
        max_talk_time: str = None,
        total_customer_ring_time: str = None,
        total_ring_time: str = None,
        total_talk_time: str = None,
    ):
        self.agent_handle_rate = agent_handle_rate
        self.answer_rate = answer_rate
        self.average_customer_ring_time = average_customer_ring_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.calls_agent_handled = calls_agent_handled
        self.calls_answered = calls_answered
        self.calls_customer_answered = calls_customer_answered
        self.calls_dialed = calls_dialed
        self.customer_answer_rate = customer_answer_rate
        self.max_customer_ring_time = max_customer_ring_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.total_customer_ring_time = total_customer_ring_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_handle_rate is not None:
            result['AgentHandleRate'] = self.agent_handle_rate
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_customer_ring_time is not None:
            result['AverageCustomerRingTime'] = self.average_customer_ring_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_agent_handled is not None:
            result['CallsAgentHandled'] = self.calls_agent_handled
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_customer_answered is not None:
            result['CallsCustomerAnswered'] = self.calls_customer_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.customer_answer_rate is not None:
            result['CustomerAnswerRate'] = self.customer_answer_rate
        if self.max_customer_ring_time is not None:
            result['MaxCustomerRingTime'] = self.max_customer_ring_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_customer_ring_time is not None:
            result['TotalCustomerRingTime'] = self.total_customer_ring_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentHandleRate') is not None:
            self.agent_handle_rate = m.get('AgentHandleRate')
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageCustomerRingTime') is not None:
            self.average_customer_ring_time = m.get('AverageCustomerRingTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAgentHandled') is not None:
            self.calls_agent_handled = m.get('CallsAgentHandled')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsCustomerAnswered') is not None:
            self.calls_customer_answered = m.get('CallsCustomerAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CustomerAnswerRate') is not None:
            self.customer_answer_rate = m.get('CustomerAnswerRate')
        if m.get('MaxCustomerRingTime') is not None:
            self.max_customer_ring_time = m.get('MaxCustomerRingTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalCustomerRingTime') is not None:
            self.total_customer_ring_time = m.get('TotalCustomerRingTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails(TeaModel):
    def __init__(
        self,
        access_channel_type: str = None,
        calls_offered: int = None,
    ):
        self.access_channel_type = access_channel_type
        self.calls_offered = calls_offered

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_type is not None:
            result['AccessChannelType'] = self.access_channel_type
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelType') is not None:
            self.access_channel_type = m.get('AccessChannelType')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        return self


class ListHistoricalAgentReportResponseBodyDataListInbound(TeaModel):
    def __init__(
        self,
        access_channel_type_details: List[ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails] = None,
        average_first_response_time: float = None,
        average_hold_time: float = None,
        average_response_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_handled: int = None,
        calls_hold: int = None,
        calls_offered: int = None,
        calls_ringed: int = None,
        handle_rate: float = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        service_level_15: float = None,
        total_hold_time: int = None,
        total_messages_sent: int = None,
        total_messages_sent_by_agent: int = None,
        total_messages_sent_by_customer: str = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.access_channel_type_details = access_channel_type_details
        self.average_first_response_time = average_first_response_time
        self.average_hold_time = average_hold_time
        self.average_response_time = average_response_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_handled = calls_handled
        self.calls_hold = calls_hold
        self.calls_offered = calls_offered
        self.calls_ringed = calls_ringed
        self.handle_rate = handle_rate
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.service_level_15 = service_level_15
        self.total_hold_time = total_hold_time
        self.total_messages_sent = total_messages_sent
        self.total_messages_sent_by_agent = total_messages_sent_by_agent
        self.total_messages_sent_by_customer = total_messages_sent_by_customer
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.access_channel_type_details:
            for k in self.access_channel_type_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AccessChannelTypeDetails'] = []
        if self.access_channel_type_details is not None:
            for k in self.access_channel_type_details:
                result['AccessChannelTypeDetails'].append(k.to_map() if k else None)
        if self.average_first_response_time is not None:
            result['AverageFirstResponseTime'] = self.average_first_response_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_response_time is not None:
            result['AverageResponseTime'] = self.average_response_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.service_level_15 is not None:
            result['ServiceLevel15'] = self.service_level_15
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_messages_sent is not None:
            result['TotalMessagesSent'] = self.total_messages_sent
        if self.total_messages_sent_by_agent is not None:
            result['TotalMessagesSentByAgent'] = self.total_messages_sent_by_agent
        if self.total_messages_sent_by_customer is not None:
            result['TotalMessagesSentByCustomer'] = self.total_messages_sent_by_customer
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.access_channel_type_details = []
        if m.get('AccessChannelTypeDetails') is not None:
            for k in m.get('AccessChannelTypeDetails'):
                temp_model = ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails()
                self.access_channel_type_details.append(temp_model.from_map(k))
        if m.get('AverageFirstResponseTime') is not None:
            self.average_first_response_time = m.get('AverageFirstResponseTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageResponseTime') is not None:
            self.average_response_time = m.get('AverageResponseTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('ServiceLevel15') is not None:
            self.service_level_15 = m.get('ServiceLevel15')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalMessagesSent') is not None:
            self.total_messages_sent = m.get('TotalMessagesSent')
        if m.get('TotalMessagesSentByAgent') is not None:
            self.total_messages_sent_by_agent = m.get('TotalMessagesSentByAgent')
        if m.get('TotalMessagesSentByCustomer') is not None:
            self.total_messages_sent_by_customer = m.get('TotalMessagesSentByCustomer')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalAgentReportResponseBodyDataListInternal(TeaModel):
    def __init__(
        self,
        average_talk_time: float = None,
        calls_answered: int = None,
        calls_dialed: int = None,
        calls_handled: int = None,
        calls_offered: int = None,
        calls_talked: int = None,
        max_talk_time: int = None,
        total_talk_time: int = None,
    ):
        self.average_talk_time = average_talk_time
        self.calls_answered = calls_answered
        self.calls_dialed = calls_dialed
        self.calls_handled = calls_handled
        self.calls_offered = calls_offered
        self.calls_talked = calls_talked
        self.max_talk_time = max_talk_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_talked is not None:
            result['CallsTalked'] = self.calls_talked
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsTalked') is not None:
            self.calls_talked = m.get('CallsTalked')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListHistoricalAgentReportResponseBodyDataListOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: float = None,
        average_hold_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_answered: int = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_dialed: int = None,
        calls_hold: int = None,
        calls_ringed: int = None,
        max_dialing_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_hold_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_hold_time = average_hold_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_dialed = calls_dialed
        self.calls_hold = calls_hold
        self.calls_ringed = calls_ringed
        self.max_dialing_time = max_dialing_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_hold_time = total_hold_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        count: int = None,
        duration: int = None,
    ):
        self.break_code = break_code
        self.count = count
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.count is not None:
            result['Count'] = self.count
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class ListHistoricalAgentReportResponseBodyDataListOverall(TeaModel):
    def __init__(
        self,
        average_break_time: float = None,
        average_hold_time: float = None,
        average_ready_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        break_code_detail_list: List[ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList] = None,
        first_check_in_time: int = None,
        last_check_out_time: int = None,
        max_break_time: int = None,
        max_hold_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_hold_time: int = None,
        total_logged_in_time: int = None,
        total_off_site_logged_in_time: int = None,
        total_off_site_online_time: int = None,
        total_office_phone_logged_in_time: int = None,
        total_office_phone_online_time: int = None,
        total_on_site_logged_in_time: int = None,
        total_on_site_online_time: int = None,
        total_outbound_scenario_logged_in_time: int = None,
        total_outbound_scenario_ready_time: int = None,
        total_outbound_scenario_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_break_time = average_break_time
        self.average_hold_time = average_hold_time
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.break_code_detail_list = break_code_detail_list
        self.first_check_in_time = first_check_in_time
        self.last_check_out_time = last_check_out_time
        self.max_break_time = max_break_time
        self.max_hold_time = max_hold_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_hold_time = total_hold_time
        self.total_logged_in_time = total_logged_in_time
        self.total_off_site_logged_in_time = total_off_site_logged_in_time
        self.total_off_site_online_time = total_off_site_online_time
        self.total_office_phone_logged_in_time = total_office_phone_logged_in_time
        self.total_office_phone_online_time = total_office_phone_online_time
        self.total_on_site_logged_in_time = total_on_site_logged_in_time
        self.total_on_site_online_time = total_on_site_online_time
        self.total_outbound_scenario_logged_in_time = total_outbound_scenario_logged_in_time
        self.total_outbound_scenario_ready_time = total_outbound_scenario_ready_time
        self.total_outbound_scenario_time = total_outbound_scenario_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.break_code_detail_list:
            for k in self.break_code_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_break_time is not None:
            result['AverageBreakTime'] = self.average_break_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        result['BreakCodeDetailList'] = []
        if self.break_code_detail_list is not None:
            for k in self.break_code_detail_list:
                result['BreakCodeDetailList'].append(k.to_map() if k else None)
        if self.first_check_in_time is not None:
            result['FirstCheckInTime'] = self.first_check_in_time
        if self.last_check_out_time is not None:
            result['LastCheckOutTime'] = self.last_check_out_time
        if self.max_break_time is not None:
            result['MaxBreakTime'] = self.max_break_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_off_site_logged_in_time is not None:
            result['TotalOffSiteLoggedInTime'] = self.total_off_site_logged_in_time
        if self.total_off_site_online_time is not None:
            result['TotalOffSiteOnlineTime'] = self.total_off_site_online_time
        if self.total_office_phone_logged_in_time is not None:
            result['TotalOfficePhoneLoggedInTime'] = self.total_office_phone_logged_in_time
        if self.total_office_phone_online_time is not None:
            result['TotalOfficePhoneOnlineTime'] = self.total_office_phone_online_time
        if self.total_on_site_logged_in_time is not None:
            result['TotalOnSiteLoggedInTime'] = self.total_on_site_logged_in_time
        if self.total_on_site_online_time is not None:
            result['TotalOnSiteOnlineTime'] = self.total_on_site_online_time
        if self.total_outbound_scenario_logged_in_time is not None:
            result['TotalOutboundScenarioLoggedInTime'] = self.total_outbound_scenario_logged_in_time
        if self.total_outbound_scenario_ready_time is not None:
            result['TotalOutboundScenarioReadyTime'] = self.total_outbound_scenario_ready_time
        if self.total_outbound_scenario_time is not None:
            result['TotalOutboundScenarioTime'] = self.total_outbound_scenario_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageBreakTime') is not None:
            self.average_break_time = m.get('AverageBreakTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        self.break_code_detail_list = []
        if m.get('BreakCodeDetailList') is not None:
            for k in m.get('BreakCodeDetailList'):
                temp_model = ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList()
                self.break_code_detail_list.append(temp_model.from_map(k))
        if m.get('FirstCheckInTime') is not None:
            self.first_check_in_time = m.get('FirstCheckInTime')
        if m.get('LastCheckOutTime') is not None:
            self.last_check_out_time = m.get('LastCheckOutTime')
        if m.get('MaxBreakTime') is not None:
            self.max_break_time = m.get('MaxBreakTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalOffSiteLoggedInTime') is not None:
            self.total_off_site_logged_in_time = m.get('TotalOffSiteLoggedInTime')
        if m.get('TotalOffSiteOnlineTime') is not None:
            self.total_off_site_online_time = m.get('TotalOffSiteOnlineTime')
        if m.get('TotalOfficePhoneLoggedInTime') is not None:
            self.total_office_phone_logged_in_time = m.get('TotalOfficePhoneLoggedInTime')
        if m.get('TotalOfficePhoneOnlineTime') is not None:
            self.total_office_phone_online_time = m.get('TotalOfficePhoneOnlineTime')
        if m.get('TotalOnSiteLoggedInTime') is not None:
            self.total_on_site_logged_in_time = m.get('TotalOnSiteLoggedInTime')
        if m.get('TotalOnSiteOnlineTime') is not None:
            self.total_on_site_online_time = m.get('TotalOnSiteOnlineTime')
        if m.get('TotalOutboundScenarioLoggedInTime') is not None:
            self.total_outbound_scenario_logged_in_time = m.get('TotalOutboundScenarioLoggedInTime')
        if m.get('TotalOutboundScenarioReadyTime') is not None:
            self.total_outbound_scenario_ready_time = m.get('TotalOutboundScenarioReadyTime')
        if m.get('TotalOutboundScenarioTime') is not None:
            self.total_outbound_scenario_time = m.get('TotalOutboundScenarioTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalAgentReportResponseBodyDataList(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        agent_name: str = None,
        back_2back: ListHistoricalAgentReportResponseBodyDataListBack2Back = None,
        display_id: str = None,
        inbound: ListHistoricalAgentReportResponseBodyDataListInbound = None,
        internal: ListHistoricalAgentReportResponseBodyDataListInternal = None,
        outbound: ListHistoricalAgentReportResponseBodyDataListOutbound = None,
        overall: ListHistoricalAgentReportResponseBodyDataListOverall = None,
        skill_group_ids: str = None,
        skill_group_names: str = None,
    ):
        self.agent_id = agent_id
        self.agent_name = agent_name
        self.back_2back = back_2back
        self.display_id = display_id
        self.inbound = inbound
        self.internal = internal
        self.outbound = outbound
        self.overall = overall
        self.skill_group_ids = skill_group_ids
        self.skill_group_names = skill_group_names

    def validate(self):
        if self.back_2back:
            self.back_2back.validate()
        if self.inbound:
            self.inbound.validate()
        if self.internal:
            self.internal.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        if self.back_2back is not None:
            result['Back2Back'] = self.back_2back.to_map()
        if self.display_id is not None:
            result['DisplayId'] = self.display_id
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.internal is not None:
            result['Internal'] = self.internal.to_map()
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.skill_group_ids is not None:
            result['SkillGroupIds'] = self.skill_group_ids
        if self.skill_group_names is not None:
            result['SkillGroupNames'] = self.skill_group_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        if m.get('Back2Back') is not None:
            temp_model = ListHistoricalAgentReportResponseBodyDataListBack2Back()
            self.back_2back = temp_model.from_map(m['Back2Back'])
        if m.get('DisplayId') is not None:
            self.display_id = m.get('DisplayId')
        if m.get('Inbound') is not None:
            temp_model = ListHistoricalAgentReportResponseBodyDataListInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('Internal') is not None:
            temp_model = ListHistoricalAgentReportResponseBodyDataListInternal()
            self.internal = temp_model.from_map(m['Internal'])
        if m.get('Outbound') is not None:
            temp_model = ListHistoricalAgentReportResponseBodyDataListOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListHistoricalAgentReportResponseBodyDataListOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('SkillGroupIds') is not None:
            self.skill_group_ids = m.get('SkillGroupIds')
        if m.get('SkillGroupNames') is not None:
            self.skill_group_names = m.get('SkillGroupNames')
        return self


class ListHistoricalAgentReportResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListHistoricalAgentReportResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHistoricalAgentReportResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHistoricalAgentReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListHistoricalAgentReportResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListHistoricalAgentReportResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListHistoricalAgentReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHistoricalAgentReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHistoricalAgentReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHistoricalAgentSkillGroupReportRequest(TeaModel):
    def __init__(
        self,
        agent_id_list: str = None,
        end_time: int = None,
        instance_id: str = None,
        media_type: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_id_list: str = None,
        start_time: int = None,
    ):
        self.agent_id_list = agent_id_list
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.skill_group_id_list = skill_group_id_list
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id_list is not None:
            result['AgentIdList'] = self.agent_id_list
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentIdList') is not None:
            self.agent_id_list = m.get('AgentIdList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back(TeaModel):
    def __init__(
        self,
        agent_answer_rate: float = None,
        agent_handle_rate: float = None,
        answer_rate: float = None,
        average_customer_ring_time: float = None,
        average_ring_time: float = None,
        average_talk_time: int = None,
        calls_agent_handled: int = None,
        calls_answered: int = None,
        calls_customer_answered: int = None,
        calls_customer_handled: int = None,
        calls_dialed: int = None,
        customer_answer_rate: float = None,
        customer_handle_rate: float = None,
        max_customer_ring_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        total_customer_ring_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
    ):
        self.agent_answer_rate = agent_answer_rate
        self.agent_handle_rate = agent_handle_rate
        self.answer_rate = answer_rate
        self.average_customer_ring_time = average_customer_ring_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.calls_agent_handled = calls_agent_handled
        self.calls_answered = calls_answered
        self.calls_customer_answered = calls_customer_answered
        self.calls_customer_handled = calls_customer_handled
        self.calls_dialed = calls_dialed
        self.customer_answer_rate = customer_answer_rate
        self.customer_handle_rate = customer_handle_rate
        self.max_customer_ring_time = max_customer_ring_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.total_customer_ring_time = total_customer_ring_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_answer_rate is not None:
            result['AgentAnswerRate'] = self.agent_answer_rate
        if self.agent_handle_rate is not None:
            result['AgentHandleRate'] = self.agent_handle_rate
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_customer_ring_time is not None:
            result['AverageCustomerRingTime'] = self.average_customer_ring_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_agent_handled is not None:
            result['CallsAgentHandled'] = self.calls_agent_handled
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_customer_answered is not None:
            result['CallsCustomerAnswered'] = self.calls_customer_answered
        if self.calls_customer_handled is not None:
            result['CallsCustomerHandled'] = self.calls_customer_handled
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.customer_answer_rate is not None:
            result['CustomerAnswerRate'] = self.customer_answer_rate
        if self.customer_handle_rate is not None:
            result['CustomerHandleRate'] = self.customer_handle_rate
        if self.max_customer_ring_time is not None:
            result['MaxCustomerRingTime'] = self.max_customer_ring_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_customer_ring_time is not None:
            result['TotalCustomerRingTime'] = self.total_customer_ring_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentAnswerRate') is not None:
            self.agent_answer_rate = m.get('AgentAnswerRate')
        if m.get('AgentHandleRate') is not None:
            self.agent_handle_rate = m.get('AgentHandleRate')
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageCustomerRingTime') is not None:
            self.average_customer_ring_time = m.get('AverageCustomerRingTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAgentHandled') is not None:
            self.calls_agent_handled = m.get('CallsAgentHandled')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsCustomerAnswered') is not None:
            self.calls_customer_answered = m.get('CallsCustomerAnswered')
        if m.get('CallsCustomerHandled') is not None:
            self.calls_customer_handled = m.get('CallsCustomerHandled')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CustomerAnswerRate') is not None:
            self.customer_answer_rate = m.get('CustomerAnswerRate')
        if m.get('CustomerHandleRate') is not None:
            self.customer_handle_rate = m.get('CustomerHandleRate')
        if m.get('MaxCustomerRingTime') is not None:
            self.max_customer_ring_time = m.get('MaxCustomerRingTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalCustomerRingTime') is not None:
            self.total_customer_ring_time = m.get('TotalCustomerRingTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound(TeaModel):
    def __init__(
        self,
        average_first_response_time: float = None,
        average_hold_time: float = None,
        average_response_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_handled: int = None,
        calls_hold: int = None,
        calls_offered: int = None,
        calls_ringed: int = None,
        handle_rate: float = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_hold_time: int = None,
        total_messages_sent: int = None,
        total_messages_sent_by_agent: int = None,
        total_messages_sent_by_customer: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_first_response_time = average_first_response_time
        self.average_hold_time = average_hold_time
        self.average_response_time = average_response_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_handled = calls_handled
        self.calls_hold = calls_hold
        self.calls_offered = calls_offered
        self.calls_ringed = calls_ringed
        self.handle_rate = handle_rate
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_hold_time = total_hold_time
        self.total_messages_sent = total_messages_sent
        self.total_messages_sent_by_agent = total_messages_sent_by_agent
        self.total_messages_sent_by_customer = total_messages_sent_by_customer
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_first_response_time is not None:
            result['AverageFirstResponseTime'] = self.average_first_response_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_response_time is not None:
            result['AverageResponseTime'] = self.average_response_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_messages_sent is not None:
            result['TotalMessagesSent'] = self.total_messages_sent
        if self.total_messages_sent_by_agent is not None:
            result['TotalMessagesSentByAgent'] = self.total_messages_sent_by_agent
        if self.total_messages_sent_by_customer is not None:
            result['TotalMessagesSentByCustomer'] = self.total_messages_sent_by_customer
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageFirstResponseTime') is not None:
            self.average_first_response_time = m.get('AverageFirstResponseTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageResponseTime') is not None:
            self.average_response_time = m.get('AverageResponseTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalMessagesSent') is not None:
            self.total_messages_sent = m.get('TotalMessagesSent')
        if m.get('TotalMessagesSentByAgent') is not None:
            self.total_messages_sent_by_agent = m.get('TotalMessagesSentByAgent')
        if m.get('TotalMessagesSentByCustomer') is not None:
            self.total_messages_sent_by_customer = m.get('TotalMessagesSentByCustomer')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal(TeaModel):
    def __init__(
        self,
        average_talk_time: int = None,
        calls_answered: int = None,
        calls_dialed: int = None,
        calls_handled: int = None,
        calls_offered: int = None,
        calls_talk: int = None,
        calls_talked: int = None,
        max_talk_time: int = None,
        total_talk_time: int = None,
    ):
        self.average_talk_time = average_talk_time
        self.calls_answered = calls_answered
        self.calls_dialed = calls_dialed
        self.calls_handled = calls_handled
        self.calls_offered = calls_offered
        self.calls_talk = calls_talk
        self.calls_talked = calls_talked
        self.max_talk_time = max_talk_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_talk is not None:
            result['CallsTalk'] = self.calls_talk
        if self.calls_talked is not None:
            result['CallsTalked'] = self.calls_talked
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsTalk') is not None:
            self.calls_talk = m.get('CallsTalk')
        if m.get('CallsTalked') is not None:
            self.calls_talked = m.get('CallsTalked')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: float = None,
        average_hold_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_answered: int = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_dialed: int = None,
        calls_hold: int = None,
        calls_ringed: int = None,
        max_dialing_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_hold_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_hold_time = average_hold_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_dialed = calls_dialed
        self.calls_hold = calls_hold
        self.calls_ringed = calls_ringed
        self.max_dialing_time = max_dialing_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_hold_time = total_hold_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        count: int = None,
        duration: int = None,
    ):
        self.break_code = break_code
        self.count = count
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.count is not None:
            result['Count'] = self.count
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall(TeaModel):
    def __init__(
        self,
        average_break_time: float = None,
        average_hold_time: float = None,
        average_ready_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        break_code_detail_list: List[ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList] = None,
        first_check_in_time: int = None,
        last_check_out_time: int = None,
        max_break_time: int = None,
        max_hold_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_hold_time: int = None,
        total_logged_in_time: int = None,
        total_off_site_lgged_in_time: int = None,
        total_office_phone_logged_in_time: int = None,
        total_on_site_logged_in_time: str = None,
        total_outbound_scenario_logged_in_time: int = None,
        total_outbound_scenario_ready_time: int = None,
        total_outbound_scenario_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_break_time = average_break_time
        self.average_hold_time = average_hold_time
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.break_code_detail_list = break_code_detail_list
        self.first_check_in_time = first_check_in_time
        self.last_check_out_time = last_check_out_time
        self.max_break_time = max_break_time
        self.max_hold_time = max_hold_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_hold_time = total_hold_time
        self.total_logged_in_time = total_logged_in_time
        self.total_off_site_lgged_in_time = total_off_site_lgged_in_time
        self.total_office_phone_logged_in_time = total_office_phone_logged_in_time
        self.total_on_site_logged_in_time = total_on_site_logged_in_time
        self.total_outbound_scenario_logged_in_time = total_outbound_scenario_logged_in_time
        self.total_outbound_scenario_ready_time = total_outbound_scenario_ready_time
        self.total_outbound_scenario_time = total_outbound_scenario_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.break_code_detail_list:
            for k in self.break_code_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_break_time is not None:
            result['AverageBreakTime'] = self.average_break_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        result['BreakCodeDetailList'] = []
        if self.break_code_detail_list is not None:
            for k in self.break_code_detail_list:
                result['BreakCodeDetailList'].append(k.to_map() if k else None)
        if self.first_check_in_time is not None:
            result['FirstCheckInTime'] = self.first_check_in_time
        if self.last_check_out_time is not None:
            result['LastCheckOutTime'] = self.last_check_out_time
        if self.max_break_time is not None:
            result['MaxBreakTime'] = self.max_break_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_off_site_lgged_in_time is not None:
            result['TotalOffSiteLggedInTime'] = self.total_off_site_lgged_in_time
        if self.total_office_phone_logged_in_time is not None:
            result['TotalOfficePhoneLoggedInTime'] = self.total_office_phone_logged_in_time
        if self.total_on_site_logged_in_time is not None:
            result['TotalOnSiteLoggedInTime'] = self.total_on_site_logged_in_time
        if self.total_outbound_scenario_logged_in_time is not None:
            result['TotalOutboundScenarioLoggedInTime'] = self.total_outbound_scenario_logged_in_time
        if self.total_outbound_scenario_ready_time is not None:
            result['TotalOutboundScenarioReadyTime'] = self.total_outbound_scenario_ready_time
        if self.total_outbound_scenario_time is not None:
            result['TotalOutboundScenarioTime'] = self.total_outbound_scenario_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageBreakTime') is not None:
            self.average_break_time = m.get('AverageBreakTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        self.break_code_detail_list = []
        if m.get('BreakCodeDetailList') is not None:
            for k in m.get('BreakCodeDetailList'):
                temp_model = ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList()
                self.break_code_detail_list.append(temp_model.from_map(k))
        if m.get('FirstCheckInTime') is not None:
            self.first_check_in_time = m.get('FirstCheckInTime')
        if m.get('LastCheckOutTime') is not None:
            self.last_check_out_time = m.get('LastCheckOutTime')
        if m.get('MaxBreakTime') is not None:
            self.max_break_time = m.get('MaxBreakTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalOffSiteLggedInTime') is not None:
            self.total_off_site_lgged_in_time = m.get('TotalOffSiteLggedInTime')
        if m.get('TotalOfficePhoneLoggedInTime') is not None:
            self.total_office_phone_logged_in_time = m.get('TotalOfficePhoneLoggedInTime')
        if m.get('TotalOnSiteLoggedInTime') is not None:
            self.total_on_site_logged_in_time = m.get('TotalOnSiteLoggedInTime')
        if m.get('TotalOutboundScenarioLoggedInTime') is not None:
            self.total_outbound_scenario_logged_in_time = m.get('TotalOutboundScenarioLoggedInTime')
        if m.get('TotalOutboundScenarioReadyTime') is not None:
            self.total_outbound_scenario_ready_time = m.get('TotalOutboundScenarioReadyTime')
        if m.get('TotalOutboundScenarioTime') is not None:
            self.total_outbound_scenario_time = m.get('TotalOutboundScenarioTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalAgentSkillGroupReportResponseBodyDataList(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        agent_name: str = None,
        back_2back: ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back = None,
        display_id: str = None,
        inbound: ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound = None,
        internal: ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal = None,
        outbound: ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound = None,
        overall: ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
    ):
        self.agent_id = agent_id
        self.agent_name = agent_name
        self.back_2back = back_2back
        self.display_id = display_id
        self.inbound = inbound
        self.internal = internal
        self.outbound = outbound
        self.overall = overall
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name

    def validate(self):
        if self.back_2back:
            self.back_2back.validate()
        if self.inbound:
            self.inbound.validate()
        if self.internal:
            self.internal.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        if self.back_2back is not None:
            result['Back2Back'] = self.back_2back.to_map()
        if self.display_id is not None:
            result['DisplayId'] = self.display_id
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.internal is not None:
            result['Internal'] = self.internal.to_map()
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        if m.get('Back2Back') is not None:
            temp_model = ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back()
            self.back_2back = temp_model.from_map(m['Back2Back'])
        if m.get('DisplayId') is not None:
            self.display_id = m.get('DisplayId')
        if m.get('Inbound') is not None:
            temp_model = ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('Internal') is not None:
            temp_model = ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal()
            self.internal = temp_model.from_map(m['Internal'])
        if m.get('Outbound') is not None:
            temp_model = ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        return self


class ListHistoricalAgentSkillGroupReportResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListHistoricalAgentSkillGroupReportResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHistoricalAgentSkillGroupReportResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHistoricalAgentSkillGroupReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListHistoricalAgentSkillGroupReportResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListHistoricalAgentSkillGroupReportResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListHistoricalAgentSkillGroupReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHistoricalAgentSkillGroupReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHistoricalAgentSkillGroupReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHistoricalSkillGroupReportRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_id: str = None,
        media_type: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_id_list: str = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.skill_group_id_list = skill_group_id_list
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListHistoricalSkillGroupReportResponseBodyDataListBack2Back(TeaModel):
    def __init__(
        self,
        agent_handle_rate: float = None,
        answer_rate: float = None,
        average_customer_ring_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        calls_answered: int = None,
        calls_customer_answered: int = None,
        calls_dialed: int = None,
        customer_answer_rate: float = None,
        max_customer_ring_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        total_customer_ring_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
    ):
        self.agent_handle_rate = agent_handle_rate
        self.answer_rate = answer_rate
        self.average_customer_ring_time = average_customer_ring_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.calls_answered = calls_answered
        self.calls_customer_answered = calls_customer_answered
        self.calls_dialed = calls_dialed
        self.customer_answer_rate = customer_answer_rate
        self.max_customer_ring_time = max_customer_ring_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.total_customer_ring_time = total_customer_ring_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_handle_rate is not None:
            result['AgentHandleRate'] = self.agent_handle_rate
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_customer_ring_time is not None:
            result['AverageCustomerRingTime'] = self.average_customer_ring_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_customer_answered is not None:
            result['CallsCustomerAnswered'] = self.calls_customer_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.customer_answer_rate is not None:
            result['CustomerAnswerRate'] = self.customer_answer_rate
        if self.max_customer_ring_time is not None:
            result['MaxCustomerRingTime'] = self.max_customer_ring_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_customer_ring_time is not None:
            result['TotalCustomerRingTime'] = self.total_customer_ring_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentHandleRate') is not None:
            self.agent_handle_rate = m.get('AgentHandleRate')
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageCustomerRingTime') is not None:
            self.average_customer_ring_time = m.get('AverageCustomerRingTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsCustomerAnswered') is not None:
            self.calls_customer_answered = m.get('CallsCustomerAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CustomerAnswerRate') is not None:
            self.customer_answer_rate = m.get('CustomerAnswerRate')
        if m.get('MaxCustomerRingTime') is not None:
            self.max_customer_ring_time = m.get('MaxCustomerRingTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalCustomerRingTime') is not None:
            self.total_customer_ring_time = m.get('TotalCustomerRingTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails(TeaModel):
    def __init__(
        self,
        access_channel_type: str = None,
        calls_offered: int = None,
    ):
        self.access_channel_type = access_channel_type
        self.calls_offered = calls_offered

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_type is not None:
            result['AccessChannelType'] = self.access_channel_type
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelType') is not None:
            self.access_channel_type = m.get('AccessChannelType')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        return self


class ListHistoricalSkillGroupReportResponseBodyDataListInbound(TeaModel):
    def __init__(
        self,
        abandon_rate: float = None,
        access_channel_type_details: List[ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails] = None,
        average_abandon_time: float = None,
        average_abandoned_in_queue_time: float = None,
        average_abandoned_in_ring_time: float = None,
        average_first_response_time: float = None,
        average_hold_time: float = None,
        average_response_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_wait_time: float = None,
        average_work_time: float = None,
        calls_abandoned: int = None,
        calls_abandoned_in_queue: int = None,
        calls_abandoned_in_ring: int = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_handled: int = None,
        calls_hold: int = None,
        calls_offered: int = None,
        calls_overflow: int = None,
        calls_queued: int = None,
        calls_queuing_failed: int = None,
        calls_queuing_overflow: int = None,
        calls_queuing_timeout: int = None,
        calls_ringed: int = None,
        calls_timeout: int = None,
        handle_rate: float = None,
        max_abandon_time: int = None,
        max_abandoned_in_queue_time: int = None,
        max_abandoned_in_ring_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_wait_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        service_level_15: float = None,
        service_level_20: float = None,
        service_level_30: float = None,
        total_abandon_time: int = None,
        total_abandoned_in_queue_time: int = None,
        total_abandoned_in_ring_time: int = None,
        total_hold_time: int = None,
        total_messages_sent: int = None,
        total_messages_sent_by_agent: int = None,
        total_messages_sent_by_customer: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_wait_time: int = None,
        total_work_time: int = None,
    ):
        self.abandon_rate = abandon_rate
        self.access_channel_type_details = access_channel_type_details
        self.average_abandon_time = average_abandon_time
        self.average_abandoned_in_queue_time = average_abandoned_in_queue_time
        self.average_abandoned_in_ring_time = average_abandoned_in_ring_time
        self.average_first_response_time = average_first_response_time
        self.average_hold_time = average_hold_time
        self.average_response_time = average_response_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_wait_time = average_wait_time
        self.average_work_time = average_work_time
        self.calls_abandoned = calls_abandoned
        self.calls_abandoned_in_queue = calls_abandoned_in_queue
        self.calls_abandoned_in_ring = calls_abandoned_in_ring
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_handled = calls_handled
        self.calls_hold = calls_hold
        self.calls_offered = calls_offered
        self.calls_overflow = calls_overflow
        self.calls_queued = calls_queued
        self.calls_queuing_failed = calls_queuing_failed
        self.calls_queuing_overflow = calls_queuing_overflow
        self.calls_queuing_timeout = calls_queuing_timeout
        self.calls_ringed = calls_ringed
        self.calls_timeout = calls_timeout
        self.handle_rate = handle_rate
        self.max_abandon_time = max_abandon_time
        self.max_abandoned_in_queue_time = max_abandoned_in_queue_time
        self.max_abandoned_in_ring_time = max_abandoned_in_ring_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_wait_time = max_wait_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.service_level_15 = service_level_15
        self.service_level_20 = service_level_20
        self.service_level_30 = service_level_30
        self.total_abandon_time = total_abandon_time
        self.total_abandoned_in_queue_time = total_abandoned_in_queue_time
        self.total_abandoned_in_ring_time = total_abandoned_in_ring_time
        self.total_hold_time = total_hold_time
        self.total_messages_sent = total_messages_sent
        self.total_messages_sent_by_agent = total_messages_sent_by_agent
        self.total_messages_sent_by_customer = total_messages_sent_by_customer
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_wait_time = total_wait_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.access_channel_type_details:
            for k in self.access_channel_type_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abandon_rate is not None:
            result['AbandonRate'] = self.abandon_rate
        result['AccessChannelTypeDetails'] = []
        if self.access_channel_type_details is not None:
            for k in self.access_channel_type_details:
                result['AccessChannelTypeDetails'].append(k.to_map() if k else None)
        if self.average_abandon_time is not None:
            result['AverageAbandonTime'] = self.average_abandon_time
        if self.average_abandoned_in_queue_time is not None:
            result['AverageAbandonedInQueueTime'] = self.average_abandoned_in_queue_time
        if self.average_abandoned_in_ring_time is not None:
            result['AverageAbandonedInRingTime'] = self.average_abandoned_in_ring_time
        if self.average_first_response_time is not None:
            result['AverageFirstResponseTime'] = self.average_first_response_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_response_time is not None:
            result['AverageResponseTime'] = self.average_response_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_wait_time is not None:
            result['AverageWaitTime'] = self.average_wait_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_abandoned is not None:
            result['CallsAbandoned'] = self.calls_abandoned
        if self.calls_abandoned_in_queue is not None:
            result['CallsAbandonedInQueue'] = self.calls_abandoned_in_queue
        if self.calls_abandoned_in_ring is not None:
            result['CallsAbandonedInRing'] = self.calls_abandoned_in_ring
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_overflow is not None:
            result['CallsOverflow'] = self.calls_overflow
        if self.calls_queued is not None:
            result['CallsQueued'] = self.calls_queued
        if self.calls_queuing_failed is not None:
            result['CallsQueuingFailed'] = self.calls_queuing_failed
        if self.calls_queuing_overflow is not None:
            result['CallsQueuingOverflow'] = self.calls_queuing_overflow
        if self.calls_queuing_timeout is not None:
            result['CallsQueuingTimeout'] = self.calls_queuing_timeout
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.calls_timeout is not None:
            result['CallsTimeout'] = self.calls_timeout
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_abandon_time is not None:
            result['MaxAbandonTime'] = self.max_abandon_time
        if self.max_abandoned_in_queue_time is not None:
            result['MaxAbandonedInQueueTime'] = self.max_abandoned_in_queue_time
        if self.max_abandoned_in_ring_time is not None:
            result['MaxAbandonedInRingTime'] = self.max_abandoned_in_ring_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.service_level_15 is not None:
            result['ServiceLevel15'] = self.service_level_15
        if self.service_level_20 is not None:
            result['ServiceLevel20'] = self.service_level_20
        if self.service_level_30 is not None:
            result['ServiceLevel30'] = self.service_level_30
        if self.total_abandon_time is not None:
            result['TotalAbandonTime'] = self.total_abandon_time
        if self.total_abandoned_in_queue_time is not None:
            result['TotalAbandonedInQueueTime'] = self.total_abandoned_in_queue_time
        if self.total_abandoned_in_ring_time is not None:
            result['TotalAbandonedInRingTime'] = self.total_abandoned_in_ring_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_messages_sent is not None:
            result['TotalMessagesSent'] = self.total_messages_sent
        if self.total_messages_sent_by_agent is not None:
            result['TotalMessagesSentByAgent'] = self.total_messages_sent_by_agent
        if self.total_messages_sent_by_customer is not None:
            result['TotalMessagesSentByCustomer'] = self.total_messages_sent_by_customer
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbandonRate') is not None:
            self.abandon_rate = m.get('AbandonRate')
        self.access_channel_type_details = []
        if m.get('AccessChannelTypeDetails') is not None:
            for k in m.get('AccessChannelTypeDetails'):
                temp_model = ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails()
                self.access_channel_type_details.append(temp_model.from_map(k))
        if m.get('AverageAbandonTime') is not None:
            self.average_abandon_time = m.get('AverageAbandonTime')
        if m.get('AverageAbandonedInQueueTime') is not None:
            self.average_abandoned_in_queue_time = m.get('AverageAbandonedInQueueTime')
        if m.get('AverageAbandonedInRingTime') is not None:
            self.average_abandoned_in_ring_time = m.get('AverageAbandonedInRingTime')
        if m.get('AverageFirstResponseTime') is not None:
            self.average_first_response_time = m.get('AverageFirstResponseTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageResponseTime') is not None:
            self.average_response_time = m.get('AverageResponseTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWaitTime') is not None:
            self.average_wait_time = m.get('AverageWaitTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAbandoned') is not None:
            self.calls_abandoned = m.get('CallsAbandoned')
        if m.get('CallsAbandonedInQueue') is not None:
            self.calls_abandoned_in_queue = m.get('CallsAbandonedInQueue')
        if m.get('CallsAbandonedInRing') is not None:
            self.calls_abandoned_in_ring = m.get('CallsAbandonedInRing')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsOverflow') is not None:
            self.calls_overflow = m.get('CallsOverflow')
        if m.get('CallsQueued') is not None:
            self.calls_queued = m.get('CallsQueued')
        if m.get('CallsQueuingFailed') is not None:
            self.calls_queuing_failed = m.get('CallsQueuingFailed')
        if m.get('CallsQueuingOverflow') is not None:
            self.calls_queuing_overflow = m.get('CallsQueuingOverflow')
        if m.get('CallsQueuingTimeout') is not None:
            self.calls_queuing_timeout = m.get('CallsQueuingTimeout')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('CallsTimeout') is not None:
            self.calls_timeout = m.get('CallsTimeout')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxAbandonTime') is not None:
            self.max_abandon_time = m.get('MaxAbandonTime')
        if m.get('MaxAbandonedInQueueTime') is not None:
            self.max_abandoned_in_queue_time = m.get('MaxAbandonedInQueueTime')
        if m.get('MaxAbandonedInRingTime') is not None:
            self.max_abandoned_in_ring_time = m.get('MaxAbandonedInRingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('ServiceLevel15') is not None:
            self.service_level_15 = m.get('ServiceLevel15')
        if m.get('ServiceLevel20') is not None:
            self.service_level_20 = m.get('ServiceLevel20')
        if m.get('ServiceLevel30') is not None:
            self.service_level_30 = m.get('ServiceLevel30')
        if m.get('TotalAbandonTime') is not None:
            self.total_abandon_time = m.get('TotalAbandonTime')
        if m.get('TotalAbandonedInQueueTime') is not None:
            self.total_abandoned_in_queue_time = m.get('TotalAbandonedInQueueTime')
        if m.get('TotalAbandonedInRingTime') is not None:
            self.total_abandoned_in_ring_time = m.get('TotalAbandonedInRingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalMessagesSent') is not None:
            self.total_messages_sent = m.get('TotalMessagesSent')
        if m.get('TotalMessagesSentByAgent') is not None:
            self.total_messages_sent_by_agent = m.get('TotalMessagesSentByAgent')
        if m.get('TotalMessagesSentByCustomer') is not None:
            self.total_messages_sent_by_customer = m.get('TotalMessagesSentByCustomer')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalSkillGroupReportResponseBodyDataListOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: float = None,
        average_hold_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_answered: int = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_dialed: int = None,
        calls_hold: int = None,
        calls_ringed: int = None,
        max_dialing_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_hold_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_hold_time = average_hold_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_dialed = calls_dialed
        self.calls_hold = calls_hold
        self.calls_ringed = calls_ringed
        self.max_dialing_time = max_dialing_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_hold_time = total_hold_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        count: int = None,
        duration: int = None,
    ):
        self.break_code = break_code
        self.count = count
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.count is not None:
            result['Count'] = self.count
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class ListHistoricalSkillGroupReportResponseBodyDataListOverall(TeaModel):
    def __init__(
        self,
        average_break_time: float = None,
        average_hold_time: float = None,
        average_ready_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        break_code_detail_list: List[ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList] = None,
        max_break_time: int = None,
        max_hold_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_hold_time: int = None,
        total_logged_in_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_break_time = average_break_time
        self.average_hold_time = average_hold_time
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.break_code_detail_list = break_code_detail_list
        self.max_break_time = max_break_time
        self.max_hold_time = max_hold_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_hold_time = total_hold_time
        self.total_logged_in_time = total_logged_in_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.break_code_detail_list:
            for k in self.break_code_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_break_time is not None:
            result['AverageBreakTime'] = self.average_break_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        result['BreakCodeDetailList'] = []
        if self.break_code_detail_list is not None:
            for k in self.break_code_detail_list:
                result['BreakCodeDetailList'].append(k.to_map() if k else None)
        if self.max_break_time is not None:
            result['MaxBreakTime'] = self.max_break_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageBreakTime') is not None:
            self.average_break_time = m.get('AverageBreakTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        self.break_code_detail_list = []
        if m.get('BreakCodeDetailList') is not None:
            for k in m.get('BreakCodeDetailList'):
                temp_model = ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList()
                self.break_code_detail_list.append(temp_model.from_map(k))
        if m.get('MaxBreakTime') is not None:
            self.max_break_time = m.get('MaxBreakTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListHistoricalSkillGroupReportResponseBodyDataList(TeaModel):
    def __init__(
        self,
        back_2back: ListHistoricalSkillGroupReportResponseBodyDataListBack2Back = None,
        inbound: ListHistoricalSkillGroupReportResponseBodyDataListInbound = None,
        outbound: ListHistoricalSkillGroupReportResponseBodyDataListOutbound = None,
        overall: ListHistoricalSkillGroupReportResponseBodyDataListOverall = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
    ):
        self.back_2back = back_2back
        self.inbound = inbound
        self.outbound = outbound
        self.overall = overall
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name

    def validate(self):
        if self.back_2back:
            self.back_2back.validate()
        if self.inbound:
            self.inbound.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.back_2back is not None:
            result['Back2Back'] = self.back_2back.to_map()
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Back2Back') is not None:
            temp_model = ListHistoricalSkillGroupReportResponseBodyDataListBack2Back()
            self.back_2back = temp_model.from_map(m['Back2Back'])
        if m.get('Inbound') is not None:
            temp_model = ListHistoricalSkillGroupReportResponseBodyDataListInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('Outbound') is not None:
            temp_model = ListHistoricalSkillGroupReportResponseBodyDataListOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListHistoricalSkillGroupReportResponseBodyDataListOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        return self


class ListHistoricalSkillGroupReportResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListHistoricalSkillGroupReportResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListHistoricalSkillGroupReportResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHistoricalSkillGroupReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListHistoricalSkillGroupReportResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListHistoricalSkillGroupReportResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListHistoricalSkillGroupReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHistoricalSkillGroupReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHistoricalSkillGroupReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstancesRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInstancesResponseBodyDataListAdminList(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        email: str = None,
        extension: str = None,
        instance_id: str = None,
        login_name: str = None,
        mobile: str = None,
        role_id: str = None,
        role_name: str = None,
        user_id: str = None,
        work_mode: str = None,
    ):
        self.display_name = display_name
        self.email = email
        self.extension = extension
        self.instance_id = instance_id
        self.login_name = login_name
        self.mobile = mobile
        self.role_id = role_id
        self.role_name = role_name
        self.user_id = user_id
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.email is not None:
            result['Email'] = self.email
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ListInstancesResponseBodyDataListNumberList(TeaModel):
    def __init__(
        self,
        number: str = None,
    ):
        self.number = number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.number is not None:
            result['Number'] = self.number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Number') is not None:
            self.number = m.get('Number')
        return self


class ListInstancesResponseBodyDataList(TeaModel):
    def __init__(
        self,
        admin_list: List[ListInstancesResponseBodyDataListAdminList] = None,
        aliyun_uid: str = None,
        console_url: str = None,
        create_time: int = None,
        description: str = None,
        domain_name: str = None,
        id: str = None,
        name: str = None,
        number_list: List[ListInstancesResponseBodyDataListNumberList] = None,
        status: str = None,
    ):
        self.admin_list = admin_list
        self.aliyun_uid = aliyun_uid
        self.console_url = console_url
        self.create_time = create_time
        self.description = description
        self.domain_name = domain_name
        self.id = id
        self.name = name
        self.number_list = number_list
        self.status = status

    def validate(self):
        if self.admin_list:
            for k in self.admin_list:
                if k:
                    k.validate()
        if self.number_list:
            for k in self.number_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdminList'] = []
        if self.admin_list is not None:
            for k in self.admin_list:
                result['AdminList'].append(k.to_map() if k else None)
        if self.aliyun_uid is not None:
            result['AliyunUid'] = self.aliyun_uid
        if self.console_url is not None:
            result['ConsoleUrl'] = self.console_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['NumberList'] = []
        if self.number_list is not None:
            for k in self.number_list:
                result['NumberList'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.admin_list = []
        if m.get('AdminList') is not None:
            for k in m.get('AdminList'):
                temp_model = ListInstancesResponseBodyDataListAdminList()
                self.admin_list.append(temp_model.from_map(k))
        if m.get('AliyunUid') is not None:
            self.aliyun_uid = m.get('AliyunUid')
        if m.get('ConsoleUrl') is not None:
            self.console_url = m.get('ConsoleUrl')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.number_list = []
        if m.get('NumberList') is not None:
            for k in m.get('NumberList'):
                temp_model = ListInstancesResponseBodyDataListNumberList()
                self.number_list.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListInstancesResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListInstancesResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListInstancesResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListInstancesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListInstancesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstancesOfUserRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInstancesOfUserResponseBodyDataListAdminList(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        email: str = None,
        extension: str = None,
        instance_id: str = None,
        login_name: str = None,
        mobile: str = None,
        role_id: str = None,
        role_name: str = None,
        user_id: str = None,
        work_mode: str = None,
    ):
        self.display_name = display_name
        self.email = email
        self.extension = extension
        self.instance_id = instance_id
        self.login_name = login_name
        self.mobile = mobile
        self.role_id = role_id
        self.role_name = role_name
        self.user_id = user_id
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.email is not None:
            result['Email'] = self.email
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ListInstancesOfUserResponseBodyDataListNumberListSkillGroups(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        instance_id: str = None,
        name: str = None,
        phone_number_count: int = None,
        skill_group_id: str = None,
        user_count: int = None,
    ):
        self.description = description
        self.display_name = display_name
        self.instance_id = instance_id
        self.name = name
        self.phone_number_count = phone_number_count
        self.skill_group_id = skill_group_id
        self.user_count = user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.phone_number_count is not None:
            result['PhoneNumberCount'] = self.phone_number_count
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.user_count is not None:
            result['UserCount'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PhoneNumberCount') is not None:
            self.phone_number_count = m.get('PhoneNumberCount')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('UserCount') is not None:
            self.user_count = m.get('UserCount')
        return self


class ListInstancesOfUserResponseBodyDataListNumberList(TeaModel):
    def __init__(
        self,
        active: bool = None,
        city: str = None,
        contact_flow_id: str = None,
        instance_id: str = None,
        number: str = None,
        province: str = None,
        skill_groups: List[ListInstancesOfUserResponseBodyDataListNumberListSkillGroups] = None,
        usage: str = None,
        user_id: str = None,
    ):
        self.active = active
        self.city = city
        self.contact_flow_id = contact_flow_id
        self.instance_id = instance_id
        self.number = number
        self.province = province
        self.skill_groups = skill_groups
        self.usage = usage
        self.user_id = user_id

    def validate(self):
        if self.skill_groups:
            for k in self.skill_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.city is not None:
            result['City'] = self.city
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        result['SkillGroups'] = []
        if self.skill_groups is not None:
            for k in self.skill_groups:
                result['SkillGroups'].append(k.to_map() if k else None)
        if self.usage is not None:
            result['Usage'] = self.usage
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        self.skill_groups = []
        if m.get('SkillGroups') is not None:
            for k in m.get('SkillGroups'):
                temp_model = ListInstancesOfUserResponseBodyDataListNumberListSkillGroups()
                self.skill_groups.append(temp_model.from_map(k))
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListInstancesOfUserResponseBodyDataList(TeaModel):
    def __init__(
        self,
        admin_list: List[ListInstancesOfUserResponseBodyDataListAdminList] = None,
        aliyun_uid: str = None,
        console_url: str = None,
        description: str = None,
        domain_name: str = None,
        id: str = None,
        name: str = None,
        number_list: List[ListInstancesOfUserResponseBodyDataListNumberList] = None,
        status: str = None,
    ):
        self.admin_list = admin_list
        self.aliyun_uid = aliyun_uid
        self.console_url = console_url
        self.description = description
        self.domain_name = domain_name
        self.id = id
        self.name = name
        self.number_list = number_list
        self.status = status

    def validate(self):
        if self.admin_list:
            for k in self.admin_list:
                if k:
                    k.validate()
        if self.number_list:
            for k in self.number_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdminList'] = []
        if self.admin_list is not None:
            for k in self.admin_list:
                result['AdminList'].append(k.to_map() if k else None)
        if self.aliyun_uid is not None:
            result['AliyunUid'] = self.aliyun_uid
        if self.console_url is not None:
            result['ConsoleUrl'] = self.console_url
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['NumberList'] = []
        if self.number_list is not None:
            for k in self.number_list:
                result['NumberList'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.admin_list = []
        if m.get('AdminList') is not None:
            for k in m.get('AdminList'):
                temp_model = ListInstancesOfUserResponseBodyDataListAdminList()
                self.admin_list.append(temp_model.from_map(k))
        if m.get('AliyunUid') is not None:
            self.aliyun_uid = m.get('AliyunUid')
        if m.get('ConsoleUrl') is not None:
            self.console_url = m.get('ConsoleUrl')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.number_list = []
        if m.get('NumberList') is not None:
            for k in m.get('NumberList'):
                temp_model = ListInstancesOfUserResponseBodyDataListNumberList()
                self.number_list.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListInstancesOfUserResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListInstancesOfUserResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListInstancesOfUserResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstancesOfUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListInstancesOfUserResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListInstancesOfUserResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListInstancesOfUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstancesOfUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstancesOfUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntervalAgentReportRequest(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        interval: str = None,
        media_type: str = None,
        start_time: int = None,
    ):
        # This parameter is required.
        self.agent_id = agent_id
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.interval = interval
        self.media_type = media_type
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListIntervalAgentReportResponseBodyDataBack2Back(TeaModel):
    def __init__(
        self,
        agent_handle_rate: float = None,
        answer_rate: float = None,
        average_customer_ring_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        calls_agent_handled: int = None,
        calls_answered: int = None,
        calls_customer_answered: int = None,
        calls_dialed: int = None,
        customer_answer_rate: float = None,
        max_customer_ring_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        total_customer_ring_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
    ):
        self.agent_handle_rate = agent_handle_rate
        self.answer_rate = answer_rate
        self.average_customer_ring_time = average_customer_ring_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.calls_agent_handled = calls_agent_handled
        self.calls_answered = calls_answered
        self.calls_customer_answered = calls_customer_answered
        self.calls_dialed = calls_dialed
        self.customer_answer_rate = customer_answer_rate
        self.max_customer_ring_time = max_customer_ring_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.total_customer_ring_time = total_customer_ring_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_handle_rate is not None:
            result['AgentHandleRate'] = self.agent_handle_rate
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_customer_ring_time is not None:
            result['AverageCustomerRingTime'] = self.average_customer_ring_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_agent_handled is not None:
            result['CallsAgentHandled'] = self.calls_agent_handled
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_customer_answered is not None:
            result['CallsCustomerAnswered'] = self.calls_customer_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.customer_answer_rate is not None:
            result['CustomerAnswerRate'] = self.customer_answer_rate
        if self.max_customer_ring_time is not None:
            result['MaxCustomerRingTime'] = self.max_customer_ring_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_customer_ring_time is not None:
            result['TotalCustomerRingTime'] = self.total_customer_ring_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentHandleRate') is not None:
            self.agent_handle_rate = m.get('AgentHandleRate')
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageCustomerRingTime') is not None:
            self.average_customer_ring_time = m.get('AverageCustomerRingTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAgentHandled') is not None:
            self.calls_agent_handled = m.get('CallsAgentHandled')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsCustomerAnswered') is not None:
            self.calls_customer_answered = m.get('CallsCustomerAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CustomerAnswerRate') is not None:
            self.customer_answer_rate = m.get('CustomerAnswerRate')
        if m.get('MaxCustomerRingTime') is not None:
            self.max_customer_ring_time = m.get('MaxCustomerRingTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalCustomerRingTime') is not None:
            self.total_customer_ring_time = m.get('TotalCustomerRingTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails(TeaModel):
    def __init__(
        self,
        access_channel_type: str = None,
        calls_offered: int = None,
    ):
        self.access_channel_type = access_channel_type
        self.calls_offered = calls_offered

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_type is not None:
            result['AccessChannelType'] = self.access_channel_type
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelType') is not None:
            self.access_channel_type = m.get('AccessChannelType')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        return self


class ListIntervalAgentReportResponseBodyDataInbound(TeaModel):
    def __init__(
        self,
        access_channel_type_details: List[ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails] = None,
        average_first_response_time: float = None,
        average_hold_time: float = None,
        average_response_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_handled: int = None,
        calls_hold: int = None,
        calls_offered: int = None,
        calls_ringed: int = None,
        handle_rate: float = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        service_level_15: float = None,
        total_hold_time: int = None,
        total_messages_sent: int = None,
        total_messages_sent_by_agent: int = None,
        total_messages_sent_by_customer: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.access_channel_type_details = access_channel_type_details
        self.average_first_response_time = average_first_response_time
        self.average_hold_time = average_hold_time
        self.average_response_time = average_response_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_handled = calls_handled
        self.calls_hold = calls_hold
        self.calls_offered = calls_offered
        self.calls_ringed = calls_ringed
        self.handle_rate = handle_rate
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.service_level_15 = service_level_15
        self.total_hold_time = total_hold_time
        self.total_messages_sent = total_messages_sent
        self.total_messages_sent_by_agent = total_messages_sent_by_agent
        self.total_messages_sent_by_customer = total_messages_sent_by_customer
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.access_channel_type_details:
            for k in self.access_channel_type_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AccessChannelTypeDetails'] = []
        if self.access_channel_type_details is not None:
            for k in self.access_channel_type_details:
                result['AccessChannelTypeDetails'].append(k.to_map() if k else None)
        if self.average_first_response_time is not None:
            result['AverageFirstResponseTime'] = self.average_first_response_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_response_time is not None:
            result['AverageResponseTime'] = self.average_response_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.service_level_15 is not None:
            result['ServiceLevel15'] = self.service_level_15
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_messages_sent is not None:
            result['TotalMessagesSent'] = self.total_messages_sent
        if self.total_messages_sent_by_agent is not None:
            result['TotalMessagesSentByAgent'] = self.total_messages_sent_by_agent
        if self.total_messages_sent_by_customer is not None:
            result['TotalMessagesSentByCustomer'] = self.total_messages_sent_by_customer
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.access_channel_type_details = []
        if m.get('AccessChannelTypeDetails') is not None:
            for k in m.get('AccessChannelTypeDetails'):
                temp_model = ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails()
                self.access_channel_type_details.append(temp_model.from_map(k))
        if m.get('AverageFirstResponseTime') is not None:
            self.average_first_response_time = m.get('AverageFirstResponseTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageResponseTime') is not None:
            self.average_response_time = m.get('AverageResponseTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('ServiceLevel15') is not None:
            self.service_level_15 = m.get('ServiceLevel15')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalMessagesSent') is not None:
            self.total_messages_sent = m.get('TotalMessagesSent')
        if m.get('TotalMessagesSentByAgent') is not None:
            self.total_messages_sent_by_agent = m.get('TotalMessagesSentByAgent')
        if m.get('TotalMessagesSentByCustomer') is not None:
            self.total_messages_sent_by_customer = m.get('TotalMessagesSentByCustomer')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalAgentReportResponseBodyDataInternal(TeaModel):
    def __init__(
        self,
        average_talk_time: float = None,
        calls_answered: int = None,
        calls_dialed: int = None,
        calls_handled: int = None,
        calls_offered: int = None,
        calls_talked: int = None,
    ):
        self.average_talk_time = average_talk_time
        self.calls_answered = calls_answered
        self.calls_dialed = calls_dialed
        self.calls_handled = calls_handled
        self.calls_offered = calls_offered
        self.calls_talked = calls_talked

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_talked is not None:
            result['CallsTalked'] = self.calls_talked
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsTalked') is not None:
            self.calls_talked = m.get('CallsTalked')
        return self


class ListIntervalAgentReportResponseBodyDataOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: float = None,
        average_hold_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_answered: int = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_dialed: int = None,
        calls_hold: int = None,
        calls_ringed: int = None,
        max_dialing_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_hold_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_hold_time = average_hold_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_dialed = calls_dialed
        self.calls_hold = calls_hold
        self.calls_ringed = calls_ringed
        self.max_dialing_time = max_dialing_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_hold_time = total_hold_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        count: int = None,
        duration: int = None,
    ):
        self.break_code = break_code
        self.count = count
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.count is not None:
            result['Count'] = self.count
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class ListIntervalAgentReportResponseBodyDataOverall(TeaModel):
    def __init__(
        self,
        average_break_time: float = None,
        average_hold_time: float = None,
        average_ready_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        break_code_detail_list: List[ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList] = None,
        first_check_in_time: int = None,
        last_check_out_time: int = None,
        last_checkout_time: int = None,
        max_break_time: int = None,
        max_hold_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_hold_time: int = None,
        total_logged_in_time: int = None,
        total_off_site_logged_in_time: int = None,
        total_off_site_online_time: int = None,
        total_office_phone_logged_in_time: int = None,
        total_office_phone_online_time: int = None,
        total_on_site_logged_in_time: int = None,
        total_on_site_online_time: int = None,
        total_outbound_scenario_logged_in_time: int = None,
        total_outbound_scenario_ready_time: int = None,
        total_outbound_scenario_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_break_time = average_break_time
        self.average_hold_time = average_hold_time
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.break_code_detail_list = break_code_detail_list
        self.first_check_in_time = first_check_in_time
        self.last_check_out_time = last_check_out_time
        self.last_checkout_time = last_checkout_time
        self.max_break_time = max_break_time
        self.max_hold_time = max_hold_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_hold_time = total_hold_time
        self.total_logged_in_time = total_logged_in_time
        self.total_off_site_logged_in_time = total_off_site_logged_in_time
        self.total_off_site_online_time = total_off_site_online_time
        self.total_office_phone_logged_in_time = total_office_phone_logged_in_time
        self.total_office_phone_online_time = total_office_phone_online_time
        self.total_on_site_logged_in_time = total_on_site_logged_in_time
        self.total_on_site_online_time = total_on_site_online_time
        self.total_outbound_scenario_logged_in_time = total_outbound_scenario_logged_in_time
        self.total_outbound_scenario_ready_time = total_outbound_scenario_ready_time
        self.total_outbound_scenario_time = total_outbound_scenario_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.break_code_detail_list:
            for k in self.break_code_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_break_time is not None:
            result['AverageBreakTime'] = self.average_break_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        result['BreakCodeDetailList'] = []
        if self.break_code_detail_list is not None:
            for k in self.break_code_detail_list:
                result['BreakCodeDetailList'].append(k.to_map() if k else None)
        if self.first_check_in_time is not None:
            result['FirstCheckInTime'] = self.first_check_in_time
        if self.last_check_out_time is not None:
            result['LastCheckOutTime'] = self.last_check_out_time
        if self.last_checkout_time is not None:
            result['LastCheckoutTime'] = self.last_checkout_time
        if self.max_break_time is not None:
            result['MaxBreakTime'] = self.max_break_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_off_site_logged_in_time is not None:
            result['TotalOffSiteLoggedInTime'] = self.total_off_site_logged_in_time
        if self.total_off_site_online_time is not None:
            result['TotalOffSiteOnlineTime'] = self.total_off_site_online_time
        if self.total_office_phone_logged_in_time is not None:
            result['TotalOfficePhoneLoggedInTime'] = self.total_office_phone_logged_in_time
        if self.total_office_phone_online_time is not None:
            result['TotalOfficePhoneOnlineTime'] = self.total_office_phone_online_time
        if self.total_on_site_logged_in_time is not None:
            result['TotalOnSiteLoggedInTime'] = self.total_on_site_logged_in_time
        if self.total_on_site_online_time is not None:
            result['TotalOnSiteOnlineTime'] = self.total_on_site_online_time
        if self.total_outbound_scenario_logged_in_time is not None:
            result['TotalOutboundScenarioLoggedInTime'] = self.total_outbound_scenario_logged_in_time
        if self.total_outbound_scenario_ready_time is not None:
            result['TotalOutboundScenarioReadyTime'] = self.total_outbound_scenario_ready_time
        if self.total_outbound_scenario_time is not None:
            result['TotalOutboundScenarioTime'] = self.total_outbound_scenario_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageBreakTime') is not None:
            self.average_break_time = m.get('AverageBreakTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        self.break_code_detail_list = []
        if m.get('BreakCodeDetailList') is not None:
            for k in m.get('BreakCodeDetailList'):
                temp_model = ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList()
                self.break_code_detail_list.append(temp_model.from_map(k))
        if m.get('FirstCheckInTime') is not None:
            self.first_check_in_time = m.get('FirstCheckInTime')
        if m.get('LastCheckOutTime') is not None:
            self.last_check_out_time = m.get('LastCheckOutTime')
        if m.get('LastCheckoutTime') is not None:
            self.last_checkout_time = m.get('LastCheckoutTime')
        if m.get('MaxBreakTime') is not None:
            self.max_break_time = m.get('MaxBreakTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalOffSiteLoggedInTime') is not None:
            self.total_off_site_logged_in_time = m.get('TotalOffSiteLoggedInTime')
        if m.get('TotalOffSiteOnlineTime') is not None:
            self.total_off_site_online_time = m.get('TotalOffSiteOnlineTime')
        if m.get('TotalOfficePhoneLoggedInTime') is not None:
            self.total_office_phone_logged_in_time = m.get('TotalOfficePhoneLoggedInTime')
        if m.get('TotalOfficePhoneOnlineTime') is not None:
            self.total_office_phone_online_time = m.get('TotalOfficePhoneOnlineTime')
        if m.get('TotalOnSiteLoggedInTime') is not None:
            self.total_on_site_logged_in_time = m.get('TotalOnSiteLoggedInTime')
        if m.get('TotalOnSiteOnlineTime') is not None:
            self.total_on_site_online_time = m.get('TotalOnSiteOnlineTime')
        if m.get('TotalOutboundScenarioLoggedInTime') is not None:
            self.total_outbound_scenario_logged_in_time = m.get('TotalOutboundScenarioLoggedInTime')
        if m.get('TotalOutboundScenarioReadyTime') is not None:
            self.total_outbound_scenario_ready_time = m.get('TotalOutboundScenarioReadyTime')
        if m.get('TotalOutboundScenarioTime') is not None:
            self.total_outbound_scenario_time = m.get('TotalOutboundScenarioTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalAgentReportResponseBodyData(TeaModel):
    def __init__(
        self,
        back_2back: ListIntervalAgentReportResponseBodyDataBack2Back = None,
        inbound: ListIntervalAgentReportResponseBodyDataInbound = None,
        internal: ListIntervalAgentReportResponseBodyDataInternal = None,
        outbound: ListIntervalAgentReportResponseBodyDataOutbound = None,
        overall: ListIntervalAgentReportResponseBodyDataOverall = None,
        stats_time: int = None,
    ):
        self.back_2back = back_2back
        self.inbound = inbound
        self.internal = internal
        self.outbound = outbound
        self.overall = overall
        self.stats_time = stats_time

    def validate(self):
        if self.back_2back:
            self.back_2back.validate()
        if self.inbound:
            self.inbound.validate()
        if self.internal:
            self.internal.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.back_2back is not None:
            result['Back2Back'] = self.back_2back.to_map()
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.internal is not None:
            result['Internal'] = self.internal.to_map()
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.stats_time is not None:
            result['StatsTime'] = self.stats_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Back2Back') is not None:
            temp_model = ListIntervalAgentReportResponseBodyDataBack2Back()
            self.back_2back = temp_model.from_map(m['Back2Back'])
        if m.get('Inbound') is not None:
            temp_model = ListIntervalAgentReportResponseBodyDataInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('Internal') is not None:
            temp_model = ListIntervalAgentReportResponseBodyDataInternal()
            self.internal = temp_model.from_map(m['Internal'])
        if m.get('Outbound') is not None:
            temp_model = ListIntervalAgentReportResponseBodyDataOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListIntervalAgentReportResponseBodyDataOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('StatsTime') is not None:
            self.stats_time = m.get('StatsTime')
        return self


class ListIntervalAgentReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListIntervalAgentReportResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListIntervalAgentReportResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListIntervalAgentReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntervalAgentReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntervalAgentReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntervalAgentSkillGroupReportRequest(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        interval: str = None,
        skill_group_id: str = None,
        start_time: int = None,
    ):
        # This parameter is required.
        self.agent_id = agent_id
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.interval = interval
        # This parameter is required.
        self.skill_group_id = skill_group_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back(TeaModel):
    def __init__(
        self,
        agent_answer_rate: float = None,
        agent_handle_rate: float = None,
        answer_rate: float = None,
        average_customer_ring_time: float = None,
        average_ring_time: float = None,
        average_talk_time: int = None,
        calls_agent_handled: int = None,
        calls_answered: int = None,
        calls_customer_answered: int = None,
        calls_customer_handled: int = None,
        calls_dialed: int = None,
        customer_answer_rate: float = None,
        customer_handle_rate: float = None,
        max_customer_ring_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        total_customer_ring_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
    ):
        self.agent_answer_rate = agent_answer_rate
        self.agent_handle_rate = agent_handle_rate
        self.answer_rate = answer_rate
        self.average_customer_ring_time = average_customer_ring_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.calls_agent_handled = calls_agent_handled
        self.calls_answered = calls_answered
        self.calls_customer_answered = calls_customer_answered
        self.calls_customer_handled = calls_customer_handled
        self.calls_dialed = calls_dialed
        self.customer_answer_rate = customer_answer_rate
        self.customer_handle_rate = customer_handle_rate
        self.max_customer_ring_time = max_customer_ring_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.total_customer_ring_time = total_customer_ring_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_answer_rate is not None:
            result['AgentAnswerRate'] = self.agent_answer_rate
        if self.agent_handle_rate is not None:
            result['AgentHandleRate'] = self.agent_handle_rate
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_customer_ring_time is not None:
            result['AverageCustomerRingTime'] = self.average_customer_ring_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_agent_handled is not None:
            result['CallsAgentHandled'] = self.calls_agent_handled
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_customer_answered is not None:
            result['CallsCustomerAnswered'] = self.calls_customer_answered
        if self.calls_customer_handled is not None:
            result['CallsCustomerHandled'] = self.calls_customer_handled
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.customer_answer_rate is not None:
            result['CustomerAnswerRate'] = self.customer_answer_rate
        if self.customer_handle_rate is not None:
            result['CustomerHandleRate'] = self.customer_handle_rate
        if self.max_customer_ring_time is not None:
            result['MaxCustomerRingTime'] = self.max_customer_ring_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_customer_ring_time is not None:
            result['TotalCustomerRingTime'] = self.total_customer_ring_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentAnswerRate') is not None:
            self.agent_answer_rate = m.get('AgentAnswerRate')
        if m.get('AgentHandleRate') is not None:
            self.agent_handle_rate = m.get('AgentHandleRate')
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageCustomerRingTime') is not None:
            self.average_customer_ring_time = m.get('AverageCustomerRingTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAgentHandled') is not None:
            self.calls_agent_handled = m.get('CallsAgentHandled')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsCustomerAnswered') is not None:
            self.calls_customer_answered = m.get('CallsCustomerAnswered')
        if m.get('CallsCustomerHandled') is not None:
            self.calls_customer_handled = m.get('CallsCustomerHandled')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CustomerAnswerRate') is not None:
            self.customer_answer_rate = m.get('CustomerAnswerRate')
        if m.get('CustomerHandleRate') is not None:
            self.customer_handle_rate = m.get('CustomerHandleRate')
        if m.get('MaxCustomerRingTime') is not None:
            self.max_customer_ring_time = m.get('MaxCustomerRingTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalCustomerRingTime') is not None:
            self.total_customer_ring_time = m.get('TotalCustomerRingTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListIntervalAgentSkillGroupReportResponseBodyDataInbound(TeaModel):
    def __init__(
        self,
        average_first_response_time: float = None,
        average_hold_time: float = None,
        average_response_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_handled: int = None,
        calls_hold: int = None,
        calls_offered: int = None,
        calls_ringed: int = None,
        handle_rate: float = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_hold_time: int = None,
        total_messages_sent: int = None,
        total_messages_sent_by_agent: int = None,
        total_messages_sent_by_customer: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_first_response_time = average_first_response_time
        self.average_hold_time = average_hold_time
        self.average_response_time = average_response_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_handled = calls_handled
        self.calls_hold = calls_hold
        self.calls_offered = calls_offered
        self.calls_ringed = calls_ringed
        self.handle_rate = handle_rate
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_hold_time = total_hold_time
        self.total_messages_sent = total_messages_sent
        self.total_messages_sent_by_agent = total_messages_sent_by_agent
        self.total_messages_sent_by_customer = total_messages_sent_by_customer
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_first_response_time is not None:
            result['AverageFirstResponseTime'] = self.average_first_response_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_response_time is not None:
            result['AverageResponseTime'] = self.average_response_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_messages_sent is not None:
            result['TotalMessagesSent'] = self.total_messages_sent
        if self.total_messages_sent_by_agent is not None:
            result['TotalMessagesSentByAgent'] = self.total_messages_sent_by_agent
        if self.total_messages_sent_by_customer is not None:
            result['TotalMessagesSentByCustomer'] = self.total_messages_sent_by_customer
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageFirstResponseTime') is not None:
            self.average_first_response_time = m.get('AverageFirstResponseTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageResponseTime') is not None:
            self.average_response_time = m.get('AverageResponseTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalMessagesSent') is not None:
            self.total_messages_sent = m.get('TotalMessagesSent')
        if m.get('TotalMessagesSentByAgent') is not None:
            self.total_messages_sent_by_agent = m.get('TotalMessagesSentByAgent')
        if m.get('TotalMessagesSentByCustomer') is not None:
            self.total_messages_sent_by_customer = m.get('TotalMessagesSentByCustomer')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalAgentSkillGroupReportResponseBodyDataInternal(TeaModel):
    def __init__(
        self,
        average_talk_time: float = None,
        calls_answered: int = None,
        calls_dialed: int = None,
        calls_handled: int = None,
        calls_offered: int = None,
        calls_talk: int = None,
        calls_talked: int = None,
        max_talk_time: int = None,
        total_talk_time: int = None,
    ):
        self.average_talk_time = average_talk_time
        self.calls_answered = calls_answered
        self.calls_dialed = calls_dialed
        self.calls_handled = calls_handled
        self.calls_offered = calls_offered
        self.calls_talk = calls_talk
        self.calls_talked = calls_talked
        self.max_talk_time = max_talk_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_talk is not None:
            result['CallsTalk'] = self.calls_talk
        if self.calls_talked is not None:
            result['CallsTalked'] = self.calls_talked
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsTalk') is not None:
            self.calls_talk = m.get('CallsTalk')
        if m.get('CallsTalked') is not None:
            self.calls_talked = m.get('CallsTalked')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListIntervalAgentSkillGroupReportResponseBodyDataOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: float = None,
        average_hold_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_answered: int = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_dialed: int = None,
        calls_hold: int = None,
        calls_ringed: int = None,
        max_dialing_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_hold_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_hold_time = average_hold_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_dialed = calls_dialed
        self.calls_hold = calls_hold
        self.calls_ringed = calls_ringed
        self.max_dialing_time = max_dialing_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_hold_time = total_hold_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        count: int = None,
        duration: int = None,
    ):
        self.break_code = break_code
        self.count = count
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.count is not None:
            result['Count'] = self.count
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class ListIntervalAgentSkillGroupReportResponseBodyDataOverall(TeaModel):
    def __init__(
        self,
        average_break_time: float = None,
        average_hold_time: float = None,
        average_ready_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        break_code_detail_list: List[ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList] = None,
        first_check_in_time: int = None,
        last_check_out_time: int = None,
        last_checkout_time: int = None,
        max_break_time: int = None,
        max_hold_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_hold_time: int = None,
        total_logged_in_time: int = None,
        total_off_site_logged_in_time: str = None,
        total_office_phone_logged_in_time: str = None,
        total_on_site_logged_in_time: str = None,
        total_outbound_scenario_logged_in_time: int = None,
        total_outbound_scenario_ready_time: int = None,
        total_outbound_scenario_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_break_time = average_break_time
        self.average_hold_time = average_hold_time
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.break_code_detail_list = break_code_detail_list
        self.first_check_in_time = first_check_in_time
        self.last_check_out_time = last_check_out_time
        self.last_checkout_time = last_checkout_time
        self.max_break_time = max_break_time
        self.max_hold_time = max_hold_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_hold_time = total_hold_time
        self.total_logged_in_time = total_logged_in_time
        self.total_off_site_logged_in_time = total_off_site_logged_in_time
        self.total_office_phone_logged_in_time = total_office_phone_logged_in_time
        self.total_on_site_logged_in_time = total_on_site_logged_in_time
        self.total_outbound_scenario_logged_in_time = total_outbound_scenario_logged_in_time
        self.total_outbound_scenario_ready_time = total_outbound_scenario_ready_time
        self.total_outbound_scenario_time = total_outbound_scenario_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.break_code_detail_list:
            for k in self.break_code_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_break_time is not None:
            result['AverageBreakTime'] = self.average_break_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        result['BreakCodeDetailList'] = []
        if self.break_code_detail_list is not None:
            for k in self.break_code_detail_list:
                result['BreakCodeDetailList'].append(k.to_map() if k else None)
        if self.first_check_in_time is not None:
            result['FirstCheckInTime'] = self.first_check_in_time
        if self.last_check_out_time is not None:
            result['LastCheckOutTime'] = self.last_check_out_time
        if self.last_checkout_time is not None:
            result['LastCheckoutTime'] = self.last_checkout_time
        if self.max_break_time is not None:
            result['MaxBreakTime'] = self.max_break_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_off_site_logged_in_time is not None:
            result['TotalOffSiteLoggedInTime'] = self.total_off_site_logged_in_time
        if self.total_office_phone_logged_in_time is not None:
            result['TotalOfficePhoneLoggedInTime'] = self.total_office_phone_logged_in_time
        if self.total_on_site_logged_in_time is not None:
            result['TotalOnSiteLoggedInTime'] = self.total_on_site_logged_in_time
        if self.total_outbound_scenario_logged_in_time is not None:
            result['TotalOutboundScenarioLoggedInTime'] = self.total_outbound_scenario_logged_in_time
        if self.total_outbound_scenario_ready_time is not None:
            result['TotalOutboundScenarioReadyTime'] = self.total_outbound_scenario_ready_time
        if self.total_outbound_scenario_time is not None:
            result['TotalOutboundScenarioTime'] = self.total_outbound_scenario_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageBreakTime') is not None:
            self.average_break_time = m.get('AverageBreakTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        self.break_code_detail_list = []
        if m.get('BreakCodeDetailList') is not None:
            for k in m.get('BreakCodeDetailList'):
                temp_model = ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList()
                self.break_code_detail_list.append(temp_model.from_map(k))
        if m.get('FirstCheckInTime') is not None:
            self.first_check_in_time = m.get('FirstCheckInTime')
        if m.get('LastCheckOutTime') is not None:
            self.last_check_out_time = m.get('LastCheckOutTime')
        if m.get('LastCheckoutTime') is not None:
            self.last_checkout_time = m.get('LastCheckoutTime')
        if m.get('MaxBreakTime') is not None:
            self.max_break_time = m.get('MaxBreakTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalOffSiteLoggedInTime') is not None:
            self.total_off_site_logged_in_time = m.get('TotalOffSiteLoggedInTime')
        if m.get('TotalOfficePhoneLoggedInTime') is not None:
            self.total_office_phone_logged_in_time = m.get('TotalOfficePhoneLoggedInTime')
        if m.get('TotalOnSiteLoggedInTime') is not None:
            self.total_on_site_logged_in_time = m.get('TotalOnSiteLoggedInTime')
        if m.get('TotalOutboundScenarioLoggedInTime') is not None:
            self.total_outbound_scenario_logged_in_time = m.get('TotalOutboundScenarioLoggedInTime')
        if m.get('TotalOutboundScenarioReadyTime') is not None:
            self.total_outbound_scenario_ready_time = m.get('TotalOutboundScenarioReadyTime')
        if m.get('TotalOutboundScenarioTime') is not None:
            self.total_outbound_scenario_time = m.get('TotalOutboundScenarioTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalAgentSkillGroupReportResponseBodyData(TeaModel):
    def __init__(
        self,
        back_2back: ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back = None,
        inbound: ListIntervalAgentSkillGroupReportResponseBodyDataInbound = None,
        internal: ListIntervalAgentSkillGroupReportResponseBodyDataInternal = None,
        outbound: ListIntervalAgentSkillGroupReportResponseBodyDataOutbound = None,
        overall: ListIntervalAgentSkillGroupReportResponseBodyDataOverall = None,
        stats_time: int = None,
    ):
        self.back_2back = back_2back
        self.inbound = inbound
        self.internal = internal
        self.outbound = outbound
        self.overall = overall
        self.stats_time = stats_time

    def validate(self):
        if self.back_2back:
            self.back_2back.validate()
        if self.inbound:
            self.inbound.validate()
        if self.internal:
            self.internal.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.back_2back is not None:
            result['Back2Back'] = self.back_2back.to_map()
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.internal is not None:
            result['Internal'] = self.internal.to_map()
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.stats_time is not None:
            result['StatsTime'] = self.stats_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Back2Back') is not None:
            temp_model = ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back()
            self.back_2back = temp_model.from_map(m['Back2Back'])
        if m.get('Inbound') is not None:
            temp_model = ListIntervalAgentSkillGroupReportResponseBodyDataInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('Internal') is not None:
            temp_model = ListIntervalAgentSkillGroupReportResponseBodyDataInternal()
            self.internal = temp_model.from_map(m['Internal'])
        if m.get('Outbound') is not None:
            temp_model = ListIntervalAgentSkillGroupReportResponseBodyDataOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListIntervalAgentSkillGroupReportResponseBodyDataOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('StatsTime') is not None:
            self.stats_time = m.get('StatsTime')
        return self


class ListIntervalAgentSkillGroupReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListIntervalAgentSkillGroupReportResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListIntervalAgentSkillGroupReportResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListIntervalAgentSkillGroupReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntervalAgentSkillGroupReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntervalAgentSkillGroupReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntervalInstanceReportRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_id: str = None,
        interval: str = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.interval = interval
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListIntervalInstanceReportResponseBodyDataInbound(TeaModel):
    def __init__(
        self,
        abandon_rate: float = None,
        abandoned_rate: float = None,
        average_abandon_time: float = None,
        average_abandoned_in_ivrtime: float = None,
        average_abandoned_in_queue_time: float = None,
        average_abandoned_in_ring_time: float = None,
        average_first_response_time: float = None,
        average_hold_time: float = None,
        average_response_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_wait_time: float = None,
        average_work_time: float = None,
        calls_abandoned: int = None,
        calls_abandoned_in_ivr: int = None,
        calls_abandoned_in_queue: int = None,
        calls_abandoned_in_ring: int = None,
        calls_abandoned_in_voice_navigator: int = None,
        calls_attended_transferred: int = None,
        calls_blind_transferred: int = None,
        calls_caused_ivrexception: int = None,
        calls_forward_to_outside_number: int = None,
        calls_handled: int = None,
        calls_hold: int = None,
        calls_ivrexception: int = None,
        calls_offered: int = None,
        calls_queued: int = None,
        calls_queuing_failed: int = None,
        calls_queuing_overflow: int = None,
        calls_queuing_timeout: int = None,
        calls_ringed: int = None,
        calls_to_voicemail: int = None,
        calls_voicemail: int = None,
        handle_rate: float = None,
        max_abandon_time: int = None,
        max_abandoned_in_ivrtime: int = None,
        max_abandoned_in_queue_time: int = None,
        max_abandoned_in_ring_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_wait_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        service_level_20: float = None,
        total_abandon_time: int = None,
        total_abandoned_in_ivrtime: int = None,
        total_abandoned_in_queue_time: int = None,
        total_abandoned_in_ring_time: int = None,
        total_hold_time: int = None,
        total_messages_sent: int = None,
        total_messages_sent_by_agent: int = None,
        total_messages_sent_by_customer: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_wait_time: int = None,
        total_work_time: int = None,
    ):
        self.abandon_rate = abandon_rate
        self.abandoned_rate = abandoned_rate
        self.average_abandon_time = average_abandon_time
        self.average_abandoned_in_ivrtime = average_abandoned_in_ivrtime
        self.average_abandoned_in_queue_time = average_abandoned_in_queue_time
        self.average_abandoned_in_ring_time = average_abandoned_in_ring_time
        self.average_first_response_time = average_first_response_time
        self.average_hold_time = average_hold_time
        self.average_response_time = average_response_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_wait_time = average_wait_time
        self.average_work_time = average_work_time
        self.calls_abandoned = calls_abandoned
        self.calls_abandoned_in_ivr = calls_abandoned_in_ivr
        self.calls_abandoned_in_queue = calls_abandoned_in_queue
        self.calls_abandoned_in_ring = calls_abandoned_in_ring
        self.calls_abandoned_in_voice_navigator = calls_abandoned_in_voice_navigator
        self.calls_attended_transferred = calls_attended_transferred
        self.calls_blind_transferred = calls_blind_transferred
        self.calls_caused_ivrexception = calls_caused_ivrexception
        self.calls_forward_to_outside_number = calls_forward_to_outside_number
        self.calls_handled = calls_handled
        self.calls_hold = calls_hold
        self.calls_ivrexception = calls_ivrexception
        self.calls_offered = calls_offered
        self.calls_queued = calls_queued
        self.calls_queuing_failed = calls_queuing_failed
        self.calls_queuing_overflow = calls_queuing_overflow
        self.calls_queuing_timeout = calls_queuing_timeout
        self.calls_ringed = calls_ringed
        self.calls_to_voicemail = calls_to_voicemail
        self.calls_voicemail = calls_voicemail
        self.handle_rate = handle_rate
        self.max_abandon_time = max_abandon_time
        self.max_abandoned_in_ivrtime = max_abandoned_in_ivrtime
        self.max_abandoned_in_queue_time = max_abandoned_in_queue_time
        self.max_abandoned_in_ring_time = max_abandoned_in_ring_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_wait_time = max_wait_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.service_level_20 = service_level_20
        self.total_abandon_time = total_abandon_time
        self.total_abandoned_in_ivrtime = total_abandoned_in_ivrtime
        self.total_abandoned_in_queue_time = total_abandoned_in_queue_time
        self.total_abandoned_in_ring_time = total_abandoned_in_ring_time
        self.total_hold_time = total_hold_time
        self.total_messages_sent = total_messages_sent
        self.total_messages_sent_by_agent = total_messages_sent_by_agent
        self.total_messages_sent_by_customer = total_messages_sent_by_customer
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_wait_time = total_wait_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abandon_rate is not None:
            result['AbandonRate'] = self.abandon_rate
        if self.abandoned_rate is not None:
            result['AbandonedRate'] = self.abandoned_rate
        if self.average_abandon_time is not None:
            result['AverageAbandonTime'] = self.average_abandon_time
        if self.average_abandoned_in_ivrtime is not None:
            result['AverageAbandonedInIVRTime'] = self.average_abandoned_in_ivrtime
        if self.average_abandoned_in_queue_time is not None:
            result['AverageAbandonedInQueueTime'] = self.average_abandoned_in_queue_time
        if self.average_abandoned_in_ring_time is not None:
            result['AverageAbandonedInRingTime'] = self.average_abandoned_in_ring_time
        if self.average_first_response_time is not None:
            result['AverageFirstResponseTime'] = self.average_first_response_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_response_time is not None:
            result['AverageResponseTime'] = self.average_response_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_wait_time is not None:
            result['AverageWaitTime'] = self.average_wait_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_abandoned is not None:
            result['CallsAbandoned'] = self.calls_abandoned
        if self.calls_abandoned_in_ivr is not None:
            result['CallsAbandonedInIVR'] = self.calls_abandoned_in_ivr
        if self.calls_abandoned_in_queue is not None:
            result['CallsAbandonedInQueue'] = self.calls_abandoned_in_queue
        if self.calls_abandoned_in_ring is not None:
            result['CallsAbandonedInRing'] = self.calls_abandoned_in_ring
        if self.calls_abandoned_in_voice_navigator is not None:
            result['CallsAbandonedInVoiceNavigator'] = self.calls_abandoned_in_voice_navigator
        if self.calls_attended_transferred is not None:
            result['CallsAttendedTransferred'] = self.calls_attended_transferred
        if self.calls_blind_transferred is not None:
            result['CallsBlindTransferred'] = self.calls_blind_transferred
        if self.calls_caused_ivrexception is not None:
            result['CallsCausedIVRException'] = self.calls_caused_ivrexception
        if self.calls_forward_to_outside_number is not None:
            result['CallsForwardToOutsideNumber'] = self.calls_forward_to_outside_number
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ivrexception is not None:
            result['CallsIVRException'] = self.calls_ivrexception
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_queued is not None:
            result['CallsQueued'] = self.calls_queued
        if self.calls_queuing_failed is not None:
            result['CallsQueuingFailed'] = self.calls_queuing_failed
        if self.calls_queuing_overflow is not None:
            result['CallsQueuingOverflow'] = self.calls_queuing_overflow
        if self.calls_queuing_timeout is not None:
            result['CallsQueuingTimeout'] = self.calls_queuing_timeout
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.calls_to_voicemail is not None:
            result['CallsToVoicemail'] = self.calls_to_voicemail
        if self.calls_voicemail is not None:
            result['CallsVoicemail'] = self.calls_voicemail
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_abandon_time is not None:
            result['MaxAbandonTime'] = self.max_abandon_time
        if self.max_abandoned_in_ivrtime is not None:
            result['MaxAbandonedInIVRTime'] = self.max_abandoned_in_ivrtime
        if self.max_abandoned_in_queue_time is not None:
            result['MaxAbandonedInQueueTime'] = self.max_abandoned_in_queue_time
        if self.max_abandoned_in_ring_time is not None:
            result['MaxAbandonedInRingTime'] = self.max_abandoned_in_ring_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.service_level_20 is not None:
            result['ServiceLevel20'] = self.service_level_20
        if self.total_abandon_time is not None:
            result['TotalAbandonTime'] = self.total_abandon_time
        if self.total_abandoned_in_ivrtime is not None:
            result['TotalAbandonedInIVRTime'] = self.total_abandoned_in_ivrtime
        if self.total_abandoned_in_queue_time is not None:
            result['TotalAbandonedInQueueTime'] = self.total_abandoned_in_queue_time
        if self.total_abandoned_in_ring_time is not None:
            result['TotalAbandonedInRingTime'] = self.total_abandoned_in_ring_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_messages_sent is not None:
            result['TotalMessagesSent'] = self.total_messages_sent
        if self.total_messages_sent_by_agent is not None:
            result['TotalMessagesSentByAgent'] = self.total_messages_sent_by_agent
        if self.total_messages_sent_by_customer is not None:
            result['TotalMessagesSentByCustomer'] = self.total_messages_sent_by_customer
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbandonRate') is not None:
            self.abandon_rate = m.get('AbandonRate')
        if m.get('AbandonedRate') is not None:
            self.abandoned_rate = m.get('AbandonedRate')
        if m.get('AverageAbandonTime') is not None:
            self.average_abandon_time = m.get('AverageAbandonTime')
        if m.get('AverageAbandonedInIVRTime') is not None:
            self.average_abandoned_in_ivrtime = m.get('AverageAbandonedInIVRTime')
        if m.get('AverageAbandonedInQueueTime') is not None:
            self.average_abandoned_in_queue_time = m.get('AverageAbandonedInQueueTime')
        if m.get('AverageAbandonedInRingTime') is not None:
            self.average_abandoned_in_ring_time = m.get('AverageAbandonedInRingTime')
        if m.get('AverageFirstResponseTime') is not None:
            self.average_first_response_time = m.get('AverageFirstResponseTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageResponseTime') is not None:
            self.average_response_time = m.get('AverageResponseTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWaitTime') is not None:
            self.average_wait_time = m.get('AverageWaitTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAbandoned') is not None:
            self.calls_abandoned = m.get('CallsAbandoned')
        if m.get('CallsAbandonedInIVR') is not None:
            self.calls_abandoned_in_ivr = m.get('CallsAbandonedInIVR')
        if m.get('CallsAbandonedInQueue') is not None:
            self.calls_abandoned_in_queue = m.get('CallsAbandonedInQueue')
        if m.get('CallsAbandonedInRing') is not None:
            self.calls_abandoned_in_ring = m.get('CallsAbandonedInRing')
        if m.get('CallsAbandonedInVoiceNavigator') is not None:
            self.calls_abandoned_in_voice_navigator = m.get('CallsAbandonedInVoiceNavigator')
        if m.get('CallsAttendedTransferred') is not None:
            self.calls_attended_transferred = m.get('CallsAttendedTransferred')
        if m.get('CallsBlindTransferred') is not None:
            self.calls_blind_transferred = m.get('CallsBlindTransferred')
        if m.get('CallsCausedIVRException') is not None:
            self.calls_caused_ivrexception = m.get('CallsCausedIVRException')
        if m.get('CallsForwardToOutsideNumber') is not None:
            self.calls_forward_to_outside_number = m.get('CallsForwardToOutsideNumber')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsIVRException') is not None:
            self.calls_ivrexception = m.get('CallsIVRException')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsQueued') is not None:
            self.calls_queued = m.get('CallsQueued')
        if m.get('CallsQueuingFailed') is not None:
            self.calls_queuing_failed = m.get('CallsQueuingFailed')
        if m.get('CallsQueuingOverflow') is not None:
            self.calls_queuing_overflow = m.get('CallsQueuingOverflow')
        if m.get('CallsQueuingTimeout') is not None:
            self.calls_queuing_timeout = m.get('CallsQueuingTimeout')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('CallsToVoicemail') is not None:
            self.calls_to_voicemail = m.get('CallsToVoicemail')
        if m.get('CallsVoicemail') is not None:
            self.calls_voicemail = m.get('CallsVoicemail')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxAbandonTime') is not None:
            self.max_abandon_time = m.get('MaxAbandonTime')
        if m.get('MaxAbandonedInIVRTime') is not None:
            self.max_abandoned_in_ivrtime = m.get('MaxAbandonedInIVRTime')
        if m.get('MaxAbandonedInQueueTime') is not None:
            self.max_abandoned_in_queue_time = m.get('MaxAbandonedInQueueTime')
        if m.get('MaxAbandonedInRingTime') is not None:
            self.max_abandoned_in_ring_time = m.get('MaxAbandonedInRingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('ServiceLevel20') is not None:
            self.service_level_20 = m.get('ServiceLevel20')
        if m.get('TotalAbandonTime') is not None:
            self.total_abandon_time = m.get('TotalAbandonTime')
        if m.get('TotalAbandonedInIVRTime') is not None:
            self.total_abandoned_in_ivrtime = m.get('TotalAbandonedInIVRTime')
        if m.get('TotalAbandonedInQueueTime') is not None:
            self.total_abandoned_in_queue_time = m.get('TotalAbandonedInQueueTime')
        if m.get('TotalAbandonedInRingTime') is not None:
            self.total_abandoned_in_ring_time = m.get('TotalAbandonedInRingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalMessagesSent') is not None:
            self.total_messages_sent = m.get('TotalMessagesSent')
        if m.get('TotalMessagesSentByAgent') is not None:
            self.total_messages_sent_by_agent = m.get('TotalMessagesSentByAgent')
        if m.get('TotalMessagesSentByCustomer') is not None:
            self.total_messages_sent_by_customer = m.get('TotalMessagesSentByCustomer')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalInstanceReportResponseBodyDataOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: float = None,
        average_hold_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_answered: int = None,
        calls_attended_transferred: int = None,
        calls_blind_transferred: int = None,
        calls_dialed: int = None,
        calls_hold: int = None,
        calls_ringed: int = None,
        max_dialing_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_hold_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_hold_time = average_hold_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_attended_transferred = calls_attended_transferred
        self.calls_blind_transferred = calls_blind_transferred
        self.calls_dialed = calls_dialed
        self.calls_hold = calls_hold
        self.calls_ringed = calls_ringed
        self.max_dialing_time = max_dialing_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_hold_time = total_hold_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_attended_transferred is not None:
            result['CallsAttendedTransferred'] = self.calls_attended_transferred
        if self.calls_blind_transferred is not None:
            result['CallsBlindTransferred'] = self.calls_blind_transferred
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsAttendedTransferred') is not None:
            self.calls_attended_transferred = m.get('CallsAttendedTransferred')
        if m.get('CallsBlindTransferred') is not None:
            self.calls_blind_transferred = m.get('CallsBlindTransferred')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalInstanceReportResponseBodyDataOverall(TeaModel):
    def __init__(
        self,
        average_break_time: float = None,
        average_hold_time: float = None,
        average_ready_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        max_break_time: int = None,
        max_hold_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_hold_time: int = None,
        total_logged_in_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_break_time = average_break_time
        self.average_hold_time = average_hold_time
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.max_break_time = max_break_time
        self.max_hold_time = max_hold_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_hold_time = total_hold_time
        self.total_logged_in_time = total_logged_in_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_break_time is not None:
            result['AverageBreakTime'] = self.average_break_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.max_break_time is not None:
            result['MaxBreakTime'] = self.max_break_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageBreakTime') is not None:
            self.average_break_time = m.get('AverageBreakTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('MaxBreakTime') is not None:
            self.max_break_time = m.get('MaxBreakTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalInstanceReportResponseBodyData(TeaModel):
    def __init__(
        self,
        inbound: ListIntervalInstanceReportResponseBodyDataInbound = None,
        outbound: ListIntervalInstanceReportResponseBodyDataOutbound = None,
        overall: ListIntervalInstanceReportResponseBodyDataOverall = None,
        stats_time: int = None,
    ):
        self.inbound = inbound
        self.outbound = outbound
        self.overall = overall
        self.stats_time = stats_time

    def validate(self):
        if self.inbound:
            self.inbound.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.stats_time is not None:
            result['StatsTime'] = self.stats_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Inbound') is not None:
            temp_model = ListIntervalInstanceReportResponseBodyDataInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('Outbound') is not None:
            temp_model = ListIntervalInstanceReportResponseBodyDataOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListIntervalInstanceReportResponseBodyDataOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('StatsTime') is not None:
            self.stats_time = m.get('StatsTime')
        return self


class ListIntervalInstanceReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListIntervalInstanceReportResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListIntervalInstanceReportResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListIntervalInstanceReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntervalInstanceReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntervalInstanceReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntervalSkillGroupReportRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_id: str = None,
        interval: str = None,
        media_type: str = None,
        skill_group_id: str = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.interval = interval
        self.media_type = media_type
        # This parameter is required.
        self.skill_group_id = skill_group_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListIntervalSkillGroupReportResponseBodyDataBack2Back(TeaModel):
    def __init__(
        self,
        agent_handle_rate: float = None,
        answer_rate: str = None,
        average_customer_ring_time: float = None,
        average_ring_time: float = None,
        average_talk_time: str = None,
        calls_agent_handled: int = None,
        calls_answered: int = None,
        calls_customer_answered: int = None,
        calls_dialed: int = None,
        customer_answer_rate: float = None,
        max_customer_ring_time: int = None,
        max_ring_time: int = None,
        max_talk_time: str = None,
        total_customer_ring_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
    ):
        self.agent_handle_rate = agent_handle_rate
        self.answer_rate = answer_rate
        self.average_customer_ring_time = average_customer_ring_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.calls_agent_handled = calls_agent_handled
        self.calls_answered = calls_answered
        self.calls_customer_answered = calls_customer_answered
        self.calls_dialed = calls_dialed
        self.customer_answer_rate = customer_answer_rate
        self.max_customer_ring_time = max_customer_ring_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.total_customer_ring_time = total_customer_ring_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_handle_rate is not None:
            result['AgentHandleRate'] = self.agent_handle_rate
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_customer_ring_time is not None:
            result['AverageCustomerRingTime'] = self.average_customer_ring_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.calls_agent_handled is not None:
            result['CallsAgentHandled'] = self.calls_agent_handled
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_customer_answered is not None:
            result['CallsCustomerAnswered'] = self.calls_customer_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.customer_answer_rate is not None:
            result['CustomerAnswerRate'] = self.customer_answer_rate
        if self.max_customer_ring_time is not None:
            result['MaxCustomerRingTime'] = self.max_customer_ring_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.total_customer_ring_time is not None:
            result['TotalCustomerRingTime'] = self.total_customer_ring_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentHandleRate') is not None:
            self.agent_handle_rate = m.get('AgentHandleRate')
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageCustomerRingTime') is not None:
            self.average_customer_ring_time = m.get('AverageCustomerRingTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('CallsAgentHandled') is not None:
            self.calls_agent_handled = m.get('CallsAgentHandled')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsCustomerAnswered') is not None:
            self.calls_customer_answered = m.get('CallsCustomerAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CustomerAnswerRate') is not None:
            self.customer_answer_rate = m.get('CustomerAnswerRate')
        if m.get('MaxCustomerRingTime') is not None:
            self.max_customer_ring_time = m.get('MaxCustomerRingTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('TotalCustomerRingTime') is not None:
            self.total_customer_ring_time = m.get('TotalCustomerRingTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        return self


class ListIntervalSkillGroupReportResponseBodyDataInbound(TeaModel):
    def __init__(
        self,
        abandon_rate: float = None,
        average_abandon_time: float = None,
        average_abandoned_in_queue_time: float = None,
        average_abandoned_in_ring_time: float = None,
        average_first_response_time: float = None,
        average_hold_time: float = None,
        average_response_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_wait_time: float = None,
        average_work_time: float = None,
        calls_abandoned: int = None,
        calls_abandoned_in_queue: int = None,
        calls_abandoned_in_ring: int = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_handled: int = None,
        calls_hold: int = None,
        calls_offered: int = None,
        calls_overflow: int = None,
        calls_queued: int = None,
        calls_queuing_overflow: int = None,
        calls_queuing_timeout: int = None,
        calls_ringed: int = None,
        calls_timeout: int = None,
        handle_rate: float = None,
        max_abandon_time: int = None,
        max_abandoned_in_queue_time: int = None,
        max_abandoned_in_ring_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_wait_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        service_level_20: float = None,
        total_abandon_time: int = None,
        total_abandoned_in_queue_time: int = None,
        total_abandoned_in_ring_time: int = None,
        total_hold_time: int = None,
        total_messages_sent: int = None,
        total_messages_sent_by_agent: int = None,
        total_messages_sent_by_customer: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_wait_time: int = None,
        total_work_time: int = None,
    ):
        self.abandon_rate = abandon_rate
        self.average_abandon_time = average_abandon_time
        self.average_abandoned_in_queue_time = average_abandoned_in_queue_time
        self.average_abandoned_in_ring_time = average_abandoned_in_ring_time
        self.average_first_response_time = average_first_response_time
        self.average_hold_time = average_hold_time
        self.average_response_time = average_response_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_wait_time = average_wait_time
        self.average_work_time = average_work_time
        self.calls_abandoned = calls_abandoned
        self.calls_abandoned_in_queue = calls_abandoned_in_queue
        self.calls_abandoned_in_ring = calls_abandoned_in_ring
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_handled = calls_handled
        self.calls_hold = calls_hold
        self.calls_offered = calls_offered
        self.calls_overflow = calls_overflow
        self.calls_queued = calls_queued
        self.calls_queuing_overflow = calls_queuing_overflow
        self.calls_queuing_timeout = calls_queuing_timeout
        self.calls_ringed = calls_ringed
        self.calls_timeout = calls_timeout
        self.handle_rate = handle_rate
        self.max_abandon_time = max_abandon_time
        self.max_abandoned_in_queue_time = max_abandoned_in_queue_time
        self.max_abandoned_in_ring_time = max_abandoned_in_ring_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_wait_time = max_wait_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.service_level_20 = service_level_20
        self.total_abandon_time = total_abandon_time
        self.total_abandoned_in_queue_time = total_abandoned_in_queue_time
        self.total_abandoned_in_ring_time = total_abandoned_in_ring_time
        self.total_hold_time = total_hold_time
        self.total_messages_sent = total_messages_sent
        self.total_messages_sent_by_agent = total_messages_sent_by_agent
        self.total_messages_sent_by_customer = total_messages_sent_by_customer
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_wait_time = total_wait_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abandon_rate is not None:
            result['AbandonRate'] = self.abandon_rate
        if self.average_abandon_time is not None:
            result['AverageAbandonTime'] = self.average_abandon_time
        if self.average_abandoned_in_queue_time is not None:
            result['AverageAbandonedInQueueTime'] = self.average_abandoned_in_queue_time
        if self.average_abandoned_in_ring_time is not None:
            result['AverageAbandonedInRingTime'] = self.average_abandoned_in_ring_time
        if self.average_first_response_time is not None:
            result['AverageFirstResponseTime'] = self.average_first_response_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_response_time is not None:
            result['AverageResponseTime'] = self.average_response_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_wait_time is not None:
            result['AverageWaitTime'] = self.average_wait_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_abandoned is not None:
            result['CallsAbandoned'] = self.calls_abandoned
        if self.calls_abandoned_in_queue is not None:
            result['CallsAbandonedInQueue'] = self.calls_abandoned_in_queue
        if self.calls_abandoned_in_ring is not None:
            result['CallsAbandonedInRing'] = self.calls_abandoned_in_ring
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_overflow is not None:
            result['CallsOverflow'] = self.calls_overflow
        if self.calls_queued is not None:
            result['CallsQueued'] = self.calls_queued
        if self.calls_queuing_overflow is not None:
            result['CallsQueuingOverflow'] = self.calls_queuing_overflow
        if self.calls_queuing_timeout is not None:
            result['CallsQueuingTimeout'] = self.calls_queuing_timeout
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.calls_timeout is not None:
            result['CallsTimeout'] = self.calls_timeout
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.max_abandon_time is not None:
            result['MaxAbandonTime'] = self.max_abandon_time
        if self.max_abandoned_in_queue_time is not None:
            result['MaxAbandonedInQueueTime'] = self.max_abandoned_in_queue_time
        if self.max_abandoned_in_ring_time is not None:
            result['MaxAbandonedInRingTime'] = self.max_abandoned_in_ring_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_wait_time is not None:
            result['MaxWaitTime'] = self.max_wait_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.service_level_20 is not None:
            result['ServiceLevel20'] = self.service_level_20
        if self.total_abandon_time is not None:
            result['TotalAbandonTime'] = self.total_abandon_time
        if self.total_abandoned_in_queue_time is not None:
            result['TotalAbandonedInQueueTime'] = self.total_abandoned_in_queue_time
        if self.total_abandoned_in_ring_time is not None:
            result['TotalAbandonedInRingTime'] = self.total_abandoned_in_ring_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_messages_sent is not None:
            result['TotalMessagesSent'] = self.total_messages_sent
        if self.total_messages_sent_by_agent is not None:
            result['TotalMessagesSentByAgent'] = self.total_messages_sent_by_agent
        if self.total_messages_sent_by_customer is not None:
            result['TotalMessagesSentByCustomer'] = self.total_messages_sent_by_customer
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbandonRate') is not None:
            self.abandon_rate = m.get('AbandonRate')
        if m.get('AverageAbandonTime') is not None:
            self.average_abandon_time = m.get('AverageAbandonTime')
        if m.get('AverageAbandonedInQueueTime') is not None:
            self.average_abandoned_in_queue_time = m.get('AverageAbandonedInQueueTime')
        if m.get('AverageAbandonedInRingTime') is not None:
            self.average_abandoned_in_ring_time = m.get('AverageAbandonedInRingTime')
        if m.get('AverageFirstResponseTime') is not None:
            self.average_first_response_time = m.get('AverageFirstResponseTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageResponseTime') is not None:
            self.average_response_time = m.get('AverageResponseTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWaitTime') is not None:
            self.average_wait_time = m.get('AverageWaitTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAbandoned') is not None:
            self.calls_abandoned = m.get('CallsAbandoned')
        if m.get('CallsAbandonedInQueue') is not None:
            self.calls_abandoned_in_queue = m.get('CallsAbandonedInQueue')
        if m.get('CallsAbandonedInRing') is not None:
            self.calls_abandoned_in_ring = m.get('CallsAbandonedInRing')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsOverflow') is not None:
            self.calls_overflow = m.get('CallsOverflow')
        if m.get('CallsQueued') is not None:
            self.calls_queued = m.get('CallsQueued')
        if m.get('CallsQueuingOverflow') is not None:
            self.calls_queuing_overflow = m.get('CallsQueuingOverflow')
        if m.get('CallsQueuingTimeout') is not None:
            self.calls_queuing_timeout = m.get('CallsQueuingTimeout')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('CallsTimeout') is not None:
            self.calls_timeout = m.get('CallsTimeout')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('MaxAbandonTime') is not None:
            self.max_abandon_time = m.get('MaxAbandonTime')
        if m.get('MaxAbandonedInQueueTime') is not None:
            self.max_abandoned_in_queue_time = m.get('MaxAbandonedInQueueTime')
        if m.get('MaxAbandonedInRingTime') is not None:
            self.max_abandoned_in_ring_time = m.get('MaxAbandonedInRingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWaitTime') is not None:
            self.max_wait_time = m.get('MaxWaitTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('ServiceLevel20') is not None:
            self.service_level_20 = m.get('ServiceLevel20')
        if m.get('TotalAbandonTime') is not None:
            self.total_abandon_time = m.get('TotalAbandonTime')
        if m.get('TotalAbandonedInQueueTime') is not None:
            self.total_abandoned_in_queue_time = m.get('TotalAbandonedInQueueTime')
        if m.get('TotalAbandonedInRingTime') is not None:
            self.total_abandoned_in_ring_time = m.get('TotalAbandonedInRingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalMessagesSent') is not None:
            self.total_messages_sent = m.get('TotalMessagesSent')
        if m.get('TotalMessagesSentByAgent') is not None:
            self.total_messages_sent_by_agent = m.get('TotalMessagesSentByAgent')
        if m.get('TotalMessagesSentByCustomer') is not None:
            self.total_messages_sent_by_customer = m.get('TotalMessagesSentByCustomer')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalSkillGroupReportResponseBodyDataOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: float = None,
        average_hold_time: float = None,
        average_ring_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        calls_answered: int = None,
        calls_attended_transfer_in: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_in: int = None,
        calls_blind_transfer_out: int = None,
        calls_dialed: int = None,
        calls_hold: int = None,
        calls_ringed: int = None,
        max_dialing_time: int = None,
        max_hold_time: int = None,
        max_ring_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_hold_time: int = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_hold_time = average_hold_time
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_answered = calls_answered
        self.calls_attended_transfer_in = calls_attended_transfer_in
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_in = calls_blind_transfer_in
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_dialed = calls_dialed
        self.calls_hold = calls_hold
        self.calls_ringed = calls_ringed
        self.max_dialing_time = max_dialing_time
        self.max_hold_time = max_hold_time
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_hold_time = total_hold_time
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_attended_transfer_in is not None:
            result['CallsAttendedTransferIn'] = self.calls_attended_transfer_in
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_in is not None:
            result['CallsBlindTransferIn'] = self.calls_blind_transfer_in
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_hold is not None:
            result['CallsHold'] = self.calls_hold
        if self.calls_ringed is not None:
            result['CallsRinged'] = self.calls_ringed
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsAttendedTransferIn') is not None:
            self.calls_attended_transfer_in = m.get('CallsAttendedTransferIn')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferIn') is not None:
            self.calls_blind_transfer_in = m.get('CallsBlindTransferIn')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsHold') is not None:
            self.calls_hold = m.get('CallsHold')
        if m.get('CallsRinged') is not None:
            self.calls_ringed = m.get('CallsRinged')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        count: int = None,
        duration: int = None,
    ):
        self.break_code = break_code
        self.count = count
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.count is not None:
            result['Count'] = self.count
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class ListIntervalSkillGroupReportResponseBodyDataOverall(TeaModel):
    def __init__(
        self,
        average_break_time: float = None,
        average_hold_time: float = None,
        average_ready_time: float = None,
        average_talk_time: float = None,
        average_work_time: float = None,
        break_code_detail_list: List[ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList] = None,
        max_break_time: int = None,
        max_hold_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_rate: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_hold_time: int = None,
        total_logged_in_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_break_time = average_break_time
        self.average_hold_time = average_hold_time
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.break_code_detail_list = break_code_detail_list
        self.max_break_time = max_break_time
        self.max_hold_time = max_hold_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_rate = satisfaction_rate
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_hold_time = total_hold_time
        self.total_logged_in_time = total_logged_in_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        if self.break_code_detail_list:
            for k in self.break_code_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_break_time is not None:
            result['AverageBreakTime'] = self.average_break_time
        if self.average_hold_time is not None:
            result['AverageHoldTime'] = self.average_hold_time
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        result['BreakCodeDetailList'] = []
        if self.break_code_detail_list is not None:
            for k in self.break_code_detail_list:
                result['BreakCodeDetailList'].append(k.to_map() if k else None)
        if self.max_break_time is not None:
            result['MaxBreakTime'] = self.max_break_time
        if self.max_hold_time is not None:
            result['MaxHoldTime'] = self.max_hold_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_rate is not None:
            result['SatisfactionRate'] = self.satisfaction_rate
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_hold_time is not None:
            result['TotalHoldTime'] = self.total_hold_time
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageBreakTime') is not None:
            self.average_break_time = m.get('AverageBreakTime')
        if m.get('AverageHoldTime') is not None:
            self.average_hold_time = m.get('AverageHoldTime')
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        self.break_code_detail_list = []
        if m.get('BreakCodeDetailList') is not None:
            for k in m.get('BreakCodeDetailList'):
                temp_model = ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList()
                self.break_code_detail_list.append(temp_model.from_map(k))
        if m.get('MaxBreakTime') is not None:
            self.max_break_time = m.get('MaxBreakTime')
        if m.get('MaxHoldTime') is not None:
            self.max_hold_time = m.get('MaxHoldTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionRate') is not None:
            self.satisfaction_rate = m.get('SatisfactionRate')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalHoldTime') is not None:
            self.total_hold_time = m.get('TotalHoldTime')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListIntervalSkillGroupReportResponseBodyData(TeaModel):
    def __init__(
        self,
        back_2back: ListIntervalSkillGroupReportResponseBodyDataBack2Back = None,
        inbound: ListIntervalSkillGroupReportResponseBodyDataInbound = None,
        outbound: ListIntervalSkillGroupReportResponseBodyDataOutbound = None,
        overall: ListIntervalSkillGroupReportResponseBodyDataOverall = None,
        stats_time: int = None,
    ):
        self.back_2back = back_2back
        self.inbound = inbound
        self.outbound = outbound
        self.overall = overall
        self.stats_time = stats_time

    def validate(self):
        if self.back_2back:
            self.back_2back.validate()
        if self.inbound:
            self.inbound.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.back_2back is not None:
            result['Back2Back'] = self.back_2back.to_map()
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.stats_time is not None:
            result['StatsTime'] = self.stats_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Back2Back') is not None:
            temp_model = ListIntervalSkillGroupReportResponseBodyDataBack2Back()
            self.back_2back = temp_model.from_map(m['Back2Back'])
        if m.get('Inbound') is not None:
            temp_model = ListIntervalSkillGroupReportResponseBodyDataInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('Outbound') is not None:
            temp_model = ListIntervalSkillGroupReportResponseBodyDataOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListIntervalSkillGroupReportResponseBodyDataOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('StatsTime') is not None:
            self.stats_time = m.get('StatsTime')
        return self


class ListIntervalSkillGroupReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListIntervalSkillGroupReportResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListIntervalSkillGroupReportResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListIntervalSkillGroupReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntervalSkillGroupReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntervalSkillGroupReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIvrTrackingDetailsRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListIvrTrackingDetailsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        callee: str = None,
        caller: str = None,
        channel_id: str = None,
        channel_variables: str = None,
        contact_id: str = None,
        enter_time: int = None,
        flow_id: str = None,
        flow_name: str = None,
        instance: str = None,
        leave_time: int = None,
        node_exit_code: str = None,
        node_id: str = None,
        node_name: str = None,
        node_properties: Dict[str, Any] = None,
        node_type: str = None,
        node_variables: Dict[str, Any] = None,
    ):
        self.callee = callee
        self.caller = caller
        self.channel_id = channel_id
        self.channel_variables = channel_variables
        self.contact_id = contact_id
        self.enter_time = enter_time
        self.flow_id = flow_id
        self.flow_name = flow_name
        self.instance = instance
        self.leave_time = leave_time
        self.node_exit_code = node_exit_code
        self.node_id = node_id
        self.node_name = node_name
        self.node_properties = node_properties
        self.node_type = node_type
        self.node_variables = node_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_variables is not None:
            result['ChannelVariables'] = self.channel_variables
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.enter_time is not None:
            result['EnterTime'] = self.enter_time
        if self.flow_id is not None:
            result['FlowId'] = self.flow_id
        if self.flow_name is not None:
            result['FlowName'] = self.flow_name
        if self.instance is not None:
            result['Instance'] = self.instance
        if self.leave_time is not None:
            result['LeaveTime'] = self.leave_time
        if self.node_exit_code is not None:
            result['NodeExitCode'] = self.node_exit_code
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_properties is not None:
            result['NodeProperties'] = self.node_properties
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.node_variables is not None:
            result['NodeVariables'] = self.node_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelVariables') is not None:
            self.channel_variables = m.get('ChannelVariables')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('EnterTime') is not None:
            self.enter_time = m.get('EnterTime')
        if m.get('FlowId') is not None:
            self.flow_id = m.get('FlowId')
        if m.get('FlowName') is not None:
            self.flow_name = m.get('FlowName')
        if m.get('Instance') is not None:
            self.instance = m.get('Instance')
        if m.get('LeaveTime') is not None:
            self.leave_time = m.get('LeaveTime')
        if m.get('NodeExitCode') is not None:
            self.node_exit_code = m.get('NodeExitCode')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeProperties') is not None:
            self.node_properties = m.get('NodeProperties')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('NodeVariables') is not None:
            self.node_variables = m.get('NodeVariables')
        return self


class ListIvrTrackingDetailsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListIvrTrackingDetailsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListIvrTrackingDetailsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListIvrTrackingDetailsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListIvrTrackingDetailsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListIvrTrackingDetailsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListIvrTrackingDetailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIvrTrackingDetailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIvrTrackingDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLegacyAgentEventLogsRequest(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
    ):
        self.agent_id = agent_id
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListLegacyAgentEventLogsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        agent_drop_call: str = None,
        agent_no: str = None,
        call_dir: str = None,
        call_id: str = None,
        call_mode: str = None,
        call_type: str = None,
        callee_id: str = None,
        caller_id: str = None,
        conn_id: str = None,
        event: str = None,
        group_no: str = None,
        outbound_scenario: bool = None,
        phone_no: str = None,
        statistic_date: str = None,
        target_request: str = None,
        target_select: str = None,
        tenant_id: str = None,
        transfer_number: str = None,
    ):
        self.agent_drop_call = agent_drop_call
        self.agent_no = agent_no
        self.call_dir = call_dir
        self.call_id = call_id
        self.call_mode = call_mode
        self.call_type = call_type
        self.callee_id = callee_id
        self.caller_id = caller_id
        self.conn_id = conn_id
        self.event = event
        self.group_no = group_no
        self.outbound_scenario = outbound_scenario
        self.phone_no = phone_no
        self.statistic_date = statistic_date
        self.target_request = target_request
        self.target_select = target_select
        self.tenant_id = tenant_id
        self.transfer_number = transfer_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_drop_call is not None:
            result['AgentDropCall'] = self.agent_drop_call
        if self.agent_no is not None:
            result['AgentNo'] = self.agent_no
        if self.call_dir is not None:
            result['CallDir'] = self.call_dir
        if self.call_id is not None:
            result['CallId'] = self.call_id
        if self.call_mode is not None:
            result['CallMode'] = self.call_mode
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.callee_id is not None:
            result['CalleeId'] = self.callee_id
        if self.caller_id is not None:
            result['CallerId'] = self.caller_id
        if self.conn_id is not None:
            result['ConnId'] = self.conn_id
        if self.event is not None:
            result['Event'] = self.event
        if self.group_no is not None:
            result['GroupNo'] = self.group_no
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.phone_no is not None:
            result['PhoneNo'] = self.phone_no
        if self.statistic_date is not None:
            result['StatisticDate'] = self.statistic_date
        if self.target_request is not None:
            result['TargetRequest'] = self.target_request
        if self.target_select is not None:
            result['TargetSelect'] = self.target_select
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.transfer_number is not None:
            result['TransferNumber'] = self.transfer_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentDropCall') is not None:
            self.agent_drop_call = m.get('AgentDropCall')
        if m.get('AgentNo') is not None:
            self.agent_no = m.get('AgentNo')
        if m.get('CallDir') is not None:
            self.call_dir = m.get('CallDir')
        if m.get('CallId') is not None:
            self.call_id = m.get('CallId')
        if m.get('CallMode') is not None:
            self.call_mode = m.get('CallMode')
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('CalleeId') is not None:
            self.callee_id = m.get('CalleeId')
        if m.get('CallerId') is not None:
            self.caller_id = m.get('CallerId')
        if m.get('ConnId') is not None:
            self.conn_id = m.get('ConnId')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('GroupNo') is not None:
            self.group_no = m.get('GroupNo')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('PhoneNo') is not None:
            self.phone_no = m.get('PhoneNo')
        if m.get('StatisticDate') is not None:
            self.statistic_date = m.get('StatisticDate')
        if m.get('TargetRequest') is not None:
            self.target_request = m.get('TargetRequest')
        if m.get('TargetSelect') is not None:
            self.target_select = m.get('TargetSelect')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TransferNumber') is not None:
            self.transfer_number = m.get('TransferNumber')
        return self


class ListLegacyAgentEventLogsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListLegacyAgentEventLogsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListLegacyAgentEventLogsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLegacyAgentEventLogsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListLegacyAgentEventLogsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListLegacyAgentEventLogsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLegacyAgentEventLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLegacyAgentEventLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLegacyAgentEventLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLegacyAgentStatusLogsRequest(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
    ):
        self.agent_id = agent_id
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListLegacyAgentStatusLogsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        agent_drop_call: str = None,
        agent_no: str = None,
        ali_hangup_cause: str = None,
        call_dir: str = None,
        call_id: str = None,
        call_type: str = None,
        callee_id: str = None,
        caller_id: str = None,
        conn_id: str = None,
        extend_1: str = None,
        extend_2: str = None,
        extend_3: str = None,
        extend_4: str = None,
        group_no: str = None,
        monited_agent_no: str = None,
        monited_agent_phone_no: str = None,
        outbound_scenario: bool = None,
        phone_no: str = None,
        statistic_date: str = None,
        statistic_time: int = None,
        status: str = None,
        target_request: str = None,
        target_select: str = None,
        tenant_id: str = None,
        transfer_no: str = None,
        transfer_number: str = None,
    ):
        self.agent_drop_call = agent_drop_call
        self.agent_no = agent_no
        self.ali_hangup_cause = ali_hangup_cause
        self.call_dir = call_dir
        self.call_id = call_id
        self.call_type = call_type
        self.callee_id = callee_id
        self.caller_id = caller_id
        self.conn_id = conn_id
        self.extend_1 = extend_1
        self.extend_2 = extend_2
        self.extend_3 = extend_3
        self.extend_4 = extend_4
        self.group_no = group_no
        self.monited_agent_no = monited_agent_no
        self.monited_agent_phone_no = monited_agent_phone_no
        self.outbound_scenario = outbound_scenario
        self.phone_no = phone_no
        self.statistic_date = statistic_date
        self.statistic_time = statistic_time
        self.status = status
        self.target_request = target_request
        self.target_select = target_select
        self.tenant_id = tenant_id
        self.transfer_no = transfer_no
        self.transfer_number = transfer_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_drop_call is not None:
            result['AgentDropCall'] = self.agent_drop_call
        if self.agent_no is not None:
            result['AgentNo'] = self.agent_no
        if self.ali_hangup_cause is not None:
            result['AliHangupCause'] = self.ali_hangup_cause
        if self.call_dir is not None:
            result['CallDir'] = self.call_dir
        if self.call_id is not None:
            result['CallId'] = self.call_id
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.callee_id is not None:
            result['CalleeId'] = self.callee_id
        if self.caller_id is not None:
            result['CallerId'] = self.caller_id
        if self.conn_id is not None:
            result['ConnId'] = self.conn_id
        if self.extend_1 is not None:
            result['Extend1'] = self.extend_1
        if self.extend_2 is not None:
            result['Extend2'] = self.extend_2
        if self.extend_3 is not None:
            result['Extend3'] = self.extend_3
        if self.extend_4 is not None:
            result['Extend4'] = self.extend_4
        if self.group_no is not None:
            result['GroupNo'] = self.group_no
        if self.monited_agent_no is not None:
            result['MonitedAgentNo'] = self.monited_agent_no
        if self.monited_agent_phone_no is not None:
            result['MonitedAgentPhoneNo'] = self.monited_agent_phone_no
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.phone_no is not None:
            result['PhoneNo'] = self.phone_no
        if self.statistic_date is not None:
            result['StatisticDate'] = self.statistic_date
        if self.statistic_time is not None:
            result['StatisticTime'] = self.statistic_time
        if self.status is not None:
            result['Status'] = self.status
        if self.target_request is not None:
            result['TargetRequest'] = self.target_request
        if self.target_select is not None:
            result['TargetSelect'] = self.target_select
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.transfer_no is not None:
            result['TransferNo'] = self.transfer_no
        if self.transfer_number is not None:
            result['TransferNumber'] = self.transfer_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentDropCall') is not None:
            self.agent_drop_call = m.get('AgentDropCall')
        if m.get('AgentNo') is not None:
            self.agent_no = m.get('AgentNo')
        if m.get('AliHangupCause') is not None:
            self.ali_hangup_cause = m.get('AliHangupCause')
        if m.get('CallDir') is not None:
            self.call_dir = m.get('CallDir')
        if m.get('CallId') is not None:
            self.call_id = m.get('CallId')
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('CalleeId') is not None:
            self.callee_id = m.get('CalleeId')
        if m.get('CallerId') is not None:
            self.caller_id = m.get('CallerId')
        if m.get('ConnId') is not None:
            self.conn_id = m.get('ConnId')
        if m.get('Extend1') is not None:
            self.extend_1 = m.get('Extend1')
        if m.get('Extend2') is not None:
            self.extend_2 = m.get('Extend2')
        if m.get('Extend3') is not None:
            self.extend_3 = m.get('Extend3')
        if m.get('Extend4') is not None:
            self.extend_4 = m.get('Extend4')
        if m.get('GroupNo') is not None:
            self.group_no = m.get('GroupNo')
        if m.get('MonitedAgentNo') is not None:
            self.monited_agent_no = m.get('MonitedAgentNo')
        if m.get('MonitedAgentPhoneNo') is not None:
            self.monited_agent_phone_no = m.get('MonitedAgentPhoneNo')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('PhoneNo') is not None:
            self.phone_no = m.get('PhoneNo')
        if m.get('StatisticDate') is not None:
            self.statistic_date = m.get('StatisticDate')
        if m.get('StatisticTime') is not None:
            self.statistic_time = m.get('StatisticTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetRequest') is not None:
            self.target_request = m.get('TargetRequest')
        if m.get('TargetSelect') is not None:
            self.target_select = m.get('TargetSelect')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TransferNo') is not None:
            self.transfer_no = m.get('TransferNo')
        if m.get('TransferNumber') is not None:
            self.transfer_number = m.get('TransferNumber')
        return self


class ListLegacyAgentStatusLogsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListLegacyAgentStatusLogsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListLegacyAgentStatusLogsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLegacyAgentStatusLogsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListLegacyAgentStatusLogsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListLegacyAgentStatusLogsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLegacyAgentStatusLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLegacyAgentStatusLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLegacyAgentStatusLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLegacyAppraiseLogsRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListLegacyAppraiseLogsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        acid: str = None,
        contact_type: str = None,
        id: int = None,
        instance_id: str = None,
        key_mark_relation: str = None,
        note: str = None,
        parent_note: str = None,
        press_key: str = None,
        ram_id: str = None,
        skill_group_id: str = None,
        statistic_date: str = None,
        type: str = None,
    ):
        self.acid = acid
        self.contact_type = contact_type
        self.id = id
        self.instance_id = instance_id
        self.key_mark_relation = key_mark_relation
        self.note = note
        self.parent_note = parent_note
        self.press_key = press_key
        self.ram_id = ram_id
        self.skill_group_id = skill_group_id
        self.statistic_date = statistic_date
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acid is not None:
            result['Acid'] = self.acid
        if self.contact_type is not None:
            result['ContactType'] = self.contact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.key_mark_relation is not None:
            result['KeyMarkRelation'] = self.key_mark_relation
        if self.note is not None:
            result['Note'] = self.note
        if self.parent_note is not None:
            result['ParentNote'] = self.parent_note
        if self.press_key is not None:
            result['PressKey'] = self.press_key
        if self.ram_id is not None:
            result['RamId'] = self.ram_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.statistic_date is not None:
            result['StatisticDate'] = self.statistic_date
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Acid') is not None:
            self.acid = m.get('Acid')
        if m.get('ContactType') is not None:
            self.contact_type = m.get('ContactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KeyMarkRelation') is not None:
            self.key_mark_relation = m.get('KeyMarkRelation')
        if m.get('Note') is not None:
            self.note = m.get('Note')
        if m.get('ParentNote') is not None:
            self.parent_note = m.get('ParentNote')
        if m.get('PressKey') is not None:
            self.press_key = m.get('PressKey')
        if m.get('RamId') is not None:
            self.ram_id = m.get('RamId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StatisticDate') is not None:
            self.statistic_date = m.get('StatisticDate')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLegacyAppraiseLogsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListLegacyAppraiseLogsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListLegacyAppraiseLogsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLegacyAppraiseLogsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListLegacyAppraiseLogsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListLegacyAppraiseLogsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLegacyAppraiseLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLegacyAppraiseLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLegacyAppraiseLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLegacyQueueEventLogsRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_id: str = None,
        start_time: int = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.skill_group_id = skill_group_id
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListLegacyQueueEventLogsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        acid: str = None,
        ani: str = None,
        answer_phone: str = None,
        answer_time: int = None,
        cause: str = None,
        dnis: str = None,
        id: int = None,
        queue_time: int = None,
        statistic_date: str = None,
        tenant_id: str = None,
        vq: str = None,
    ):
        self.acid = acid
        self.ani = ani
        self.answer_phone = answer_phone
        self.answer_time = answer_time
        self.cause = cause
        self.dnis = dnis
        self.id = id
        self.queue_time = queue_time
        self.statistic_date = statistic_date
        self.tenant_id = tenant_id
        self.vq = vq

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acid is not None:
            result['Acid'] = self.acid
        if self.ani is not None:
            result['Ani'] = self.ani
        if self.answer_phone is not None:
            result['AnswerPhone'] = self.answer_phone
        if self.answer_time is not None:
            result['AnswerTime'] = self.answer_time
        if self.cause is not None:
            result['Cause'] = self.cause
        if self.dnis is not None:
            result['Dnis'] = self.dnis
        if self.id is not None:
            result['Id'] = self.id
        if self.queue_time is not None:
            result['QueueTime'] = self.queue_time
        if self.statistic_date is not None:
            result['StatisticDate'] = self.statistic_date
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.vq is not None:
            result['Vq'] = self.vq
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Acid') is not None:
            self.acid = m.get('Acid')
        if m.get('Ani') is not None:
            self.ani = m.get('Ani')
        if m.get('AnswerPhone') is not None:
            self.answer_phone = m.get('AnswerPhone')
        if m.get('AnswerTime') is not None:
            self.answer_time = m.get('AnswerTime')
        if m.get('Cause') is not None:
            self.cause = m.get('Cause')
        if m.get('Dnis') is not None:
            self.dnis = m.get('Dnis')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('QueueTime') is not None:
            self.queue_time = m.get('QueueTime')
        if m.get('StatisticDate') is not None:
            self.statistic_date = m.get('StatisticDate')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Vq') is not None:
            self.vq = m.get('Vq')
        return self


class ListLegacyQueueEventLogsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListLegacyQueueEventLogsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListLegacyQueueEventLogsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLegacyQueueEventLogsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListLegacyQueueEventLogsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListLegacyQueueEventLogsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLegacyQueueEventLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLegacyQueueEventLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLegacyQueueEventLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMonoRecordingsRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ListMonoRecordingsResponseBodyData(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        agent_name: str = None,
        contact_id: str = None,
        duration: str = None,
        file_name: str = None,
        file_url: str = None,
        ram_id: str = None,
        skill_group_id: str = None,
        start_time: str = None,
    ):
        self.agent_id = agent_id
        self.agent_name = agent_name
        self.contact_id = contact_id
        self.duration = duration
        self.file_name = file_name
        self.file_url = file_url
        self.ram_id = ram_id
        self.skill_group_id = skill_group_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.ram_id is not None:
            result['RamId'] = self.ram_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RamId') is not None:
            self.ram_id = m.get('RamId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListMonoRecordingsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListMonoRecordingsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListMonoRecordingsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMonoRecordingsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMonoRecordingsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMonoRecordingsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMultiChannelRecordingsRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_id = contact_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListMultiChannelRecordingsResponseBodyData(TeaModel):
    def __init__(
        self,
        agent_channel_id: str = None,
        agent_id: str = None,
        agent_name: str = None,
        contact_id: str = None,
        duration: str = None,
        file_name: str = None,
        file_url: str = None,
        hold_time_segments: List[ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments] = None,
        ram_id: str = None,
        skill_group_id: str = None,
        start_time: int = None,
    ):
        self.agent_channel_id = agent_channel_id
        self.agent_id = agent_id
        self.agent_name = agent_name
        self.contact_id = contact_id
        self.duration = duration
        self.file_name = file_name
        self.file_url = file_url
        self.hold_time_segments = hold_time_segments
        self.ram_id = ram_id
        self.skill_group_id = skill_group_id
        self.start_time = start_time

    def validate(self):
        if self.hold_time_segments:
            for k in self.hold_time_segments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_channel_id is not None:
            result['AgentChannelId'] = self.agent_channel_id
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        result['HoldTimeSegments'] = []
        if self.hold_time_segments is not None:
            for k in self.hold_time_segments:
                result['HoldTimeSegments'].append(k.to_map() if k else None)
        if self.ram_id is not None:
            result['RamId'] = self.ram_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentChannelId') is not None:
            self.agent_channel_id = m.get('AgentChannelId')
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        self.hold_time_segments = []
        if m.get('HoldTimeSegments') is not None:
            for k in m.get('HoldTimeSegments'):
                temp_model = ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments()
                self.hold_time_segments.append(temp_model.from_map(k))
        if m.get('RamId') is not None:
            self.ram_id = m.get('RamId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListMultiChannelRecordingsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListMultiChannelRecordingsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListMultiChannelRecordingsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMultiChannelRecordingsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMultiChannelRecordingsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMultiChannelRecordingsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOutboundNumbersOfUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_id_list: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.skill_group_id_list = skill_group_id_list
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListOutboundNumbersOfUserResponseBodyDataList(TeaModel):
    def __init__(
        self,
        city: str = None,
        number: str = None,
        provider: str = None,
        provider_code: str = None,
        provider_display_name: str = None,
        provider_short_name: str = None,
        provider_type: str = None,
        province: str = None,
    ):
        self.city = city
        self.number = number
        self.provider = provider
        self.provider_code = provider_code
        self.provider_display_name = provider_display_name
        self.provider_short_name = provider_short_name
        self.provider_type = provider_type
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city is not None:
            result['City'] = self.city
        if self.number is not None:
            result['Number'] = self.number
        if self.provider is not None:
            result['Provider'] = self.provider
        if self.provider_code is not None:
            result['ProviderCode'] = self.provider_code
        if self.provider_display_name is not None:
            result['ProviderDisplayName'] = self.provider_display_name
        if self.provider_short_name is not None:
            result['ProviderShortName'] = self.provider_short_name
        if self.provider_type is not None:
            result['ProviderType'] = self.provider_type
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Provider') is not None:
            self.provider = m.get('Provider')
        if m.get('ProviderCode') is not None:
            self.provider_code = m.get('ProviderCode')
        if m.get('ProviderDisplayName') is not None:
            self.provider_display_name = m.get('ProviderDisplayName')
        if m.get('ProviderShortName') is not None:
            self.provider_short_name = m.get('ProviderShortName')
        if m.get('ProviderType') is not None:
            self.provider_type = m.get('ProviderType')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class ListOutboundNumbersOfUserResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListOutboundNumbersOfUserResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListOutboundNumbersOfUserResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListOutboundNumbersOfUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListOutboundNumbersOfUserResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListOutboundNumbersOfUserResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListOutboundNumbersOfUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOutboundNumbersOfUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOutboundNumbersOfUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPersonalNumbersOfUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        is_member: bool = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.is_member = is_member
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.is_member is not None:
            result['IsMember'] = self.is_member
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IsMember') is not None:
            self.is_member = m.get('IsMember')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListPersonalNumbersOfUserResponseBodyDataList(TeaModel):
    def __init__(
        self,
        active: bool = None,
        city: str = None,
        contact_flow_id: str = None,
        instance_id: str = None,
        number: str = None,
        province: str = None,
    ):
        self.active = active
        self.city = city
        self.contact_flow_id = contact_flow_id
        self.instance_id = instance_id
        self.number = number
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.city is not None:
            result['City'] = self.city
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class ListPersonalNumbersOfUserResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListPersonalNumbersOfUserResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListPersonalNumbersOfUserResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPersonalNumbersOfUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListPersonalNumbersOfUserResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListPersonalNumbersOfUserResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPersonalNumbersOfUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPersonalNumbersOfUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPersonalNumbersOfUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPhoneNumbersRequest(TeaModel):
    def __init__(
        self,
        active: bool = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
        usage: str = None,
    ):
        self.active = active
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class ListPhoneNumbersResponseBodyDataListSkillGroups(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        instance_id: str = None,
        name: str = None,
        skill_group_id: str = None,
    ):
        self.display_name = display_name
        self.instance_id = instance_id
        self.name = name
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class ListPhoneNumbersResponseBodyDataList(TeaModel):
    def __init__(
        self,
        active: bool = None,
        city: str = None,
        contact_flow_id: str = None,
        contact_flow_name: str = None,
        create_time: str = None,
        instance_id: str = None,
        number: str = None,
        provider: str = None,
        province: str = None,
        skill_groups: List[ListPhoneNumbersResponseBodyDataListSkillGroups] = None,
        tags: str = None,
        usage: str = None,
        user_id: str = None,
    ):
        self.active = active
        self.city = city
        self.contact_flow_id = contact_flow_id
        self.contact_flow_name = contact_flow_name
        self.create_time = create_time
        self.instance_id = instance_id
        self.number = number
        self.provider = provider
        self.province = province
        self.skill_groups = skill_groups
        self.tags = tags
        self.usage = usage
        self.user_id = user_id

    def validate(self):
        if self.skill_groups:
            for k in self.skill_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.city is not None:
            result['City'] = self.city
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.contact_flow_name is not None:
            result['ContactFlowName'] = self.contact_flow_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.provider is not None:
            result['Provider'] = self.provider
        if self.province is not None:
            result['Province'] = self.province
        result['SkillGroups'] = []
        if self.skill_groups is not None:
            for k in self.skill_groups:
                result['SkillGroups'].append(k.to_map() if k else None)
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.usage is not None:
            result['Usage'] = self.usage
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('ContactFlowName') is not None:
            self.contact_flow_name = m.get('ContactFlowName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Provider') is not None:
            self.provider = m.get('Provider')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        self.skill_groups = []
        if m.get('SkillGroups') is not None:
            for k in m.get('SkillGroups'):
                temp_model = ListPhoneNumbersResponseBodyDataListSkillGroups()
                self.skill_groups.append(temp_model.from_map(k))
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListPhoneNumbersResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListPhoneNumbersResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListPhoneNumbersResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPhoneNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListPhoneNumbersResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListPhoneNumbersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPhoneNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPhoneNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPhoneNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPhoneNumbersOfSkillGroupRequest(TeaModel):
    def __init__(
        self,
        active: bool = None,
        instance_id: str = None,
        is_member: bool = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
        skill_group_id: str = None,
    ):
        self.active = active
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.is_member = is_member
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern
        # This parameter is required.
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.is_member is not None:
            result['IsMember'] = self.is_member
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IsMember') is not None:
            self.is_member = m.get('IsMember')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class ListPhoneNumbersOfSkillGroupResponseBodyDataList(TeaModel):
    def __init__(
        self,
        active: bool = None,
        city: str = None,
        contact_flow_id: str = None,
        instance_id: str = None,
        number: str = None,
        province: str = None,
        usage: str = None,
    ):
        self.active = active
        self.city = city
        self.contact_flow_id = contact_flow_id
        self.instance_id = instance_id
        self.number = number
        self.province = province
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.city is not None:
            result['City'] = self.city
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class ListPhoneNumbersOfSkillGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListPhoneNumbersOfSkillGroupResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListPhoneNumbersOfSkillGroupResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPhoneNumbersOfSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListPhoneNumbersOfSkillGroupResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListPhoneNumbersOfSkillGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPhoneNumbersOfSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPhoneNumbersOfSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPhoneNumbersOfSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrivilegesOfUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ListPrivilegesOfUserResponseBodyData(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        name: str = None,
        scope: str = None,
    ):
        self.instance_id = instance_id
        self.name = name
        self.scope = scope

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.scope is not None:
            result['Scope'] = self.scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        return self


class ListPrivilegesOfUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListPrivilegesOfUserResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListPrivilegesOfUserResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrivilegesOfUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrivilegesOfUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrivilegesOfUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRamUsersRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        return self


class ListRamUsersResponseBodyDataList(TeaModel):
    def __init__(
        self,
        aliyun_uid: int = None,
        display_name: str = None,
        email: str = None,
        login_name: str = None,
        mobile: str = None,
        primary: bool = None,
        ram_id: str = None,
    ):
        self.aliyun_uid = aliyun_uid
        self.display_name = display_name
        self.email = email
        self.login_name = login_name
        self.mobile = mobile
        self.primary = primary
        self.ram_id = ram_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_uid is not None:
            result['AliyunUid'] = self.aliyun_uid
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.email is not None:
            result['Email'] = self.email
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.primary is not None:
            result['Primary'] = self.primary
        if self.ram_id is not None:
            result['RamId'] = self.ram_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunUid') is not None:
            self.aliyun_uid = m.get('AliyunUid')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('Primary') is not None:
            self.primary = m.get('Primary')
        if m.get('RamId') is not None:
            self.ram_id = m.get('RamId')
        return self


class ListRamUsersResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListRamUsersResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListRamUsersResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListRamUsersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListRamUsersResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListRamUsersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListRamUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRamUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRamUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRealtimeAgentStatesRequest(TeaModel):
    def __init__(
        self,
        agent_id_list: str = None,
        agent_name: str = None,
        call_type_list: str = None,
        instance_id: str = None,
        media_type: str = None,
        outbound_scenario: bool = None,
        page_number: int = None,
        page_size: int = None,
        query: str = None,
        skill_group_id: str = None,
        state_list: str = None,
        work_mode_list: str = None,
    ):
        self.agent_id_list = agent_id_list
        self.agent_name = agent_name
        self.call_type_list = call_type_list
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        self.outbound_scenario = outbound_scenario
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.query = query
        self.skill_group_id = skill_group_id
        self.state_list = state_list
        self.work_mode_list = work_mode_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id_list is not None:
            result['AgentIdList'] = self.agent_id_list
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        if self.call_type_list is not None:
            result['CallTypeList'] = self.call_type_list
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.state_list is not None:
            result['StateList'] = self.state_list
        if self.work_mode_list is not None:
            result['WorkModeList'] = self.work_mode_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentIdList') is not None:
            self.agent_id_list = m.get('AgentIdList')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        if m.get('CallTypeList') is not None:
            self.call_type_list = m.get('CallTypeList')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('StateList') is not None:
            self.state_list = m.get('StateList')
        if m.get('WorkModeList') is not None:
            self.work_mode_list = m.get('WorkModeList')
        return self


class ListRealtimeAgentStatesResponseBodyDataList(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        agent_name: str = None,
        break_code: str = None,
        call_type: str = None,
        counter_party: str = None,
        duration: int = None,
        extension: str = None,
        instance_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        skill_group_id_list: List[str] = None,
        skill_group_name_list: List[str] = None,
        state: str = None,
        state_code: str = None,
        state_time: int = None,
        work_mode: str = None,
    ):
        self.agent_id = agent_id
        self.agent_name = agent_name
        self.break_code = break_code
        self.call_type = call_type
        self.counter_party = counter_party
        self.duration = duration
        self.extension = extension
        self.instance_id = instance_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.skill_group_id_list = skill_group_id_list
        self.skill_group_name_list = skill_group_name_list
        self.state = state
        self.state_code = state_code
        self.state_time = state_time
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.agent_name is not None:
            result['AgentName'] = self.agent_name
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.counter_party is not None:
            result['CounterParty'] = self.counter_party
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        if self.skill_group_name_list is not None:
            result['SkillGroupNameList'] = self.skill_group_name_list
        if self.state is not None:
            result['State'] = self.state
        if self.state_code is not None:
            result['StateCode'] = self.state_code
        if self.state_time is not None:
            result['StateTime'] = self.state_time
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('AgentName') is not None:
            self.agent_name = m.get('AgentName')
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('CounterParty') is not None:
            self.counter_party = m.get('CounterParty')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        if m.get('SkillGroupNameList') is not None:
            self.skill_group_name_list = m.get('SkillGroupNameList')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('StateCode') is not None:
            self.state_code = m.get('StateCode')
        if m.get('StateTime') is not None:
            self.state_time = m.get('StateTime')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ListRealtimeAgentStatesResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListRealtimeAgentStatesResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListRealtimeAgentStatesResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListRealtimeAgentStatesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListRealtimeAgentStatesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListRealtimeAgentStatesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListRealtimeAgentStatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRealtimeAgentStatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRealtimeAgentStatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRealtimeSkillGroupStatesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        media_type: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_id_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.skill_group_id_list = skill_group_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        return self


class ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        count: int = None,
    ):
        self.break_code = break_code
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class ListRealtimeSkillGroupStatesResponseBodyDataList(TeaModel):
    def __init__(
        self,
        break_code_detail_list: List[ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList] = None,
        breaking_agents: int = None,
        instance_id: str = None,
        logged_in_agents: int = None,
        longest_waiting_time: int = None,
        outbound_scenario_ready_agents: int = None,
        ready_agents: int = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
        talking_agents: int = None,
        total_agents: int = None,
        waiting_calls: int = None,
        working_agents: int = None,
    ):
        self.break_code_detail_list = break_code_detail_list
        self.breaking_agents = breaking_agents
        self.instance_id = instance_id
        self.logged_in_agents = logged_in_agents
        self.longest_waiting_time = longest_waiting_time
        self.outbound_scenario_ready_agents = outbound_scenario_ready_agents
        self.ready_agents = ready_agents
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name
        self.talking_agents = talking_agents
        self.total_agents = total_agents
        self.waiting_calls = waiting_calls
        self.working_agents = working_agents

    def validate(self):
        if self.break_code_detail_list:
            for k in self.break_code_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BreakCodeDetailList'] = []
        if self.break_code_detail_list is not None:
            for k in self.break_code_detail_list:
                result['BreakCodeDetailList'].append(k.to_map() if k else None)
        if self.breaking_agents is not None:
            result['BreakingAgents'] = self.breaking_agents
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logged_in_agents is not None:
            result['LoggedInAgents'] = self.logged_in_agents
        if self.longest_waiting_time is not None:
            result['LongestWaitingTime'] = self.longest_waiting_time
        if self.outbound_scenario_ready_agents is not None:
            result['OutboundScenarioReadyAgents'] = self.outbound_scenario_ready_agents
        if self.ready_agents is not None:
            result['ReadyAgents'] = self.ready_agents
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        if self.talking_agents is not None:
            result['TalkingAgents'] = self.talking_agents
        if self.total_agents is not None:
            result['TotalAgents'] = self.total_agents
        if self.waiting_calls is not None:
            result['WaitingCalls'] = self.waiting_calls
        if self.working_agents is not None:
            result['WorkingAgents'] = self.working_agents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.break_code_detail_list = []
        if m.get('BreakCodeDetailList') is not None:
            for k in m.get('BreakCodeDetailList'):
                temp_model = ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList()
                self.break_code_detail_list.append(temp_model.from_map(k))
        if m.get('BreakingAgents') is not None:
            self.breaking_agents = m.get('BreakingAgents')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoggedInAgents') is not None:
            self.logged_in_agents = m.get('LoggedInAgents')
        if m.get('LongestWaitingTime') is not None:
            self.longest_waiting_time = m.get('LongestWaitingTime')
        if m.get('OutboundScenarioReadyAgents') is not None:
            self.outbound_scenario_ready_agents = m.get('OutboundScenarioReadyAgents')
        if m.get('ReadyAgents') is not None:
            self.ready_agents = m.get('ReadyAgents')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        if m.get('TalkingAgents') is not None:
            self.talking_agents = m.get('TalkingAgents')
        if m.get('TotalAgents') is not None:
            self.total_agents = m.get('TotalAgents')
        if m.get('WaitingCalls') is not None:
            self.waiting_calls = m.get('WaitingCalls')
        if m.get('WorkingAgents') is not None:
            self.working_agents = m.get('WorkingAgents')
        return self


class ListRealtimeSkillGroupStatesResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListRealtimeSkillGroupStatesResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListRealtimeSkillGroupStatesResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListRealtimeSkillGroupStatesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListRealtimeSkillGroupStatesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListRealtimeSkillGroupStatesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListRealtimeSkillGroupStatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRealtimeSkillGroupStatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRealtimeSkillGroupStatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRecentCallDetailRecordsRequest(TeaModel):
    def __init__(
        self,
        criteria: str = None,
        end_time: int = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
    ):
        self.criteria = criteria
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.criteria is not None:
            result['Criteria'] = self.criteria
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Criteria') is not None:
            self.criteria = m.get('Criteria')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListRecentCallDetailRecordsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        agent_ids: str = None,
        call_duration: str = None,
        called_number: str = None,
        calling_number: str = None,
        contact_disposition: str = None,
        contact_id: str = None,
        contact_type: str = None,
        duration: int = None,
        instance_id: str = None,
        skill_group_ids: str = None,
        start_time: int = None,
    ):
        self.agent_ids = agent_ids
        self.call_duration = call_duration
        self.called_number = called_number
        self.calling_number = calling_number
        self.contact_disposition = contact_disposition
        self.contact_id = contact_id
        self.contact_type = contact_type
        self.duration = duration
        self.instance_id = instance_id
        self.skill_group_ids = skill_group_ids
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_ids is not None:
            result['AgentIds'] = self.agent_ids
        if self.call_duration is not None:
            result['CallDuration'] = self.call_duration
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.calling_number is not None:
            result['CallingNumber'] = self.calling_number
        if self.contact_disposition is not None:
            result['ContactDisposition'] = self.contact_disposition
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_type is not None:
            result['ContactType'] = self.contact_type
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_ids is not None:
            result['SkillGroupIds'] = self.skill_group_ids
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentIds') is not None:
            self.agent_ids = m.get('AgentIds')
        if m.get('CallDuration') is not None:
            self.call_duration = m.get('CallDuration')
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('CallingNumber') is not None:
            self.calling_number = m.get('CallingNumber')
        if m.get('ContactDisposition') is not None:
            self.contact_disposition = m.get('ContactDisposition')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactType') is not None:
            self.contact_type = m.get('ContactType')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupIds') is not None:
            self.skill_group_ids = m.get('SkillGroupIds')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListRecentCallDetailRecordsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListRecentCallDetailRecordsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListRecentCallDetailRecordsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListRecentCallDetailRecordsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListRecentCallDetailRecordsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListRecentCallDetailRecordsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListRecentCallDetailRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRecentCallDetailRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRecentCallDetailRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRolesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ListRolesResponseBodyData(TeaModel):
    def __init__(
        self,
        name: str = None,
        role_id: str = None,
    ):
        self.name = name
        self.role_id = role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        return self


class ListRolesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListRolesResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListRolesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListRolesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRolesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSkillGroupStatesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_group_ids: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.skill_group_ids = skill_group_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_group_ids is not None:
            result['SkillGroupIds'] = self.skill_group_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroupIds') is not None:
            self.skill_group_ids = m.get('SkillGroupIds')
        return self


class ListSkillGroupStatesResponseBodyDataList(TeaModel):
    def __init__(
        self,
        average_waiting_time: int = None,
        breaking_agents: int = None,
        inbound_talking_agents: int = None,
        instance_id: str = None,
        logged_in_agents: int = None,
        longest_call: int = None,
        outbound_scenario_ready_agents: int = None,
        outbound_talking_agents: int = None,
        ready_agents: int = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
        talking_agents: int = None,
        waiting_calls: int = None,
        waiting_calls_level_10: int = None,
        waiting_calls_level_20: int = None,
        waiting_calls_level_30: int = None,
        working_agents: int = None,
    ):
        self.average_waiting_time = average_waiting_time
        self.breaking_agents = breaking_agents
        self.inbound_talking_agents = inbound_talking_agents
        self.instance_id = instance_id
        self.logged_in_agents = logged_in_agents
        self.longest_call = longest_call
        self.outbound_scenario_ready_agents = outbound_scenario_ready_agents
        self.outbound_talking_agents = outbound_talking_agents
        self.ready_agents = ready_agents
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name
        self.talking_agents = talking_agents
        self.waiting_calls = waiting_calls
        self.waiting_calls_level_10 = waiting_calls_level_10
        self.waiting_calls_level_20 = waiting_calls_level_20
        self.waiting_calls_level_30 = waiting_calls_level_30
        self.working_agents = working_agents

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_waiting_time is not None:
            result['AverageWaitingTime'] = self.average_waiting_time
        if self.breaking_agents is not None:
            result['BreakingAgents'] = self.breaking_agents
        if self.inbound_talking_agents is not None:
            result['InboundTalkingAgents'] = self.inbound_talking_agents
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logged_in_agents is not None:
            result['LoggedInAgents'] = self.logged_in_agents
        if self.longest_call is not None:
            result['LongestCall'] = self.longest_call
        if self.outbound_scenario_ready_agents is not None:
            result['OutboundScenarioReadyAgents'] = self.outbound_scenario_ready_agents
        if self.outbound_talking_agents is not None:
            result['OutboundTalkingAgents'] = self.outbound_talking_agents
        if self.ready_agents is not None:
            result['ReadyAgents'] = self.ready_agents
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        if self.talking_agents is not None:
            result['TalkingAgents'] = self.talking_agents
        if self.waiting_calls is not None:
            result['WaitingCalls'] = self.waiting_calls
        if self.waiting_calls_level_10 is not None:
            result['WaitingCallsLevel10'] = self.waiting_calls_level_10
        if self.waiting_calls_level_20 is not None:
            result['WaitingCallsLevel20'] = self.waiting_calls_level_20
        if self.waiting_calls_level_30 is not None:
            result['WaitingCallsLevel30'] = self.waiting_calls_level_30
        if self.working_agents is not None:
            result['WorkingAgents'] = self.working_agents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageWaitingTime') is not None:
            self.average_waiting_time = m.get('AverageWaitingTime')
        if m.get('BreakingAgents') is not None:
            self.breaking_agents = m.get('BreakingAgents')
        if m.get('InboundTalkingAgents') is not None:
            self.inbound_talking_agents = m.get('InboundTalkingAgents')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LoggedInAgents') is not None:
            self.logged_in_agents = m.get('LoggedInAgents')
        if m.get('LongestCall') is not None:
            self.longest_call = m.get('LongestCall')
        if m.get('OutboundScenarioReadyAgents') is not None:
            self.outbound_scenario_ready_agents = m.get('OutboundScenarioReadyAgents')
        if m.get('OutboundTalkingAgents') is not None:
            self.outbound_talking_agents = m.get('OutboundTalkingAgents')
        if m.get('ReadyAgents') is not None:
            self.ready_agents = m.get('ReadyAgents')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        if m.get('TalkingAgents') is not None:
            self.talking_agents = m.get('TalkingAgents')
        if m.get('WaitingCalls') is not None:
            self.waiting_calls = m.get('WaitingCalls')
        if m.get('WaitingCallsLevel10') is not None:
            self.waiting_calls_level_10 = m.get('WaitingCallsLevel10')
        if m.get('WaitingCallsLevel20') is not None:
            self.waiting_calls_level_20 = m.get('WaitingCallsLevel20')
        if m.get('WaitingCallsLevel30') is not None:
            self.waiting_calls_level_30 = m.get('WaitingCallsLevel30')
        if m.get('WorkingAgents') is not None:
            self.working_agents = m.get('WorkingAgents')
        return self


class ListSkillGroupStatesResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListSkillGroupStatesResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListSkillGroupStatesResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSkillGroupStatesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListSkillGroupStatesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListSkillGroupStatesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSkillGroupStatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSkillGroupStatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSkillGroupStatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSkillGroupSummaryReportsSinceMidnightRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        skill_groups: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.skill_groups = skill_groups

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.skill_groups is not None:
            result['SkillGroups'] = self.skill_groups
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SkillGroups') is not None:
            self.skill_groups = m.get('SkillGroups')
        return self


class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound(TeaModel):
    def __init__(
        self,
        abandoned_in_queue_of_queue_count: int = None,
        answered_by_agent_of_queue_count: int = None,
        answered_by_agent_of_queue_max_wait_time_duration: int = None,
        answered_by_agent_of_queue_wait_time_duration: int = None,
        average_ring_time: int = None,
        average_talk_time: int = None,
        average_work_time: int = None,
        calls_abandoned: int = None,
        calls_attended_transfer_out: int = None,
        calls_blind_transfer_out: int = None,
        calls_handled: int = None,
        calls_offered: int = None,
        calls_overflow: str = None,
        calls_queuing_canceled: str = None,
        calls_queuing_failure: str = None,
        calls_queuing_rerouted: str = None,
        calls_queuing_timeout: int = None,
        calls_service_level_10: int = None,
        calls_service_level_20: int = None,
        calls_service_level_30: int = None,
        calls_timeout: int = None,
        give_up_by_agent_of_queue_count: int = None,
        handle_rate: float = None,
        in_coming_queue_of_queue_count: int = None,
        max_ring_time: int = None,
        max_talk_time: str = None,
        max_work_time: int = None,
        over_flow_in_queue_of_queue_count: int = None,
        queue_max_wait_time_duration: int = None,
        queue_wait_time_duration: int = None,
        satisfaction_index: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        service_level_20: float = None,
        total_ring_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.abandoned_in_queue_of_queue_count = abandoned_in_queue_of_queue_count
        self.answered_by_agent_of_queue_count = answered_by_agent_of_queue_count
        self.answered_by_agent_of_queue_max_wait_time_duration = answered_by_agent_of_queue_max_wait_time_duration
        self.answered_by_agent_of_queue_wait_time_duration = answered_by_agent_of_queue_wait_time_duration
        self.average_ring_time = average_ring_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_abandoned = calls_abandoned
        self.calls_attended_transfer_out = calls_attended_transfer_out
        self.calls_blind_transfer_out = calls_blind_transfer_out
        self.calls_handled = calls_handled
        self.calls_offered = calls_offered
        self.calls_overflow = calls_overflow
        self.calls_queuing_canceled = calls_queuing_canceled
        self.calls_queuing_failure = calls_queuing_failure
        self.calls_queuing_rerouted = calls_queuing_rerouted
        self.calls_queuing_timeout = calls_queuing_timeout
        self.calls_service_level_10 = calls_service_level_10
        self.calls_service_level_20 = calls_service_level_20
        self.calls_service_level_30 = calls_service_level_30
        self.calls_timeout = calls_timeout
        self.give_up_by_agent_of_queue_count = give_up_by_agent_of_queue_count
        self.handle_rate = handle_rate
        self.in_coming_queue_of_queue_count = in_coming_queue_of_queue_count
        self.max_ring_time = max_ring_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.over_flow_in_queue_of_queue_count = over_flow_in_queue_of_queue_count
        self.queue_max_wait_time_duration = queue_max_wait_time_duration
        self.queue_wait_time_duration = queue_wait_time_duration
        self.satisfaction_index = satisfaction_index
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.service_level_20 = service_level_20
        self.total_ring_time = total_ring_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abandoned_in_queue_of_queue_count is not None:
            result['AbandonedInQueueOfQueueCount'] = self.abandoned_in_queue_of_queue_count
        if self.answered_by_agent_of_queue_count is not None:
            result['AnsweredByAgentOfQueueCount'] = self.answered_by_agent_of_queue_count
        if self.answered_by_agent_of_queue_max_wait_time_duration is not None:
            result['AnsweredByAgentOfQueueMaxWaitTimeDuration'] = self.answered_by_agent_of_queue_max_wait_time_duration
        if self.answered_by_agent_of_queue_wait_time_duration is not None:
            result['AnsweredByAgentOfQueueWaitTimeDuration'] = self.answered_by_agent_of_queue_wait_time_duration
        if self.average_ring_time is not None:
            result['AverageRingTime'] = self.average_ring_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_abandoned is not None:
            result['CallsAbandoned'] = self.calls_abandoned
        if self.calls_attended_transfer_out is not None:
            result['CallsAttendedTransferOut'] = self.calls_attended_transfer_out
        if self.calls_blind_transfer_out is not None:
            result['CallsBlindTransferOut'] = self.calls_blind_transfer_out
        if self.calls_handled is not None:
            result['CallsHandled'] = self.calls_handled
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_overflow is not None:
            result['CallsOverflow'] = self.calls_overflow
        if self.calls_queuing_canceled is not None:
            result['CallsQueuingCanceled'] = self.calls_queuing_canceled
        if self.calls_queuing_failure is not None:
            result['CallsQueuingFailure'] = self.calls_queuing_failure
        if self.calls_queuing_rerouted is not None:
            result['CallsQueuingRerouted'] = self.calls_queuing_rerouted
        if self.calls_queuing_timeout is not None:
            result['CallsQueuingTimeout'] = self.calls_queuing_timeout
        if self.calls_service_level_10 is not None:
            result['CallsServiceLevel10'] = self.calls_service_level_10
        if self.calls_service_level_20 is not None:
            result['CallsServiceLevel20'] = self.calls_service_level_20
        if self.calls_service_level_30 is not None:
            result['CallsServiceLevel30'] = self.calls_service_level_30
        if self.calls_timeout is not None:
            result['CallsTimeout'] = self.calls_timeout
        if self.give_up_by_agent_of_queue_count is not None:
            result['GiveUpByAgentOfQueueCount'] = self.give_up_by_agent_of_queue_count
        if self.handle_rate is not None:
            result['HandleRate'] = self.handle_rate
        if self.in_coming_queue_of_queue_count is not None:
            result['InComingQueueOfQueueCount'] = self.in_coming_queue_of_queue_count
        if self.max_ring_time is not None:
            result['MaxRingTime'] = self.max_ring_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.over_flow_in_queue_of_queue_count is not None:
            result['OverFlowInQueueOfQueueCount'] = self.over_flow_in_queue_of_queue_count
        if self.queue_max_wait_time_duration is not None:
            result['QueueMaxWaitTimeDuration'] = self.queue_max_wait_time_duration
        if self.queue_wait_time_duration is not None:
            result['QueueWaitTimeDuration'] = self.queue_wait_time_duration
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.service_level_20 is not None:
            result['ServiceLevel20'] = self.service_level_20
        if self.total_ring_time is not None:
            result['TotalRingTime'] = self.total_ring_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbandonedInQueueOfQueueCount') is not None:
            self.abandoned_in_queue_of_queue_count = m.get('AbandonedInQueueOfQueueCount')
        if m.get('AnsweredByAgentOfQueueCount') is not None:
            self.answered_by_agent_of_queue_count = m.get('AnsweredByAgentOfQueueCount')
        if m.get('AnsweredByAgentOfQueueMaxWaitTimeDuration') is not None:
            self.answered_by_agent_of_queue_max_wait_time_duration = m.get('AnsweredByAgentOfQueueMaxWaitTimeDuration')
        if m.get('AnsweredByAgentOfQueueWaitTimeDuration') is not None:
            self.answered_by_agent_of_queue_wait_time_duration = m.get('AnsweredByAgentOfQueueWaitTimeDuration')
        if m.get('AverageRingTime') is not None:
            self.average_ring_time = m.get('AverageRingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAbandoned') is not None:
            self.calls_abandoned = m.get('CallsAbandoned')
        if m.get('CallsAttendedTransferOut') is not None:
            self.calls_attended_transfer_out = m.get('CallsAttendedTransferOut')
        if m.get('CallsBlindTransferOut') is not None:
            self.calls_blind_transfer_out = m.get('CallsBlindTransferOut')
        if m.get('CallsHandled') is not None:
            self.calls_handled = m.get('CallsHandled')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsOverflow') is not None:
            self.calls_overflow = m.get('CallsOverflow')
        if m.get('CallsQueuingCanceled') is not None:
            self.calls_queuing_canceled = m.get('CallsQueuingCanceled')
        if m.get('CallsQueuingFailure') is not None:
            self.calls_queuing_failure = m.get('CallsQueuingFailure')
        if m.get('CallsQueuingRerouted') is not None:
            self.calls_queuing_rerouted = m.get('CallsQueuingRerouted')
        if m.get('CallsQueuingTimeout') is not None:
            self.calls_queuing_timeout = m.get('CallsQueuingTimeout')
        if m.get('CallsServiceLevel10') is not None:
            self.calls_service_level_10 = m.get('CallsServiceLevel10')
        if m.get('CallsServiceLevel20') is not None:
            self.calls_service_level_20 = m.get('CallsServiceLevel20')
        if m.get('CallsServiceLevel30') is not None:
            self.calls_service_level_30 = m.get('CallsServiceLevel30')
        if m.get('CallsTimeout') is not None:
            self.calls_timeout = m.get('CallsTimeout')
        if m.get('GiveUpByAgentOfQueueCount') is not None:
            self.give_up_by_agent_of_queue_count = m.get('GiveUpByAgentOfQueueCount')
        if m.get('HandleRate') is not None:
            self.handle_rate = m.get('HandleRate')
        if m.get('InComingQueueOfQueueCount') is not None:
            self.in_coming_queue_of_queue_count = m.get('InComingQueueOfQueueCount')
        if m.get('MaxRingTime') is not None:
            self.max_ring_time = m.get('MaxRingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OverFlowInQueueOfQueueCount') is not None:
            self.over_flow_in_queue_of_queue_count = m.get('OverFlowInQueueOfQueueCount')
        if m.get('QueueMaxWaitTimeDuration') is not None:
            self.queue_max_wait_time_duration = m.get('QueueMaxWaitTimeDuration')
        if m.get('QueueWaitTimeDuration') is not None:
            self.queue_wait_time_duration = m.get('QueueWaitTimeDuration')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('ServiceLevel20') is not None:
            self.service_level_20 = m.get('ServiceLevel20')
        if m.get('TotalRingTime') is not None:
            self.total_ring_time = m.get('TotalRingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound(TeaModel):
    def __init__(
        self,
        answer_rate: float = None,
        average_dialing_time: int = None,
        average_talk_time: int = None,
        average_work_time: int = None,
        calls_abandoned: int = None,
        calls_agent_handled: int = None,
        calls_answered: int = None,
        calls_dialed: int = None,
        calls_offered: int = None,
        calls_queuing_cancelled: int = None,
        calls_queuing_failed: int = None,
        calls_queuing_failure: int = None,
        calls_queuing_overflow: int = None,
        calls_queuing_rerouted: int = None,
        calls_queuing_timeout: int = None,
        calls_service_level_30: str = None,
        calls_service_level_30v2: int = None,
        max_dialing_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        satisfaction_index: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_dialing_time: int = None,
        total_talk_time: int = None,
        total_wait_time: int = None,
        total_work_time: int = None,
    ):
        self.answer_rate = answer_rate
        self.average_dialing_time = average_dialing_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.calls_abandoned = calls_abandoned
        self.calls_agent_handled = calls_agent_handled
        self.calls_answered = calls_answered
        self.calls_dialed = calls_dialed
        self.calls_offered = calls_offered
        self.calls_queuing_cancelled = calls_queuing_cancelled
        self.calls_queuing_failed = calls_queuing_failed
        self.calls_queuing_failure = calls_queuing_failure
        self.calls_queuing_overflow = calls_queuing_overflow
        self.calls_queuing_rerouted = calls_queuing_rerouted
        self.calls_queuing_timeout = calls_queuing_timeout
        self.calls_service_level_30 = calls_service_level_30
        self.calls_service_level_30v2 = calls_service_level_30v2
        self.max_dialing_time = max_dialing_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.satisfaction_index = satisfaction_index
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_dialing_time = total_dialing_time
        self.total_talk_time = total_talk_time
        self.total_wait_time = total_wait_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_rate is not None:
            result['AnswerRate'] = self.answer_rate
        if self.average_dialing_time is not None:
            result['AverageDialingTime'] = self.average_dialing_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.calls_abandoned is not None:
            result['CallsAbandoned'] = self.calls_abandoned
        if self.calls_agent_handled is not None:
            result['CallsAgentHandled'] = self.calls_agent_handled
        if self.calls_answered is not None:
            result['CallsAnswered'] = self.calls_answered
        if self.calls_dialed is not None:
            result['CallsDialed'] = self.calls_dialed
        if self.calls_offered is not None:
            result['CallsOffered'] = self.calls_offered
        if self.calls_queuing_cancelled is not None:
            result['CallsQueuingCancelled'] = self.calls_queuing_cancelled
        if self.calls_queuing_failed is not None:
            result['CallsQueuingFailed'] = self.calls_queuing_failed
        if self.calls_queuing_failure is not None:
            result['CallsQueuingFailure'] = self.calls_queuing_failure
        if self.calls_queuing_overflow is not None:
            result['CallsQueuingOverflow'] = self.calls_queuing_overflow
        if self.calls_queuing_rerouted is not None:
            result['CallsQueuingRerouted'] = self.calls_queuing_rerouted
        if self.calls_queuing_timeout is not None:
            result['CallsQueuingTimeout'] = self.calls_queuing_timeout
        if self.calls_service_level_30 is not None:
            result['CallsServiceLevel30'] = self.calls_service_level_30
        if self.calls_service_level_30v2 is not None:
            result['CallsServiceLevel30V2'] = self.calls_service_level_30v2
        if self.max_dialing_time is not None:
            result['MaxDialingTime'] = self.max_dialing_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_dialing_time is not None:
            result['TotalDialingTime'] = self.total_dialing_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_wait_time is not None:
            result['TotalWaitTime'] = self.total_wait_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerRate') is not None:
            self.answer_rate = m.get('AnswerRate')
        if m.get('AverageDialingTime') is not None:
            self.average_dialing_time = m.get('AverageDialingTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('CallsAbandoned') is not None:
            self.calls_abandoned = m.get('CallsAbandoned')
        if m.get('CallsAgentHandled') is not None:
            self.calls_agent_handled = m.get('CallsAgentHandled')
        if m.get('CallsAnswered') is not None:
            self.calls_answered = m.get('CallsAnswered')
        if m.get('CallsDialed') is not None:
            self.calls_dialed = m.get('CallsDialed')
        if m.get('CallsOffered') is not None:
            self.calls_offered = m.get('CallsOffered')
        if m.get('CallsQueuingCancelled') is not None:
            self.calls_queuing_cancelled = m.get('CallsQueuingCancelled')
        if m.get('CallsQueuingFailed') is not None:
            self.calls_queuing_failed = m.get('CallsQueuingFailed')
        if m.get('CallsQueuingFailure') is not None:
            self.calls_queuing_failure = m.get('CallsQueuingFailure')
        if m.get('CallsQueuingOverflow') is not None:
            self.calls_queuing_overflow = m.get('CallsQueuingOverflow')
        if m.get('CallsQueuingRerouted') is not None:
            self.calls_queuing_rerouted = m.get('CallsQueuingRerouted')
        if m.get('CallsQueuingTimeout') is not None:
            self.calls_queuing_timeout = m.get('CallsQueuingTimeout')
        if m.get('CallsServiceLevel30') is not None:
            self.calls_service_level_30 = m.get('CallsServiceLevel30')
        if m.get('CallsServiceLevel30V2') is not None:
            self.calls_service_level_30v2 = m.get('CallsServiceLevel30V2')
        if m.get('MaxDialingTime') is not None:
            self.max_dialing_time = m.get('MaxDialingTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalDialingTime') is not None:
            self.total_dialing_time = m.get('TotalDialingTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWaitTime') is not None:
            self.total_wait_time = m.get('TotalWaitTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall(TeaModel):
    def __init__(
        self,
        average_ready_time: int = None,
        average_talk_time: int = None,
        average_work_time: int = None,
        max_ready_time: int = None,
        max_talk_time: int = None,
        max_work_time: int = None,
        occupancy_rate: float = None,
        satisfaction_index: float = None,
        satisfaction_surveys_offered: int = None,
        satisfaction_surveys_responded: int = None,
        total_break_time: int = None,
        total_calls: int = None,
        total_logged_in_time: int = None,
        total_ready_time: int = None,
        total_talk_time: int = None,
        total_work_time: int = None,
    ):
        self.average_ready_time = average_ready_time
        self.average_talk_time = average_talk_time
        self.average_work_time = average_work_time
        self.max_ready_time = max_ready_time
        self.max_talk_time = max_talk_time
        self.max_work_time = max_work_time
        self.occupancy_rate = occupancy_rate
        self.satisfaction_index = satisfaction_index
        self.satisfaction_surveys_offered = satisfaction_surveys_offered
        self.satisfaction_surveys_responded = satisfaction_surveys_responded
        self.total_break_time = total_break_time
        self.total_calls = total_calls
        self.total_logged_in_time = total_logged_in_time
        self.total_ready_time = total_ready_time
        self.total_talk_time = total_talk_time
        self.total_work_time = total_work_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_ready_time is not None:
            result['AverageReadyTime'] = self.average_ready_time
        if self.average_talk_time is not None:
            result['AverageTalkTime'] = self.average_talk_time
        if self.average_work_time is not None:
            result['AverageWorkTime'] = self.average_work_time
        if self.max_ready_time is not None:
            result['MaxReadyTime'] = self.max_ready_time
        if self.max_talk_time is not None:
            result['MaxTalkTime'] = self.max_talk_time
        if self.max_work_time is not None:
            result['MaxWorkTime'] = self.max_work_time
        if self.occupancy_rate is not None:
            result['OccupancyRate'] = self.occupancy_rate
        if self.satisfaction_index is not None:
            result['SatisfactionIndex'] = self.satisfaction_index
        if self.satisfaction_surveys_offered is not None:
            result['SatisfactionSurveysOffered'] = self.satisfaction_surveys_offered
        if self.satisfaction_surveys_responded is not None:
            result['SatisfactionSurveysResponded'] = self.satisfaction_surveys_responded
        if self.total_break_time is not None:
            result['TotalBreakTime'] = self.total_break_time
        if self.total_calls is not None:
            result['TotalCalls'] = self.total_calls
        if self.total_logged_in_time is not None:
            result['TotalLoggedInTime'] = self.total_logged_in_time
        if self.total_ready_time is not None:
            result['TotalReadyTime'] = self.total_ready_time
        if self.total_talk_time is not None:
            result['TotalTalkTime'] = self.total_talk_time
        if self.total_work_time is not None:
            result['TotalWorkTime'] = self.total_work_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AverageReadyTime') is not None:
            self.average_ready_time = m.get('AverageReadyTime')
        if m.get('AverageTalkTime') is not None:
            self.average_talk_time = m.get('AverageTalkTime')
        if m.get('AverageWorkTime') is not None:
            self.average_work_time = m.get('AverageWorkTime')
        if m.get('MaxReadyTime') is not None:
            self.max_ready_time = m.get('MaxReadyTime')
        if m.get('MaxTalkTime') is not None:
            self.max_talk_time = m.get('MaxTalkTime')
        if m.get('MaxWorkTime') is not None:
            self.max_work_time = m.get('MaxWorkTime')
        if m.get('OccupancyRate') is not None:
            self.occupancy_rate = m.get('OccupancyRate')
        if m.get('SatisfactionIndex') is not None:
            self.satisfaction_index = m.get('SatisfactionIndex')
        if m.get('SatisfactionSurveysOffered') is not None:
            self.satisfaction_surveys_offered = m.get('SatisfactionSurveysOffered')
        if m.get('SatisfactionSurveysResponded') is not None:
            self.satisfaction_surveys_responded = m.get('SatisfactionSurveysResponded')
        if m.get('TotalBreakTime') is not None:
            self.total_break_time = m.get('TotalBreakTime')
        if m.get('TotalCalls') is not None:
            self.total_calls = m.get('TotalCalls')
        if m.get('TotalLoggedInTime') is not None:
            self.total_logged_in_time = m.get('TotalLoggedInTime')
        if m.get('TotalReadyTime') is not None:
            self.total_ready_time = m.get('TotalReadyTime')
        if m.get('TotalTalkTime') is not None:
            self.total_talk_time = m.get('TotalTalkTime')
        if m.get('TotalWorkTime') is not None:
            self.total_work_time = m.get('TotalWorkTime')
        return self


class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList(TeaModel):
    def __init__(
        self,
        inbound: ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound = None,
        instance_id: str = None,
        outbound: ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound = None,
        overall: ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
        timestamp: str = None,
    ):
        self.inbound = inbound
        self.instance_id = instance_id
        self.outbound = outbound
        self.overall = overall
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name
        self.timestamp = timestamp

    def validate(self):
        if self.inbound:
            self.inbound.validate()
        if self.outbound:
            self.outbound.validate()
        if self.overall:
            self.overall.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inbound is not None:
            result['Inbound'] = self.inbound.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.outbound is not None:
            result['Outbound'] = self.outbound.to_map()
        if self.overall is not None:
            result['Overall'] = self.overall.to_map()
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Inbound') is not None:
            temp_model = ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound()
            self.inbound = temp_model.from_map(m['Inbound'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Outbound') is not None:
            temp_model = ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound()
            self.outbound = temp_model.from_map(m['Outbound'])
        if m.get('Overall') is not None:
            temp_model = ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall()
            self.overall = temp_model.from_map(m['Overall'])
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport(TeaModel):
    def __init__(
        self,
        list: List[ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSkillGroupSummaryReportsSinceMidnightResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        paged_skill_group_summary_report: ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.paged_skill_group_summary_report = paged_skill_group_summary_report
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paged_skill_group_summary_report:
            self.paged_skill_group_summary_report.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.paged_skill_group_summary_report is not None:
            result['PagedSkillGroupSummaryReport'] = self.paged_skill_group_summary_report.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PagedSkillGroupSummaryReport') is not None:
            temp_model = ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport()
            self.paged_skill_group_summary_report = temp_model.from_map(m['PagedSkillGroupSummaryReport'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSkillGroupSummaryReportsSinceMidnightResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSkillGroupSummaryReportsSinceMidnightResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSkillGroupSummaryReportsSinceMidnightResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSkillGroupsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        media_type: str = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.media_type = media_type
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        return self


class ListSkillGroupsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        instance_id: str = None,
        media_type: str = None,
        phone_number_count: int = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
        user_count: int = None,
    ):
        self.description = description
        self.display_name = display_name
        self.instance_id = instance_id
        self.media_type = media_type
        self.phone_number_count = phone_number_count
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name
        self.user_count = user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.phone_number_count is not None:
            result['PhoneNumberCount'] = self.phone_number_count
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        if self.user_count is not None:
            result['UserCount'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('PhoneNumberCount') is not None:
            self.phone_number_count = m.get('PhoneNumberCount')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        if m.get('UserCount') is not None:
            self.user_count = m.get('UserCount')
        return self


class ListSkillGroupsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListSkillGroupsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListSkillGroupsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSkillGroupsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListSkillGroupsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListSkillGroupsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSkillGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSkillGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSkillGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSkillLevelsOfUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        is_member: bool = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.is_member = is_member
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.is_member is not None:
            result['IsMember'] = self.is_member
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IsMember') is not None:
            self.is_member = m.get('IsMember')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListSkillLevelsOfUserResponseBodyDataList(TeaModel):
    def __init__(
        self,
        media_type: str = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
        skill_level: str = None,
    ):
        self.media_type = media_type
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name
        self.skill_level = skill_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        if self.skill_level is not None:
            result['SkillLevel'] = self.skill_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        if m.get('SkillLevel') is not None:
            self.skill_level = m.get('SkillLevel')
        return self


class ListSkillLevelsOfUserResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListSkillLevelsOfUserResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListSkillLevelsOfUserResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSkillLevelsOfUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListSkillLevelsOfUserResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListSkillLevelsOfUserResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSkillLevelsOfUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSkillLevelsOfUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSkillLevelsOfUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSmsMetadataRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        scenario_list_json: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.scenario_list_json = scenario_list_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scenario_list_json is not None:
            result['ScenarioListJson'] = self.scenario_list_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScenarioListJson') is not None:
            self.scenario_list_json = m.get('ScenarioListJson')
        return self


class ListSmsMetadataResponseBodyDataList(TeaModel):
    def __init__(
        self,
        aliyun_uid: int = None,
        description: str = None,
        instance_id: str = None,
        name: str = None,
        scenario: str = None,
        sign_name: str = None,
        sms_metadata_id: str = None,
        template_code: str = None,
    ):
        self.aliyun_uid = aliyun_uid
        self.description = description
        self.instance_id = instance_id
        self.name = name
        self.scenario = scenario
        self.sign_name = sign_name
        self.sms_metadata_id = sms_metadata_id
        self.template_code = template_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_uid is not None:
            result['AliyunUid'] = self.aliyun_uid
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.sign_name is not None:
            result['SignName'] = self.sign_name
        if self.sms_metadata_id is not None:
            result['SmsMetadataId'] = self.sms_metadata_id
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunUid') is not None:
            self.aliyun_uid = m.get('AliyunUid')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('SignName') is not None:
            self.sign_name = m.get('SignName')
        if m.get('SmsMetadataId') is not None:
            self.sms_metadata_id = m.get('SmsMetadataId')
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class ListSmsMetadataResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListSmsMetadataResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListSmsMetadataResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSmsMetadataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListSmsMetadataResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListSmsMetadataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSmsMetadataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSmsMetadataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSmsMetadataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTicketTasksRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        ticket_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class ListTicketTasksResponseBodyData(TeaModel):
    def __init__(
        self,
        action: str = None,
        assignee: str = None,
        assignee_name: str = None,
        comment: str = None,
        end_time: int = None,
        file_keys: List[str] = None,
        file_urls: List[str] = None,
        instance_id: str = None,
        start_time: int = None,
        task_definition_node_id: str = None,
        task_definition_node_type: str = None,
        task_id: str = None,
        task_name: str = None,
        ticket_id: str = None,
    ):
        self.action = action
        self.assignee = assignee
        self.assignee_name = assignee_name
        self.comment = comment
        self.end_time = end_time
        self.file_keys = file_keys
        self.file_urls = file_urls
        self.instance_id = instance_id
        self.start_time = start_time
        self.task_definition_node_id = task_definition_node_id
        self.task_definition_node_type = task_definition_node_type
        self.task_id = task_id
        self.task_name = task_name
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.assignee is not None:
            result['Assignee'] = self.assignee
        if self.assignee_name is not None:
            result['AssigneeName'] = self.assignee_name
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_keys is not None:
            result['FileKeys'] = self.file_keys
        if self.file_urls is not None:
            result['FileUrls'] = self.file_urls
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_definition_node_id is not None:
            result['TaskDefinitionNodeId'] = self.task_definition_node_id
        if self.task_definition_node_type is not None:
            result['TaskDefinitionNodeType'] = self.task_definition_node_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Assignee') is not None:
            self.assignee = m.get('Assignee')
        if m.get('AssigneeName') is not None:
            self.assignee_name = m.get('AssigneeName')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileKeys') is not None:
            self.file_keys = m.get('FileKeys')
        if m.get('FileUrls') is not None:
            self.file_urls = m.get('FileUrls')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskDefinitionNodeId') is not None:
            self.task_definition_node_id = m.get('TaskDefinitionNodeId')
        if m.get('TaskDefinitionNodeType') is not None:
            self.task_definition_node_type = m.get('TaskDefinitionNodeType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class ListTicketTasksResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListTicketTasksResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListTicketTasksResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTicketTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTicketTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTicketTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTicketTemplatesRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
        state: str = None,
    ):
        self.category_id = category_id
        # This parameter is required.
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.search_pattern = search_pattern
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListTicketTemplatesResponseBodyDataListTicketFields(TeaModel):
    def __init__(
        self,
        array: bool = None,
        attribute: str = None,
        created_time: int = None,
        creator: str = None,
        data_type: str = None,
        description: str = None,
        disabled: bool = None,
        display_name: str = None,
        display_order: int = None,
        editor_type: str = None,
        max_length: int = None,
        maximum: float = None,
        min_length: int = None,
        minimum: float = None,
        name: str = None,
        pattern: str = None,
        pattern_error_message: str = None,
        read_only: bool = None,
        required: bool = None,
        system: bool = None,
        updated_time: int = None,
    ):
        self.array = array
        self.attribute = attribute
        self.created_time = created_time
        self.creator = creator
        self.data_type = data_type
        self.description = description
        self.disabled = disabled
        self.display_name = display_name
        self.display_order = display_order
        self.editor_type = editor_type
        self.max_length = max_length
        self.maximum = maximum
        self.min_length = min_length
        self.minimum = minimum
        self.name = name
        self.pattern = pattern
        self.pattern_error_message = pattern_error_message
        self.read_only = read_only
        self.required = required
        self.system = system
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.array is not None:
            result['Array'] = self.array
        if self.attribute is not None:
            result['Attribute'] = self.attribute
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.description is not None:
            result['Description'] = self.description
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.display_order is not None:
            result['DisplayOrder'] = self.display_order
        if self.editor_type is not None:
            result['EditorType'] = self.editor_type
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.pattern_error_message is not None:
            result['PatternErrorMessage'] = self.pattern_error_message
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.required is not None:
            result['Required'] = self.required
        if self.system is not None:
            result['System'] = self.system
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Array') is not None:
            self.array = m.get('Array')
        if m.get('Attribute') is not None:
            self.attribute = m.get('Attribute')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('DisplayOrder') is not None:
            self.display_order = m.get('DisplayOrder')
        if m.get('EditorType') is not None:
            self.editor_type = m.get('EditorType')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('PatternErrorMessage') is not None:
            self.pattern_error_message = m.get('PatternErrorMessage')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('System') is not None:
            self.system = m.get('System')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class ListTicketTemplatesResponseBodyDataList(TeaModel):
    def __init__(
        self,
        applied_version: str = None,
        category_id: str = None,
        editor: str = None,
        instance_id: str = None,
        latest_version: str = None,
        name: str = None,
        process_definition: str = None,
        state: str = None,
        template_id: str = None,
        ticket_fields: List[ListTicketTemplatesResponseBodyDataListTicketFields] = None,
        updated_time: int = None,
    ):
        self.applied_version = applied_version
        self.category_id = category_id
        self.editor = editor
        self.instance_id = instance_id
        self.latest_version = latest_version
        self.name = name
        self.process_definition = process_definition
        self.state = state
        self.template_id = template_id
        self.ticket_fields = ticket_fields
        self.updated_time = updated_time

    def validate(self):
        if self.ticket_fields:
            for k in self.ticket_fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.applied_version is not None:
            result['AppliedVersion'] = self.applied_version
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.editor is not None:
            result['Editor'] = self.editor
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.latest_version is not None:
            result['LatestVersion'] = self.latest_version
        if self.name is not None:
            result['Name'] = self.name
        if self.process_definition is not None:
            result['ProcessDefinition'] = self.process_definition
        if self.state is not None:
            result['State'] = self.state
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['TicketFields'] = []
        if self.ticket_fields is not None:
            for k in self.ticket_fields:
                result['TicketFields'].append(k.to_map() if k else None)
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppliedVersion') is not None:
            self.applied_version = m.get('AppliedVersion')
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Editor') is not None:
            self.editor = m.get('Editor')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LatestVersion') is not None:
            self.latest_version = m.get('LatestVersion')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProcessDefinition') is not None:
            self.process_definition = m.get('ProcessDefinition')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.ticket_fields = []
        if m.get('TicketFields') is not None:
            for k in m.get('TicketFields'):
                temp_model = ListTicketTemplatesResponseBodyDataListTicketFields()
                self.ticket_fields.append(temp_model.from_map(k))
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class ListTicketTemplatesResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListTicketTemplatesResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListTicketTemplatesResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTicketTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListTicketTemplatesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListTicketTemplatesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTicketTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTicketTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTicketTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTicketsRequest(TeaModel):
    def __init__(
        self,
        assignee: str = None,
        assignee_type: str = None,
        category_id: str = None,
        creator: str = None,
        customer_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        job_id_list: str = None,
        page_number: int = None,
        page_size: int = None,
        participant: str = None,
        start_time: int = None,
        state: str = None,
        ticket_id: str = None,
        title: str = None,
    ):
        self.assignee = assignee
        self.assignee_type = assignee_type
        self.category_id = category_id
        self.creator = creator
        self.customer_id = customer_id
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.job_id_list = job_id_list
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.participant = participant
        self.start_time = start_time
        self.state = state
        self.ticket_id = ticket_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assignee is not None:
            result['Assignee'] = self.assignee
        if self.assignee_type is not None:
            result['AssigneeType'] = self.assignee_type
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.customer_id is not None:
            result['CustomerId'] = self.customer_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id_list is not None:
            result['JobIdList'] = self.job_id_list
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.participant is not None:
            result['Participant'] = self.participant
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assignee') is not None:
            self.assignee = m.get('Assignee')
        if m.get('AssigneeType') is not None:
            self.assignee_type = m.get('AssigneeType')
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('CustomerId') is not None:
            self.customer_id = m.get('CustomerId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobIdList') is not None:
            self.job_id_list = m.get('JobIdList')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Participant') is not None:
            self.participant = m.get('Participant')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class ListTicketsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        assignee: str = None,
        assignee_name: str = None,
        category_id: str = None,
        category_name: str = None,
        close_code: str = None,
        comment: str = None,
        context: str = None,
        created_time: str = None,
        creator: str = None,
        creator_name: str = None,
        current_task_id: str = None,
        current_task_name: str = None,
        current_task_start_time: int = None,
        customer_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        job_id: str = None,
        source: str = None,
        start_time: int = None,
        state: str = None,
        template_id: str = None,
        template_version: str = None,
        ticket_id: str = None,
        title: str = None,
        updated_time: str = None,
    ):
        self.assignee = assignee
        self.assignee_name = assignee_name
        self.category_id = category_id
        self.category_name = category_name
        self.close_code = close_code
        self.comment = comment
        self.context = context
        self.created_time = created_time
        self.creator = creator
        self.creator_name = creator_name
        self.current_task_id = current_task_id
        self.current_task_name = current_task_name
        self.current_task_start_time = current_task_start_time
        self.customer_id = customer_id
        self.end_time = end_time
        self.instance_id = instance_id
        self.job_id = job_id
        self.source = source
        self.start_time = start_time
        self.state = state
        self.template_id = template_id
        self.template_version = template_version
        self.ticket_id = ticket_id
        self.title = title
        self.updated_time = updated_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assignee is not None:
            result['Assignee'] = self.assignee
        if self.assignee_name is not None:
            result['AssigneeName'] = self.assignee_name
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.category_name is not None:
            result['CategoryName'] = self.category_name
        if self.close_code is not None:
            result['CloseCode'] = self.close_code
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.context is not None:
            result['Context'] = self.context
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.current_task_id is not None:
            result['CurrentTaskId'] = self.current_task_id
        if self.current_task_name is not None:
            result['CurrentTaskName'] = self.current_task_name
        if self.current_task_start_time is not None:
            result['CurrentTaskStartTime'] = self.current_task_start_time
        if self.customer_id is not None:
            result['CustomerId'] = self.customer_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_version is not None:
            result['TemplateVersion'] = self.template_version
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        if self.title is not None:
            result['Title'] = self.title
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assignee') is not None:
            self.assignee = m.get('Assignee')
        if m.get('AssigneeName') is not None:
            self.assignee_name = m.get('AssigneeName')
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('CategoryName') is not None:
            self.category_name = m.get('CategoryName')
        if m.get('CloseCode') is not None:
            self.close_code = m.get('CloseCode')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('CurrentTaskId') is not None:
            self.current_task_id = m.get('CurrentTaskId')
        if m.get('CurrentTaskName') is not None:
            self.current_task_name = m.get('CurrentTaskName')
        if m.get('CurrentTaskStartTime') is not None:
            self.current_task_start_time = m.get('CurrentTaskStartTime')
        if m.get('CustomerId') is not None:
            self.customer_id = m.get('CustomerId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateVersion') is not None:
            self.template_version = m.get('TemplateVersion')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        return self


class ListTicketsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListTicketsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListTicketsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTicketsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListTicketsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListTicketsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTicketsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTicketsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTicketsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUnassignedNumbersRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
    ):
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        return self


class ListUnassignedNumbersResponseBodyDataList(TeaModel):
    def __init__(
        self,
        city: str = None,
        number: str = None,
        province: str = None,
    ):
        self.city = city
        self.number = number
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city is not None:
            result['City'] = self.city
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class ListUnassignedNumbersResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListUnassignedNumbersResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListUnassignedNumbersResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUnassignedNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListUnassignedNumbersResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListUnassignedNumbersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUnassignedNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUnassignedNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUnassignedNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserLevelsOfSkillGroupRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        is_member: bool = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
        skill_group_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.is_member = is_member
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern
        # This parameter is required.
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.is_member is not None:
            result['IsMember'] = self.is_member
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IsMember') is not None:
            self.is_member = m.get('IsMember')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class ListUserLevelsOfSkillGroupResponseBodyDataList(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        login_name: str = None,
        ram_id: str = None,
        role_id: str = None,
        role_name: str = None,
        skill_group_id: str = None,
        skill_group_name: str = None,
        skill_level: int = None,
        user_id: str = None,
    ):
        self.display_name = display_name
        self.login_name = login_name
        self.ram_id = ram_id
        self.role_id = role_id
        self.role_name = role_name
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name
        self.skill_level = skill_level
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.ram_id is not None:
            result['RamId'] = self.ram_id
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        if self.skill_level is not None:
            result['SkillLevel'] = self.skill_level
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('RamId') is not None:
            self.ram_id = m.get('RamId')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        if m.get('SkillLevel') is not None:
            self.skill_level = m.get('SkillLevel')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListUserLevelsOfSkillGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListUserLevelsOfSkillGroupResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListUserLevelsOfSkillGroupResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUserLevelsOfSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListUserLevelsOfSkillGroupResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListUserLevelsOfSkillGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUserLevelsOfSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserLevelsOfSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserLevelsOfSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUsersRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        search_pattern: str = None,
        skill_group_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.search_pattern = search_pattern
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_pattern is not None:
            result['SearchPattern'] = self.search_pattern
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchPattern') is not None:
            self.search_pattern = m.get('SearchPattern')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class ListUsersResponseBodyDataListPersonalOutboundNumberList(TeaModel):
    def __init__(
        self,
        active: bool = None,
        city: str = None,
        number: str = None,
        province: str = None,
        usage: str = None,
    ):
        self.active = active
        self.city = city
        self.number = number
        self.province = province
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.city is not None:
            result['City'] = self.city
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class ListUsersResponseBodyDataListSkillLevelList(TeaModel):
    def __init__(
        self,
        skill_group_id: str = None,
        skill_group_name: str = None,
        skill_level: int = None,
    ):
        self.skill_group_id = skill_group_id
        self.skill_group_name = skill_group_name
        self.skill_level = skill_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.skill_group_name is not None:
            result['SkillGroupName'] = self.skill_group_name
        if self.skill_level is not None:
            result['SkillLevel'] = self.skill_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('SkillGroupName') is not None:
            self.skill_group_name = m.get('SkillGroupName')
        if m.get('SkillLevel') is not None:
            self.skill_level = m.get('SkillLevel')
        return self


class ListUsersResponseBodyDataList(TeaModel):
    def __init__(
        self,
        device_ext: str = None,
        device_id: str = None,
        device_state: str = None,
        display_id: str = None,
        display_name: str = None,
        email: str = None,
        extension: str = None,
        login_name: str = None,
        mobile: str = None,
        personal_outbound_number_list: List[ListUsersResponseBodyDataListPersonalOutboundNumberList] = None,
        primary: bool = None,
        primary_account: bool = None,
        ram_id: int = None,
        role_id: str = None,
        role_name: str = None,
        skill_level_list: List[ListUsersResponseBodyDataListSkillLevelList] = None,
        user_id: str = None,
        work_mode: str = None,
    ):
        self.device_ext = device_ext
        self.device_id = device_id
        self.device_state = device_state
        self.display_id = display_id
        self.display_name = display_name
        self.email = email
        self.extension = extension
        self.login_name = login_name
        self.mobile = mobile
        self.personal_outbound_number_list = personal_outbound_number_list
        self.primary = primary
        self.primary_account = primary_account
        self.ram_id = ram_id
        self.role_id = role_id
        self.role_name = role_name
        self.skill_level_list = skill_level_list
        self.user_id = user_id
        self.work_mode = work_mode

    def validate(self):
        if self.personal_outbound_number_list:
            for k in self.personal_outbound_number_list:
                if k:
                    k.validate()
        if self.skill_level_list:
            for k in self.skill_level_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_ext is not None:
            result['DeviceExt'] = self.device_ext
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.display_id is not None:
            result['DisplayId'] = self.display_id
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.email is not None:
            result['Email'] = self.email
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        result['PersonalOutboundNumberList'] = []
        if self.personal_outbound_number_list is not None:
            for k in self.personal_outbound_number_list:
                result['PersonalOutboundNumberList'].append(k.to_map() if k else None)
        if self.primary is not None:
            result['Primary'] = self.primary
        if self.primary_account is not None:
            result['PrimaryAccount'] = self.primary_account
        if self.ram_id is not None:
            result['RamId'] = self.ram_id
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        result['SkillLevelList'] = []
        if self.skill_level_list is not None:
            for k in self.skill_level_list:
                result['SkillLevelList'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceExt') is not None:
            self.device_ext = m.get('DeviceExt')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('DisplayId') is not None:
            self.display_id = m.get('DisplayId')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        self.personal_outbound_number_list = []
        if m.get('PersonalOutboundNumberList') is not None:
            for k in m.get('PersonalOutboundNumberList'):
                temp_model = ListUsersResponseBodyDataListPersonalOutboundNumberList()
                self.personal_outbound_number_list.append(temp_model.from_map(k))
        if m.get('Primary') is not None:
            self.primary = m.get('Primary')
        if m.get('PrimaryAccount') is not None:
            self.primary_account = m.get('PrimaryAccount')
        if m.get('RamId') is not None:
            self.ram_id = m.get('RamId')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        self.skill_level_list = []
        if m.get('SkillLevelList') is not None:
            for k in m.get('SkillLevelList'):
                temp_model = ListUsersResponseBodyDataListSkillLevelList()
                self.skill_level_list.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ListUsersResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListUsersResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListUsersResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUsersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListUsersResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListUsersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVisitorChatMessagesRequest(TeaModel):
    def __init__(
        self,
        access_channel_id: str = None,
        access_token: str = None,
        end_time: str = None,
        instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        sort_order: str = None,
        start_time: int = None,
        visitor_id: str = None,
    ):
        self.access_channel_id = access_channel_id
        self.access_token = access_token
        self.end_time = end_time
        self.instance_id = instance_id
        self.next_page_token = next_page_token
        self.page_size = page_size
        self.sort_order = sort_order
        self.start_time = start_time
        self.visitor_id = visitor_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_id is not None:
            result['AccessChannelId'] = self.access_channel_id
        if self.access_token is not None:
            result['AccessToken'] = self.access_token
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_order is not None:
            result['SortOrder'] = self.sort_order
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.visitor_id is not None:
            result['VisitorId'] = self.visitor_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelId') is not None:
            self.access_channel_id = m.get('AccessChannelId')
        if m.get('AccessToken') is not None:
            self.access_token = m.get('AccessToken')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortOrder') is not None:
            self.sort_order = m.get('SortOrder')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('VisitorId') is not None:
            self.visitor_id = m.get('VisitorId')
        return self


class ListVisitorChatMessagesResponseBodyDataMessages(TeaModel):
    def __init__(
        self,
        content: str = None,
        job_id: str = None,
        sender_avatar_url: str = None,
        sender_id: str = None,
        sender_name: str = None,
        sender_type: str = None,
        timestamp: int = None,
    ):
        self.content = content
        self.job_id = job_id
        self.sender_avatar_url = sender_avatar_url
        self.sender_id = sender_id
        self.sender_name = sender_name
        self.sender_type = sender_type
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.sender_avatar_url is not None:
            result['SenderAvatarUrl'] = self.sender_avatar_url
        if self.sender_id is not None:
            result['SenderId'] = self.sender_id
        if self.sender_name is not None:
            result['SenderName'] = self.sender_name
        if self.sender_type is not None:
            result['SenderType'] = self.sender_type
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('SenderAvatarUrl') is not None:
            self.sender_avatar_url = m.get('SenderAvatarUrl')
        if m.get('SenderId') is not None:
            self.sender_id = m.get('SenderId')
        if m.get('SenderName') is not None:
            self.sender_name = m.get('SenderName')
        if m.get('SenderType') is not None:
            self.sender_type = m.get('SenderType')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class ListVisitorChatMessagesResponseBodyData(TeaModel):
    def __init__(
        self,
        messages: List[ListVisitorChatMessagesResponseBodyDataMessages] = None,
        next_page_token: str = None,
    ):
        self.messages = messages
        self.next_page_token = next_page_token

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['Messages'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.messages = []
        if m.get('Messages') is not None:
            for k in m.get('Messages'):
                temp_model = ListVisitorChatMessagesResponseBodyDataMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        return self


class ListVisitorChatMessagesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListVisitorChatMessagesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListVisitorChatMessagesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListVisitorChatMessagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVisitorChatMessagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVisitorChatMessagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVoicemailsRequest(TeaModel):
    def __init__(
        self,
        caller: str = None,
        contact_id: str = None,
        end_time: int = None,
        instance_id: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
    ):
        self.caller = caller
        self.contact_id = contact_id
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.name = name
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListVoicemailsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        callee: str = None,
        caller: str = None,
        cdr_start_time: int = None,
        contact_id: str = None,
        duration: int = None,
        instance_id: str = None,
        name: str = None,
        recording_duration: int = None,
        start_time: str = None,
    ):
        self.callee = callee
        self.caller = caller
        self.cdr_start_time = cdr_start_time
        self.contact_id = contact_id
        self.duration = duration
        self.instance_id = instance_id
        self.name = name
        self.recording_duration = recording_duration
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.cdr_start_time is not None:
            result['CdrStartTime'] = self.cdr_start_time
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.recording_duration is not None:
            result['RecordingDuration'] = self.recording_duration
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('CdrStartTime') is not None:
            self.cdr_start_time = m.get('CdrStartTime')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RecordingDuration') is not None:
            self.recording_duration = m.get('RecordingDuration')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListVoicemailsResponseBodyData(TeaModel):
    def __init__(
        self,
        list: List[ListVoicemailsResponseBodyDataList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = ListVoicemailsResponseBodyDataList()
                self.list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListVoicemailsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListVoicemailsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListVoicemailsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListVoicemailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVoicemailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVoicemailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWaitingChatsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        skill_group_id_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.skill_group_id_list = skill_group_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        return self


class ListWaitingChatsResponseBodyDataMessages(TeaModel):
    def __init__(
        self,
        content: str = None,
        sender_id: str = None,
        sender_type: str = None,
    ):
        self.content = content
        self.sender_id = sender_id
        self.sender_type = sender_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.sender_id is not None:
            result['SenderId'] = self.sender_id
        if self.sender_type is not None:
            result['SenderType'] = self.sender_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('SenderId') is not None:
            self.sender_id = m.get('SenderId')
        if m.get('SenderType') is not None:
            self.sender_type = m.get('SenderType')
        return self


class ListWaitingChatsResponseBodyDataUserList(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        user_id: str = None,
        user_name: str = None,
        user_type: str = None,
    ):
        self.avatar_url = avatar_url
        self.user_id = user_id
        self.user_name = user_name
        self.user_type = user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class ListWaitingChatsResponseBodyData(TeaModel):
    def __init__(
        self,
        access_channel_id: str = None,
        access_channel_type: str = None,
        being_assigned: bool = None,
        chat_conversation_id: str = None,
        enqueue_time: int = None,
        job_id: str = None,
        messages: List[ListWaitingChatsResponseBodyDataMessages] = None,
        skill_group_id: str = None,
        user_list: List[ListWaitingChatsResponseBodyDataUserList] = None,
    ):
        self.access_channel_id = access_channel_id
        self.access_channel_type = access_channel_type
        self.being_assigned = being_assigned
        self.chat_conversation_id = chat_conversation_id
        self.enqueue_time = enqueue_time
        self.job_id = job_id
        self.messages = messages
        self.skill_group_id = skill_group_id
        self.user_list = user_list

    def validate(self):
        if self.messages:
            for k in self.messages:
                if k:
                    k.validate()
        if self.user_list:
            for k in self.user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_id is not None:
            result['AccessChannelId'] = self.access_channel_id
        if self.access_channel_type is not None:
            result['AccessChannelType'] = self.access_channel_type
        if self.being_assigned is not None:
            result['BeingAssigned'] = self.being_assigned
        if self.chat_conversation_id is not None:
            result['ChatConversationId'] = self.chat_conversation_id
        if self.enqueue_time is not None:
            result['EnqueueTime'] = self.enqueue_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        result['Messages'] = []
        if self.messages is not None:
            for k in self.messages:
                result['Messages'].append(k.to_map() if k else None)
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        result['UserList'] = []
        if self.user_list is not None:
            for k in self.user_list:
                result['UserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelId') is not None:
            self.access_channel_id = m.get('AccessChannelId')
        if m.get('AccessChannelType') is not None:
            self.access_channel_type = m.get('AccessChannelType')
        if m.get('BeingAssigned') is not None:
            self.being_assigned = m.get('BeingAssigned')
        if m.get('ChatConversationId') is not None:
            self.chat_conversation_id = m.get('ChatConversationId')
        if m.get('EnqueueTime') is not None:
            self.enqueue_time = m.get('EnqueueTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        self.messages = []
        if m.get('Messages') is not None:
            for k in m.get('Messages'):
                temp_model = ListWaitingChatsResponseBodyDataMessages()
                self.messages.append(temp_model.from_map(k))
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        self.user_list = []
        if m.get('UserList') is not None:
            for k in m.get('UserList'):
                temp_model = ListWaitingChatsResponseBodyDataUserList()
                self.user_list.append(temp_model.from_map(k))
        return self


class ListWaitingChatsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListWaitingChatsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListWaitingChatsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListWaitingChatsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWaitingChatsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWaitingChatsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MakeCallRequest(TeaModel):
    def __init__(
        self,
        callee: str = None,
        caller: str = None,
        device_id: str = None,
        flash_sms_variables: str = None,
        instance_id: str = None,
        masked_callee: str = None,
        media_type: str = None,
        tags: str = None,
        timeout_seconds: int = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.callee = callee
        self.caller = caller
        self.device_id = device_id
        self.flash_sms_variables = flash_sms_variables
        # This parameter is required.
        self.instance_id = instance_id
        self.masked_callee = masked_callee
        self.media_type = media_type
        self.tags = tags
        self.timeout_seconds = timeout_seconds
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.flash_sms_variables is not None:
            result['FlashSmsVariables'] = self.flash_sms_variables
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.masked_callee is not None:
            result['MaskedCallee'] = self.masked_callee
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('FlashSmsVariables') is not None:
            self.flash_sms_variables = m.get('FlashSmsVariables')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MaskedCallee') is not None:
            self.masked_callee = m.get('MaskedCallee')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class MakeCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        media_type: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.media_type = media_type
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class MakeCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        call_variables: str = None,
        channel_contexts: List[MakeCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.call_variables = call_variables
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.call_variables is not None:
            result['CallVariables'] = self.call_variables
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('CallVariables') is not None:
            self.call_variables = m.get('CallVariables')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = MakeCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class MakeCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class MakeCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: MakeCallResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: MakeCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = MakeCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = MakeCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class MakeCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: MakeCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = MakeCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class MakeCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MakeCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MakeCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAudioFileRequest(TeaModel):
    def __init__(
        self,
        audio_file_name: str = None,
        audio_resource_id: str = None,
        instance_id: str = None,
        name: str = None,
        oss_file_key: str = None,
        usage: str = None,
    ):
        # This parameter is required.
        self.audio_file_name = audio_file_name
        # This parameter is required.
        self.audio_resource_id = audio_resource_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.oss_file_key = oss_file_key
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_file_name is not None:
            result['AudioFileName'] = self.audio_file_name
        if self.audio_resource_id is not None:
            result['AudioResourceId'] = self.audio_resource_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_file_key is not None:
            result['OssFileKey'] = self.oss_file_key
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFileName') is not None:
            self.audio_file_name = m.get('AudioFileName')
        if m.get('AudioResourceId') is not None:
            self.audio_resource_id = m.get('AudioResourceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssFileKey') is not None:
            self.oss_file_key = m.get('OssFileKey')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class ModifyAudioFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAudioFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAudioFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAudioFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCustomCallTaggingRequest(TeaModel):
    def __init__(
        self,
        call_tag_name_list: str = None,
        description: str = None,
        instance_id: str = None,
        number: str = None,
    ):
        self.call_tag_name_list = call_tag_name_list
        self.description = description
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number = number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_tag_name_list is not None:
            result['CallTagNameList'] = self.call_tag_name_list
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallTagNameList') is not None:
            self.call_tag_name_list = m.get('CallTagNameList')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        return self


class ModifyCustomCallTaggingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCustomCallTaggingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCustomCallTaggingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCustomCallTaggingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        instance_id: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ModifyInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPhoneNumberRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        instance_id: str = None,
        number: str = None,
        usage: str = None,
    ):
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number = number
        # This parameter is required.
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class ModifyPhoneNumberResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPhoneNumberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyPhoneNumberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPhoneNumberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySkillGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        instance_id: str = None,
        skill_group_id: str = None,
    ):
        self.description = description
        self.display_name = display_name
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class ModifySkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifySkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySkillLevelsOfUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        skill_level_list: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_level_list = skill_level_list
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_level_list is not None:
            result['SkillLevelList'] = self.skill_level_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillLevelList') is not None:
            self.skill_level_list = m.get('SkillLevelList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ModifySkillLevelsOfUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySkillLevelsOfUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifySkillLevelsOfUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySkillLevelsOfUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyUserRequest(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        display_id: str = None,
        display_name: str = None,
        force: bool = None,
        instance_id: str = None,
        mobile: str = None,
        nickname: str = None,
        role_id: str = None,
        user_id: str = None,
        work_mode: str = None,
    ):
        self.avatar_url = avatar_url
        self.display_id = display_id
        self.display_name = display_name
        self.force = force
        # This parameter is required.
        self.instance_id = instance_id
        self.mobile = mobile
        self.nickname = nickname
        self.role_id = role_id
        # This parameter is required.
        self.user_id = user_id
        # This parameter is required.
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.display_id is not None:
            result['DisplayId'] = self.display_id
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('DisplayId') is not None:
            self.display_id = m.get('DisplayId')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ModifyUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyUserLevelsOfSkillGroupRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        skill_group_id: str = None,
        user_level_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_group_id = skill_group_id
        # This parameter is required.
        self.user_level_list = user_level_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.user_level_list is not None:
            result['UserLevelList'] = self.user_level_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('UserLevelList') is not None:
            self.user_level_list = m.get('UserLevelList')
        return self


class ModifyUserLevelsOfSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyUserLevelsOfSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyUserLevelsOfSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyUserLevelsOfSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MonitorCallRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        monitored_user_id: str = None,
        timeout_seconds: int = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.monitored_user_id = monitored_user_id
        self.timeout_seconds = timeout_seconds
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.monitored_user_id is not None:
            result['MonitoredUserId'] = self.monitored_user_id
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MonitoredUserId') is not None:
            self.monitored_user_id = m.get('MonitoredUserId')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class MonitorCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class MonitorCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[MonitorCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = MonitorCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class MonitorCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class MonitorCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: MonitorCallResponseBodyDataCallContext = None,
        user_context: MonitorCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = MonitorCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = MonitorCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class MonitorCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: MonitorCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = MonitorCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class MonitorCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MonitorCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MonitorCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MuteCallRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        self.channel_id = channel_id
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class MuteCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class MuteCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[MuteCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = MuteCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class MuteCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class MuteCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: MuteCallResponseBodyDataCallContext = None,
        user_context: MuteCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = MuteCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = MuteCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class MuteCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: MuteCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = MuteCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class MuteCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MuteCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MuteCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PauseCampaignRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class PauseCampaignResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PauseCampaignResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PauseCampaignResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PauseCampaignResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PickOutboundNumbersRequest(TeaModel):
    def __init__(
        self,
        called_number: str = None,
        count: int = None,
        instance_id: str = None,
        skill_group_id_list: str = None,
    ):
        # This parameter is required.
        self.called_number = called_number
        self.count = count
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_group_id_list = skill_group_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.called_number is not None:
            result['CalledNumber'] = self.called_number
        if self.count is not None:
            result['Count'] = self.count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalledNumber') is not None:
            self.called_number = m.get('CalledNumber')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        return self


class PickOutboundNumbersResponseBodyDataCallee(TeaModel):
    def __init__(
        self,
        city: str = None,
        number: str = None,
        province: str = None,
    ):
        self.city = city
        self.number = number
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city is not None:
            result['City'] = self.city
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class PickOutboundNumbersResponseBodyDataCaller(TeaModel):
    def __init__(
        self,
        city: str = None,
        number: str = None,
        province: str = None,
    ):
        self.city = city
        self.number = number
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city is not None:
            result['City'] = self.city
        if self.number is not None:
            result['Number'] = self.number
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class PickOutboundNumbersResponseBodyData(TeaModel):
    def __init__(
        self,
        callee: PickOutboundNumbersResponseBodyDataCallee = None,
        caller: PickOutboundNumbersResponseBodyDataCaller = None,
    ):
        self.callee = callee
        self.caller = caller

    def validate(self):
        if self.callee:
            self.callee.validate()
        if self.caller:
            self.caller.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callee is not None:
            result['Callee'] = self.callee.to_map()
        if self.caller is not None:
            result['Caller'] = self.caller.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callee') is not None:
            temp_model = PickOutboundNumbersResponseBodyDataCallee()
            self.callee = temp_model.from_map(m['Callee'])
        if m.get('Caller') is not None:
            temp_model = PickOutboundNumbersResponseBodyDataCaller()
            self.caller = temp_model.from_map(m['Caller'])
        return self


class PickOutboundNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[PickOutboundNumbersResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = PickOutboundNumbersResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PickOutboundNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PickOutboundNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PickOutboundNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PollUserStatusRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class PollUserStatusResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        channel_variables: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.channel_variables = channel_variables
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.channel_variables is not None:
            result['ChannelVariables'] = self.channel_variables
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('ChannelVariables') is not None:
            self.channel_variables = m.get('ChannelVariables')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class PollUserStatusResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        call_variables: str = None,
        channel_contexts: List[PollUserStatusResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.call_variables = call_variables
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.call_variables is not None:
            result['CallVariables'] = self.call_variables
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('CallVariables') is not None:
            self.call_variables = m.get('CallVariables')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = PollUserStatusResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class PollUserStatusResponseBodyDataChatContextsMembers(TeaModel):
    def __init__(
        self,
        index: int = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        status: str = None,
        user_id: str = None,
        user_type: str = None,
    ):
        self.index = index
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.status = status
        self.user_id = user_id
        self.user_type = user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class PollUserStatusResponseBodyDataChatContexts(TeaModel):
    def __init__(
        self,
        call_variables: str = None,
        chat_type: str = None,
        instance_id: str = None,
        job_id: str = None,
        members: List[PollUserStatusResponseBodyDataChatContextsMembers] = None,
    ):
        self.call_variables = call_variables
        self.chat_type = chat_type
        self.instance_id = instance_id
        self.job_id = job_id
        self.members = members

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_variables is not None:
            result['CallVariables'] = self.call_variables
        if self.chat_type is not None:
            result['ChatType'] = self.chat_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallVariables') is not None:
            self.call_variables = m.get('CallVariables')
        if m.get('ChatType') is not None:
            self.chat_type = m.get('ChatType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = PollUserStatusResponseBodyDataChatContextsMembers()
                self.members.append(temp_model.from_map(k))
        return self


class PollUserStatusResponseBodyDataUserContextParallelJobList(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        status: str = None,
        timestamp: int = None,
    ):
        self.job_id = job_id
        self.status = status
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.status is not None:
            result['Status'] = self.status
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class PollUserStatusResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        parallel_job_list: List[PollUserStatusResponseBodyDataUserContextParallelJobList] = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.parallel_job_list = parallel_job_list
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        if self.parallel_job_list:
            for k in self.parallel_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        result['ParallelJobList'] = []
        if self.parallel_job_list is not None:
            for k in self.parallel_job_list:
                result['ParallelJobList'].append(k.to_map() if k else None)
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        self.parallel_job_list = []
        if m.get('ParallelJobList') is not None:
            for k in m.get('ParallelJobList'):
                temp_model = PollUserStatusResponseBodyDataUserContextParallelJobList()
                self.parallel_job_list.append(temp_model.from_map(k))
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class PollUserStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: PollUserStatusResponseBodyDataCallContext = None,
        chat_contexts: List[PollUserStatusResponseBodyDataChatContexts] = None,
        context_id: int = None,
        user_context: PollUserStatusResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.chat_contexts = chat_contexts
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.chat_contexts:
            for k in self.chat_contexts:
                if k:
                    k.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        result['ChatContexts'] = []
        if self.chat_contexts is not None:
            for k in self.chat_contexts:
                result['ChatContexts'].append(k.to_map() if k else None)
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = PollUserStatusResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        self.chat_contexts = []
        if m.get('ChatContexts') is not None:
            for k in m.get('ChatContexts'):
                temp_model = PollUserStatusResponseBodyDataChatContexts()
                self.chat_contexts.append(temp_model.from_map(k))
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = PollUserStatusResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class PollUserStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: PollUserStatusResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = PollUserStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PollUserStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PollUserStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PollUserStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ProcessAliMeCallbackOfStagingRequest(TeaModel):
    def __init__(
        self,
        data: str = None,
        token: str = None,
    ):
        self.data = data
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class ProcessAliMeCallbackOfStagingResponseBodyData(TeaModel):
    def __init__(
        self,
        result: str = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class ProcessAliMeCallbackOfStagingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ProcessAliMeCallbackOfStagingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ProcessAliMeCallbackOfStagingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ProcessAliMeCallbackOfStagingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ProcessAliMeCallbackOfStagingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ProcessAliMeCallbackOfStagingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ProcessCustomIMCallbackRequest(TeaModel):
    def __init__(
        self,
        access_channel_id: str = None,
        conversation_id: str = None,
        instance_id: str = None,
        message_content: str = None,
        request_id: str = None,
        sender_avatar_media_id: str = None,
        sender_id: str = None,
        sender_name: str = None,
    ):
        # This parameter is required.
        self.access_channel_id = access_channel_id
        # This parameter is required.
        self.conversation_id = conversation_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.message_content = message_content
        self.request_id = request_id
        self.sender_avatar_media_id = sender_avatar_media_id
        # This parameter is required.
        self.sender_id = sender_id
        self.sender_name = sender_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_id is not None:
            result['AccessChannelId'] = self.access_channel_id
        if self.conversation_id is not None:
            result['ConversationId'] = self.conversation_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message_content is not None:
            result['MessageContent'] = self.message_content
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sender_avatar_media_id is not None:
            result['SenderAvatarMediaId'] = self.sender_avatar_media_id
        if self.sender_id is not None:
            result['SenderId'] = self.sender_id
        if self.sender_name is not None:
            result['SenderName'] = self.sender_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelId') is not None:
            self.access_channel_id = m.get('AccessChannelId')
        if m.get('ConversationId') is not None:
            self.conversation_id = m.get('ConversationId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MessageContent') is not None:
            self.message_content = m.get('MessageContent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SenderAvatarMediaId') is not None:
            self.sender_avatar_media_id = m.get('SenderAvatarMediaId')
        if m.get('SenderId') is not None:
            self.sender_id = m.get('SenderId')
        if m.get('SenderName') is not None:
            self.sender_name = m.get('SenderName')
        return self


class ProcessCustomIMCallbackResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        job_id: str = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.job_id = job_id
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ProcessCustomIMCallbackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ProcessCustomIMCallbackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ProcessCustomIMCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishContactFlowRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        draft_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.draft_id = draft_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.draft_id is not None:
            result['DraftId'] = self.draft_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('DraftId') is not None:
            self.draft_id = m.get('DraftId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class PublishContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PublishContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublishContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReadyForServiceRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        outbound_scenario: bool = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.outbound_scenario = outbound_scenario
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ReadyForServiceResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ReadyForServiceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ReadyForServiceResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ReadyForServiceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReadyForServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReadyForServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReadyForServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RedialCallRequest(TeaModel):
    def __init__(
        self,
        callee: str = None,
        caller: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        tags: str = None,
        timeout_seconds: int = None,
        user_id: str = None,
    ):
        self.callee = callee
        self.caller = caller
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.job_id = job_id
        self.tags = tags
        self.timeout_seconds = timeout_seconds
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RedialCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RedialCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[RedialCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = RedialCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class RedialCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class RedialCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: RedialCallResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: RedialCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = RedialCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = RedialCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class RedialCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RedialCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RedialCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RedialCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RedialCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RedialCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterDeviceRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        password: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.password = password
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.password is not None:
            result['Password'] = self.password
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RegisterDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RegisterDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterDevicesRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        password: str = None,
        user_id_list_json: str = None,
    ):
        # This parameter is required.
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.password = password
        self.user_id_list_json = user_id_list_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.password is not None:
            result['Password'] = self.password
        if self.user_id_list_json is not None:
            result['UserIdListJson'] = self.user_id_list_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserIdListJson') is not None:
            self.user_id_list_json = m.get('UserIdListJson')
        return self


class RegisterDevicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RegisterDevicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterDevicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterDevicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RejectChatRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class RejectChatResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RejectChatResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RejectChatResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RejectChatResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RejectTicketRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        instance_id: str = None,
        ticket_id: str = None,
    ):
        self.comment = comment
        # This parameter is required.
        self.instance_id = instance_id
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class RejectTicketResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RejectTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RejectTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RejectTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseCallRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        self.channel_id = channel_id
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ReleaseCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_id: str = None,
        channel_state: str = None,
        channel_variables: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.channel_variables = channel_variables
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.channel_variables is not None:
            result['ChannelVariables'] = self.channel_variables
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('ChannelVariables') is not None:
            self.channel_variables = m.get('ChannelVariables')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ReleaseCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        channel_contexts: List[ReleaseCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = ReleaseCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class ReleaseCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ReleaseCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: ReleaseCallResponseBodyDataCallContext = None,
        context_id: int = None,
        user_context: ReleaseCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.context_id = context_id
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.context_id is not None:
            result['ContextId'] = self.context_id
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = ReleaseCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('ContextId') is not None:
            self.context_id = m.get('ContextId')
        if m.get('UserContext') is not None:
            temp_model = ReleaseCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class ReleaseCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ReleaseCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ReleaseCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleaseCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleaseCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseChatRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
        token: str = None,
        user_id: str = None,
        user_type: str = None,
    ):
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.token = token
        self.user_id = user_id
        # This parameter is required.
        self.user_type = user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.token is not None:
            result['Token'] = self.token
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class ReleaseChatResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleaseChatResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleaseChatResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseChatResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveBlacklistCallTaggingRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        job_id: str = None,
        number: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.job_id = job_id
        # This parameter is required.
        self.number = number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.number is not None:
            result['Number'] = self.number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        return self


class RemoveBlacklistCallTaggingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveBlacklistCallTaggingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveBlacklistCallTaggingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveBlacklistCallTaggingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveDoNotCallNumbersRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.number_list = number_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        return self


class RemoveDoNotCallNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveDoNotCallNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveDoNotCallNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveDoNotCallNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemovePersonalNumbersFromUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number_list: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number_list = number_list
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RemovePersonalNumbersFromUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemovePersonalNumbersFromUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemovePersonalNumbersFromUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemovePersonalNumbersFromUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemovePhoneNumberFromSkillGroupsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number: str = None,
        skill_group_id_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number = number
        # This parameter is required.
        self.skill_group_id_list = skill_group_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number is not None:
            result['Number'] = self.number
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        return self


class RemovePhoneNumberFromSkillGroupsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemovePhoneNumberFromSkillGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemovePhoneNumberFromSkillGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemovePhoneNumberFromSkillGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemovePhoneNumbersRequest(TeaModel):
    def __init__(
        self,
        force: bool = None,
        instance_id: str = None,
        number_list: str = None,
    ):
        self.force = force
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number_list = number_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        return self


class RemovePhoneNumbersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[str] = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemovePhoneNumbersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemovePhoneNumbersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemovePhoneNumbersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemovePhoneNumbersFromSkillGroupRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        number_list: str = None,
        skill_group_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.number_list = number_list
        # This parameter is required.
        self.skill_group_id = skill_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.number_list is not None:
            result['NumberList'] = self.number_list
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NumberList') is not None:
            self.number_list = m.get('NumberList')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        return self


class RemovePhoneNumbersFromSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemovePhoneNumbersFromSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemovePhoneNumbersFromSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemovePhoneNumbersFromSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveSkillGroupsFromUserRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        skill_group_id_list: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_group_id_list = skill_group_id_list
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id_list is not None:
            result['SkillGroupIdList'] = self.skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupIdList') is not None:
            self.skill_group_id_list = m.get('SkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RemoveSkillGroupsFromUserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveSkillGroupsFromUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveSkillGroupsFromUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveSkillGroupsFromUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveUsersRequest(TeaModel):
    def __init__(
        self,
        file_path: str = None,
        force: bool = None,
        instance_id: str = None,
        notification_email: str = None,
        user_id_list: str = None,
    ):
        self.file_path = file_path
        self.force = force
        # This parameter is required.
        self.instance_id = instance_id
        self.notification_email = notification_email
        self.user_id_list = user_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.notification_email is not None:
            result['NotificationEmail'] = self.notification_email
        if self.user_id_list is not None:
            result['UserIdList'] = self.user_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NotificationEmail') is not None:
            self.notification_email = m.get('NotificationEmail')
        if m.get('UserIdList') is not None:
            self.user_id_list = m.get('UserIdList')
        return self


class RemoveUsersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveUsersFromSkillGroupRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        skill_group_id: str = None,
        user_id_list: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.skill_group_id = skill_group_id
        # This parameter is required.
        self.user_id_list = user_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.user_id_list is not None:
            result['UserIdList'] = self.user_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('UserIdList') is not None:
            self.user_id_list = m.get('UserIdList')
        return self


class RemoveUsersFromSkillGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveUsersFromSkillGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveUsersFromSkillGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveUsersFromSkillGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetAgentStateRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ResetAgentStateResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class ResetAgentStateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ResetAgentStateResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ResetAgentStateResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetAgentStateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetAgentStateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetAgentStateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetUserPasswordRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        password: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.password = password
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.password is not None:
            result['Password'] = self.password
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ResetUserPasswordResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetUserPasswordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetUserPasswordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetUserPasswordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestoreArchivedRecordingsRequest(TeaModel):
    def __init__(
        self,
        contact_ids: str = None,
        instance_id: str = None,
    ):
        self.contact_ids = contact_ids
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class RestoreArchivedRecordingsResponseBodyData(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        exists: str = None,
        status: str = None,
        storage_type: str = None,
    ):
        self.contact_id = contact_id
        self.exists = exists
        self.status = status
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.exists is not None:
            result['Exists'] = self.exists
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Exists') is not None:
            self.exists = m.get('Exists')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class RestoreArchivedRecordingsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[RestoreArchivedRecordingsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = RestoreArchivedRecordingsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RestoreArchivedRecordingsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestoreArchivedRecordingsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestoreArchivedRecordingsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResubmitTicketRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        instance_id: str = None,
        ticket_id: str = None,
    ):
        self.comment = comment
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class ResubmitTicketResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResubmitTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResubmitTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResubmitTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeCampaignRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ResumeCampaignResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResumeCampaignResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResumeCampaignResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeCampaignResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetrieveCallRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.channel_id = channel_id
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RetrieveCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RetrieveCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[RetrieveCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = RetrieveCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class RetrieveCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class RetrieveCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: RetrieveCallResponseBodyDataCallContext = None,
        user_context: RetrieveCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = RetrieveCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = RetrieveCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class RetrieveCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RetrieveCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RetrieveCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RetrieveCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetrieveCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetrieveCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveDocumentRequest(TeaModel):
    def __init__(
        self,
        document_id: str = None,
        document_json: str = None,
        instance_id: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        self.document_id = document_id
        # This parameter is required.
        self.document_json = document_json
        # This parameter is required.
        self.instance_id = instance_id
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.document_id is not None:
            result['DocumentId'] = self.document_id
        if self.document_json is not None:
            result['DocumentJson'] = self.document_json
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocumentId') is not None:
            self.document_id = m.get('DocumentId')
        if m.get('DocumentJson') is not None:
            self.document_json = m.get('DocumentJson')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class SaveDocumentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SaveDocumentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveDocumentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveDocumentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveRTCStatsV2Request(TeaModel):
    def __init__(
        self,
        call_id: str = None,
        general_info: str = None,
        goog_address: str = None,
        instance_id: str = None,
        receiver_report: str = None,
        sender_report: str = None,
    ):
        # This parameter is required.
        self.call_id = call_id
        # This parameter is required.
        self.general_info = general_info
        # This parameter is required.
        self.goog_address = goog_address
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.receiver_report = receiver_report
        # This parameter is required.
        self.sender_report = sender_report

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_id is not None:
            result['CallId'] = self.call_id
        if self.general_info is not None:
            result['GeneralInfo'] = self.general_info
        if self.goog_address is not None:
            result['GoogAddress'] = self.goog_address
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.receiver_report is not None:
            result['ReceiverReport'] = self.receiver_report
        if self.sender_report is not None:
            result['SenderReport'] = self.sender_report
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallId') is not None:
            self.call_id = m.get('CallId')
        if m.get('GeneralInfo') is not None:
            self.general_info = m.get('GeneralInfo')
        if m.get('GoogAddress') is not None:
            self.goog_address = m.get('GoogAddress')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ReceiverReport') is not None:
            self.receiver_report = m.get('ReceiverReport')
        if m.get('SenderReport') is not None:
            self.sender_report = m.get('SenderReport')
        return self


class SaveRTCStatsV2ResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        row_count: int = None,
        success: bool = None,
        time_stamp: int = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.row_count = row_count
        self.success = success
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.success is not None:
            result['Success'] = self.success
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class SaveRTCStatsV2Response(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveRTCStatsV2ResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveRTCStatsV2ResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveTerminalLogRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        call_id: str = None,
        content: str = None,
        data_type: int = None,
        instance_id: str = None,
        job_id: str = None,
        method_name: str = None,
        status: str = None,
        unique_request_id: str = None,
    ):
        # This parameter is required.
        self.app_name = app_name
        # This parameter is required.
        self.call_id = call_id
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.data_type = data_type
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.method_name = method_name
        # This parameter is required.
        self.status = status
        # This parameter is required.
        self.unique_request_id = unique_request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.call_id is not None:
            result['CallId'] = self.call_id
        if self.content is not None:
            result['Content'] = self.content
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.method_name is not None:
            result['MethodName'] = self.method_name
        if self.status is not None:
            result['Status'] = self.status
        if self.unique_request_id is not None:
            result['UniqueRequestId'] = self.unique_request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CallId') is not None:
            self.call_id = m.get('CallId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MethodName') is not None:
            self.method_name = m.get('MethodName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UniqueRequestId') is not None:
            self.unique_request_id = m.get('UniqueRequestId')
        return self


class SaveTerminalLogResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        time_stamp: int = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class SaveTerminalLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveTerminalLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveTerminalLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveWebRTCStatsRequest(TeaModel):
    def __init__(
        self,
        call_id: str = None,
        general_info: str = None,
        goog_address: str = None,
        instance_id: str = None,
        receiver_report: str = None,
        sender_report: str = None,
    ):
        # This parameter is required.
        self.call_id = call_id
        # This parameter is required.
        self.general_info = general_info
        # This parameter is required.
        self.goog_address = goog_address
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.receiver_report = receiver_report
        # This parameter is required.
        self.sender_report = sender_report

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_id is not None:
            result['CallId'] = self.call_id
        if self.general_info is not None:
            result['GeneralInfo'] = self.general_info
        if self.goog_address is not None:
            result['GoogAddress'] = self.goog_address
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.receiver_report is not None:
            result['ReceiverReport'] = self.receiver_report
        if self.sender_report is not None:
            result['SenderReport'] = self.sender_report
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallId') is not None:
            self.call_id = m.get('CallId')
        if m.get('GeneralInfo') is not None:
            self.general_info = m.get('GeneralInfo')
        if m.get('GoogAddress') is not None:
            self.goog_address = m.get('GoogAddress')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ReceiverReport') is not None:
            self.receiver_report = m.get('ReceiverReport')
        if m.get('SenderReport') is not None:
            self.sender_report = m.get('SenderReport')
        return self


class SaveWebRTCStatsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        row_count: int = None,
        success: bool = None,
        time_stamp: int = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.row_count = row_count
        self.success = success
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.success is not None:
            result['Success'] = self.success
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class SaveWebRTCStatsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveWebRTCStatsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveWebRTCStatsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveWebRtcInfoRequest(TeaModel):
    def __init__(
        self,
        call_id: str = None,
        content: str = None,
        content_type: str = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        # This parameter is required.
        self.call_id = call_id
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.content_type = content_type
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_id is not None:
            result['CallId'] = self.call_id
        if self.content is not None:
            result['Content'] = self.content
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallId') is not None:
            self.call_id = m.get('CallId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SaveWebRtcInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        row_count: int = None,
        success: bool = None,
        time_stamp: int = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.row_count = row_count
        self.success = success
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.success is not None:
            result['Success'] = self.success
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class SaveWebRtcInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveWebRtcInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveWebRtcInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendDtmfSignalingRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        device_id: str = None,
        dtmf: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.channel_id = channel_id
        self.device_id = device_id
        # This parameter is required.
        self.dtmf = dtmf
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.dtmf is not None:
            result['Dtmf'] = self.dtmf
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Dtmf') is not None:
            self.dtmf = m.get('Dtmf')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SendDtmfSignalingResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SendDtmfSignalingResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[SendDtmfSignalingResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = SendDtmfSignalingResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SendDtmfSignalingResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class SendDtmfSignalingResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: SendDtmfSignalingResponseBodyDataCallContext = None,
        user_context: SendDtmfSignalingResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = SendDtmfSignalingResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = SendDtmfSignalingResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class SendDtmfSignalingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SendDtmfSignalingResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SendDtmfSignalingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendDtmfSignalingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendDtmfSignalingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendDtmfSignalingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SignInGroupRequest(TeaModel):
    def __init__(
        self,
        additivity: bool = None,
        chat_device_id: str = None,
        device_id: str = None,
        instance_id: str = None,
        signed_skill_group_id_list: str = None,
        user_id: str = None,
    ):
        self.additivity = additivity
        self.chat_device_id = chat_device_id
        # This parameter is required.
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additivity is not None:
            result['Additivity'] = self.additivity
        if self.chat_device_id is not None:
            result['ChatDeviceId'] = self.chat_device_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Additivity') is not None:
            self.additivity = m.get('Additivity')
        if m.get('ChatDeviceId') is not None:
            self.chat_device_id = m.get('ChatDeviceId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SignInGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        chat_device_id: str = None,
        device_id: str = None,
        extension: str = None,
        instance_id: str = None,
        job_id: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.chat_device_id = chat_device_id
        self.device_id = device_id
        self.extension = extension
        self.instance_id = instance_id
        self.job_id = job_id
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.chat_device_id is not None:
            result['ChatDeviceId'] = self.chat_device_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('ChatDeviceId') is not None:
            self.chat_device_id = m.get('ChatDeviceId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class SignInGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SignInGroupResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SignInGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SignInGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SignInGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SignInGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SignOutGroupRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SignOutGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class SignOutGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SignOutGroupResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SignOutGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SignOutGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SignOutGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SignOutGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartBack2BackCallRequest(TeaModel):
    def __init__(
        self,
        additional_broker: str = None,
        broker: str = None,
        callee: str = None,
        caller: str = None,
        instance_id: str = None,
        tags: str = None,
        timeout_seconds: int = None,
    ):
        self.additional_broker = additional_broker
        # This parameter is required.
        self.broker = broker
        # This parameter is required.
        self.callee = callee
        # This parameter is required.
        self.caller = caller
        # This parameter is required.
        self.instance_id = instance_id
        self.tags = tags
        self.timeout_seconds = timeout_seconds

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_broker is not None:
            result['AdditionalBroker'] = self.additional_broker
        if self.broker is not None:
            result['Broker'] = self.broker
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdditionalBroker') is not None:
            self.additional_broker = m.get('AdditionalBroker')
        if m.get('Broker') is not None:
            self.broker = m.get('Broker')
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        return self


class StartBack2BackCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartBack2BackCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[StartBack2BackCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = StartBack2BackCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class StartBack2BackCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        device_state: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.device_state = device_state
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class StartBack2BackCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: StartBack2BackCallResponseBodyDataCallContext = None,
        user_context: StartBack2BackCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = StartBack2BackCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = StartBack2BackCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class StartBack2BackCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StartBack2BackCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StartBack2BackCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartBack2BackCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartBack2BackCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartBack2BackCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartChatRequestUserList(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        nickname: str = None,
        user_id: str = None,
        user_type: str = None,
    ):
        self.avatar_url = avatar_url
        self.nickname = nickname
        self.user_id = user_id
        self.user_type = user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class StartChatRequest(TeaModel):
    def __init__(
        self,
        access_channel_id: str = None,
        instance_id: str = None,
        token: str = None,
        user_list: List[StartChatRequestUserList] = None,
    ):
        self.access_channel_id = access_channel_id
        self.instance_id = instance_id
        self.token = token
        # This parameter is required.
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            for k in self.user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_id is not None:
            result['AccessChannelId'] = self.access_channel_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.token is not None:
            result['Token'] = self.token
        result['UserList'] = []
        if self.user_list is not None:
            for k in self.user_list:
                result['UserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelId') is not None:
            self.access_channel_id = m.get('AccessChannelId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        self.user_list = []
        if m.get('UserList') is not None:
            for k in m.get('UserList'):
                temp_model = StartChatRequestUserList()
                self.user_list.append(temp_model.from_map(k))
        return self


class StartChatShrinkRequest(TeaModel):
    def __init__(
        self,
        access_channel_id: str = None,
        instance_id: str = None,
        token: str = None,
        user_list_shrink: str = None,
    ):
        self.access_channel_id = access_channel_id
        self.instance_id = instance_id
        self.token = token
        # This parameter is required.
        self.user_list_shrink = user_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_channel_id is not None:
            result['AccessChannelId'] = self.access_channel_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.token is not None:
            result['Token'] = self.token
        if self.user_list_shrink is not None:
            result['UserList'] = self.user_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessChannelId') is not None:
            self.access_channel_id = m.get('AccessChannelId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('UserList') is not None:
            self.user_list_shrink = m.get('UserList')
        return self


class StartChatResponseBodyData(TeaModel):
    def __init__(
        self,
        chat_conversation_id: str = None,
        job_id: str = None,
    ):
        self.chat_conversation_id = chat_conversation_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_conversation_id is not None:
            result['ChatConversationId'] = self.chat_conversation_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatConversationId') is not None:
            self.chat_conversation_id = m.get('ChatConversationId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class StartChatResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StartChatResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StartChatResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartChatResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartChatResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartChatResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartConferenceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        participant_list_json: str = None,
        tags: str = None,
        timeout_seconds: int = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.participant_list_json = participant_list_json
        self.tags = tags
        self.timeout_seconds = timeout_seconds
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.participant_list_json is not None:
            result['ParticipantListJson'] = self.participant_list_json
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ParticipantListJson') is not None:
            self.participant_list_json = m.get('ParticipantListJson')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartConferenceResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartConferenceResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[StartConferenceResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = StartConferenceResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class StartConferenceResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        device_state: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.device_state = device_state
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class StartConferenceResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: StartConferenceResponseBodyDataCallContext = None,
        user_context: StartConferenceResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = StartConferenceResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = StartConferenceResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class StartConferenceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StartConferenceResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StartConferenceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartEditContactFlowRequest(TeaModel):
    def __init__(
        self,
        contact_flow_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class StartEditContactFlowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartEditContactFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartEditContactFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartEditContactFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartPredictiveCallRequest(TeaModel):
    def __init__(
        self,
        callee: str = None,
        caller: str = None,
        contact_flow_id: str = None,
        contact_flow_variables: str = None,
        instance_id: str = None,
        masked_callee: str = None,
        skill_group_id: str = None,
        tags: str = None,
        timeout_seconds: int = None,
    ):
        # This parameter is required.
        self.callee = callee
        # This parameter is required.
        self.caller = caller
        # This parameter is required.
        self.contact_flow_id = contact_flow_id
        self.contact_flow_variables = contact_flow_variables
        # This parameter is required.
        self.instance_id = instance_id
        self.masked_callee = masked_callee
        self.skill_group_id = skill_group_id
        self.tags = tags
        self.timeout_seconds = timeout_seconds

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.contact_flow_variables is not None:
            result['ContactFlowVariables'] = self.contact_flow_variables
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.masked_callee is not None:
            result['MaskedCallee'] = self.masked_callee
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('ContactFlowVariables') is not None:
            self.contact_flow_variables = m.get('ContactFlowVariables')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MaskedCallee') is not None:
            self.masked_callee = m.get('MaskedCallee')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        return self


class StartPredictiveCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartPredictiveCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[StartPredictiveCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = StartPredictiveCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class StartPredictiveCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        device_state: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.device_state = device_state
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class StartPredictiveCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: StartPredictiveCallResponseBodyDataCallContext = None,
        user_context: StartPredictiveCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = StartPredictiveCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = StartPredictiveCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class StartPredictiveCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StartPredictiveCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StartPredictiveCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartPredictiveCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartPredictiveCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartPredictiveCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartPrivacyCallRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callee: str = None,
        caller: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.callee = callee
        # This parameter is required.
        self.caller = caller
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callee is not None:
            result['Callee'] = self.callee
        if self.caller is not None:
            result['Caller'] = self.caller
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Callee') is not None:
            self.callee = m.get('Callee')
        if m.get('Caller') is not None:
            self.caller = m.get('Caller')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class StartPrivacyCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartPrivacyCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartPrivacyCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartPrivacyCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCampaignRequest(TeaModel):
    def __init__(
        self,
        campaign_id: str = None,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.campaign_id = campaign_id
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class SubmitCampaignResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitCampaignResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCampaignResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCampaignResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchToConferenceRequest(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SwitchToConferenceResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SwitchToConferenceResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[SwitchToConferenceResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = SwitchToConferenceResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SwitchToConferenceResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        device_state: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.device_state = device_state
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_state is not None:
            result['DeviceState'] = self.device_state
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceState') is not None:
            self.device_state = m.get('DeviceState')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class SwitchToConferenceResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: SwitchToConferenceResponseBodyDataCallContext = None,
        user_context: SwitchToConferenceResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = SwitchToConferenceResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = SwitchToConferenceResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class SwitchToConferenceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SwitchToConferenceResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SwitchToConferenceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SwitchToConferenceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchToConferenceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchToConferenceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TakeBreakRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
        device_id: str = None,
        instance_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.code = code
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class TakeBreakResponseBodyData(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        reserved: int = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.reserved = reserved
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class TakeBreakResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: TakeBreakResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = TakeBreakResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TakeBreakResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TakeBreakResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TakeBreakResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TerminateTicketRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        instance_id: str = None,
        ticket_id: str = None,
    ):
        self.comment = comment
        # This parameter is required.
        self.instance_id = instance_id
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class TerminateTicketResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TerminateTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TerminateTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TerminateTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TransferTicketTaskRequest(TeaModel):
    def __init__(
        self,
        assignee: str = None,
        comment: str = None,
        instance_id: str = None,
        task_id: str = None,
        ticket_id: str = None,
    ):
        # This parameter is required.
        self.assignee = assignee
        self.comment = comment
        # This parameter is required.
        self.instance_id = instance_id
        self.task_id = task_id
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assignee is not None:
            result['Assignee'] = self.assignee
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assignee') is not None:
            self.assignee = m.get('Assignee')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class TransferTicketTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TransferTicketTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TransferTicketTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TransferTicketTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnmuteCallRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        device_id: str = None,
        instance_id: str = None,
        job_id: str = None,
        user_id: str = None,
    ):
        self.channel_id = channel_id
        self.device_id = device_id
        # This parameter is required.
        self.instance_id = instance_id
        self.job_id = job_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UnmuteCallResponseBodyDataCallContextChannelContexts(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_flags: str = None,
        channel_id: str = None,
        channel_state: str = None,
        destination: str = None,
        index: int = None,
        job_id: str = None,
        originator: str = None,
        release_initiator: str = None,
        release_reason: str = None,
        skill_group_id: str = None,
        timestamp: int = None,
        user_extension: str = None,
        user_id: str = None,
    ):
        self.call_type = call_type
        self.channel_flags = channel_flags
        self.channel_id = channel_id
        self.channel_state = channel_state
        self.destination = destination
        self.index = index
        self.job_id = job_id
        self.originator = originator
        self.release_initiator = release_initiator
        self.release_reason = release_reason
        self.skill_group_id = skill_group_id
        self.timestamp = timestamp
        self.user_extension = user_extension
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        if self.channel_flags is not None:
            result['ChannelFlags'] = self.channel_flags
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_state is not None:
            result['ChannelState'] = self.channel_state
        if self.destination is not None:
            result['Destination'] = self.destination
        if self.index is not None:
            result['Index'] = self.index
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.originator is not None:
            result['Originator'] = self.originator
        if self.release_initiator is not None:
            result['ReleaseInitiator'] = self.release_initiator
        if self.release_reason is not None:
            result['ReleaseReason'] = self.release_reason
        if self.skill_group_id is not None:
            result['SkillGroupId'] = self.skill_group_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        if m.get('ChannelFlags') is not None:
            self.channel_flags = m.get('ChannelFlags')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelState') is not None:
            self.channel_state = m.get('ChannelState')
        if m.get('Destination') is not None:
            self.destination = m.get('Destination')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Originator') is not None:
            self.originator = m.get('Originator')
        if m.get('ReleaseInitiator') is not None:
            self.release_initiator = m.get('ReleaseInitiator')
        if m.get('ReleaseReason') is not None:
            self.release_reason = m.get('ReleaseReason')
        if m.get('SkillGroupId') is not None:
            self.skill_group_id = m.get('SkillGroupId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UnmuteCallResponseBodyDataCallContext(TeaModel):
    def __init__(
        self,
        call_type: str = None,
        channel_contexts: List[UnmuteCallResponseBodyDataCallContextChannelContexts] = None,
        instance_id: str = None,
        job_id: str = None,
    ):
        self.call_type = call_type
        self.channel_contexts = channel_contexts
        self.instance_id = instance_id
        self.job_id = job_id

    def validate(self):
        if self.channel_contexts:
            for k in self.channel_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_type is not None:
            result['CallType'] = self.call_type
        result['ChannelContexts'] = []
        if self.channel_contexts is not None:
            for k in self.channel_contexts:
                result['ChannelContexts'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallType') is not None:
            self.call_type = m.get('CallType')
        self.channel_contexts = []
        if m.get('ChannelContexts') is not None:
            for k in m.get('ChannelContexts'):
                temp_model = UnmuteCallResponseBodyDataCallContextChannelContexts()
                self.channel_contexts.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class UnmuteCallResponseBodyDataUserContext(TeaModel):
    def __init__(
        self,
        break_code: str = None,
        device_id: str = None,
        extension: str = None,
        heartbeat: int = None,
        instance_id: str = None,
        job_id: str = None,
        mobile: str = None,
        outbound_scenario: bool = None,
        signed_skill_group_id_list: List[str] = None,
        user_id: str = None,
        user_state: str = None,
        work_mode: str = None,
    ):
        self.break_code = break_code
        self.device_id = device_id
        self.extension = extension
        self.heartbeat = heartbeat
        self.instance_id = instance_id
        self.job_id = job_id
        self.mobile = mobile
        self.outbound_scenario = outbound_scenario
        self.signed_skill_group_id_list = signed_skill_group_id_list
        self.user_id = user_id
        self.user_state = user_state
        self.work_mode = work_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_code is not None:
            result['BreakCode'] = self.break_code
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.heartbeat is not None:
            result['Heartbeat'] = self.heartbeat
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.outbound_scenario is not None:
            result['OutboundScenario'] = self.outbound_scenario
        if self.signed_skill_group_id_list is not None:
            result['SignedSkillGroupIdList'] = self.signed_skill_group_id_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_state is not None:
            result['UserState'] = self.user_state
        if self.work_mode is not None:
            result['WorkMode'] = self.work_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BreakCode') is not None:
            self.break_code = m.get('BreakCode')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Heartbeat') is not None:
            self.heartbeat = m.get('Heartbeat')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('OutboundScenario') is not None:
            self.outbound_scenario = m.get('OutboundScenario')
        if m.get('SignedSkillGroupIdList') is not None:
            self.signed_skill_group_id_list = m.get('SignedSkillGroupIdList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        if m.get('WorkMode') is not None:
            self.work_mode = m.get('WorkMode')
        return self


class UnmuteCallResponseBodyData(TeaModel):
    def __init__(
        self,
        call_context: UnmuteCallResponseBodyDataCallContext = None,
        user_context: UnmuteCallResponseBodyDataUserContext = None,
    ):
        self.call_context = call_context
        self.user_context = user_context

    def validate(self):
        if self.call_context:
            self.call_context.validate()
        if self.user_context:
            self.user_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_context is not None:
            result['CallContext'] = self.call_context.to_map()
        if self.user_context is not None:
            result['UserContext'] = self.user_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallContext') is not None:
            temp_model = UnmuteCallResponseBodyDataCallContext()
            self.call_context = temp_model.from_map(m['CallContext'])
        if m.get('UserContext') is not None:
            temp_model = UnmuteCallResponseBodyDataUserContext()
            self.user_context = temp_model.from_map(m['UserContext'])
        return self


class UnmuteCallResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UnmuteCallResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UnmuteCallResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnmuteCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnmuteCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnmuteCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnregisterDeviceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UnregisterDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnregisterDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnregisterDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnregisterDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCallSummaryRequest(TeaModel):
    def __init__(
        self,
        context: str = None,
        instance_id: str = None,
        ticket_id: str = None,
    ):
        self.context = context
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context is not None:
            result['Context'] = self.context
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class UpdateCallSummaryResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCallSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCallSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCallSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCampaignRequest(TeaModel):
    def __init__(
        self,
        callable_time: str = None,
        campaign_id: str = None,
        contact_flow_id: str = None,
        end_time: str = None,
        instance_id: str = None,
        name: str = None,
        start_time: str = None,
        strategy_parameters: str = None,
    ):
        self.callable_time = callable_time
        # This parameter is required.
        self.campaign_id = campaign_id
        self.contact_flow_id = contact_flow_id
        self.end_time = end_time
        # This parameter is required.
        self.instance_id = instance_id
        self.name = name
        self.start_time = start_time
        self.strategy_parameters = strategy_parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callable_time is not None:
            result['CallableTime'] = self.callable_time
        if self.campaign_id is not None:
            result['CampaignId'] = self.campaign_id
        if self.contact_flow_id is not None:
            result['ContactFlowId'] = self.contact_flow_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.strategy_parameters is not None:
            result['StrategyParameters'] = self.strategy_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallableTime') is not None:
            self.callable_time = m.get('CallableTime')
        if m.get('CampaignId') is not None:
            self.campaign_id = m.get('CampaignId')
        if m.get('ContactFlowId') is not None:
            self.contact_flow_id = m.get('ContactFlowId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StrategyParameters') is not None:
            self.strategy_parameters = m.get('StrategyParameters')
        return self


class UpdateCampaignResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCampaignResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCampaignResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCampaignResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateChatRoutingProfileRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        routing_profiles: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.routing_profiles = routing_profiles

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.routing_profiles is not None:
            result['RoutingProfiles'] = self.routing_profiles
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RoutingProfiles') is not None:
            self.routing_profiles = m.get('RoutingProfiles')
        return self


class UpdateChatRoutingProfileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateChatRoutingProfileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateChatRoutingProfileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateChatRoutingProfileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateConfigItemsRequest(TeaModel):
    def __init__(
        self,
        config_items: str = None,
        instance_id: str = None,
        object_id: str = None,
        object_type: str = None,
    ):
        # This parameter is required.
        self.config_items = config_items
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.object_id = object_id
        # This parameter is required.
        self.object_type = object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_items is not None:
            result['ConfigItems'] = self.config_items
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigItems') is not None:
            self.config_items = m.get('ConfigItems')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        return self


class UpdateConfigItemsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateConfigItemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateConfigItemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateConfigItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSchemaPropertyRequestProperty(TeaModel):
    def __init__(
        self,
        array: bool = None,
        attributes: str = None,
        data_type: str = None,
        description: str = None,
        disabled: bool = None,
        display_name: str = None,
        display_order: int = None,
        editor_type: str = None,
        max_length: int = None,
        maximum: float = None,
        min_length: int = None,
        minimum: float = None,
        name: str = None,
        pattern: str = None,
        pattern_error_message: str = None,
        read_only: bool = None,
        required: bool = None,
    ):
        self.array = array
        self.attributes = attributes
        # This parameter is required.
        self.data_type = data_type
        self.description = description
        self.disabled = disabled
        self.display_name = display_name
        self.display_order = display_order
        self.editor_type = editor_type
        self.max_length = max_length
        self.maximum = maximum
        self.min_length = min_length
        self.minimum = minimum
        # This parameter is required.
        self.name = name
        self.pattern = pattern
        self.pattern_error_message = pattern_error_message
        self.read_only = read_only
        self.required = required

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.array is not None:
            result['Array'] = self.array
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.description is not None:
            result['Description'] = self.description
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.display_order is not None:
            result['DisplayOrder'] = self.display_order
        if self.editor_type is not None:
            result['EditorType'] = self.editor_type
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.pattern_error_message is not None:
            result['PatternErrorMessage'] = self.pattern_error_message
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        if self.required is not None:
            result['Required'] = self.required
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Array') is not None:
            self.array = m.get('Array')
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('DisplayOrder') is not None:
            self.display_order = m.get('DisplayOrder')
        if m.get('EditorType') is not None:
            self.editor_type = m.get('EditorType')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('PatternErrorMessage') is not None:
            self.pattern_error_message = m.get('PatternErrorMessage')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        return self


class UpdateSchemaPropertyRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        property: UpdateSchemaPropertyRequestProperty = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.property = property
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        if self.property:
            self.property.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.property is not None:
            result['Property'] = self.property.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Property') is not None:
            temp_model = UpdateSchemaPropertyRequestProperty()
            self.property = temp_model.from_map(m['Property'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class UpdateSchemaPropertyShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        property_shrink: str = None,
        request_id: str = None,
        schema_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.property_shrink = property_shrink
        self.request_id = request_id
        # schema id
        # 
        # This parameter is required.
        self.schema_id = schema_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.property_shrink is not None:
            result['Property'] = self.property_shrink
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema_id is not None:
            result['SchemaId'] = self.schema_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Property') is not None:
            self.property_shrink = m.get('Property')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SchemaId') is not None:
            self.schema_id = m.get('SchemaId')
        return self


class UpdateSchemaPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateSchemaPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSchemaPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSchemaPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTicketRequest(TeaModel):
    def __init__(
        self,
        context: str = None,
        customer_id: str = None,
        instance_id: str = None,
        ticket_id: str = None,
        title: str = None,
    ):
        self.context = context
        self.customer_id = customer_id
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.ticket_id = ticket_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context is not None:
            result['Context'] = self.context
        if self.customer_id is not None:
            result['CustomerId'] = self.customer_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('CustomerId') is not None:
            self.customer_id = m.get('CustomerId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateTicketResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class WithdrawTicketRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        instance_id: str = None,
        ticket_id: str = None,
    ):
        # This parameter is required.
        self.comment = comment
        # This parameter is required.
        self.instance_id = instance_id
        # This parameter is required.
        self.ticket_id = ticket_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ticket_id is not None:
            result['TicketId'] = self.ticket_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('TicketId') is not None:
            self.ticket_id = m.get('TicketId')
        return self


class WithdrawTicketResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: Any = None,
        http_status_code: int = None,
        message: str = None,
        params: List[str] = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.params = params
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.params is not None:
            result['Params'] = self.params
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class WithdrawTicketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WithdrawTicketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WithdrawTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


