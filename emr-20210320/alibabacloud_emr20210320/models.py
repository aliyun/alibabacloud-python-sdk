# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict


class AckConfigPvcs(TeaModel):
    def __init__(
        self,
        data_disk_size: int = None,
        data_disk_storage_class: str = None,
        name: str = None,
        path: str = None,
    ):
        self.data_disk_size = data_disk_size
        self.data_disk_storage_class = data_disk_storage_class
        self.name = name
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.data_disk_storage_class is not None:
            result['DataDiskStorageClass'] = self.data_disk_storage_class
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('DataDiskStorageClass') is not None:
            self.data_disk_storage_class = m.get('DataDiskStorageClass')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class AckConfigVolumeMounts(TeaModel):
    def __init__(
        self,
        name: str = None,
        path: str = None,
    ):
        self.name = name
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class AckConfigVolumes(TeaModel):
    def __init__(
        self,
        name: str = None,
        path: str = None,
        type: str = None,
    ):
        self.name = name
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class Tag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # 标签键。必填参数，不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或https://。
        # 
        # This parameter is required.
        self.key = key
        # 标签值。非必填，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class Toleration(TeaModel):
    def __init__(
        self,
        effect: str = None,
        key: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.effect = effect
        self.key = key
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AckConfig(TeaModel):
    def __init__(
        self,
        ack_instance_id: str = None,
        custom_annotations: List[Tag] = None,
        custom_labels: List[Tag] = None,
        data_disk_size: int = None,
        data_disk_storage_class: str = None,
        limit_cpu: float = None,
        limit_memory: float = None,
        mount_host_cgroup: bool = None,
        namespace: str = None,
        node_affinity: str = None,
        node_selectors: List[Tag] = None,
        pod_affinity: str = None,
        pod_anti_affinity: str = None,
        pre_start_command: List[str] = None,
        pvcs: List[AckConfigPvcs] = None,
        request_cpu: float = None,
        request_memory: float = None,
        tolerations: List[Toleration] = None,
        volume_mounts: List[AckConfigVolumeMounts] = None,
        volumes: List[AckConfigVolumes] = None,
    ):
        # ack集群id
        self.ack_instance_id = ack_instance_id
        self.custom_annotations = custom_annotations
        self.custom_labels = custom_labels
        self.data_disk_size = data_disk_size
        self.data_disk_storage_class = data_disk_storage_class
        # Pod的CPU限制值。
        self.limit_cpu = limit_cpu
        # Pod的内存限制值。
        self.limit_memory = limit_memory
        self.mount_host_cgroup = mount_host_cgroup
        # ack 命名空间
        self.namespace = namespace
        self.node_affinity = node_affinity
        # ack的节点标签限制
        self.node_selectors = node_selectors
        self.pod_affinity = pod_affinity
        self.pod_anti_affinity = pod_anti_affinity
        self.pre_start_command = pre_start_command
        self.pvcs = pvcs
        # Pod的CPU请求值
        self.request_cpu = request_cpu
        # Pod的内存请求值。
        self.request_memory = request_memory
        # ack的节点污点容忍
        self.tolerations = tolerations
        self.volume_mounts = volume_mounts
        self.volumes = volumes

    def validate(self):
        if self.custom_annotations:
            for k in self.custom_annotations:
                if k:
                    k.validate()
        if self.custom_labels:
            for k in self.custom_labels:
                if k:
                    k.validate()
        if self.node_selectors:
            for k in self.node_selectors:
                if k:
                    k.validate()
        if self.pvcs:
            for k in self.pvcs:
                if k:
                    k.validate()
        if self.tolerations:
            for k in self.tolerations:
                if k:
                    k.validate()
        if self.volume_mounts:
            for k in self.volume_mounts:
                if k:
                    k.validate()
        if self.volumes:
            for k in self.volumes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ack_instance_id is not None:
            result['AckInstanceId'] = self.ack_instance_id
        result['CustomAnnotations'] = []
        if self.custom_annotations is not None:
            for k in self.custom_annotations:
                result['CustomAnnotations'].append(k.to_map() if k else None)
        result['CustomLabels'] = []
        if self.custom_labels is not None:
            for k in self.custom_labels:
                result['CustomLabels'].append(k.to_map() if k else None)
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.data_disk_storage_class is not None:
            result['DataDiskStorageClass'] = self.data_disk_storage_class
        if self.limit_cpu is not None:
            result['LimitCpu'] = self.limit_cpu
        if self.limit_memory is not None:
            result['LimitMemory'] = self.limit_memory
        if self.mount_host_cgroup is not None:
            result['MountHostCgroup'] = self.mount_host_cgroup
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.node_affinity is not None:
            result['NodeAffinity'] = self.node_affinity
        result['NodeSelectors'] = []
        if self.node_selectors is not None:
            for k in self.node_selectors:
                result['NodeSelectors'].append(k.to_map() if k else None)
        if self.pod_affinity is not None:
            result['PodAffinity'] = self.pod_affinity
        if self.pod_anti_affinity is not None:
            result['PodAntiAffinity'] = self.pod_anti_affinity
        if self.pre_start_command is not None:
            result['PreStartCommand'] = self.pre_start_command
        result['Pvcs'] = []
        if self.pvcs is not None:
            for k in self.pvcs:
                result['Pvcs'].append(k.to_map() if k else None)
        if self.request_cpu is not None:
            result['RequestCpu'] = self.request_cpu
        if self.request_memory is not None:
            result['RequestMemory'] = self.request_memory
        result['Tolerations'] = []
        if self.tolerations is not None:
            for k in self.tolerations:
                result['Tolerations'].append(k.to_map() if k else None)
        result['VolumeMounts'] = []
        if self.volume_mounts is not None:
            for k in self.volume_mounts:
                result['VolumeMounts'].append(k.to_map() if k else None)
        result['Volumes'] = []
        if self.volumes is not None:
            for k in self.volumes:
                result['Volumes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AckInstanceId') is not None:
            self.ack_instance_id = m.get('AckInstanceId')
        self.custom_annotations = []
        if m.get('CustomAnnotations') is not None:
            for k in m.get('CustomAnnotations'):
                temp_model = Tag()
                self.custom_annotations.append(temp_model.from_map(k))
        self.custom_labels = []
        if m.get('CustomLabels') is not None:
            for k in m.get('CustomLabels'):
                temp_model = Tag()
                self.custom_labels.append(temp_model.from_map(k))
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('DataDiskStorageClass') is not None:
            self.data_disk_storage_class = m.get('DataDiskStorageClass')
        if m.get('LimitCpu') is not None:
            self.limit_cpu = m.get('LimitCpu')
        if m.get('LimitMemory') is not None:
            self.limit_memory = m.get('LimitMemory')
        if m.get('MountHostCgroup') is not None:
            self.mount_host_cgroup = m.get('MountHostCgroup')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NodeAffinity') is not None:
            self.node_affinity = m.get('NodeAffinity')
        self.node_selectors = []
        if m.get('NodeSelectors') is not None:
            for k in m.get('NodeSelectors'):
                temp_model = Tag()
                self.node_selectors.append(temp_model.from_map(k))
        if m.get('PodAffinity') is not None:
            self.pod_affinity = m.get('PodAffinity')
        if m.get('PodAntiAffinity') is not None:
            self.pod_anti_affinity = m.get('PodAntiAffinity')
        if m.get('PreStartCommand') is not None:
            self.pre_start_command = m.get('PreStartCommand')
        self.pvcs = []
        if m.get('Pvcs') is not None:
            for k in m.get('Pvcs'):
                temp_model = AckConfigPvcs()
                self.pvcs.append(temp_model.from_map(k))
        if m.get('RequestCpu') is not None:
            self.request_cpu = m.get('RequestCpu')
        if m.get('RequestMemory') is not None:
            self.request_memory = m.get('RequestMemory')
        self.tolerations = []
        if m.get('Tolerations') is not None:
            for k in m.get('Tolerations'):
                temp_model = Toleration()
                self.tolerations.append(temp_model.from_map(k))
        self.volume_mounts = []
        if m.get('VolumeMounts') is not None:
            for k in m.get('VolumeMounts'):
                temp_model = AckConfigVolumeMounts()
                self.volume_mounts.append(temp_model.from_map(k))
        self.volumes = []
        if m.get('Volumes') is not None:
            for k in m.get('Volumes'):
                temp_model = AckConfigVolumes()
                self.volumes.append(temp_model.from_map(k))
        return self


class AckNodeSelectorLabels(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # 标签键。
        self.key = key
        # 标签值。
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AckNodeSelectorTaints(TeaModel):
    def __init__(
        self,
        effect: str = None,
        key: str = None,
        value: str = None,
    ):
        # 污点效果。
        self.effect = effect
        # 污点键。
        self.key = key
        # 污点值。
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AckNodeSelector(TeaModel):
    def __init__(
        self,
        labels: List[AckNodeSelectorLabels] = None,
        taints: List[AckNodeSelectorTaints] = None,
    ):
        # 污点列表。
        self.labels = labels
        # 污点列表。
        self.taints = taints

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.taints:
            for k in self.taints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        result['Taints'] = []
        if self.taints is not None:
            for k in self.taints:
                result['Taints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = AckNodeSelectorLabels()
                self.labels.append(temp_model.from_map(k))
        self.taints = []
        if m.get('Taints') is not None:
            for k in m.get('Taints'):
                temp_model = AckNodeSelectorTaints()
                self.taints.append(temp_model.from_map(k))
        return self


class AckNode(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        node_selector: AckNodeSelector = None,
    ):
        # 节点ID。
        self.node_id = node_id
        # ACK节点选择器。
        self.node_selector = node_selector

    def validate(self):
        if self.node_selector:
            self.node_selector.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_selector is not None:
            result['NodeSelector'] = self.node_selector.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeSelector') is not None:
            temp_model = AckNodeSelector()
            self.node_selector = temp_model.from_map(m['NodeSelector'])
        return self


class AckNodePool(TeaModel):
    def __init__(
        self,
        node_pool_id: str = None,
        node_selector: AckNodeSelector = None,
    ):
        # 节点池ID。
        self.node_pool_id = node_pool_id
        # ACK节点选择器。
        self.node_selector = node_selector

    def validate(self):
        if self.node_selector:
            self.node_selector.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_pool_id is not None:
            result['NodePoolId'] = self.node_pool_id
        if self.node_selector is not None:
            result['NodeSelector'] = self.node_selector.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodePoolId') is not None:
            self.node_pool_id = m.get('NodePoolId')
        if m.get('NodeSelector') is not None:
            temp_model = AckNodeSelector()
            self.node_selector = temp_model.from_map(m['NodeSelector'])
        return self


class DoubleMetric(TeaModel):
    def __init__(
        self,
        unit: str = None,
        value: float = None,
    ):
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AdviseSummary(TeaModel):
    def __init__(
        self,
        memory_utilization_rate: DoubleMetric = None,
        vcore_utilization_rate: DoubleMetric = None,
    ):
        self.memory_utilization_rate = memory_utilization_rate
        self.vcore_utilization_rate = vcore_utilization_rate

    def validate(self):
        if self.memory_utilization_rate:
            self.memory_utilization_rate.validate()
        if self.vcore_utilization_rate:
            self.vcore_utilization_rate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.memory_utilization_rate is not None:
            result['MemoryUtilizationRate'] = self.memory_utilization_rate.to_map()
        if self.vcore_utilization_rate is not None:
            result['VcoreUtilizationRate'] = self.vcore_utilization_rate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemoryUtilizationRate') is not None:
            temp_model = DoubleMetric()
            self.memory_utilization_rate = temp_model.from_map(m['MemoryUtilizationRate'])
        if m.get('VcoreUtilizationRate') is not None:
            temp_model = DoubleMetric()
            self.vcore_utilization_rate = temp_model.from_map(m['VcoreUtilizationRate'])
        return self


class ApiTemplate(TeaModel):
    def __init__(
        self,
        api_name: str = None,
        content: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        status: str = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # 接口名。
        self.api_name = api_name
        # 模版接口参数。
        self.content = content
        # 区域ID。
        self.region_id = region_id
        # 资源组ID。
        self.resource_group_id = resource_group_id
        # 模板状态。
        self.status = status
        # 模板ID。
        self.template_id = template_id
        # 模板ID。
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_name is not None:
            result['ApiName'] = self.api_name
        if self.content is not None:
            result['Content'] = self.content
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiName') is not None:
            self.api_name = m.get('ApiName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class Application(TeaModel):
    def __init__(
        self,
        application_name: str = None,
    ):
        # 应用名称。从EMR控制台集群创建页面可查看到指定发行版的应用名称列表。
        # 
        # This parameter is required.
        self.application_name = application_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        return self


class ApplicationConfig(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        config_file_name: str = None,
        config_item_key: str = None,
        config_item_value: str = None,
        config_scope: str = None,
        node_group_id: str = None,
        node_group_name: str = None,
    ):
        # 应用名称。从EMR控制台集群创建页面可查看到指定发行版的应用名称列表。
        # 
        # This parameter is required.
        self.application_name = application_name
        # 应用配置文件名。
        # 
        # This parameter is required.
        self.config_file_name = config_file_name
        # 配置项键。
        # 
        # This parameter is required.
        self.config_item_key = config_item_key
        # 配置项值。
        self.config_item_value = config_item_value
        # 配置范围。取值范围：
        # - CLUSTER：集群级别。
        # - NODE_GROUP：节点组级别。
        # 
        # 默认值：CLUSTER。
        self.config_scope = config_scope
        # 节点组ID。ConfigScope取值NODE_GROUP时，该参数生效。NodeGroupId参数优先级高于NodeGroupName。
        self.node_group_id = node_group_id
        # 节点组名称。ConfigScope取值NODE_GROUP时，且参数NodeGroupId为空时生效，该参数生效。
        self.node_group_name = node_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.config_file_name is not None:
            result['ConfigFileName'] = self.config_file_name
        if self.config_item_key is not None:
            result['ConfigItemKey'] = self.config_item_key
        if self.config_item_value is not None:
            result['ConfigItemValue'] = self.config_item_value
        if self.config_scope is not None:
            result['ConfigScope'] = self.config_scope
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ConfigFileName') is not None:
            self.config_file_name = m.get('ConfigFileName')
        if m.get('ConfigItemKey') is not None:
            self.config_item_key = m.get('ConfigItemKey')
        if m.get('ConfigItemValue') is not None:
            self.config_item_value = m.get('ConfigItemValue')
        if m.get('ConfigScope') is not None:
            self.config_scope = m.get('ConfigScope')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        return self


class ApplicationConfigFile(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        config_file_name: str = None,
    ):
        # 应用名称。
        # 
        # This parameter is required.
        self.application_name = application_name
        # 配置文件名称。
        # 
        # This parameter is required.
        self.config_file_name = config_file_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.config_file_name is not None:
            result['ConfigFileName'] = self.config_file_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ConfigFileName') is not None:
            self.config_file_name = m.get('ConfigFileName')
        return self


class ApplicationConfigParam(TeaModel):
    def __init__(
        self,
        config_action: str = None,
        config_file_name: str = None,
        config_item_description: str = None,
        config_item_key: str = None,
        config_item_value: str = None,
        config_scope: str = None,
        effective_actions: str = None,
        effective_type: str = None,
        node_group_id: str = None,
        node_id: str = None,
    ):
        self.config_action = config_action
        self.config_file_name = config_file_name
        self.config_item_description = config_item_description
        self.config_item_key = config_item_key
        self.config_item_value = config_item_value
        self.config_scope = config_scope
        self.effective_actions = effective_actions
        self.effective_type = effective_type
        self.node_group_id = node_group_id
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_action is not None:
            result['ConfigAction'] = self.config_action
        if self.config_file_name is not None:
            result['ConfigFileName'] = self.config_file_name
        if self.config_item_description is not None:
            result['ConfigItemDescription'] = self.config_item_description
        if self.config_item_key is not None:
            result['ConfigItemKey'] = self.config_item_key
        if self.config_item_value is not None:
            result['ConfigItemValue'] = self.config_item_value
        if self.config_scope is not None:
            result['ConfigScope'] = self.config_scope
        if self.effective_actions is not None:
            result['EffectiveActions'] = self.effective_actions
        if self.effective_type is not None:
            result['EffectiveType'] = self.effective_type
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigAction') is not None:
            self.config_action = m.get('ConfigAction')
        if m.get('ConfigFileName') is not None:
            self.config_file_name = m.get('ConfigFileName')
        if m.get('ConfigItemDescription') is not None:
            self.config_item_description = m.get('ConfigItemDescription')
        if m.get('ConfigItemKey') is not None:
            self.config_item_key = m.get('ConfigItemKey')
        if m.get('ConfigItemValue') is not None:
            self.config_item_value = m.get('ConfigItemValue')
        if m.get('ConfigScope') is not None:
            self.config_scope = m.get('ConfigScope')
        if m.get('EffectiveActions') is not None:
            self.effective_actions = m.get('EffectiveActions')
        if m.get('EffectiveType') is not None:
            self.effective_type = m.get('EffectiveType')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class ApplicationConfigurationFile(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        cluster_id: str = None,
        config_file_format: str = None,
        config_file_group: str = None,
        config_file_link: str = None,
        config_file_mode: str = None,
        config_file_name: str = None,
        config_file_owner: str = None,
        config_file_path: str = None,
        description: str = None,
        node_group_id: str = None,
        node_id: str = None,
    ):
        self.application_name = application_name
        self.cluster_id = cluster_id
        self.config_file_format = config_file_format
        self.config_file_group = config_file_group
        self.config_file_link = config_file_link
        self.config_file_mode = config_file_mode
        self.config_file_name = config_file_name
        self.config_file_owner = config_file_owner
        self.config_file_path = config_file_path
        self.description = description
        self.node_group_id = node_group_id
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.config_file_format is not None:
            result['ConfigFileFormat'] = self.config_file_format
        if self.config_file_group is not None:
            result['ConfigFileGroup'] = self.config_file_group
        if self.config_file_link is not None:
            result['ConfigFileLink'] = self.config_file_link
        if self.config_file_mode is not None:
            result['ConfigFileMode'] = self.config_file_mode
        if self.config_file_name is not None:
            result['ConfigFileName'] = self.config_file_name
        if self.config_file_owner is not None:
            result['ConfigFileOwner'] = self.config_file_owner
        if self.config_file_path is not None:
            result['ConfigFilePath'] = self.config_file_path
        if self.description is not None:
            result['Description'] = self.description
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ConfigFileFormat') is not None:
            self.config_file_format = m.get('ConfigFileFormat')
        if m.get('ConfigFileGroup') is not None:
            self.config_file_group = m.get('ConfigFileGroup')
        if m.get('ConfigFileLink') is not None:
            self.config_file_link = m.get('ConfigFileLink')
        if m.get('ConfigFileMode') is not None:
            self.config_file_mode = m.get('ConfigFileMode')
        if m.get('ConfigFileName') is not None:
            self.config_file_name = m.get('ConfigFileName')
        if m.get('ConfigFileOwner') is not None:
            self.config_file_owner = m.get('ConfigFileOwner')
        if m.get('ConfigFilePath') is not None:
            self.config_file_path = m.get('ConfigFilePath')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class Attribute(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # 键。
        self.key = key
        # 值。
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AutoRenewInstance(TeaModel):
    def __init__(
        self,
        auto_renew: bool = None,
        auto_renew_duration: int = None,
        auto_renew_duration_unit: str = None,
        emr_auto_renew_duration: int = None,
        emr_auto_renew_duration_unit: str = None,
        instance_id: str = None,
    ):
        # 自动续费。
        self.auto_renew = auto_renew
        # 自动续费时长。
        self.auto_renew_duration = auto_renew_duration
        # 自动付费时长单位。
        self.auto_renew_duration_unit = auto_renew_duration_unit
        # emr实例自动续费时长。
        self.emr_auto_renew_duration = emr_auto_renew_duration
        # emr实例自动续费时长单位。
        self.emr_auto_renew_duration_unit = emr_auto_renew_duration_unit
        # 节点ID。
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_duration is not None:
            result['AutoRenewDuration'] = self.auto_renew_duration
        if self.auto_renew_duration_unit is not None:
            result['AutoRenewDurationUnit'] = self.auto_renew_duration_unit
        if self.emr_auto_renew_duration is not None:
            result['EmrAutoRenewDuration'] = self.emr_auto_renew_duration
        if self.emr_auto_renew_duration_unit is not None:
            result['EmrAutoRenewDurationUnit'] = self.emr_auto_renew_duration_unit
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewDuration') is not None:
            self.auto_renew_duration = m.get('AutoRenewDuration')
        if m.get('AutoRenewDurationUnit') is not None:
            self.auto_renew_duration_unit = m.get('AutoRenewDurationUnit')
        if m.get('EmrAutoRenewDuration') is not None:
            self.emr_auto_renew_duration = m.get('EmrAutoRenewDuration')
        if m.get('EmrAutoRenewDurationUnit') is not None:
            self.emr_auto_renew_duration_unit = m.get('EmrAutoRenewDurationUnit')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class AutoRenewInstanceParam(TeaModel):
    def __init__(
        self,
        auto_renew: str = None,
        auto_renew_duration: str = None,
        auto_renew_duration_unit: str = None,
        instance_id: str = None,
    ):
        self.auto_renew = auto_renew
        self.auto_renew_duration = auto_renew_duration
        self.auto_renew_duration_unit = auto_renew_duration_unit
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_duration is not None:
            result['AutoRenewDuration'] = self.auto_renew_duration
        if self.auto_renew_duration_unit is not None:
            result['AutoRenewDurationUnit'] = self.auto_renew_duration_unit
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewDuration') is not None:
            self.auto_renew_duration = m.get('AutoRenewDuration')
        if m.get('AutoRenewDurationUnit') is not None:
            self.auto_renew_duration_unit = m.get('AutoRenewDurationUnit')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class AutoScalingConstraintsSupportMetricTags(TeaModel):
    def __init__(
        self,
        metric_name: str = None,
        tags: List[Tag] = None,
    ):
        # 指标名称。
        self.metric_name = metric_name
        # 指标Tag。
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class MetricUnitValue(TeaModel):
    def __init__(
        self,
        metric_name: str = None,
        metric_unit: str = None,
    ):
        # 指标名称。
        self.metric_name = metric_name
        # 指标单位。
        self.metric_unit = metric_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.metric_unit is not None:
            result['MetricUnit'] = self.metric_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('MetricUnit') is not None:
            self.metric_unit = m.get('MetricUnit')
        return self


class TriggerCondition(TeaModel):
    def __init__(
        self,
        comparison_operator: str = None,
        metric_name: str = None,
        statistics: str = None,
        tags: List[Tag] = None,
        threshold: float = None,
    ):
        # 比较符。取值范围：
        # - EQ:等于。
        # - NE:不等于。
        # - GT:大于。
        # - LT:小于。
        # - GE:大于等于。
        # - LE:小于等于。
        # 
        # This parameter is required.
        self.comparison_operator = comparison_operator
        # 指标名称。指标名称需要在 ListAutoScalingMetrics 接口返回的指标名称列表中。
        # 
        # This parameter is required.
        self.metric_name = metric_name
        # 统计量名称。取值范围：
        # - MAX：最大值。
        # - MIN：最小值。
        # - AVG：平均值。
        # 
        # This parameter is required.
        self.statistics = statistics
        # 指标Tag。
        self.tags = tags
        # 阈值。
        # 
        # This parameter is required.
        self.threshold = threshold

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class TimeConstraint(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        start_time: str = None,
    ):
        # 结束时间。取值范围：00:00:00至23:59:59
        self.end_time = end_time
        # 开始时间。取值范围：00:00:00至23:59:59
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class MetricsTrigger(TeaModel):
    def __init__(
        self,
        condition_logic_operator: str = None,
        conditions: List[TriggerCondition] = None,
        cool_down_interval: int = None,
        evaluation_count: int = None,
        time_constraints: List[TimeConstraint] = None,
        time_window: int = None,
    ):
        # 多指标逻辑关系。默认：Or。取值范围：
        # - And:与
        # - Or：或
        self.condition_logic_operator = condition_logic_operator
        # 指标触发条件列表。
        self.conditions = conditions
        # 冷却时间。 单位为秒
        self.cool_down_interval = cool_down_interval
        # 统计次数。
        # 
        # This parameter is required.
        self.evaluation_count = evaluation_count
        # 时间限制。
        self.time_constraints = time_constraints
        # 统计窗口。单位为秒。
        # 
        # This parameter is required.
        self.time_window = time_window

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        if self.time_constraints:
            for k in self.time_constraints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_logic_operator is not None:
            result['ConditionLogicOperator'] = self.condition_logic_operator
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.cool_down_interval is not None:
            result['CoolDownInterval'] = self.cool_down_interval
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        result['TimeConstraints'] = []
        if self.time_constraints is not None:
            for k in self.time_constraints:
                result['TimeConstraints'].append(k.to_map() if k else None)
        if self.time_window is not None:
            result['TimeWindow'] = self.time_window
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionLogicOperator') is not None:
            self.condition_logic_operator = m.get('ConditionLogicOperator')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = TriggerCondition()
                self.conditions.append(temp_model.from_map(k))
        if m.get('CoolDownInterval') is not None:
            self.cool_down_interval = m.get('CoolDownInterval')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        self.time_constraints = []
        if m.get('TimeConstraints') is not None:
            for k in m.get('TimeConstraints'):
                temp_model = TimeConstraint()
                self.time_constraints.append(temp_model.from_map(k))
        if m.get('TimeWindow') is not None:
            self.time_window = m.get('TimeWindow')
        return self


class TimeTrigger(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        launch_expiration_time: int = None,
        launch_time: str = None,
        recurrence_type: str = None,
        recurrence_value: str = None,
        start_time: int = None,
    ):
        # 结束时间戳。单位为毫秒。
        self.end_time = end_time
        # 定时任务触发操作失败后，在此时间内重试。单位为秒，取值范围：0~3600。
        self.launch_expiration_time = launch_expiration_time
        # 启动时间。
        # 
        # This parameter is required.
        self.launch_time = launch_time
        # 指定时间规则的执行类型。
        self.recurrence_type = recurrence_type
        # 重复执行定时任务的数值。具体取值取决于 recurrenceType 设置。
        # - recurrenceType 取 MINUTELY 时，只能填一个数值，取值范围：1~1440。
        # - recurrenceType 取 HOURLY 时，只能填一个数值，取值范围：1~24。
        # - recurrenceType 取 DAILY 时，只能填一个数值，取值范围：1~31。
        # - recurrenceType 取 WEEKLY 时，可以填入多个值，填多个值时使用英文逗号（,）分隔。周一到周天分别用MON，TUE，WED，THU，FRI，SAT，SUN代替。 比如 MON,FRI,SUN 代表周一、周五、周天。
        # - recurrenceType 取 MONTHLY 时，格式为A-B或者A,B。A、B的取值范围为1~31，如果使用A-B时B必须大于A。
        self.recurrence_value = recurrence_value
        # 开始时间戳。单位为毫秒。
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.launch_expiration_time is not None:
            result['LaunchExpirationTime'] = self.launch_expiration_time
        if self.launch_time is not None:
            result['LaunchTime'] = self.launch_time
        if self.recurrence_type is not None:
            result['RecurrenceType'] = self.recurrence_type
        if self.recurrence_value is not None:
            result['RecurrenceValue'] = self.recurrence_value
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LaunchExpirationTime') is not None:
            self.launch_expiration_time = m.get('LaunchExpirationTime')
        if m.get('LaunchTime') is not None:
            self.launch_time = m.get('LaunchTime')
        if m.get('RecurrenceType') is not None:
            self.recurrence_type = m.get('RecurrenceType')
        if m.get('RecurrenceValue') is not None:
            self.recurrence_value = m.get('RecurrenceValue')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ScalingRule(TeaModel):
    def __init__(
        self,
        activity_type: str = None,
        adjustment_value: int = None,
        metrics_trigger: MetricsTrigger = None,
        min_adjustment_value: int = None,
        rule_name: str = None,
        time_trigger: TimeTrigger = None,
        trigger_type: str = None,
    ):
        # 伸缩活动类型。取值范围：
        # - SCALE_OUT：扩容。
        # - SCALE_IN：缩容。
        # 
        # This parameter is required.
        self.activity_type = activity_type
        # 调整值。需要为正数，代表需要扩容或者缩容的实例数量。
        # 
        # This parameter is required.
        self.adjustment_value = adjustment_value
        # 按照负载伸缩描述。
        # <p>
        self.metrics_trigger = metrics_trigger
        self.min_adjustment_value = min_adjustment_value
        # 规则名称。
        # 
        # This parameter is required.
        self.rule_name = rule_name
        # 按照时间伸缩描述。
        # <p>
        self.time_trigger = time_trigger
        # 伸缩规则类型。 取值范围：
        # - TIME_TRIGGER: 按时间伸缩。
        # - METRICS_TRIGGER: 按负载伸缩。
        # 
        # This parameter is required.
        self.trigger_type = trigger_type

    def validate(self):
        if self.metrics_trigger:
            self.metrics_trigger.validate()
        if self.time_trigger:
            self.time_trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_type is not None:
            result['ActivityType'] = self.activity_type
        if self.adjustment_value is not None:
            result['AdjustmentValue'] = self.adjustment_value
        if self.metrics_trigger is not None:
            result['MetricsTrigger'] = self.metrics_trigger.to_map()
        if self.min_adjustment_value is not None:
            result['MinAdjustmentValue'] = self.min_adjustment_value
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.time_trigger is not None:
            result['TimeTrigger'] = self.time_trigger.to_map()
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityType') is not None:
            self.activity_type = m.get('ActivityType')
        if m.get('AdjustmentValue') is not None:
            self.adjustment_value = m.get('AdjustmentValue')
        if m.get('MetricsTrigger') is not None:
            temp_model = MetricsTrigger()
            self.metrics_trigger = temp_model.from_map(m['MetricsTrigger'])
        if m.get('MinAdjustmentValue') is not None:
            self.min_adjustment_value = m.get('MinAdjustmentValue')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('TimeTrigger') is not None:
            temp_model = TimeTrigger()
            self.time_trigger = temp_model.from_map(m['TimeTrigger'])
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class AutoScalingConstraints(TeaModel):
    def __init__(
        self,
        auto_scaling_metric_units: List[MetricUnitValue] = None,
        default_metric_triggered_rules: List[ScalingRule] = None,
        max_adjustment_value: int = None,
        max_by_load_rule_count: int = None,
        max_by_time_rule_count: int = None,
        support_metric_tags: List[AutoScalingConstraintsSupportMetricTags] = None,
        support_metrics: List[str] = None,
        support_rule_types: List[str] = None,
    ):
        # 按负载伸缩指标单位描述。
        self.auto_scaling_metric_units = auto_scaling_metric_units
        # 默认按负载弹性伸缩规则列表
        self.default_metric_triggered_rules = default_metric_triggered_rules
        # 单次伸缩活动最大扩缩容节点数量。
        self.max_adjustment_value = max_adjustment_value
        # 按负载规则数量最大值。
        self.max_by_load_rule_count = max_by_load_rule_count
        # 按时间规则数量最大值。
        self.max_by_time_rule_count = max_by_time_rule_count
        # 支持的按负载弹性伸缩指标Tag列表。
        self.support_metric_tags = support_metric_tags
        # 支持的按负载弹性伸缩指标列表。
        self.support_metrics = support_metrics
        # 支持的弹性伸缩规则类型。
        self.support_rule_types = support_rule_types

    def validate(self):
        if self.auto_scaling_metric_units:
            for k in self.auto_scaling_metric_units:
                if k:
                    k.validate()
        if self.default_metric_triggered_rules:
            for k in self.default_metric_triggered_rules:
                if k:
                    k.validate()
        if self.support_metric_tags:
            for k in self.support_metric_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AutoScalingMetricUnits'] = []
        if self.auto_scaling_metric_units is not None:
            for k in self.auto_scaling_metric_units:
                result['AutoScalingMetricUnits'].append(k.to_map() if k else None)
        result['DefaultMetricTriggeredRules'] = []
        if self.default_metric_triggered_rules is not None:
            for k in self.default_metric_triggered_rules:
                result['DefaultMetricTriggeredRules'].append(k.to_map() if k else None)
        if self.max_adjustment_value is not None:
            result['MaxAdjustmentValue'] = self.max_adjustment_value
        if self.max_by_load_rule_count is not None:
            result['MaxByLoadRuleCount'] = self.max_by_load_rule_count
        if self.max_by_time_rule_count is not None:
            result['MaxByTimeRuleCount'] = self.max_by_time_rule_count
        result['SupportMetricTags'] = []
        if self.support_metric_tags is not None:
            for k in self.support_metric_tags:
                result['SupportMetricTags'].append(k.to_map() if k else None)
        if self.support_metrics is not None:
            result['SupportMetrics'] = self.support_metrics
        if self.support_rule_types is not None:
            result['SupportRuleTypes'] = self.support_rule_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.auto_scaling_metric_units = []
        if m.get('AutoScalingMetricUnits') is not None:
            for k in m.get('AutoScalingMetricUnits'):
                temp_model = MetricUnitValue()
                self.auto_scaling_metric_units.append(temp_model.from_map(k))
        self.default_metric_triggered_rules = []
        if m.get('DefaultMetricTriggeredRules') is not None:
            for k in m.get('DefaultMetricTriggeredRules'):
                temp_model = ScalingRule()
                self.default_metric_triggered_rules.append(temp_model.from_map(k))
        if m.get('MaxAdjustmentValue') is not None:
            self.max_adjustment_value = m.get('MaxAdjustmentValue')
        if m.get('MaxByLoadRuleCount') is not None:
            self.max_by_load_rule_count = m.get('MaxByLoadRuleCount')
        if m.get('MaxByTimeRuleCount') is not None:
            self.max_by_time_rule_count = m.get('MaxByTimeRuleCount')
        self.support_metric_tags = []
        if m.get('SupportMetricTags') is not None:
            for k in m.get('SupportMetricTags'):
                temp_model = AutoScalingConstraintsSupportMetricTags()
                self.support_metric_tags.append(temp_model.from_map(k))
        if m.get('SupportMetrics') is not None:
            self.support_metrics = m.get('SupportMetrics')
        if m.get('SupportRuleTypes') is not None:
            self.support_rule_types = m.get('SupportRuleTypes')
        return self


class AutoScalingPolicyConstraints(TeaModel):
    def __init__(
        self,
        max_capacity: int = None,
        min_capacity: int = None,
    ):
        self.max_capacity = max_capacity
        self.min_capacity = min_capacity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity is not None:
            result['MaxCapacity'] = self.max_capacity
        if self.min_capacity is not None:
            result['MinCapacity'] = self.min_capacity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxCapacity') is not None:
            self.max_capacity = m.get('MaxCapacity')
        if m.get('MinCapacity') is not None:
            self.min_capacity = m.get('MinCapacity')
        return self


class AutoScalingPolicy(TeaModel):
    def __init__(
        self,
        constraints: AutoScalingPolicyConstraints = None,
        scaling_rules: List[ScalingRule] = None,
    ):
        self.constraints = constraints
        self.scaling_rules = scaling_rules

    def validate(self):
        if self.constraints:
            self.constraints.validate()
        if self.scaling_rules:
            for k in self.scaling_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.constraints is not None:
            result['Constraints'] = self.constraints.to_map()
        result['ScalingRules'] = []
        if self.scaling_rules is not None:
            for k in self.scaling_rules:
                result['ScalingRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Constraints') is not None:
            temp_model = AutoScalingPolicyConstraints()
            self.constraints = temp_model.from_map(m['Constraints'])
        self.scaling_rules = []
        if m.get('ScalingRules') is not None:
            for k in m.get('ScalingRules'):
                temp_model = ScalingRule()
                self.scaling_rules.append(temp_model.from_map(k))
        return self


class ByLoadScalingRule(TeaModel):
    def __init__(
        self,
        comparison_operator: str = None,
        cool_down_interval: int = None,
        evaluation_count: int = None,
        metric_name: str = None,
        statistics: str = None,
        threshold: float = None,
        time_window: int = None,
    ):
        # 比较符。
        # 
        # This parameter is required.
        self.comparison_operator = comparison_operator
        self.cool_down_interval = cool_down_interval
        # 统计次数。
        # 
        # This parameter is required.
        self.evaluation_count = evaluation_count
        # 指标名称。指标名称需要在 ListAutoScalingMetrics 接口返回的指标名称列表中。
        # 
        # This parameter is required.
        self.metric_name = metric_name
        # 统计量名称。
        # 
        # This parameter is required.
        self.statistics = statistics
        # 阈值。
        # 
        # This parameter is required.
        self.threshold = threshold
        # 统计窗口。单位为秒。
        # 
        # This parameter is required.
        self.time_window = time_window

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.cool_down_interval is not None:
            result['CoolDownInterval'] = self.cool_down_interval
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.time_window is not None:
            result['TimeWindow'] = self.time_window
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('CoolDownInterval') is not None:
            self.cool_down_interval = m.get('CoolDownInterval')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('TimeWindow') is not None:
            self.time_window = m.get('TimeWindow')
        return self


class ByLoadScalingRuleSpec(TeaModel):
    def __init__(
        self,
        comparison_operator: str = None,
        evaluation_count: int = None,
        metric_name: str = None,
        statistics: str = None,
        threshold: float = None,
        time_window: int = None,
    ):
        # 比较符。
        # 
        # This parameter is required.
        self.comparison_operator = comparison_operator
        # 统计次数。
        # 
        # This parameter is required.
        self.evaluation_count = evaluation_count
        # 指标名称。指标名称需要在 ListAutoScalingMetrics 接口返回的指标名称列表中。
        # 
        # This parameter is required.
        self.metric_name = metric_name
        # 统计量名称。
        # 
        # This parameter is required.
        self.statistics = statistics
        # 阈值。
        # 
        # This parameter is required.
        self.threshold = threshold
        # 统计窗口。单位为秒。
        # 
        # This parameter is required.
        self.time_window = time_window

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.time_window is not None:
            result['TimeWindow'] = self.time_window
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('TimeWindow') is not None:
            self.time_window = m.get('TimeWindow')
        return self


class ByTimeScalingRule(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        launch_expiration_time: int = None,
        launch_time: int = None,
        recurrence_type: str = None,
        recurrence_value: str = None,
    ):
        # 重复执行定时任务的结束时间戳。单位为毫秒。
        self.end_time = end_time
        # 定时任务触发操作失败后，在此时间内重试。单位为秒，取值范围：0~3600。
        self.launch_expiration_time = launch_expiration_time
        # 启动时间戳。单位为毫秒。
        # 
        # This parameter is required.
        self.launch_time = launch_time
        # 指定时间规则的执行类型。
        self.recurrence_type = recurrence_type
        # 重复执行定时任务的数值。具体取值取决于 recurrenceType 设置。
        # - recurrenceType 取 MINUTELY 时，只能填一个数值，取值范围：1~1440。
        # - recurrenceType 取 HOURLY 时，只能填一个数值，取值范围：1~24。
        # - recurrenceType 取 DAILY 时，只能填一个数值，取值范围：1~31。
        # - recurrenceType 取 WEEKLY 时，可以填入多个值，填多个值时使用英文逗号（,）分隔。周一到周天分别用MON，TUE，WED，THU，FRI，SAT，SUN代替。 比如 MON,FRI,SUN 代表周一、周五、周天。
        # - recurrenceType 取 MONTHLY 时，格式为A-B或者A,B。A、B的取值范围为1~31，如果使用A-B时B必须大于A。
        self.recurrence_value = recurrence_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.launch_expiration_time is not None:
            result['LaunchExpirationTime'] = self.launch_expiration_time
        if self.launch_time is not None:
            result['LaunchTime'] = self.launch_time
        if self.recurrence_type is not None:
            result['RecurrenceType'] = self.recurrence_type
        if self.recurrence_value is not None:
            result['RecurrenceValue'] = self.recurrence_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LaunchExpirationTime') is not None:
            self.launch_expiration_time = m.get('LaunchExpirationTime')
        if m.get('LaunchTime') is not None:
            self.launch_time = m.get('LaunchTime')
        if m.get('RecurrenceType') is not None:
            self.recurrence_type = m.get('RecurrenceType')
        if m.get('RecurrenceValue') is not None:
            self.recurrence_value = m.get('RecurrenceValue')
        return self


class ByTimeScalingRuleSpec(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        launch_time: int = None,
        recurrence_type: str = None,
        recurrence_value: str = None,
    ):
        # 重复执行定时任务的结束时间戳。单位为毫秒。
        self.end_time = end_time
        # 启动时间戳。单位为毫秒。
        # 
        # This parameter is required.
        self.launch_time = launch_time
        # 指定时间规则的执行类型。
        self.recurrence_type = recurrence_type
        # 重复执行定时任务的数值。具体取值取决于 recurrenceType 设置。
        self.recurrence_value = recurrence_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.launch_time is not None:
            result['LaunchTime'] = self.launch_time
        if self.recurrence_type is not None:
            result['RecurrenceType'] = self.recurrence_type
        if self.recurrence_value is not None:
            result['RecurrenceValue'] = self.recurrence_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LaunchTime') is not None:
            self.launch_time = m.get('LaunchTime')
        if m.get('RecurrenceType') is not None:
            self.recurrence_type = m.get('RecurrenceType')
        if m.get('RecurrenceValue') is not None:
            self.recurrence_value = m.get('RecurrenceValue')
        return self


class ClickhouseConf(TeaModel):
    def __init__(
        self,
        initial_replica: int = None,
        initial_shard: int = None,
        new_node_count: int = None,
        resize_type: str = None,
    ):
        self.initial_replica = initial_replica
        self.initial_shard = initial_shard
        self.new_node_count = new_node_count
        self.resize_type = resize_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.initial_replica is not None:
            result['InitialReplica'] = self.initial_replica
        if self.initial_shard is not None:
            result['InitialShard'] = self.initial_shard
        if self.new_node_count is not None:
            result['NewNodeCount'] = self.new_node_count
        if self.resize_type is not None:
            result['ResizeType'] = self.resize_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InitialReplica') is not None:
            self.initial_replica = m.get('InitialReplica')
        if m.get('InitialShard') is not None:
            self.initial_shard = m.get('InitialShard')
        if m.get('NewNodeCount') is not None:
            self.new_node_count = m.get('NewNodeCount')
        if m.get('ResizeType') is not None:
            self.resize_type = m.get('ResizeType')
        return self


class NodeAttributes(TeaModel):
    def __init__(
        self,
        data_disk_encrypted: bool = None,
        data_disk_kmskey_id: str = None,
        key_pair_name: str = None,
        master_root_password: str = None,
        ram_role: str = None,
        security_group_id: str = None,
        system_disk_encrypted: bool = None,
        system_disk_kmskey_id: str = None,
        vpc_id: str = None,
        zone_id: str = None,
    ):
        # 是否启用云盘加密。取值范围：
        # - true：启用加密。
        # - false：不加密。
        # 
        # 默认值：false，不加密
        self.data_disk_encrypted = data_disk_encrypted
        # KMS加密秘钥ID。
        self.data_disk_kmskey_id = data_disk_kmskey_id
        # ECS ssh登录秘钥。
        self.key_pair_name = key_pair_name
        # MASTER节点root密码。
        self.master_root_password = master_root_password
        # ECS访问资源绑定的角色。
        self.ram_role = ram_role
        # 安全组ID。EMR只支持普通安全组，不支持企业安全组。
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # 是否启用云盘加密。取值范围：
        # - true：启用加密。
        # - false：不加密。
        # 
        # 默认值：false，不加密
        self.system_disk_encrypted = system_disk_encrypted
        # KMS加密秘钥ID。
        self.system_disk_kmskey_id = system_disk_kmskey_id
        # 专有网络ID。
        # 
        # This parameter is required.
        self.vpc_id = vpc_id
        # 可用区ID。
        # 
        # This parameter is required.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_encrypted is not None:
            result['DataDiskEncrypted'] = self.data_disk_encrypted
        if self.data_disk_kmskey_id is not None:
            result['DataDiskKMSKeyId'] = self.data_disk_kmskey_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.master_root_password is not None:
            result['MasterRootPassword'] = self.master_root_password
        if self.ram_role is not None:
            result['RamRole'] = self.ram_role
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.system_disk_encrypted is not None:
            result['SystemDiskEncrypted'] = self.system_disk_encrypted
        if self.system_disk_kmskey_id is not None:
            result['SystemDiskKMSKeyId'] = self.system_disk_kmskey_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataDiskEncrypted') is not None:
            self.data_disk_encrypted = m.get('DataDiskEncrypted')
        if m.get('DataDiskKMSKeyId') is not None:
            self.data_disk_kmskey_id = m.get('DataDiskKMSKeyId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('MasterRootPassword') is not None:
            self.master_root_password = m.get('MasterRootPassword')
        if m.get('RamRole') is not None:
            self.ram_role = m.get('RamRole')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SystemDiskEncrypted') is not None:
            self.system_disk_encrypted = m.get('SystemDiskEncrypted')
        if m.get('SystemDiskKMSKeyId') is not None:
            self.system_disk_kmskey_id = m.get('SystemDiskKMSKeyId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ClusterStateChangeReason(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
    ):
        # 状态码。取值范围：
        # - UserRequest：用户请求。
        # - OutOfStock：请求的ECS实例类型无库存。
        # - NotAuthorized：无权限。
        # - QuotaExceeded：Quota超出。
        # - OperationDenied：操作被拒绝。
        # - AccountException：账号异常。
        # - NodeFailure：ECS节点异常。
        # - BootstrapFailure：引导失败。
        # - ValidationFail：业务逻辑校验失败。
        # - ServiceFailure：依赖的其他服务失败。
        # - InternalError：内部错误。
        self.code = code
        # 状态变化信息。
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class SubscriptionConfig(TeaModel):
    def __init__(
        self,
        auto_renew: bool = None,
        auto_renew_duration: int = None,
        auto_renew_duration_unit: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
    ):
        # 自动续费。取值范围：
        # - true：开启启动续费。
        # - false：不开启自动续费。
        # 默认值：false。
        self.auto_renew = auto_renew
        # 自动续费时长。当AutoRenew取值为true时生效。当AutoRenewDurationUnit取值为Month时，取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
        self.auto_renew_duration = auto_renew_duration
        # - Month：月。
        self.auto_renew_duration_unit = auto_renew_duration_unit
        # 付费时长。PaymentDurationUnit取值为Month时，取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
        # 
        # This parameter is required.
        self.payment_duration = payment_duration
        # 付费时长单位。取值范围：
        # - Month：月。
        # 
        # This parameter is required.
        self.payment_duration_unit = payment_duration_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_duration is not None:
            result['AutoRenewDuration'] = self.auto_renew_duration
        if self.auto_renew_duration_unit is not None:
            result['AutoRenewDurationUnit'] = self.auto_renew_duration_unit
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewDuration') is not None:
            self.auto_renew_duration = m.get('AutoRenewDuration')
        if m.get('AutoRenewDurationUnit') is not None:
            self.auto_renew_duration_unit = m.get('AutoRenewDurationUnit')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        return self


class Cluster(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_state: str = None,
        cluster_type: str = None,
        create_time: int = None,
        deletion_protection: bool = None,
        deploy_mode: str = None,
        description: str = None,
        emr_default_role: str = None,
        end_time: int = None,
        expire_time: int = None,
        node_attributes: NodeAttributes = None,
        payment_type: str = None,
        ready_time: int = None,
        region_id: str = None,
        release_version: str = None,
        resource_group_id: str = None,
        security_mode: str = None,
        state_change_reason: ClusterStateChangeReason = None,
        subscription_config: SubscriptionConfig = None,
        tags: List[Tag] = None,
    ):
        # 集群ID。
        self.cluster_id = cluster_id
        # 集群名称。
        self.cluster_name = cluster_name
        # 集群状态。
        self.cluster_state = cluster_state
        # 集群类型。
        self.cluster_type = cluster_type
        # 创建时间。
        self.create_time = create_time
        self.deletion_protection = deletion_protection
        # 部署模式。
        self.deploy_mode = deploy_mode
        self.description = description
        # EMR默认角色。
        self.emr_default_role = emr_default_role
        # 删除时间。
        self.end_time = end_time
        # 过期时间。
        self.expire_time = expire_time
        # 节点属性。
        self.node_attributes = node_attributes
        # 付费类型。
        self.payment_type = payment_type
        # 可用时间。
        self.ready_time = ready_time
        # 地域ID。
        self.region_id = region_id
        # EMR发行版。
        self.release_version = release_version
        # 资源组ID。
        self.resource_group_id = resource_group_id
        # Kerberos安全模式。
        self.security_mode = security_mode
        self.state_change_reason = state_change_reason
        # 预付费配置。
        self.subscription_config = subscription_config
        # 集群标签。
        self.tags = tags

    def validate(self):
        if self.node_attributes:
            self.node_attributes.validate()
        if self.state_change_reason:
            self.state_change_reason.validate()
        if self.subscription_config:
            self.subscription_config.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_state is not None:
            result['ClusterState'] = self.cluster_state
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.emr_default_role is not None:
            result['EmrDefaultRole'] = self.emr_default_role
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.node_attributes is not None:
            result['NodeAttributes'] = self.node_attributes.to_map()
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.ready_time is not None:
            result['ReadyTime'] = self.ready_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_version is not None:
            result['ReleaseVersion'] = self.release_version
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_mode is not None:
            result['SecurityMode'] = self.security_mode
        if self.state_change_reason is not None:
            result['StateChangeReason'] = self.state_change_reason.to_map()
        if self.subscription_config is not None:
            result['SubscriptionConfig'] = self.subscription_config.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterState') is not None:
            self.cluster_state = m.get('ClusterState')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EmrDefaultRole') is not None:
            self.emr_default_role = m.get('EmrDefaultRole')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('NodeAttributes') is not None:
            temp_model = NodeAttributes()
            self.node_attributes = temp_model.from_map(m['NodeAttributes'])
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('ReadyTime') is not None:
            self.ready_time = m.get('ReadyTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseVersion') is not None:
            self.release_version = m.get('ReleaseVersion')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityMode') is not None:
            self.security_mode = m.get('SecurityMode')
        if m.get('StateChangeReason') is not None:
            temp_model = ClusterStateChangeReason()
            self.state_change_reason = temp_model.from_map(m['StateChangeReason'])
        if m.get('SubscriptionConfig') is not None:
            temp_model = SubscriptionConfig()
            self.subscription_config = temp_model.from_map(m['SubscriptionConfig'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class NodeSelector(TeaModel):
    def __init__(
        self,
        node_group_id: str = None,
        node_group_ids: List[str] = None,
        node_group_name: str = None,
        node_group_names: List[str] = None,
        node_group_types: List[str] = None,
        node_names: List[str] = None,
        node_select_type: str = None,
    ):
        # 节点组ID。当NodeSelectType取值NodeGroup时，该参数生效。
        self.node_group_id = node_group_id
        self.node_group_ids = node_group_ids
        # 节点组名称。当NodeSelectType取值NodeGroup，且参数NodeGroupId为空时生效，该参数生效。
        self.node_group_name = node_group_name
        self.node_group_names = node_group_names
        # 节点组类型。当NodeSelectType取值NodeGroup，且参数NodeGroupId为空时生效。数组元数个数N取值范围：0~10。
        self.node_group_types = node_group_types
        # 节点名称列表。当NodeSelectType取值Node时，该参数生效。
        self.node_names = node_names
        # 节点选择类型。取值范围：
        # - CLUSTER：集群。
        # - NODE_GROUP：节点组。
        # - NODE：节点。
        # 
        # This parameter is required.
        self.node_select_type = node_select_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_ids is not None:
            result['NodeGroupIds'] = self.node_group_ids
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.node_group_names is not None:
            result['NodeGroupNames'] = self.node_group_names
        if self.node_group_types is not None:
            result['NodeGroupTypes'] = self.node_group_types
        if self.node_names is not None:
            result['NodeNames'] = self.node_names
        if self.node_select_type is not None:
            result['NodeSelectType'] = self.node_select_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupIds') is not None:
            self.node_group_ids = m.get('NodeGroupIds')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('NodeGroupNames') is not None:
            self.node_group_names = m.get('NodeGroupNames')
        if m.get('NodeGroupTypes') is not None:
            self.node_group_types = m.get('NodeGroupTypes')
        if m.get('NodeNames') is not None:
            self.node_names = m.get('NodeNames')
        if m.get('NodeSelectType') is not None:
            self.node_select_type = m.get('NodeSelectType')
        return self


class ClusterScript(TeaModel):
    def __init__(
        self,
        execution_fail_strategy: str = None,
        execution_moment: str = None,
        node_select: NodeSelector = None,
        priority: int = None,
        script_args: str = None,
        script_name: str = None,
        script_path: str = None,
    ):
        self.execution_fail_strategy = execution_fail_strategy
        self.execution_moment = execution_moment
        self.node_select = node_select
        self.priority = priority
        self.script_args = script_args
        self.script_name = script_name
        self.script_path = script_path

    def validate(self):
        if self.node_select:
            self.node_select.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.execution_fail_strategy is not None:
            result['ExecutionFailStrategy'] = self.execution_fail_strategy
        if self.execution_moment is not None:
            result['ExecutionMoment'] = self.execution_moment
        if self.node_select is not None:
            result['NodeSelect'] = self.node_select.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.script_args is not None:
            result['ScriptArgs'] = self.script_args
        if self.script_name is not None:
            result['ScriptName'] = self.script_name
        if self.script_path is not None:
            result['ScriptPath'] = self.script_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecutionFailStrategy') is not None:
            self.execution_fail_strategy = m.get('ExecutionFailStrategy')
        if m.get('ExecutionMoment') is not None:
            self.execution_moment = m.get('ExecutionMoment')
        if m.get('NodeSelect') is not None:
            temp_model = NodeSelector()
            self.node_select = temp_model.from_map(m['NodeSelect'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ScriptArgs') is not None:
            self.script_args = m.get('ScriptArgs')
        if m.get('ScriptName') is not None:
            self.script_name = m.get('ScriptName')
        if m.get('ScriptPath') is not None:
            self.script_path = m.get('ScriptPath')
        return self


class ClusterSummary(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_state: str = None,
        cluster_type: str = None,
        create_time: int = None,
        deletion_protection: bool = None,
        description: str = None,
        emr_default_role: str = None,
        end_time: int = None,
        expire_time: int = None,
        payment_type: str = None,
        ready_time: int = None,
        release_version: str = None,
        resource_group_id: str = None,
        state_change_reason: ClusterStateChangeReason = None,
        tags: List[Tag] = None,
    ):
        # 集群ID。
        self.cluster_id = cluster_id
        # 集群名称。
        self.cluster_name = cluster_name
        # 集群状态。取值范围：
        # - STARTING：启动中。
        # - START_FAILED：启动失败。
        # - BOOTSTRAPPING：引导操作初始化。
        # - RUNNING：运行中。
        # - TERMINATING：终止中。
        # - TERMINATED：已终止。
        # - TERMINATED_WITH_ERRORS：发生异常导致终止。
        # - TERMINATE_FAILED：终止失败。
        self.cluster_state = cluster_state
        # 集群类型。取值范围：
        # - DATALAKE：新版数据湖。
        # - OLAP：数据分析。
        # - DATAFLOW：实时数据流。
        # - DATASERVING：数据服务。
        self.cluster_type = cluster_type
        # 创建时间。
        self.create_time = create_time
        self.deletion_protection = deletion_protection
        self.description = description
        # EMR服务角色。
        self.emr_default_role = emr_default_role
        # 删除时间。
        self.end_time = end_time
        # 过期时间。
        self.expire_time = expire_time
        # 付费类型。取值范围：
        # - PayAsYouGo：后付费。
        # - Subscription：预付费。
        self.payment_type = payment_type
        # 可用时间。
        self.ready_time = ready_time
        # EMR发行版。
        self.release_version = release_version
        # 资源组ID。
        self.resource_group_id = resource_group_id
        # 失败原因。
        self.state_change_reason = state_change_reason
        # 标签列表。
        self.tags = tags

    def validate(self):
        if self.state_change_reason:
            self.state_change_reason.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_state is not None:
            result['ClusterState'] = self.cluster_state
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.description is not None:
            result['Description'] = self.description
        if self.emr_default_role is not None:
            result['EmrDefaultRole'] = self.emr_default_role
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.ready_time is not None:
            result['ReadyTime'] = self.ready_time
        if self.release_version is not None:
            result['ReleaseVersion'] = self.release_version
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.state_change_reason is not None:
            result['StateChangeReason'] = self.state_change_reason.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterState') is not None:
            self.cluster_state = m.get('ClusterState')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EmrDefaultRole') is not None:
            self.emr_default_role = m.get('EmrDefaultRole')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('ReadyTime') is not None:
            self.ready_time = m.get('ReadyTime')
        if m.get('ReleaseVersion') is not None:
            self.release_version = m.get('ReleaseVersion')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('StateChangeReason') is not None:
            temp_model = ClusterStateChangeReason()
            self.state_change_reason = temp_model.from_map(m['StateChangeReason'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class ComponentInstanceSelectorComponentInstances(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        component_name: str = None,
        node_id: str = None,
    ):
        # 应用名称。
        self.application_name = application_name
        # 组件名称。
        self.component_name = component_name
        # 节点ID。
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class ComponentInstanceSelectorComponents(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        component_name: str = None,
    ):
        # 应用名称。
        self.application_name = application_name
        # 组件名称。
        self.component_name = component_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        return self


class ComponentInstanceSelector(TeaModel):
    def __init__(
        self,
        action_scope: str = None,
        application_name: str = None,
        component_instances: List[ComponentInstanceSelectorComponentInstances] = None,
        components: List[ComponentInstanceSelectorComponents] = None,
        run_action_scope: str = None,
    ):
        self.action_scope = action_scope
        # 应用名称。
        self.application_name = application_name
        # 组件实例列表。actionScope为COPONENT_INSTANCE时使用。
        self.component_instances = component_instances
        # 组件列表。
        # actionScope为COPONENT时使用。
        self.components = components
        # 动作执行范围。取值范围：
        # - APPLICATION：应用级别。
        # - COMPONENT：组件级别。
        # - COMPONENT_INSTANCE：组件实例级别。
        # 
        # This parameter is required.
        self.run_action_scope = run_action_scope

    def validate(self):
        if self.component_instances:
            for k in self.component_instances:
                if k:
                    k.validate()
        if self.components:
            for k in self.components:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_scope is not None:
            result['ActionScope'] = self.action_scope
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        result['ComponentInstances'] = []
        if self.component_instances is not None:
            for k in self.component_instances:
                result['ComponentInstances'].append(k.to_map() if k else None)
        result['Components'] = []
        if self.components is not None:
            for k in self.components:
                result['Components'].append(k.to_map() if k else None)
        if self.run_action_scope is not None:
            result['RunActionScope'] = self.run_action_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionScope') is not None:
            self.action_scope = m.get('ActionScope')
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        self.component_instances = []
        if m.get('ComponentInstances') is not None:
            for k in m.get('ComponentInstances'):
                temp_model = ComponentInstanceSelectorComponentInstances()
                self.component_instances.append(temp_model.from_map(k))
        self.components = []
        if m.get('Components') is not None:
            for k in m.get('Components'):
                temp_model = ComponentInstanceSelectorComponents()
                self.components.append(temp_model.from_map(k))
        if m.get('RunActionScope') is not None:
            self.run_action_scope = m.get('RunActionScope')
        return self


class ComponentLayoutNodeSelector(TeaModel):
    def __init__(
        self,
        node_end_index: int = None,
        node_group_id: str = None,
        node_group_index: int = None,
        node_group_name: str = None,
        node_group_types: List[str] = None,
        node_names: List[str] = None,
        node_select_type: str = None,
        node_start_index: int = None,
    ):
        # 节点结束编号，包含结束编号。
        self.node_end_index = node_end_index
        # 节点组ID。
        self.node_group_id = node_group_id
        # 机器组下标编号。
        self.node_group_index = node_group_index
        # 机器组名。
        self.node_group_name = node_group_name
        # SelectType = NODE_GROUP 且 nodeGroupId 不存在时使用
        self.node_group_types = node_group_types
        # 节点名称列表。
        self.node_names = node_names
        # 节点选择类型。
        # 
        # This parameter is required.
        self.node_select_type = node_select_type
        # 节点开始编号，包含开始编号。
        self.node_start_index = node_start_index

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_end_index is not None:
            result['NodeEndIndex'] = self.node_end_index
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_index is not None:
            result['NodeGroupIndex'] = self.node_group_index
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.node_group_types is not None:
            result['NodeGroupTypes'] = self.node_group_types
        if self.node_names is not None:
            result['NodeNames'] = self.node_names
        if self.node_select_type is not None:
            result['NodeSelectType'] = self.node_select_type
        if self.node_start_index is not None:
            result['NodeStartIndex'] = self.node_start_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeEndIndex') is not None:
            self.node_end_index = m.get('NodeEndIndex')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupIndex') is not None:
            self.node_group_index = m.get('NodeGroupIndex')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('NodeGroupTypes') is not None:
            self.node_group_types = m.get('NodeGroupTypes')
        if m.get('NodeNames') is not None:
            self.node_names = m.get('NodeNames')
        if m.get('NodeSelectType') is not None:
            self.node_select_type = m.get('NodeSelectType')
        if m.get('NodeStartIndex') is not None:
            self.node_start_index = m.get('NodeStartIndex')
        return self


class ComponentLayout(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        component_name: str = None,
        node_selector: ComponentLayoutNodeSelector = None,
    ):
        # 应用名称。
        self.application_name = application_name
        # 组件名称。
        self.component_name = component_name
        # 节点选择器。
        self.node_selector = node_selector

    def validate(self):
        if self.node_selector:
            self.node_selector.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.node_selector is not None:
            result['NodeSelector'] = self.node_selector.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('NodeSelector') is not None:
            temp_model = ComponentLayoutNodeSelector()
            self.node_selector = temp_model.from_map(m['NodeSelector'])
        return self


class ConfigEffectActions(TeaModel):
    def __init__(
        self,
        config_effect_action: str = None,
        config_files: List[str] = None,
    ):
        # 配置生效动作。
        self.config_effect_action = config_effect_action
        # 配置生效配置文件。
        self.config_files = config_files

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_effect_action is not None:
            result['ConfigEffectAction'] = self.config_effect_action
        if self.config_files is not None:
            result['ConfigFiles'] = self.config_files
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigEffectAction') is not None:
            self.config_effect_action = m.get('ConfigEffectAction')
        if m.get('ConfigFiles') is not None:
            self.config_files = m.get('ConfigFiles')
        return self


class ConvertNodeGroup(TeaModel):
    def __init__(
        self,
        node_group_id: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        payment_type: str = None,
    ):
        # 节点组ID。
        self.node_group_id = node_group_id
        # 付费时长。
        self.payment_duration = payment_duration
        # 付费时长单位。
        self.payment_duration_unit = payment_duration_unit
        # 付费类型。
        self.payment_type = payment_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        return self


class ConvertNodeGroupParam(TeaModel):
    def __init__(
        self,
        node_group_id: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        payment_type: str = None,
    ):
        # This parameter is required.
        self.node_group_id = node_group_id
        # This parameter is required.
        self.payment_duration = payment_duration
        self.payment_duration_unit = payment_duration_unit
        # This parameter is required.
        self.payment_type = payment_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        return self


class DataDisk(TeaModel):
    def __init__(
        self,
        category: str = None,
        count: int = None,
        performance_level: str = None,
        size: int = None,
    ):
        # 磁盘类型。
        # 
        # This parameter is required.
        self.category = category
        # 每个节点磁盘数量。
        self.count = count
        # 创建ESSD云盘作为数据盘使用时，设置云盘的性能等级。取值范围：
        # - PL0：单盘最高随机读写IOPS 1万。
        # - PL1（默认）：单盘最高随机读写IOPS 5万。
        # - PL2：单盘最高随机读写IOPS 10万。
        # - PL3：单盘最高随机读写IOPS 100万。
        # 
        # 默认值：PL1。
        self.performance_level = performance_level
        # 单位GB。
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.count is not None:
            result['Count'] = self.count
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class SystemDisk(TeaModel):
    def __init__(
        self,
        category: str = None,
        count: int = None,
        performance_level: str = None,
        size: int = None,
    ):
        # 磁盘类型。
        # 
        # This parameter is required.
        self.category = category
        # 每个节点系统盘数量，默认值为1。
        self.count = count
        # 创建ESSD云盘作为系统盘使用时，设置云盘的性能等级。取值范围：
        # - PL0：单盘最高随机读写IOPS 1万。
        # - PL1（默认）：单盘最高随机读写IOPS 5万。
        # - PL2：单盘最高随机读写IOPS 10万。
        # - PL3：单盘最高随机读写IOPS 100万。
        # 
        # 默认值：PL1。
        self.performance_level = performance_level
        # 单位GB。
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.count is not None:
            result['Count'] = self.count
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CostInstanceType(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        data_disks: List[DataDisk] = None,
        instance_type: str = None,
        memory: int = None,
        system_disk: SystemDisk = None,
    ):
        # CPU核数。
        self.cpu = cpu
        # 数据盘列表。
        self.data_disks = data_disks
        # 实例类型列表。
        self.instance_type = instance_type
        # 内存大小。
        self.memory = memory
        # 系统盘信息。
        self.system_disk = system_disk

    def validate(self):
        if self.data_disks:
            for k in self.data_disks:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        result['DataDisks'] = []
        if self.data_disks is not None:
            for k in self.data_disks:
                result['DataDisks'].append(k.to_map() if k else None)
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        self.data_disks = []
        if m.get('DataDisks') is not None:
            for k in m.get('DataDisks'):
                temp_model = DataDisk()
                self.data_disks.append(temp_model.from_map(k))
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('SystemDisk') is not None:
            temp_model = SystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        return self


class CostNodeGroupConfig(TeaModel):
    def __init__(
        self,
        instance_types: List[CostInstanceType] = None,
        maximal_node_count: int = None,
        minimal_node_count: int = None,
        node_count: int = None,
        node_group_name: str = None,
        node_group_type: str = None,
        payment_type: str = None,
    ):
        # 实例类型列表。
        self.instance_types = instance_types
        # 最大节点数限制。
        self.maximal_node_count = maximal_node_count
        # 最小节点数限制。
        self.minimal_node_count = minimal_node_count
        # 节点数。
        self.node_count = node_count
        self.node_group_name = node_group_name
        # 节点组类型。取值范围：
        # - MASTER：管理类型节点组。
        # - CORE：存储类型节点组。
        # - TASK：计算类型节点组。
        self.node_group_type = node_group_type
        # 付费类型。
        self.payment_type = payment_type

    def validate(self):
        if self.instance_types:
            for k in self.instance_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceTypes'] = []
        if self.instance_types is not None:
            for k in self.instance_types:
                result['InstanceTypes'].append(k.to_map() if k else None)
        if self.maximal_node_count is not None:
            result['MaximalNodeCount'] = self.maximal_node_count
        if self.minimal_node_count is not None:
            result['MinimalNodeCount'] = self.minimal_node_count
        if self.node_count is not None:
            result['NodeCount'] = self.node_count
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.node_group_type is not None:
            result['NodeGroupType'] = self.node_group_type
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_types = []
        if m.get('InstanceTypes') is not None:
            for k in m.get('InstanceTypes'):
                temp_model = CostInstanceType()
                self.instance_types.append(temp_model.from_map(k))
        if m.get('MaximalNodeCount') is not None:
            self.maximal_node_count = m.get('MaximalNodeCount')
        if m.get('MinimalNodeCount') is not None:
            self.minimal_node_count = m.get('MinimalNodeCount')
        if m.get('NodeCount') is not None:
            self.node_count = m.get('NodeCount')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('NodeGroupType') is not None:
            self.node_group_type = m.get('NodeGroupType')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        return self


class CostOptimizedConfig(TeaModel):
    def __init__(
        self,
        on_demand_base_capacity: int = None,
        on_demand_percentage_above_base_capacity: int = None,
        spot_instance_pools: int = None,
    ):
        # 按量实例个数的最小值。节点组所需要按量实例个数的最小值，取值范围：0~1000。当按量实例个数少于该值时，将优先创建按量实例。
        # 
        # This parameter is required.
        self.on_demand_base_capacity = on_demand_base_capacity
        # 节点组满足最小按量实例OnDemandBaseCapacity要求后，超出的实例中按量实例应占的比例，取值范围：0～100。
        # 
        # This parameter is required.
        self.on_demand_percentage_above_base_capacity = on_demand_percentage_above_base_capacity
        # 指定可用实例规格的个数，伸缩组将按成本最低的多个规格均衡创建抢占式实例。取值范围：0~10。
        # 
        # This parameter is required.
        self.spot_instance_pools = spot_instance_pools

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.on_demand_base_capacity is not None:
            result['OnDemandBaseCapacity'] = self.on_demand_base_capacity
        if self.on_demand_percentage_above_base_capacity is not None:
            result['OnDemandPercentageAboveBaseCapacity'] = self.on_demand_percentage_above_base_capacity
        if self.spot_instance_pools is not None:
            result['SpotInstancePools'] = self.spot_instance_pools
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OnDemandBaseCapacity') is not None:
            self.on_demand_base_capacity = m.get('OnDemandBaseCapacity')
        if m.get('OnDemandPercentageAboveBaseCapacity') is not None:
            self.on_demand_percentage_above_base_capacity = m.get('OnDemandPercentageAboveBaseCapacity')
        if m.get('SpotInstancePools') is not None:
            self.spot_instance_pools = m.get('SpotInstancePools')
        return self


class DiskInfo(TeaModel):
    def __init__(
        self,
        category: str = None,
        count: int = None,
        performance_level: str = None,
        size: int = None,
    ):
        self.category = category
        self.count = count
        self.performance_level = performance_level
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.count is not None:
            result['Count'] = self.count
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class SystemDiskParam(TeaModel):
    def __init__(
        self,
        category: str = None,
        performance_level: str = None,
        size: int = None,
    ):
        self.category = category
        self.performance_level = performance_level
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CreateNodeGroupParam(TeaModel):
    def __init__(
        self,
        auto_renew: bool = None,
        auto_renew_duration: int = None,
        auto_renew_duration_unit: str = None,
        data_disks: List[DiskInfo] = None,
        instance_types: List[str] = None,
        node_count: int = None,
        node_group_name: str = None,
        node_group_type: str = None,
        node_key_pair_name: str = None,
        node_ram_role: str = None,
        node_root_password: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        payment_type: str = None,
        security_group_id: str = None,
        spot_strategy: str = None,
        system_disk: SystemDiskParam = None,
        v_switch_ids: List[str] = None,
        with_public_ip: bool = None,
        zone_id: str = None,
    ):
        self.auto_renew = auto_renew
        self.auto_renew_duration = auto_renew_duration
        self.auto_renew_duration_unit = auto_renew_duration_unit
        self.data_disks = data_disks
        self.instance_types = instance_types
        self.node_count = node_count
        self.node_group_name = node_group_name
        self.node_group_type = node_group_type
        self.node_key_pair_name = node_key_pair_name
        self.node_ram_role = node_ram_role
        self.node_root_password = node_root_password
        self.payment_duration = payment_duration
        self.payment_duration_unit = payment_duration_unit
        self.payment_type = payment_type
        self.security_group_id = security_group_id
        self.spot_strategy = spot_strategy
        self.system_disk = system_disk
        self.v_switch_ids = v_switch_ids
        self.with_public_ip = with_public_ip
        self.zone_id = zone_id

    def validate(self):
        if self.data_disks:
            for k in self.data_disks:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_duration is not None:
            result['AutoRenewDuration'] = self.auto_renew_duration
        if self.auto_renew_duration_unit is not None:
            result['AutoRenewDurationUnit'] = self.auto_renew_duration_unit
        result['DataDisks'] = []
        if self.data_disks is not None:
            for k in self.data_disks:
                result['DataDisks'].append(k.to_map() if k else None)
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.node_count is not None:
            result['NodeCount'] = self.node_count
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.node_group_type is not None:
            result['NodeGroupType'] = self.node_group_type
        if self.node_key_pair_name is not None:
            result['NodeKeyPairName'] = self.node_key_pair_name
        if self.node_ram_role is not None:
            result['NodeRamRole'] = self.node_ram_role
        if self.node_root_password is not None:
            result['NodeRootPassword'] = self.node_root_password
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.with_public_ip is not None:
            result['WithPublicIp'] = self.with_public_ip
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewDuration') is not None:
            self.auto_renew_duration = m.get('AutoRenewDuration')
        if m.get('AutoRenewDurationUnit') is not None:
            self.auto_renew_duration_unit = m.get('AutoRenewDurationUnit')
        self.data_disks = []
        if m.get('DataDisks') is not None:
            for k in m.get('DataDisks'):
                temp_model = DiskInfo()
                self.data_disks.append(temp_model.from_map(k))
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('NodeCount') is not None:
            self.node_count = m.get('NodeCount')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('NodeGroupType') is not None:
            self.node_group_type = m.get('NodeGroupType')
        if m.get('NodeKeyPairName') is not None:
            self.node_key_pair_name = m.get('NodeKeyPairName')
        if m.get('NodeRamRole') is not None:
            self.node_ram_role = m.get('NodeRamRole')
        if m.get('NodeRootPassword') is not None:
            self.node_root_password = m.get('NodeRootPassword')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('SystemDisk') is not None:
            temp_model = SystemDiskParam()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('WithPublicIp') is not None:
            self.with_public_ip = m.get('WithPublicIp')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DecreaseNodeGroupParam(TeaModel):
    def __init__(
        self,
        node_group_id: str = None,
        release_instance_ids: List[str] = None,
    ):
        # This parameter is required.
        self.node_group_id = node_group_id
        # This parameter is required.
        self.release_instance_ids = release_instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.release_instance_ids is not None:
            result['ReleaseInstanceIds'] = self.release_instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('ReleaseInstanceIds') is not None:
            self.release_instance_ids = m.get('ReleaseInstanceIds')
        return self


class DeploymentLayout(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        component_name: str = None,
        node_selector: NodeSelector = None,
    ):
        self.application_name = application_name
        self.component_name = component_name
        self.node_selector = node_selector

    def validate(self):
        if self.node_selector:
            self.node_selector.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.node_selector is not None:
            result['NodeSelector'] = self.node_selector.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('NodeSelector') is not None:
            temp_model = NodeSelector()
            self.node_selector = temp_model.from_map(m['NodeSelector'])
        return self


class InstanceCategory(TeaModel):
    def __init__(
        self,
        default_value: str = None,
        keys: List[str] = None,
        values: List[str] = None,
    ):
        # 默认值。
        self.default_value = default_value
        self.keys = keys
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.keys is not None:
            result['Keys'] = self.keys
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Keys') is not None:
            self.keys = m.get('Keys')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class ReplacementStrategy(TeaModel):
    def __init__(
        self,
        instance_categories: List[InstanceCategory] = None,
    ):
        self.instance_categories = instance_categories

    def validate(self):
        if self.instance_categories:
            for k in self.instance_categories:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceCategories'] = []
        if self.instance_categories is not None:
            for k in self.instance_categories:
                result['InstanceCategories'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_categories = []
        if m.get('InstanceCategories') is not None:
            for k in m.get('InstanceCategories'):
                temp_model = InstanceCategory()
                self.instance_categories.append(temp_model.from_map(k))
        return self


class DeploymentSetConstraints(TeaModel):
    def __init__(
        self,
        default_value: str = None,
        enable_state: str = None,
        replacement_strategy: ReplacementStrategy = None,
        values: List[str] = None,
    ):
        # 默认值。
        self.default_value = default_value
        self.enable_state = enable_state
        # 替换策略。
        self.replacement_strategy = replacement_strategy
        # 枚举值。
        self.values = values

    def validate(self):
        if self.replacement_strategy:
            self.replacement_strategy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.enable_state is not None:
            result['EnableState'] = self.enable_state
        if self.replacement_strategy is not None:
            result['ReplacementStrategy'] = self.replacement_strategy.to_map()
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('EnableState') is not None:
            self.enable_state = m.get('EnableState')
        if m.get('ReplacementStrategy') is not None:
            temp_model = ReplacementStrategy()
            self.replacement_strategy = temp_model.from_map(m['ReplacementStrategy'])
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class Disk(TeaModel):
    def __init__(
        self,
        category: str = None,
        count: int = None,
        performance_level: str = None,
        size: int = None,
    ):
        # 磁盘类型。
        self.category = category
        # 每个节点磁盘数量。
        self.count = count
        # 性能级别。
        self.performance_level = performance_level
        # 单位GB。
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.count is not None:
            result['Count'] = self.count
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ValueConstraints(TeaModel):
    def __init__(
        self,
        default_value: int = None,
        end: int = None,
        start: int = None,
        step: int = None,
        type: str = None,
        values: List[int] = None,
    ):
        # 默认值。
        self.default_value = default_value
        # 结束值。
        self.end = end
        # 起始值。
        self.start = start
        # 步长。
        self.step = step
        # 值限制类型。
        self.type = type
        # 枚举值。
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.end is not None:
            result['End'] = self.end
        if self.start is not None:
            result['Start'] = self.start
        if self.step is not None:
            result['Step'] = self.step
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DiskConstraints(TeaModel):
    def __init__(
        self,
        categories: List[str] = None,
        count_constraint: ValueConstraints = None,
        size_constraint: ValueConstraints = None,
    ):
        # 支持的磁盘类型。
        self.categories = categories
        # 磁盘数量最小值。
        self.count_constraint = count_constraint
        # 磁盘容量限制。
        self.size_constraint = size_constraint

    def validate(self):
        if self.count_constraint:
            self.count_constraint.validate()
        if self.size_constraint:
            self.size_constraint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories is not None:
            result['Categories'] = self.categories
        if self.count_constraint is not None:
            result['CountConstraint'] = self.count_constraint.to_map()
        if self.size_constraint is not None:
            result['SizeConstraint'] = self.size_constraint.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        if m.get('CountConstraint') is not None:
            temp_model = ValueConstraints()
            self.count_constraint = temp_model.from_map(m['CountConstraint'])
        if m.get('SizeConstraint') is not None:
            temp_model = ValueConstraints()
            self.size_constraint = temp_model.from_map(m['SizeConstraint'])
        return self


class DiskSize(TeaModel):
    def __init__(
        self,
        category: str = None,
        size: int = None,
    ):
        # 磁盘类型。
        # 
        # This parameter is required.
        self.category = category
        # 单位GB。
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class FailedReason(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
    ):
        # 错误码。
        self.error_code = error_code
        # 错误信息。
        self.error_message = error_message
        # 请求ID。
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class HealthSummary(TeaModel):
    def __init__(
        self,
        bad_count: int = None,
        good_count: int = None,
        none_count: int = None,
        stopped_count: int = None,
        total_count: int = None,
        unknown_count: int = None,
        warning_count: int = None,
    ):
        self.bad_count = bad_count
        self.good_count = good_count
        self.none_count = none_count
        self.stopped_count = stopped_count
        self.total_count = total_count
        self.unknown_count = unknown_count
        self.warning_count = warning_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bad_count is not None:
            result['BadCount'] = self.bad_count
        if self.good_count is not None:
            result['GoodCount'] = self.good_count
        if self.none_count is not None:
            result['NoneCount'] = self.none_count
        if self.stopped_count is not None:
            result['StoppedCount'] = self.stopped_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.unknown_count is not None:
            result['UnknownCount'] = self.unknown_count
        if self.warning_count is not None:
            result['WarningCount'] = self.warning_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BadCount') is not None:
            self.bad_count = m.get('BadCount')
        if m.get('GoodCount') is not None:
            self.good_count = m.get('GoodCount')
        if m.get('NoneCount') is not None:
            self.none_count = m.get('NoneCount')
        if m.get('StoppedCount') is not None:
            self.stopped_count = m.get('StoppedCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UnknownCount') is not None:
            self.unknown_count = m.get('UnknownCount')
        if m.get('WarningCount') is not None:
            self.warning_count = m.get('WarningCount')
        return self


class IncreaseNodeGroup(TeaModel):
    def __init__(
        self,
        description: str = None,
        node_count: int = None,
        node_group_id: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        v_switch_id: str = None,
    ):
        # 描述。
        self.description = description
        # 节点数量。
        # 
        # This parameter is required.
        self.node_count = node_count
        # 节点组ID。
        # 
        # This parameter is required.
        self.node_group_id = node_group_id
        # 付费时长。
        self.payment_duration = payment_duration
        # 付费时长单位。
        self.payment_duration_unit = payment_duration_unit
        # 虚拟机交换机ID。
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.node_count is not None:
            result['NodeCount'] = self.node_count
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NodeCount') is not None:
            self.node_count = m.get('NodeCount')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class IncreaseNodeGroupParam(TeaModel):
    def __init__(
        self,
        node_count: int = None,
        node_group_id: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        v_switch_id: str = None,
    ):
        self.node_count = node_count
        self.node_group_id = node_group_id
        self.payment_duration = payment_duration
        self.payment_duration_unit = payment_duration_unit
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_count is not None:
            result['NodeCount'] = self.node_count
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeCount') is not None:
            self.node_count = m.get('NodeCount')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class InstanceType(TeaModel):
    def __init__(
        self,
        cpu_architecture: str = None,
        cpu_core: int = None,
        instance_category: str = None,
        instance_type: str = None,
        instance_type_family: str = None,
        local_storage_amount: int = None,
        local_storage_capacity: int = None,
        optimized: bool = None,
    ):
        # cpu架构。
        self.cpu_architecture = cpu_architecture
        # vCPU内核数目。
        self.cpu_core = cpu_core
        # 实例规格分类。取值范围：
        # - General-purpose： 通用型。
        # - Compute-optimized：计算型。
        # - Memory-optimized：内存型。
        # - Big data：大数据型。
        # - Local SSDs ：本地SSD型。
        # - High Clock Speed ：高主频型。
        # - Enhanced ：增强型。
        # - Shared：共享型。
        # - Compute-optimized with GPU ：GPU计算型。
        # - Visual Compute-optimized ：视觉计算型。
        # - Heterogeneous Service ：异构服务型。
        # - Compute-optimized with FPGA ：FPGA计算型。
        # - Compute-optimized with NPU ：NPU计算型。
        # - ECS Bare Metal ：弹性裸金属服务器。
        # - Super Computing Cluster：超级计算集群。
        self.instance_category = instance_category
        # 实例规格。
        self.instance_type = instance_type
        # 实例规格所属的实例规格族。取值请参见DescribeInstanceTypeFamilies。
        self.instance_type_family = instance_type_family
        # 实例挂载的本地盘的数量。
        self.local_storage_amount = local_storage_amount
        # 实例挂载的本地盘的单盘容量。单位：GiB
        self.local_storage_capacity = local_storage_capacity
        # 是否IO优化类型。
        self.optimized = optimized

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_architecture is not None:
            result['CpuArchitecture'] = self.cpu_architecture
        if self.cpu_core is not None:
            result['CpuCore'] = self.cpu_core
        if self.instance_category is not None:
            result['InstanceCategory'] = self.instance_category
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.local_storage_amount is not None:
            result['LocalStorageAmount'] = self.local_storage_amount
        if self.local_storage_capacity is not None:
            result['LocalStorageCapacity'] = self.local_storage_capacity
        if self.optimized is not None:
            result['Optimized'] = self.optimized
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CpuArchitecture') is not None:
            self.cpu_architecture = m.get('CpuArchitecture')
        if m.get('CpuCore') is not None:
            self.cpu_core = m.get('CpuCore')
        if m.get('InstanceCategory') is not None:
            self.instance_category = m.get('InstanceCategory')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('LocalStorageAmount') is not None:
            self.local_storage_amount = m.get('LocalStorageAmount')
        if m.get('LocalStorageCapacity') is not None:
            self.local_storage_capacity = m.get('LocalStorageCapacity')
        if m.get('Optimized') is not None:
            self.optimized = m.get('Optimized')
        return self


class IntegerMetric(TeaModel):
    def __init__(
        self,
        unit: str = None,
        value: int = None,
    ):
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class KeyValue(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # 键。
        self.key = key
        # 值。
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListApiTemplatesDTO(TeaModel):
    def __init__(
        self,
        api_name: str = None,
        content: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        operator_id: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        status: str = None,
        template_id: str = None,
        template_name: str = None,
        user_id: str = None,
    ):
        self.api_name = api_name
        self.content = content
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.operator_id = operator_id
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.status = status
        self.template_id = template_id
        self.template_name = template_name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_name is not None:
            result['ApiName'] = self.api_name
        if self.content is not None:
            result['Content'] = self.content
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.operator_id is not None:
            result['OperatorId'] = self.operator_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiName') is not None:
            self.api_name = m.get('ApiName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('OperatorId') is not None:
            self.operator_id = m.get('OperatorId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ManagedScalingConstraints(TeaModel):
    def __init__(
        self,
        max_capacity: int = None,
        max_on_demand_capacity: int = None,
        min_capacity: int = None,
    ):
        # 最大值。
        self.max_capacity = max_capacity
        # 最大按量节点数量
        self.max_on_demand_capacity = max_on_demand_capacity
        # 最小值。
        self.min_capacity = min_capacity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity is not None:
            result['MaxCapacity'] = self.max_capacity
        if self.max_on_demand_capacity is not None:
            result['MaxOnDemandCapacity'] = self.max_on_demand_capacity
        if self.min_capacity is not None:
            result['MinCapacity'] = self.min_capacity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxCapacity') is not None:
            self.max_capacity = m.get('MaxCapacity')
        if m.get('MaxOnDemandCapacity') is not None:
            self.max_on_demand_capacity = m.get('MaxOnDemandCapacity')
        if m.get('MinCapacity') is not None:
            self.min_capacity = m.get('MinCapacity')
        return self


class MetaStoreConf(TeaModel):
    def __init__(
        self,
        db_password: str = None,
        db_url: str = None,
        db_user_name: str = None,
    ):
        self.db_password = db_password
        self.db_url = db_url
        self.db_user_name = db_user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_password is not None:
            result['DbPassword'] = self.db_password
        if self.db_url is not None:
            result['DbUrl'] = self.db_url
        if self.db_user_name is not None:
            result['DbUserName'] = self.db_user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbPassword') is not None:
            self.db_password = m.get('DbPassword')
        if m.get('DbUrl') is not None:
            self.db_url = m.get('DbUrl')
        if m.get('DbUserName') is not None:
            self.db_user_name = m.get('DbUserName')
        return self


class Node(TeaModel):
    def __init__(
        self,
        auto_renew: bool = None,
        auto_renew_duration: int = None,
        auto_renew_duration_unit: str = None,
        create_time: int = None,
        expire_time: int = None,
        instance_type: str = None,
        maintenance_status: str = None,
        node_group_id: str = None,
        node_group_type: str = None,
        node_id: str = None,
        node_name: str = None,
        node_state: str = None,
        private_ip: str = None,
        public_ip: str = None,
        zone_id: str = None,
    ):
        # 节点是否自动续费。
        self.auto_renew = auto_renew
        # 节点自动续费时长。
        self.auto_renew_duration = auto_renew_duration
        # 节点自动续费时长单位。
        self.auto_renew_duration_unit = auto_renew_duration_unit
        self.create_time = create_time
        # 节点过期时间。
        self.expire_time = expire_time
        # 实例类型。
        self.instance_type = instance_type
        # 运维模式状态。取值范围：
        # - ON：处于运维模式。
        # - OFF：处于非运维模式。
        # 
        # 为空表示处于非运维模式。
        self.maintenance_status = maintenance_status
        # 节点组ID。
        self.node_group_id = node_group_id
        # 节点组类型。
        self.node_group_type = node_group_type
        # 节点ID。
        self.node_id = node_id
        # 节点名称。
        self.node_name = node_name
        # 节点状态。取值范围：
        # - Pending：创建中。
        # - Starting：启动中。
        # - Running：运行中。
        # - Stopping：停止中。
        # - Stopped：已停止。
        # - Terminated：已终止。
        self.node_state = node_state
        # 私网IP。
        self.private_ip = private_ip
        # 公网IP。
        self.public_ip = public_ip
        # 可用区ID。
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_duration is not None:
            result['AutoRenewDuration'] = self.auto_renew_duration
        if self.auto_renew_duration_unit is not None:
            result['AutoRenewDurationUnit'] = self.auto_renew_duration_unit
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.maintenance_status is not None:
            result['MaintenanceStatus'] = self.maintenance_status
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_type is not None:
            result['NodeGroupType'] = self.node_group_type
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_state is not None:
            result['NodeState'] = self.node_state
        if self.private_ip is not None:
            result['PrivateIp'] = self.private_ip
        if self.public_ip is not None:
            result['PublicIp'] = self.public_ip
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewDuration') is not None:
            self.auto_renew_duration = m.get('AutoRenewDuration')
        if m.get('AutoRenewDurationUnit') is not None:
            self.auto_renew_duration_unit = m.get('AutoRenewDurationUnit')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MaintenanceStatus') is not None:
            self.maintenance_status = m.get('MaintenanceStatus')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupType') is not None:
            self.node_group_type = m.get('NodeGroupType')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeState') is not None:
            self.node_state = m.get('NodeState')
        if m.get('PrivateIp') is not None:
            self.private_ip = m.get('PrivateIp')
        if m.get('PublicIp') is not None:
            self.public_ip = m.get('PublicIp')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class NodeCountConstraint(TeaModel):
    def __init__(
        self,
        max: int = None,
        min: int = None,
        type: str = None,
        values: List[int] = None,
    ):
        self.max = max
        self.min = min
        # This parameter is required.
        self.type = type
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class PrivatePoolOptions(TeaModel):
    def __init__(
        self,
        match_criteria: str = None,
        private_pool_ids: List[str] = None,
    ):
        self.match_criteria = match_criteria
        self.private_pool_ids = private_pool_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.match_criteria is not None:
            result['MatchCriteria'] = self.match_criteria
        if self.private_pool_ids is not None:
            result['PrivatePoolIds'] = self.private_pool_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MatchCriteria') is not None:
            self.match_criteria = m.get('MatchCriteria')
        if m.get('PrivatePoolIds') is not None:
            self.private_pool_ids = m.get('PrivatePoolIds')
        return self


class SpotBidPrice(TeaModel):
    def __init__(
        self,
        bid_price: float = None,
        instance_type: str = None,
    ):
        # 实例的每小时最高出价。支持最大3位小数，参数SpotStrategy=SpotWithPriceLimit时，该参数生效。
        self.bid_price = bid_price
        # 实例类型。
        self.instance_type = instance_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bid_price is not None:
            result['BidPrice'] = self.bid_price
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BidPrice') is not None:
            self.bid_price = m.get('BidPrice')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        return self


class NodeGroupStateChangeReason(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
    ):
        # 状态码。
        self.code = code
        # 描述信息。
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class NodeGroup(TeaModel):
    def __init__(
        self,
        additional_security_group_ids: List[str] = None,
        compensate_with_on_demand: bool = None,
        cost_optimized_config: CostOptimizedConfig = None,
        data_disks: List[DataDisk] = None,
        deployment_set_strategy: str = None,
        graceful_shutdown: bool = None,
        instance_types: List[str] = None,
        node_group_id: str = None,
        node_group_name: str = None,
        node_group_state: str = None,
        node_group_type: str = None,
        node_resize_strategy: str = None,
        payment_type: str = None,
        private_pool_options: PrivatePoolOptions = None,
        running_node_count: int = None,
        spot_bid_prices: List[SpotBidPrice] = None,
        spot_instance_remedy: bool = None,
        spot_strategy: str = None,
        state_change_reason: NodeGroupStateChangeReason = None,
        status: str = None,
        system_disk: SystemDisk = None,
        v_switch_ids: List[str] = None,
        with_public_ip: bool = None,
        zone_id: str = None,
    ):
        # 安全组ID。
        self.additional_security_group_ids = additional_security_group_ids
        self.compensate_with_on_demand = compensate_with_on_demand
        # 成本优化模式配置。
        self.cost_optimized_config = cost_optimized_config
        # 数据盘列表。
        self.data_disks = data_disks
        # 部署集策略。取值范围：
        # - NONE：不适用部署集。
        # - CLUSTER：使用集群级别部署集。
        # - NODE_GROUP：使用节点组级别部署集。
        # 
        # 默认值：NONE。
        self.deployment_set_strategy = deployment_set_strategy
        # 节点组上部署的组件是否开启优雅下线。取值范围：
        # - true：开启优雅下线。
        # - false：不开启优雅下线。
        self.graceful_shutdown = graceful_shutdown
        # 实例类型列表。
        self.instance_types = instance_types
        # 节点组ID。
        self.node_group_id = node_group_id
        # 节点组名称。最大长度128个字符。
        self.node_group_name = node_group_name
        # 节点组状态。
        self.node_group_state = node_group_state
        # 节点组类型。取值范围：
        # - MASTER：管理类型节点组。
        # - CORE：存储类型节点组。
        # - TASK：计算类型节点组。
        self.node_group_type = node_group_type
        # - COST_OPTIMIZED：成本优化策略。
        # - PRIORITY：优先级策略。
        self.node_resize_strategy = node_resize_strategy
        # 节点组付费类型。取值范围：
        # - PayAsYouGo：后付费，按量付费。
        # - Subscription：预付费，包年包月。
        self.payment_type = payment_type
        self.private_pool_options = private_pool_options
        # 存活节点数量。
        self.running_node_count = running_node_count
        self.spot_bid_prices = spot_bid_prices
        # 开启补齐抢占式实例后，当收到抢占式实例将被回收的系统消息时，伸缩组将尝试创建新的实例，替换掉将被回收的抢占式实例。取值范围：
        # - true：开启补齐抢占式实例。
        # - false：不开启补齐抢占式实例。
        # 
        # 默认值：false。
        self.spot_instance_remedy = spot_instance_remedy
        # 是否支持竞价实例。
        self.spot_strategy = spot_strategy
        # 状态变化原因。
        self.state_change_reason = state_change_reason
        self.status = status
        # 系统盘信息。
        self.system_disk = system_disk
        # 虚拟机交换机ID列表。
        self.v_switch_ids = v_switch_ids
        # 是否开公网IP。取值范围：
        # - true：开公网。
        # - false：不开公网。
        self.with_public_ip = with_public_ip
        # 可用区ID。
        self.zone_id = zone_id

    def validate(self):
        if self.cost_optimized_config:
            self.cost_optimized_config.validate()
        if self.data_disks:
            for k in self.data_disks:
                if k:
                    k.validate()
        if self.private_pool_options:
            self.private_pool_options.validate()
        if self.spot_bid_prices:
            for k in self.spot_bid_prices:
                if k:
                    k.validate()
        if self.state_change_reason:
            self.state_change_reason.validate()
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_security_group_ids is not None:
            result['AdditionalSecurityGroupIds'] = self.additional_security_group_ids
        if self.compensate_with_on_demand is not None:
            result['CompensateWithOnDemand'] = self.compensate_with_on_demand
        if self.cost_optimized_config is not None:
            result['CostOptimizedConfig'] = self.cost_optimized_config.to_map()
        result['DataDisks'] = []
        if self.data_disks is not None:
            for k in self.data_disks:
                result['DataDisks'].append(k.to_map() if k else None)
        if self.deployment_set_strategy is not None:
            result['DeploymentSetStrategy'] = self.deployment_set_strategy
        if self.graceful_shutdown is not None:
            result['GracefulShutdown'] = self.graceful_shutdown
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.node_group_state is not None:
            result['NodeGroupState'] = self.node_group_state
        if self.node_group_type is not None:
            result['NodeGroupType'] = self.node_group_type
        if self.node_resize_strategy is not None:
            result['NodeResizeStrategy'] = self.node_resize_strategy
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.running_node_count is not None:
            result['RunningNodeCount'] = self.running_node_count
        result['SpotBidPrices'] = []
        if self.spot_bid_prices is not None:
            for k in self.spot_bid_prices:
                result['SpotBidPrices'].append(k.to_map() if k else None)
        if self.spot_instance_remedy is not None:
            result['SpotInstanceRemedy'] = self.spot_instance_remedy
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.state_change_reason is not None:
            result['StateChangeReason'] = self.state_change_reason.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.with_public_ip is not None:
            result['WithPublicIp'] = self.with_public_ip
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdditionalSecurityGroupIds') is not None:
            self.additional_security_group_ids = m.get('AdditionalSecurityGroupIds')
        if m.get('CompensateWithOnDemand') is not None:
            self.compensate_with_on_demand = m.get('CompensateWithOnDemand')
        if m.get('CostOptimizedConfig') is not None:
            temp_model = CostOptimizedConfig()
            self.cost_optimized_config = temp_model.from_map(m['CostOptimizedConfig'])
        self.data_disks = []
        if m.get('DataDisks') is not None:
            for k in m.get('DataDisks'):
                temp_model = DataDisk()
                self.data_disks.append(temp_model.from_map(k))
        if m.get('DeploymentSetStrategy') is not None:
            self.deployment_set_strategy = m.get('DeploymentSetStrategy')
        if m.get('GracefulShutdown') is not None:
            self.graceful_shutdown = m.get('GracefulShutdown')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('NodeGroupState') is not None:
            self.node_group_state = m.get('NodeGroupState')
        if m.get('NodeGroupType') is not None:
            self.node_group_type = m.get('NodeGroupType')
        if m.get('NodeResizeStrategy') is not None:
            self.node_resize_strategy = m.get('NodeResizeStrategy')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('PrivatePoolOptions') is not None:
            temp_model = PrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('RunningNodeCount') is not None:
            self.running_node_count = m.get('RunningNodeCount')
        self.spot_bid_prices = []
        if m.get('SpotBidPrices') is not None:
            for k in m.get('SpotBidPrices'):
                temp_model = SpotBidPrice()
                self.spot_bid_prices.append(temp_model.from_map(k))
        if m.get('SpotInstanceRemedy') is not None:
            self.spot_instance_remedy = m.get('SpotInstanceRemedy')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('StateChangeReason') is not None:
            temp_model = NodeGroupStateChangeReason()
            self.state_change_reason = temp_model.from_map(m['StateChangeReason'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SystemDisk') is not None:
            temp_model = SystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('WithPublicIp') is not None:
            self.with_public_ip = m.get('WithPublicIp')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class NodeGroupConfig(TeaModel):
    def __init__(
        self,
        additional_security_group_ids: List[str] = None,
        auto_scaling_policy: AutoScalingPolicy = None,
        compensate_with_on_demand: bool = None,
        component_tags: List[str] = None,
        cost_optimized_config: CostOptimizedConfig = None,
        data_disks: List[DataDisk] = None,
        deployment_set_strategy: str = None,
        graceful_shutdown: bool = None,
        instance_types: List[str] = None,
        node_count: int = None,
        node_group_name: str = None,
        node_group_type: str = None,
        node_resize_strategy: str = None,
        payment_type: str = None,
        private_pool_options: PrivatePoolOptions = None,
        spot_bid_prices: List[SpotBidPrice] = None,
        spot_instance_remedy: bool = None,
        spot_strategy: str = None,
        subscription_config: SubscriptionConfig = None,
        system_disk: SystemDisk = None,
        v_switch_ids: List[str] = None,
        with_public_ip: bool = None,
    ):
        # 附加安全组。除集群设置的安全组外，为节点组单独设置的附加安全组。数组元数个数N的取值范围：0~2。
        self.additional_security_group_ids = additional_security_group_ids
        self.auto_scaling_policy = auto_scaling_policy
        self.compensate_with_on_demand = compensate_with_on_demand
        self.component_tags = component_tags
        # 成本优化模式配置。
        self.cost_optimized_config = cost_optimized_config
        # 数据盘。当前数据盘只支持一种磁盘类型，即数组元数个数N的取值范围：1~1。
        self.data_disks = data_disks
        # 部署集策略。取值范围：
        # - NONE：不适用部署集。
        # - CLUSTER：使用集群级别部署集。
        # - NODE_GROUP：使用节点组级别部署集。
        # 
        # 默认值：NONE。
        self.deployment_set_strategy = deployment_set_strategy
        # 节点组上部署的组件是否开启优雅下线。取值范围：
        # - true：开启优雅下线。
        # - false：不开启优雅下线。
        # 
        # 默认值：false。
        self.graceful_shutdown = graceful_shutdown
        # 节点实例类型列表。数组元数个数N的取值范围：1~100。
        self.instance_types = instance_types
        # 节点数量。取值范围：1~1000。
        self.node_count = node_count
        # 节点组名称。最大长度128个字符。集群内要求节点组名称唯一。
        self.node_group_name = node_group_name
        # 节点组类型。取值范围：
        # - MASTER：管理类型节点组。
        # - CORE：存储类型节点组。
        # - TASK：计算类型节点组。
        # 
        # This parameter is required.
        self.node_group_type = node_group_type
        # 节点扩容策略。取值范围：
        # - COST_OPTIMIZED：成本优化策略。
        # - PRIORITY：优先级策略。
        # 
        # 默认值：PRIORITY。
        self.node_resize_strategy = node_resize_strategy
        # 节点组付费类型。不传入时默认和集群付费类型一致。取值范围：
        # - PayAsYouGo：后付费，按量付费。
        # - Subscription：预付费，包年包月。
        # 
        # 默认值：PayAsYouGo。
        self.payment_type = payment_type
        self.private_pool_options = private_pool_options
        # 抢占式Spot实例出价价格。参数SpotStrategy取值为SpotWithPriceLimit时生效。数组元数个数N的取值范围：0~100。
        self.spot_bid_prices = spot_bid_prices
        # 开启后，当收到抢占式实例将被回收的系统消息时，伸缩组将尝试创建新的实例，替换掉将被回收的抢占式实例。取值范围：
        # - true：开启补齐抢占式实例。
        # - false：不开启补齐抢占式实例。
        # 
        # 默认值：false。
        self.spot_instance_remedy = spot_instance_remedy
        # 抢占式Spot实例策略。取值范围：
        # - NoSpot：正常按量付费实例。
        # - SpotWithPriceLimit：设置最高出价的抢占式实例。
        # - SpotAsPriceGo：系统自动出价，最高按量付费价格的抢占式实例。
        # 
        # 默认值：NoSpot。
        self.spot_strategy = spot_strategy
        # 节点组预付费配置。不传入时默认和集群预付费配置一致。
        self.subscription_config = subscription_config
        # 系统盘。
        self.system_disk = system_disk
        # 虚拟机交换机ID列表。数组元数个数N的取值范围：1~20。
        self.v_switch_ids = v_switch_ids
        # 是否开公网IP。取值范围：
        # - true：开公网。
        # - false：不开公网。
        # 
        # 默认值：false。
        self.with_public_ip = with_public_ip

    def validate(self):
        if self.auto_scaling_policy:
            self.auto_scaling_policy.validate()
        if self.cost_optimized_config:
            self.cost_optimized_config.validate()
        if self.data_disks:
            for k in self.data_disks:
                if k:
                    k.validate()
        if self.private_pool_options:
            self.private_pool_options.validate()
        if self.spot_bid_prices:
            for k in self.spot_bid_prices:
                if k:
                    k.validate()
        if self.subscription_config:
            self.subscription_config.validate()
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_security_group_ids is not None:
            result['AdditionalSecurityGroupIds'] = self.additional_security_group_ids
        if self.auto_scaling_policy is not None:
            result['AutoScalingPolicy'] = self.auto_scaling_policy.to_map()
        if self.compensate_with_on_demand is not None:
            result['CompensateWithOnDemand'] = self.compensate_with_on_demand
        if self.component_tags is not None:
            result['ComponentTags'] = self.component_tags
        if self.cost_optimized_config is not None:
            result['CostOptimizedConfig'] = self.cost_optimized_config.to_map()
        result['DataDisks'] = []
        if self.data_disks is not None:
            for k in self.data_disks:
                result['DataDisks'].append(k.to_map() if k else None)
        if self.deployment_set_strategy is not None:
            result['DeploymentSetStrategy'] = self.deployment_set_strategy
        if self.graceful_shutdown is not None:
            result['GracefulShutdown'] = self.graceful_shutdown
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.node_count is not None:
            result['NodeCount'] = self.node_count
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.node_group_type is not None:
            result['NodeGroupType'] = self.node_group_type
        if self.node_resize_strategy is not None:
            result['NodeResizeStrategy'] = self.node_resize_strategy
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        result['SpotBidPrices'] = []
        if self.spot_bid_prices is not None:
            for k in self.spot_bid_prices:
                result['SpotBidPrices'].append(k.to_map() if k else None)
        if self.spot_instance_remedy is not None:
            result['SpotInstanceRemedy'] = self.spot_instance_remedy
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.subscription_config is not None:
            result['SubscriptionConfig'] = self.subscription_config.to_map()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.with_public_ip is not None:
            result['WithPublicIp'] = self.with_public_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdditionalSecurityGroupIds') is not None:
            self.additional_security_group_ids = m.get('AdditionalSecurityGroupIds')
        if m.get('AutoScalingPolicy') is not None:
            temp_model = AutoScalingPolicy()
            self.auto_scaling_policy = temp_model.from_map(m['AutoScalingPolicy'])
        if m.get('CompensateWithOnDemand') is not None:
            self.compensate_with_on_demand = m.get('CompensateWithOnDemand')
        if m.get('ComponentTags') is not None:
            self.component_tags = m.get('ComponentTags')
        if m.get('CostOptimizedConfig') is not None:
            temp_model = CostOptimizedConfig()
            self.cost_optimized_config = temp_model.from_map(m['CostOptimizedConfig'])
        self.data_disks = []
        if m.get('DataDisks') is not None:
            for k in m.get('DataDisks'):
                temp_model = DataDisk()
                self.data_disks.append(temp_model.from_map(k))
        if m.get('DeploymentSetStrategy') is not None:
            self.deployment_set_strategy = m.get('DeploymentSetStrategy')
        if m.get('GracefulShutdown') is not None:
            self.graceful_shutdown = m.get('GracefulShutdown')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('NodeCount') is not None:
            self.node_count = m.get('NodeCount')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('NodeGroupType') is not None:
            self.node_group_type = m.get('NodeGroupType')
        if m.get('NodeResizeStrategy') is not None:
            self.node_resize_strategy = m.get('NodeResizeStrategy')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('PrivatePoolOptions') is not None:
            temp_model = PrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        self.spot_bid_prices = []
        if m.get('SpotBidPrices') is not None:
            for k in m.get('SpotBidPrices'):
                temp_model = SpotBidPrice()
                self.spot_bid_prices.append(temp_model.from_map(k))
        if m.get('SpotInstanceRemedy') is not None:
            self.spot_instance_remedy = m.get('SpotInstanceRemedy')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('SubscriptionConfig') is not None:
            temp_model = SubscriptionConfig()
            self.subscription_config = temp_model.from_map(m['SubscriptionConfig'])
        if m.get('SystemDisk') is not None:
            temp_model = SystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('WithPublicIp') is not None:
            self.with_public_ip = m.get('WithPublicIp')
        return self


class NodeGroupParam(TeaModel):
    def __init__(
        self,
        auto_pay_order: bool = None,
        auto_renew: bool = None,
        auto_renew_duration: int = None,
        auto_renew_duration_unit: str = None,
        data_disks: List[DiskInfo] = None,
        description: str = None,
        instance_types: List[str] = None,
        node_count: int = None,
        node_group_index: int = None,
        node_group_name: str = None,
        node_group_type: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        payment_type: str = None,
        system_disk: SystemDiskParam = None,
        v_switch_ids: List[str] = None,
        zone_id: str = None,
    ):
        self.auto_pay_order = auto_pay_order
        self.auto_renew = auto_renew
        self.auto_renew_duration = auto_renew_duration
        self.auto_renew_duration_unit = auto_renew_duration_unit
        self.data_disks = data_disks
        self.description = description
        self.instance_types = instance_types
        self.node_count = node_count
        self.node_group_index = node_group_index
        self.node_group_name = node_group_name
        self.node_group_type = node_group_type
        self.payment_duration = payment_duration
        self.payment_duration_unit = payment_duration_unit
        self.payment_type = payment_type
        self.system_disk = system_disk
        self.v_switch_ids = v_switch_ids
        self.zone_id = zone_id

    def validate(self):
        if self.data_disks:
            for k in self.data_disks:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay_order is not None:
            result['AutoPayOrder'] = self.auto_pay_order
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_duration is not None:
            result['AutoRenewDuration'] = self.auto_renew_duration
        if self.auto_renew_duration_unit is not None:
            result['AutoRenewDurationUnit'] = self.auto_renew_duration_unit
        result['DataDisks'] = []
        if self.data_disks is not None:
            for k in self.data_disks:
                result['DataDisks'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.node_count is not None:
            result['NodeCount'] = self.node_count
        if self.node_group_index is not None:
            result['NodeGroupIndex'] = self.node_group_index
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.node_group_type is not None:
            result['NodeGroupType'] = self.node_group_type
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoPayOrder') is not None:
            self.auto_pay_order = m.get('AutoPayOrder')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewDuration') is not None:
            self.auto_renew_duration = m.get('AutoRenewDuration')
        if m.get('AutoRenewDurationUnit') is not None:
            self.auto_renew_duration_unit = m.get('AutoRenewDurationUnit')
        self.data_disks = []
        if m.get('DataDisks') is not None:
            for k in m.get('DataDisks'):
                temp_model = DiskInfo()
                self.data_disks.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('NodeCount') is not None:
            self.node_count = m.get('NodeCount')
        if m.get('NodeGroupIndex') is not None:
            self.node_group_index = m.get('NodeGroupIndex')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('NodeGroupType') is not None:
            self.node_group_type = m.get('NodeGroupType')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('SystemDisk') is not None:
            temp_model = SystemDiskParam()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class OSUser(TeaModel):
    def __init__(
        self,
        group: str = None,
        password: str = None,
        user: str = None,
    ):
        # 用户组。
        self.group = group
        # 用户密码。
        self.password = password
        # 用户名称。
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['Group'] = self.group
        if self.password is not None:
            result['Password'] = self.password
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class OnKubeClusterResource(TeaModel):
    def __init__(
        self,
        cpu: str = None,
        memory: str = None,
    ):
        self.cpu = cpu
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class OperationStateChangeReason(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
    ):
        # 状态码。
        self.code = code
        # 状态变化信息。
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class Operation(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        create_time: int = None,
        description: str = None,
        end_time: int = None,
        operation_id: str = None,
        operation_state: str = None,
        operation_type: str = None,
        start_time: int = None,
        state_change_reason: OperationStateChangeReason = None,
    ):
        # 集群ID。
        self.cluster_id = cluster_id
        # 创建时间。
        self.create_time = create_time
        # 描述。
        self.description = description
        # 结束时间。
        self.end_time = end_time
        # 操作ID。
        self.operation_id = operation_id
        # 操作状态。
        self.operation_state = operation_state
        # 操作类型。
        self.operation_type = operation_type
        # 开始时间。
        self.start_time = start_time
        # 状态转换原因。
        self.state_change_reason = state_change_reason

    def validate(self):
        if self.state_change_reason:
            self.state_change_reason.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.operation_state is not None:
            result['OperationState'] = self.operation_state
        if self.operation_type is not None:
            result['OperationType'] = self.operation_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state_change_reason is not None:
            result['StateChangeReason'] = self.state_change_reason.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('OperationState') is not None:
            self.operation_state = m.get('OperationState')
        if m.get('OperationType') is not None:
            self.operation_type = m.get('OperationType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StateChangeReason') is not None:
            temp_model = OperationStateChangeReason()
            self.state_change_reason = temp_model.from_map(m['StateChangeReason'])
        return self


class OperationData(TeaModel):
    def __init__(
        self,
        actual_delivered_amounts: int = None,
        to_be_delivered_amounts: int = None,
    ):
        self.actual_delivered_amounts = actual_delivered_amounts
        self.to_be_delivered_amounts = to_be_delivered_amounts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_delivered_amounts is not None:
            result['actualDeliveredAmounts'] = self.actual_delivered_amounts
        if self.to_be_delivered_amounts is not None:
            result['toBeDeliveredAmounts'] = self.to_be_delivered_amounts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actualDeliveredAmounts') is not None:
            self.actual_delivered_amounts = m.get('actualDeliveredAmounts')
        if m.get('toBeDeliveredAmounts') is not None:
            self.to_be_delivered_amounts = m.get('toBeDeliveredAmounts')
        return self


class Order(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        order_id: str = None,
    ):
        self.create_time = create_time
        self.order_id = order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        return self


class Page(TeaModel):
    def __init__(
        self,
        items: List[str] = None,
        max_results: int = None,
        next_token: str = None,
        total_count: int = None,
    ):
        self.items = items
        self.max_results = max_results
        self.next_token = next_token
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.items is not None:
            result['Items'] = self.items
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class Pod(TeaModel):
    def __init__(
        self,
        message: str = None,
        pod_name: str = None,
        pod_status: str = None,
        reason: str = None,
    ):
        self.message = message
        self.pod_name = pod_name
        self.pod_status = pod_status
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        if self.pod_status is not None:
            result['PodStatus'] = self.pod_status
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        if m.get('PodStatus') is not None:
            self.pod_status = m.get('PodStatus')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class PromotionInfo(TeaModel):
    def __init__(
        self,
        can_prom_fee: str = None,
        is_selected: str = None,
        promotion_desc: str = None,
        promotion_name: str = None,
        promotion_option_code: str = None,
        promotion_option_no: str = None,
    ):
        self.can_prom_fee = can_prom_fee
        self.is_selected = is_selected
        self.promotion_desc = promotion_desc
        self.promotion_name = promotion_name
        self.promotion_option_code = promotion_option_code
        self.promotion_option_no = promotion_option_no

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_prom_fee is not None:
            result['CanPromFee'] = self.can_prom_fee
        if self.is_selected is not None:
            result['IsSelected'] = self.is_selected
        if self.promotion_desc is not None:
            result['PromotionDesc'] = self.promotion_desc
        if self.promotion_name is not None:
            result['PromotionName'] = self.promotion_name
        if self.promotion_option_code is not None:
            result['PromotionOptionCode'] = self.promotion_option_code
        if self.promotion_option_no is not None:
            result['PromotionOptionNo'] = self.promotion_option_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanPromFee') is not None:
            self.can_prom_fee = m.get('CanPromFee')
        if m.get('IsSelected') is not None:
            self.is_selected = m.get('IsSelected')
        if m.get('PromotionDesc') is not None:
            self.promotion_desc = m.get('PromotionDesc')
        if m.get('PromotionName') is not None:
            self.promotion_name = m.get('PromotionName')
        if m.get('PromotionOptionCode') is not None:
            self.promotion_option_code = m.get('PromotionOptionCode')
        if m.get('PromotionOptionNo') is not None:
            self.promotion_option_no = m.get('PromotionOptionNo')
        return self


class PriceInfo(TeaModel):
    def __init__(
        self,
        currency: str = None,
        discount_price: str = None,
        original_price: str = None,
        pay_type: str = None,
        promotion_results: List[PromotionInfo] = None,
        resource_type: str = None,
        spot_instance_type_original_price: str = None,
        spot_instance_type_price: str = None,
        spot_original_price: str = None,
        spot_price: str = None,
        tax_price: str = None,
        trade_price: str = None,
    ):
        self.currency = currency
        self.discount_price = discount_price
        self.original_price = original_price
        self.pay_type = pay_type
        self.promotion_results = promotion_results
        self.resource_type = resource_type
        self.spot_instance_type_original_price = spot_instance_type_original_price
        self.spot_instance_type_price = spot_instance_type_price
        self.spot_original_price = spot_original_price
        self.spot_price = spot_price
        self.tax_price = tax_price
        self.trade_price = trade_price

    def validate(self):
        if self.promotion_results:
            for k in self.promotion_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.currency is not None:
            result['Currency'] = self.currency
        if self.discount_price is not None:
            result['DiscountPrice'] = self.discount_price
        if self.original_price is not None:
            result['OriginalPrice'] = self.original_price
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        result['PromotionResults'] = []
        if self.promotion_results is not None:
            for k in self.promotion_results:
                result['PromotionResults'].append(k.to_map() if k else None)
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.spot_instance_type_original_price is not None:
            result['SpotInstanceTypeOriginalPrice'] = self.spot_instance_type_original_price
        if self.spot_instance_type_price is not None:
            result['SpotInstanceTypePrice'] = self.spot_instance_type_price
        if self.spot_original_price is not None:
            result['SpotOriginalPrice'] = self.spot_original_price
        if self.spot_price is not None:
            result['SpotPrice'] = self.spot_price
        if self.tax_price is not None:
            result['TaxPrice'] = self.tax_price
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Currency') is not None:
            self.currency = m.get('Currency')
        if m.get('DiscountPrice') is not None:
            self.discount_price = m.get('DiscountPrice')
        if m.get('OriginalPrice') is not None:
            self.original_price = m.get('OriginalPrice')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        self.promotion_results = []
        if m.get('PromotionResults') is not None:
            for k in m.get('PromotionResults'):
                temp_model = PromotionInfo()
                self.promotion_results.append(temp_model.from_map(k))
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('SpotInstanceTypeOriginalPrice') is not None:
            self.spot_instance_type_original_price = m.get('SpotInstanceTypeOriginalPrice')
        if m.get('SpotInstanceTypePrice') is not None:
            self.spot_instance_type_price = m.get('SpotInstanceTypePrice')
        if m.get('SpotOriginalPrice') is not None:
            self.spot_original_price = m.get('SpotOriginalPrice')
        if m.get('SpotPrice') is not None:
            self.spot_price = m.get('SpotPrice')
        if m.get('TaxPrice') is not None:
            self.tax_price = m.get('TaxPrice')
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class Promotion(TeaModel):
    def __init__(
        self,
        product_code: str = None,
        promotion_desc: str = None,
        promotion_name: str = None,
        promotion_option_code: str = None,
        promotion_option_no: str = None,
    ):
        # 产品码。
        self.product_code = product_code
        # 优惠券描述。
        self.promotion_desc = promotion_desc
        # 优惠券名称。
        self.promotion_name = promotion_name
        # 优惠券码。
        self.promotion_option_code = promotion_option_code
        # 优惠券号。
        # 
        # This parameter is required.
        self.promotion_option_no = promotion_option_no

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.promotion_desc is not None:
            result['PromotionDesc'] = self.promotion_desc
        if self.promotion_name is not None:
            result['PromotionName'] = self.promotion_name
        if self.promotion_option_code is not None:
            result['PromotionOptionCode'] = self.promotion_option_code
        if self.promotion_option_no is not None:
            result['PromotionOptionNo'] = self.promotion_option_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('PromotionDesc') is not None:
            self.promotion_desc = m.get('PromotionDesc')
        if m.get('PromotionName') is not None:
            self.promotion_name = m.get('PromotionName')
        if m.get('PromotionOptionCode') is not None:
            self.promotion_option_code = m.get('PromotionOptionCode')
        if m.get('PromotionOptionNo') is not None:
            self.promotion_option_no = m.get('PromotionOptionNo')
        return self


class PromotionParam(TeaModel):
    def __init__(
        self,
        product_code: str = None,
        promotion_option_code: str = None,
        promotion_option_no: str = None,
    ):
        self.product_code = product_code
        self.promotion_option_code = promotion_option_code
        self.promotion_option_no = promotion_option_no

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.promotion_option_code is not None:
            result['PromotionOptionCode'] = self.promotion_option_code
        if self.promotion_option_no is not None:
            result['PromotionOptionNo'] = self.promotion_option_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('PromotionOptionCode') is not None:
            self.promotion_option_code = m.get('PromotionOptionCode')
        if m.get('PromotionOptionNo') is not None:
            self.promotion_option_no = m.get('PromotionOptionNo')
        return self


class RecommendScalingRule(TeaModel):
    def __init__(
        self,
        activity_type: str = None,
        adjustment_value: int = None,
        instance_type: str = None,
        max_save: float = None,
        metrics_trigger: MetricsTrigger = None,
        rule_name: str = None,
        time_trigger: TimeTrigger = None,
        trigger_type: str = None,
    ):
        # 伸缩活动类型。取值范围：
        # - SCALE_OUT：扩容。
        # - SCALE_IN：缩容。
        # 
        # This parameter is required.
        self.activity_type = activity_type
        # 调整值。需要为正数，代表需要扩容或者缩容的实例数量。
        # 
        # This parameter is required.
        self.adjustment_value = adjustment_value
        # 推荐的规格类型。
        self.instance_type = instance_type
        # 最大节约成本。
        self.max_save = max_save
        # 按照负载伸缩描述。
        # <p>
        self.metrics_trigger = metrics_trigger
        # 规则名称。
        # 
        # This parameter is required.
        self.rule_name = rule_name
        # 按照时间伸缩描述。
        # <p>
        self.time_trigger = time_trigger
        # 伸缩规则类型。 取值范围：
        # - TIME_TRIGGER: 按时间伸缩。
        # - METRICS_TRIGGER: 按负载伸缩。
        # 
        # This parameter is required.
        self.trigger_type = trigger_type

    def validate(self):
        if self.metrics_trigger:
            self.metrics_trigger.validate()
        if self.time_trigger:
            self.time_trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_type is not None:
            result['ActivityType'] = self.activity_type
        if self.adjustment_value is not None:
            result['AdjustmentValue'] = self.adjustment_value
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.max_save is not None:
            result['MaxSave'] = self.max_save
        if self.metrics_trigger is not None:
            result['MetricsTrigger'] = self.metrics_trigger.to_map()
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.time_trigger is not None:
            result['TimeTrigger'] = self.time_trigger.to_map()
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityType') is not None:
            self.activity_type = m.get('ActivityType')
        if m.get('AdjustmentValue') is not None:
            self.adjustment_value = m.get('AdjustmentValue')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MaxSave') is not None:
            self.max_save = m.get('MaxSave')
        if m.get('MetricsTrigger') is not None:
            temp_model = MetricsTrigger()
            self.metrics_trigger = temp_model.from_map(m['MetricsTrigger'])
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('TimeTrigger') is not None:
            temp_model = TimeTrigger()
            self.time_trigger = temp_model.from_map(m['TimeTrigger'])
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class RenewInstance(TeaModel):
    def __init__(
        self,
        emr_renew_duration: int = None,
        emr_renew_duration_unit: str = None,
        instance_id: str = None,
        renew_duration: int = None,
        renew_duration_unit: str = None,
    ):
        # emr实例续费时长。
        self.emr_renew_duration = emr_renew_duration
        # emr实例续费时长单位。
        self.emr_renew_duration_unit = emr_renew_duration_unit
        # 节点ID。
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # 续费时长。
        self.renew_duration = renew_duration
        # 付费时长单位。
        self.renew_duration_unit = renew_duration_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.emr_renew_duration is not None:
            result['EmrRenewDuration'] = self.emr_renew_duration
        if self.emr_renew_duration_unit is not None:
            result['EmrRenewDurationUnit'] = self.emr_renew_duration_unit
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.renew_duration is not None:
            result['RenewDuration'] = self.renew_duration
        if self.renew_duration_unit is not None:
            result['RenewDurationUnit'] = self.renew_duration_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EmrRenewDuration') is not None:
            self.emr_renew_duration = m.get('EmrRenewDuration')
        if m.get('EmrRenewDurationUnit') is not None:
            self.emr_renew_duration_unit = m.get('EmrRenewDurationUnit')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RenewDuration') is not None:
            self.renew_duration = m.get('RenewDuration')
        if m.get('RenewDurationUnit') is not None:
            self.renew_duration_unit = m.get('RenewDurationUnit')
        return self


class RenewInstanceParam(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        renew_duration: int = None,
        renew_duration_unit: str = None,
    ):
        self.instance_id = instance_id
        self.renew_duration = renew_duration
        self.renew_duration_unit = renew_duration_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.renew_duration is not None:
            result['RenewDuration'] = self.renew_duration
        if self.renew_duration_unit is not None:
            result['RenewDurationUnit'] = self.renew_duration_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RenewDuration') is not None:
            self.renew_duration = m.get('RenewDuration')
        if m.get('RenewDurationUnit') is not None:
            self.renew_duration_unit = m.get('RenewDurationUnit')
        return self


class RequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ResizeDiskNodeGroupParam(TeaModel):
    def __init__(
        self,
        data_disk_capacity: int = None,
        node_group_id: str = None,
        rolling_restart: bool = None,
    ):
        self.data_disk_capacity = data_disk_capacity
        self.node_group_id = node_group_id
        self.rolling_restart = rolling_restart

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_capacity is not None:
            result['DataDiskCapacity'] = self.data_disk_capacity
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.rolling_restart is not None:
            result['RollingRestart'] = self.rolling_restart
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataDiskCapacity') is not None:
            self.data_disk_capacity = m.get('DataDiskCapacity')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('RollingRestart') is not None:
            self.rolling_restart = m.get('RollingRestart')
        return self


class ResourceSummary(TeaModel):
    def __init__(
        self,
        inefficient_task_rate: DoubleMetric = None,
        memory_utilization_rate: DoubleMetric = None,
        original_total_vcore: IntegerMetric = None,
        vcore_utilization_rate: DoubleMetric = None,
    ):
        self.inefficient_task_rate = inefficient_task_rate
        self.memory_utilization_rate = memory_utilization_rate
        self.original_total_vcore = original_total_vcore
        self.vcore_utilization_rate = vcore_utilization_rate

    def validate(self):
        if self.inefficient_task_rate:
            self.inefficient_task_rate.validate()
        if self.memory_utilization_rate:
            self.memory_utilization_rate.validate()
        if self.original_total_vcore:
            self.original_total_vcore.validate()
        if self.vcore_utilization_rate:
            self.vcore_utilization_rate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inefficient_task_rate is not None:
            result['InefficientTaskRate'] = self.inefficient_task_rate.to_map()
        if self.memory_utilization_rate is not None:
            result['MemoryUtilizationRate'] = self.memory_utilization_rate.to_map()
        if self.original_total_vcore is not None:
            result['OriginalTotalVcore'] = self.original_total_vcore.to_map()
        if self.vcore_utilization_rate is not None:
            result['VcoreUtilizationRate'] = self.vcore_utilization_rate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InefficientTaskRate') is not None:
            temp_model = DoubleMetric()
            self.inefficient_task_rate = temp_model.from_map(m['InefficientTaskRate'])
        if m.get('MemoryUtilizationRate') is not None:
            temp_model = DoubleMetric()
            self.memory_utilization_rate = temp_model.from_map(m['MemoryUtilizationRate'])
        if m.get('OriginalTotalVcore') is not None:
            temp_model = IntegerMetric()
            self.original_total_vcore = temp_model.from_map(m['OriginalTotalVcore'])
        if m.get('VcoreUtilizationRate') is not None:
            temp_model = DoubleMetric()
            self.vcore_utilization_rate = temp_model.from_map(m['VcoreUtilizationRate'])
        return self


class ScalingActivity(TeaModel):
    def __init__(
        self,
        cause: str = None,
        description: str = None,
        end_time: int = None,
        ess_scaling_rule_id: str = None,
        expect_num: int = None,
        host_group_name: str = None,
        id: str = None,
        instance_ids: str = None,
        scaling_group_id: str = None,
        scaling_rule_name: str = None,
        start_time: int = None,
        status: str = None,
        total_capacity: int = None,
        transition: str = None,
    ):
        self.cause = cause
        self.description = description
        self.end_time = end_time
        self.ess_scaling_rule_id = ess_scaling_rule_id
        self.expect_num = expect_num
        self.host_group_name = host_group_name
        self.id = id
        self.instance_ids = instance_ids
        self.scaling_group_id = scaling_group_id
        self.scaling_rule_name = scaling_rule_name
        self.start_time = start_time
        self.status = status
        self.total_capacity = total_capacity
        self.transition = transition

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cause is not None:
            result['Cause'] = self.cause
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ess_scaling_rule_id is not None:
            result['EssScalingRuleId'] = self.ess_scaling_rule_id
        if self.expect_num is not None:
            result['ExpectNum'] = self.expect_num
        if self.host_group_name is not None:
            result['HostGroupName'] = self.host_group_name
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.scaling_group_id is not None:
            result['ScalingGroupId'] = self.scaling_group_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.total_capacity is not None:
            result['TotalCapacity'] = self.total_capacity
        if self.transition is not None:
            result['Transition'] = self.transition
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cause') is not None:
            self.cause = m.get('Cause')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EssScalingRuleId') is not None:
            self.ess_scaling_rule_id = m.get('EssScalingRuleId')
        if m.get('ExpectNum') is not None:
            self.expect_num = m.get('ExpectNum')
        if m.get('HostGroupName') is not None:
            self.host_group_name = m.get('HostGroupName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('ScalingGroupId') is not None:
            self.scaling_group_id = m.get('ScalingGroupId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TotalCapacity') is not None:
            self.total_capacity = m.get('TotalCapacity')
        if m.get('Transition') is not None:
            self.transition = m.get('Transition')
        return self


class ScalingActivityResult(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # 实例ID。
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ScalingActivityResultDTO(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # 实例ID。
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ScalingAnalyzeResult(TeaModel):
    def __init__(
        self,
        actual_usage: float = None,
        ideal_usage: float = None,
        release_cores: int = None,
        reserved_cores: int = None,
    ):
        # 实际资源利用率。
        self.actual_usage = actual_usage
        # 理想资源用量。
        self.ideal_usage = ideal_usage
        # 固定资源释放核数（非master）core。
        self.release_cores = release_cores
        # 固定资源保留核数（非master）core。
        self.reserved_cores = reserved_cores

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_usage is not None:
            result['ActualUsage'] = self.actual_usage
        if self.ideal_usage is not None:
            result['IdealUsage'] = self.ideal_usage
        if self.release_cores is not None:
            result['ReleaseCores'] = self.release_cores
        if self.reserved_cores is not None:
            result['ReservedCores'] = self.reserved_cores
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualUsage') is not None:
            self.actual_usage = m.get('ActualUsage')
        if m.get('IdealUsage') is not None:
            self.ideal_usage = m.get('IdealUsage')
        if m.get('ReleaseCores') is not None:
            self.release_cores = m.get('ReleaseCores')
        if m.get('ReservedCores') is not None:
            self.reserved_cores = m.get('ReservedCores')
        return self


class ScalingAnalyzeTimeRange(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
        type: str = None,
    ):
        # 结束时间。
        self.end_time = end_time
        # 起始时间。
        self.start_time = start_time
        # 峰谷类型。 peak/valley
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ScalingConstraints(TeaModel):
    def __init__(
        self,
        max_capacity: int = None,
        min_capacity: int = None,
    ):
        # 最大值。
        self.max_capacity = max_capacity
        # 最小值。
        self.min_capacity = min_capacity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity is not None:
            result['MaxCapacity'] = self.max_capacity
        if self.min_capacity is not None:
            result['MinCapacity'] = self.min_capacity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxCapacity') is not None:
            self.max_capacity = m.get('MaxCapacity')
        if m.get('MinCapacity') is not None:
            self.min_capacity = m.get('MinCapacity')
        return self


class ScalingGroupConfigInstanceTypeList(TeaModel):
    def __init__(
        self,
        instance_type: str = None,
        spot_price_limit: float = None,
    ):
        # Ecs类型。
        self.instance_type = instance_type
        # 抢占价格上限,可空。
        self.spot_price_limit = spot_price_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.spot_price_limit is not None:
            result['SpotPriceLimit'] = self.spot_price_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('SpotPriceLimit') is not None:
            self.spot_price_limit = m.get('SpotPriceLimit')
        return self


class ScalingGroupConfigMultiAvailablePolicyPolicyParam(TeaModel):
    def __init__(
        self,
        on_demand_base_capacity: int = None,
        on_demand_percentage_above_base_capacity: int = None,
        spot_instance_pools: int = None,
        spot_instance_remedy: bool = None,
    ):
        # 按需实例最小个数。
        self.on_demand_base_capacity = on_demand_base_capacity
        # 按需实例百分比。
        self.on_demand_percentage_above_base_capacity = on_demand_percentage_above_base_capacity
        # 抢占实例类型池规模。
        self.spot_instance_pools = spot_instance_pools
        # 是否使用按量补偿。
        self.spot_instance_remedy = spot_instance_remedy

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.on_demand_base_capacity is not None:
            result['OnDemandBaseCapacity'] = self.on_demand_base_capacity
        if self.on_demand_percentage_above_base_capacity is not None:
            result['OnDemandPercentageAboveBaseCapacity'] = self.on_demand_percentage_above_base_capacity
        if self.spot_instance_pools is not None:
            result['SpotInstancePools'] = self.spot_instance_pools
        if self.spot_instance_remedy is not None:
            result['SpotInstanceRemedy'] = self.spot_instance_remedy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OnDemandBaseCapacity') is not None:
            self.on_demand_base_capacity = m.get('OnDemandBaseCapacity')
        if m.get('OnDemandPercentageAboveBaseCapacity') is not None:
            self.on_demand_percentage_above_base_capacity = m.get('OnDemandPercentageAboveBaseCapacity')
        if m.get('SpotInstancePools') is not None:
            self.spot_instance_pools = m.get('SpotInstancePools')
        if m.get('SpotInstanceRemedy') is not None:
            self.spot_instance_remedy = m.get('SpotInstanceRemedy')
        return self


class ScalingGroupConfigMultiAvailablePolicy(TeaModel):
    def __init__(
        self,
        policy_param: ScalingGroupConfigMultiAvailablePolicyPolicyParam = None,
        policy_type: str = None,
    ):
        # 资源可用性策略(成本优化参数)。
        self.policy_param = policy_param
        # 策略类型。
        self.policy_type = policy_type

    def validate(self):
        if self.policy_param:
            self.policy_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_param is not None:
            result['PolicyParam'] = self.policy_param.to_map()
        if self.policy_type is not None:
            result['PolicyType'] = self.policy_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PolicyParam') is not None:
            temp_model = ScalingGroupConfigMultiAvailablePolicyPolicyParam()
            self.policy_param = temp_model.from_map(m['PolicyParam'])
        if m.get('PolicyType') is not None:
            self.policy_type = m.get('PolicyType')
        return self


class ScalingGroupConfigNodeOfflinePolicy(TeaModel):
    def __init__(
        self,
        mode: str = None,
        timeout_ms: int = None,
    ):
        # 下线模式,是否为优雅下线。
        self.mode = mode
        # 下线超时时间,单位毫秒。
        self.timeout_ms = timeout_ms

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.timeout_ms is not None:
            result['TimeoutMs'] = self.timeout_ms
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('TimeoutMs') is not None:
            self.timeout_ms = m.get('TimeoutMs')
        return self


class ScalingGroupConfigPrivatePoolOptions(TeaModel):
    def __init__(
        self,
        id: str = None,
        match_criteria: str = None,
    ):
        # 私有池id。
        self.id = id
        # 实例启动的私有池容量选项。。
        self.match_criteria = match_criteria

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.match_criteria is not None:
            result['MatchCriteria'] = self.match_criteria
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MatchCriteria') is not None:
            self.match_criteria = m.get('MatchCriteria')
        return self


class ScalingGroupConfig(TeaModel):
    def __init__(
        self,
        data_disk_category: str = None,
        data_disk_count: int = None,
        data_disk_size: int = None,
        default_cool_down_time: int = None,
        instance_type_list: List[ScalingGroupConfigInstanceTypeList] = None,
        multi_available_policy: ScalingGroupConfigMultiAvailablePolicy = None,
        node_offline_policy: ScalingGroupConfigNodeOfflinePolicy = None,
        private_pool_options: ScalingGroupConfigPrivatePoolOptions = None,
        scaling_max_size: int = None,
        scaling_min_size: int = None,
        spot_strategy: str = None,
        sys_disk_category: str = None,
        sys_disk_size: int = None,
        trigger_mode: str = None,
    ):
        # 数据盘类型。
        self.data_disk_category = data_disk_category
        # 数据盘个数。
        self.data_disk_count = data_disk_count
        # 数据盘大小,单位GB。
        self.data_disk_size = data_disk_size
        # 默认冷却时间。
        self.default_cool_down_time = default_cool_down_time
        # 抢占实例列表。
        self.instance_type_list = instance_type_list
        # 资源可用性策略(成本优化参数)。
        self.multi_available_policy = multi_available_policy
        # 节点下线策略。
        self.node_offline_policy = node_offline_policy
        # 私有池选项	。
        self.private_pool_options = private_pool_options
        # 伸缩组节点最大个数。
        self.scaling_max_size = scaling_max_size
        # 伸缩组节点最小个数。
        self.scaling_min_size = scaling_min_size
        # 抢占式Spot实例策略。
        self.spot_strategy = spot_strategy
        # 系统盘类型。
        self.sys_disk_category = sys_disk_category
        # 系统盘大小,单位GB。
        self.sys_disk_size = sys_disk_size
        # 伸缩活动触发模式。
        self.trigger_mode = trigger_mode

    def validate(self):
        if self.instance_type_list:
            for k in self.instance_type_list:
                if k:
                    k.validate()
        if self.multi_available_policy:
            self.multi_available_policy.validate()
        if self.node_offline_policy:
            self.node_offline_policy.validate()
        if self.private_pool_options:
            self.private_pool_options.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_category is not None:
            result['DataDiskCategory'] = self.data_disk_category
        if self.data_disk_count is not None:
            result['DataDiskCount'] = self.data_disk_count
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.default_cool_down_time is not None:
            result['DefaultCoolDownTime'] = self.default_cool_down_time
        result['InstanceTypeList'] = []
        if self.instance_type_list is not None:
            for k in self.instance_type_list:
                result['InstanceTypeList'].append(k.to_map() if k else None)
        if self.multi_available_policy is not None:
            result['MultiAvailablePolicy'] = self.multi_available_policy.to_map()
        if self.node_offline_policy is not None:
            result['NodeOfflinePolicy'] = self.node_offline_policy.to_map()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.scaling_max_size is not None:
            result['ScalingMaxSize'] = self.scaling_max_size
        if self.scaling_min_size is not None:
            result['ScalingMinSize'] = self.scaling_min_size
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.sys_disk_category is not None:
            result['SysDiskCategory'] = self.sys_disk_category
        if self.sys_disk_size is not None:
            result['SysDiskSize'] = self.sys_disk_size
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataDiskCategory') is not None:
            self.data_disk_category = m.get('DataDiskCategory')
        if m.get('DataDiskCount') is not None:
            self.data_disk_count = m.get('DataDiskCount')
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('DefaultCoolDownTime') is not None:
            self.default_cool_down_time = m.get('DefaultCoolDownTime')
        self.instance_type_list = []
        if m.get('InstanceTypeList') is not None:
            for k in m.get('InstanceTypeList'):
                temp_model = ScalingGroupConfigInstanceTypeList()
                self.instance_type_list.append(temp_model.from_map(k))
        if m.get('MultiAvailablePolicy') is not None:
            temp_model = ScalingGroupConfigMultiAvailablePolicy()
            self.multi_available_policy = temp_model.from_map(m['MultiAvailablePolicy'])
        if m.get('NodeOfflinePolicy') is not None:
            temp_model = ScalingGroupConfigNodeOfflinePolicy()
            self.node_offline_policy = temp_model.from_map(m['NodeOfflinePolicy'])
        if m.get('PrivatePoolOptions') is not None:
            temp_model = ScalingGroupConfigPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('ScalingMaxSize') is not None:
            self.scaling_max_size = m.get('ScalingMaxSize')
        if m.get('ScalingMinSize') is not None:
            self.scaling_min_size = m.get('ScalingMinSize')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('SysDiskCategory') is not None:
            self.sys_disk_category = m.get('SysDiskCategory')
        if m.get('SysDiskSize') is not None:
            self.sys_disk_size = m.get('SysDiskSize')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class ScalingPolicy(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        constraints: ManagedScalingConstraints = None,
        disabled: bool = None,
        node_group_id: str = None,
        node_group_name: str = None,
        scaling_policy_id: str = None,
        scaling_policy_type: str = None,
        scaling_rules: List[ScalingRule] = None,
    ):
        self.cluster_id = cluster_id
        self.constraints = constraints
        self.disabled = disabled
        self.node_group_id = node_group_id
        self.node_group_name = node_group_name
        self.scaling_policy_id = scaling_policy_id
        self.scaling_policy_type = scaling_policy_type
        self.scaling_rules = scaling_rules

    def validate(self):
        if self.constraints:
            self.constraints.validate()
        if self.scaling_rules:
            for k in self.scaling_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.constraints is not None:
            result['Constraints'] = self.constraints.to_map()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.scaling_policy_id is not None:
            result['ScalingPolicyId'] = self.scaling_policy_id
        if self.scaling_policy_type is not None:
            result['ScalingPolicyType'] = self.scaling_policy_type
        result['ScalingRules'] = []
        if self.scaling_rules is not None:
            for k in self.scaling_rules:
                result['ScalingRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Constraints') is not None:
            temp_model = ManagedScalingConstraints()
            self.constraints = temp_model.from_map(m['Constraints'])
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('ScalingPolicyId') is not None:
            self.scaling_policy_id = m.get('ScalingPolicyId')
        if m.get('ScalingPolicyType') is not None:
            self.scaling_policy_type = m.get('ScalingPolicyType')
        self.scaling_rules = []
        if m.get('ScalingRules') is not None:
            for k in m.get('ScalingRules'):
                temp_model = ScalingRule()
                self.scaling_rules.append(temp_model.from_map(k))
        return self


class ScalingRuleSpecByLoadScalingRuleSpec(TeaModel):
    def __init__(
        self,
        comparison_operator: str = None,
        evaluation_count: int = None,
        metric_name: str = None,
        statistics: str = None,
        threshold: float = None,
        time_window: int = None,
    ):
        # 比较符。
        # 
        # This parameter is required.
        self.comparison_operator = comparison_operator
        # 统计次数。
        # 
        # This parameter is required.
        self.evaluation_count = evaluation_count
        # 指标名称。指标名称需要在 ListAutoScalingMetrics 接口返回的指标名称列表中。
        # 
        # This parameter is required.
        self.metric_name = metric_name
        # 统计量名称。
        # 
        # This parameter is required.
        self.statistics = statistics
        # 阈值。
        # 
        # This parameter is required.
        self.threshold = threshold
        # 统计窗口。单位为秒。
        # 
        # This parameter is required.
        self.time_window = time_window

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.time_window is not None:
            result['TimeWindow'] = self.time_window
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('TimeWindow') is not None:
            self.time_window = m.get('TimeWindow')
        return self


class ScalingRuleSpecByTimeScalingRuleSpec(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        launch_time: int = None,
        recurrence_type: str = None,
        recurrence_value: str = None,
    ):
        # 重复执行定时任务的结束时间戳。单位为毫秒。
        self.end_time = end_time
        # 启动时间戳。单位为毫秒。
        # 
        # This parameter is required.
        self.launch_time = launch_time
        # 指定时间规则的执行类型。
        self.recurrence_type = recurrence_type
        # 重复执行定时任务的数值。具体取值取决于 recurrenceType 设置。
        self.recurrence_value = recurrence_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.launch_time is not None:
            result['LaunchTime'] = self.launch_time
        if self.recurrence_type is not None:
            result['RecurrenceType'] = self.recurrence_type
        if self.recurrence_value is not None:
            result['RecurrenceValue'] = self.recurrence_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LaunchTime') is not None:
            self.launch_time = m.get('LaunchTime')
        if m.get('RecurrenceType') is not None:
            self.recurrence_type = m.get('RecurrenceType')
        if m.get('RecurrenceValue') is not None:
            self.recurrence_value = m.get('RecurrenceValue')
        return self


class ScalingRuleSpec(TeaModel):
    def __init__(
        self,
        adjustment_value: int = None,
        by_load_scaling_rule_spec: ScalingRuleSpecByLoadScalingRuleSpec = None,
        by_time_scaling_rule_spec: ScalingRuleSpecByTimeScalingRuleSpec = None,
        cool_down_interval: int = None,
        scaling_activity_type: str = None,
        scaling_rule_name: str = None,
        scaling_rule_type: str = None,
    ):
        # 调整值。需要为正数，代表需要扩容或者缩容的实例数量。
        # 
        # This parameter is required.
        self.adjustment_value = adjustment_value
        # 按照负载伸缩描述。
        self.by_load_scaling_rule_spec = by_load_scaling_rule_spec
        # 按照时间伸缩描述。
        self.by_time_scaling_rule_spec = by_time_scaling_rule_spec
        # 冷却时间。单位为秒，取值范围在30~10800秒之间。
        # 
        # This parameter is required.
        self.cool_down_interval = cool_down_interval
        # 伸缩活动类型。
        # 
        # This parameter is required.
        self.scaling_activity_type = scaling_activity_type
        # 规则名称。
        # 
        # This parameter is required.
        self.scaling_rule_name = scaling_rule_name
        # 伸缩规则类型。
        # 
        # This parameter is required.
        self.scaling_rule_type = scaling_rule_type

    def validate(self):
        if self.by_load_scaling_rule_spec:
            self.by_load_scaling_rule_spec.validate()
        if self.by_time_scaling_rule_spec:
            self.by_time_scaling_rule_spec.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adjustment_value is not None:
            result['AdjustmentValue'] = self.adjustment_value
        if self.by_load_scaling_rule_spec is not None:
            result['ByLoadScalingRuleSpec'] = self.by_load_scaling_rule_spec.to_map()
        if self.by_time_scaling_rule_spec is not None:
            result['ByTimeScalingRuleSpec'] = self.by_time_scaling_rule_spec.to_map()
        if self.cool_down_interval is not None:
            result['CoolDownInterval'] = self.cool_down_interval
        if self.scaling_activity_type is not None:
            result['ScalingActivityType'] = self.scaling_activity_type
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.scaling_rule_type is not None:
            result['ScalingRuleType'] = self.scaling_rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjustmentValue') is not None:
            self.adjustment_value = m.get('AdjustmentValue')
        if m.get('ByLoadScalingRuleSpec') is not None:
            temp_model = ScalingRuleSpecByLoadScalingRuleSpec()
            self.by_load_scaling_rule_spec = temp_model.from_map(m['ByLoadScalingRuleSpec'])
        if m.get('ByTimeScalingRuleSpec') is not None:
            temp_model = ScalingRuleSpecByTimeScalingRuleSpec()
            self.by_time_scaling_rule_spec = temp_model.from_map(m['ByTimeScalingRuleSpec'])
        if m.get('CoolDownInterval') is not None:
            self.cool_down_interval = m.get('CoolDownInterval')
        if m.get('ScalingActivityType') is not None:
            self.scaling_activity_type = m.get('ScalingActivityType')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('ScalingRuleType') is not None:
            self.scaling_rule_type = m.get('ScalingRuleType')
        return self


class ScalingRuleV1RuleParam(TeaModel):
    def __init__(
        self,
        comparison_operator: str = None,
        evaluation_count: int = None,
        launch_expiration_time: int = None,
        launch_time: str = None,
        metric_name: str = None,
        period: int = None,
        recurrence_end_time: str = None,
        recurrence_type: str = None,
        recurrence_value: str = None,
        statistics: str = None,
        threshold: int = None,
    ):
        # [负载触发参数] 比较符。
        self.comparison_operator = comparison_operator
        # [负载触发参数] 统计次数。
        self.evaluation_count = evaluation_count
        # [时间调度参数] 周期类型周期过期时间。
        self.launch_expiration_time = launch_expiration_time
        # [时间调度参数] 周期类型周期开始时间。
        self.launch_time = launch_time
        # [负载触发参数] 度量名称。
        self.metric_name = metric_name
        # [负载触发参数] 统计时长,单位分钟。
        self.period = period
        # [时间调度参数] 周期类型周期结束时间。
        self.recurrence_end_time = recurrence_end_time
        # [时间调度参数] 周期类型。
        self.recurrence_type = recurrence_type
        # [时间调度参数] 周期类型周期值。
        self.recurrence_value = recurrence_value
        # [负载触发参数] 统计方式。
        self.statistics = statistics
        # [负载触发参数] 阈值。
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.launch_expiration_time is not None:
            result['LaunchExpirationTime'] = self.launch_expiration_time
        if self.launch_time is not None:
            result['LaunchTime'] = self.launch_time
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.period is not None:
            result['Period'] = self.period
        if self.recurrence_end_time is not None:
            result['RecurrenceEndTime'] = self.recurrence_end_time
        if self.recurrence_type is not None:
            result['RecurrenceType'] = self.recurrence_type
        if self.recurrence_value is not None:
            result['RecurrenceValue'] = self.recurrence_value
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('LaunchExpirationTime') is not None:
            self.launch_expiration_time = m.get('LaunchExpirationTime')
        if m.get('LaunchTime') is not None:
            self.launch_time = m.get('LaunchTime')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RecurrenceEndTime') is not None:
            self.recurrence_end_time = m.get('RecurrenceEndTime')
        if m.get('RecurrenceType') is not None:
            self.recurrence_type = m.get('RecurrenceType')
        if m.get('RecurrenceValue') is not None:
            self.recurrence_value = m.get('RecurrenceValue')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class ScalingRuleV1(TeaModel):
    def __init__(
        self,
        adjustment_type: str = None,
        adjustment_value: int = None,
        cool_down_time: int = None,
        rule_name: str = None,
        rule_param: ScalingRuleV1RuleParam = None,
        rule_type: str = None,
        scaling_config_biz_id: str = None,
    ):
        # 调整类型。
        self.adjustment_type = adjustment_type
        # 调整值,正数为扩容,负数为缩容。
        self.adjustment_value = adjustment_value
        # 冷却时间,单位秒。
        self.cool_down_time = cool_down_time
        # 规则名称。
        self.rule_name = rule_name
        # 规则参数。
        self.rule_param = rule_param
        # 规则类型。
        self.rule_type = rule_type
        # 弹性规则配置ID。
        self.scaling_config_biz_id = scaling_config_biz_id

    def validate(self):
        if self.rule_param:
            self.rule_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adjustment_type is not None:
            result['AdjustmentType'] = self.adjustment_type
        if self.adjustment_value is not None:
            result['AdjustmentValue'] = self.adjustment_value
        if self.cool_down_time is not None:
            result['CoolDownTime'] = self.cool_down_time
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_param is not None:
            result['RuleParam'] = self.rule_param.to_map()
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.scaling_config_biz_id is not None:
            result['ScalingConfigBizId'] = self.scaling_config_biz_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjustmentType') is not None:
            self.adjustment_type = m.get('AdjustmentType')
        if m.get('AdjustmentValue') is not None:
            self.adjustment_value = m.get('AdjustmentValue')
        if m.get('CoolDownTime') is not None:
            self.cool_down_time = m.get('CoolDownTime')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleParam') is not None:
            temp_model = ScalingRuleV1RuleParam()
            self.rule_param = temp_model.from_map(m['RuleParam'])
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('ScalingConfigBizId') is not None:
            self.scaling_config_biz_id = m.get('ScalingConfigBizId')
        return self


class Script(TeaModel):
    def __init__(
        self,
        execution_fail_strategy: str = None,
        execution_moment: str = None,
        node_selector: NodeSelector = None,
        priority: int = None,
        script_args: str = None,
        script_name: str = None,
        script_path: str = None,
    ):
        # 执行失败策略。
        self.execution_fail_strategy = execution_fail_strategy
        # 脚本的执行时机。
        self.execution_moment = execution_moment
        # 节点选择器。
        # 
        # This parameter is required.
        self.node_selector = node_selector
        # 脚本执行优先级。取值范围：1~100。
        self.priority = priority
        # 脚本执行参数。
        self.script_args = script_args
        # 脚本名称。长度为1~64个字符，必须以大小字母或中文开头，不能以http://和https://开头。可以包含中文、英文、数字、下划线（_）、或者短划线（-）
        # 
        # This parameter is required.
        self.script_name = script_name
        # 脚本所在OSS路径。
        # 
        # This parameter is required.
        self.script_path = script_path

    def validate(self):
        if self.node_selector:
            self.node_selector.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.execution_fail_strategy is not None:
            result['ExecutionFailStrategy'] = self.execution_fail_strategy
        if self.execution_moment is not None:
            result['ExecutionMoment'] = self.execution_moment
        if self.node_selector is not None:
            result['NodeSelector'] = self.node_selector.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.script_args is not None:
            result['ScriptArgs'] = self.script_args
        if self.script_name is not None:
            result['ScriptName'] = self.script_name
        if self.script_path is not None:
            result['ScriptPath'] = self.script_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecutionFailStrategy') is not None:
            self.execution_fail_strategy = m.get('ExecutionFailStrategy')
        if m.get('ExecutionMoment') is not None:
            self.execution_moment = m.get('ExecutionMoment')
        if m.get('NodeSelector') is not None:
            temp_model = NodeSelector()
            self.node_selector = temp_model.from_map(m['NodeSelector'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ScriptArgs') is not None:
            self.script_args = m.get('ScriptArgs')
        if m.get('ScriptName') is not None:
            self.script_name = m.get('ScriptName')
        if m.get('ScriptPath') is not None:
            self.script_path = m.get('ScriptPath')
        return self


class SpotPriceLimit(TeaModel):
    def __init__(
        self,
        instance_type: str = None,
        price_limit: float = None,
    ):
        self.instance_type = instance_type
        self.price_limit = price_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.price_limit is not None:
            result['PriceLimit'] = self.price_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('PriceLimit') is not None:
            self.price_limit = m.get('PriceLimit')
        return self


class StateChangeReason(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
    ):
        # 状态码。
        self.code = code
        # 描述信息。
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class TagResource(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
        tag_key: str = None,
        tag_value: str = None,
    ):
        self.resource_id = resource_id
        self.resource_type = resource_type
        self.tag_key = tag_key
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class TimeRange(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        start_time: str = None,
    ):
        # 结束时间。
        self.end_time = end_time
        # 起始时间。
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class UpdateApplicationConfig(TeaModel):
    def __init__(
        self,
        config_description: str = None,
        config_file_name: str = None,
        config_item_key: str = None,
        config_item_value: str = None,
    ):
        # 修改描述。
        self.config_description = config_description
        # 应用配置文件名。
        self.config_file_name = config_file_name
        # 配置项键。
        self.config_item_key = config_item_key
        # 配置项值。
        self.config_item_value = config_item_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_description is not None:
            result['ConfigDescription'] = self.config_description
        if self.config_file_name is not None:
            result['ConfigFileName'] = self.config_file_name
        if self.config_item_key is not None:
            result['ConfigItemKey'] = self.config_item_key
        if self.config_item_value is not None:
            result['ConfigItemValue'] = self.config_item_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigDescription') is not None:
            self.config_description = m.get('ConfigDescription')
        if m.get('ConfigFileName') is not None:
            self.config_file_name = m.get('ConfigFileName')
        if m.get('ConfigItemKey') is not None:
            self.config_item_key = m.get('ConfigItemKey')
        if m.get('ConfigItemValue') is not None:
            self.config_item_value = m.get('ConfigItemValue')
        return self


class UpdateSpecNodeGroup(TeaModel):
    def __init__(
        self,
        new_instance_type: str = None,
        node_group_id: str = None,
    ):
        # 新实例类型。
        # 
        # This parameter is required.
        self.new_instance_type = new_instance_type
        # 节点组ID。
        # 
        # This parameter is required.
        self.node_group_id = node_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.new_instance_type is not None:
            result['NewInstanceType'] = self.new_instance_type
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NewInstanceType') is not None:
            self.new_instance_type = m.get('NewInstanceType')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        return self


class UpdateSpecNodeGroupParam(TeaModel):
    def __init__(
        self,
        new_instance_type: str = None,
        node_group_id: str = None,
    ):
        self.new_instance_type = new_instance_type
        self.node_group_id = node_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.new_instance_type is not None:
            result['NewInstanceType'] = self.new_instance_type
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NewInstanceType') is not None:
            self.new_instance_type = m.get('NewInstanceType')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        return self


class User(TeaModel):
    def __init__(
        self,
        group: str = None,
        password: str = None,
        user_id: str = None,
        user_name: str = None,
        user_type: str = None,
    ):
        # 用户组。
        self.group = group
        # 用户密码。
        # 
        # This parameter is required.
        self.password = password
        # 用户ID。
        # 
        # This parameter is required.
        self.user_id = user_id
        # 用户名称。
        # 
        # This parameter is required.
        self.user_name = user_name
        # 用户类型。
        self.user_type = user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['Group'] = self.group
        if self.password is not None:
            result['Password'] = self.password
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class UserParam(TeaModel):
    def __init__(
        self,
        password: str = None,
        user_id: str = None,
        user_name: str = None,
    ):
        self.password = password
        self.user_id = user_id
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.password is not None:
            result['Password'] = self.password
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class CreateApiTemplateRequest(TeaModel):
    def __init__(
        self,
        api_name: str = None,
        content: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        template_name: str = None,
    ):
        # The name of the API operation. You can create only a cluster API operation template. Set the value to CreateCluster.
        # 
        # This parameter is required.
        self.api_name = api_name
        # The content of the cluster API operation template. Set the value to JSON strings of the request parameters of the [CreateCluster](https://help.aliyun.com/document_detail/454393.html) API operation for creating a cluster.
        # 
        # This parameter is required.
        self.content = content
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Resource group ID.
        self.resource_group_id = resource_group_id
        # Cluster template name.
        # 
        # This parameter is required.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_name is not None:
            result['ApiName'] = self.api_name
        if self.content is not None:
            result['Content'] = self.content
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiName') is not None:
            self.api_name = m.get('ApiName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class CreateApiTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: str = None,
        template_id: str = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Template ID (to be deprecated).
        self.success = success
        # Template ID (it is recommended to use the parameter TemplateId).
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateApiTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateApiTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateApiTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateClusterRequest(TeaModel):
    def __init__(
        self,
        application_configs: List[ApplicationConfig] = None,
        applications: List[Application] = None,
        bootstrap_scripts: List[Script] = None,
        client_token: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        deletion_protection: bool = None,
        deploy_mode: str = None,
        description: str = None,
        node_attributes: NodeAttributes = None,
        node_groups: List[NodeGroupConfig] = None,
        payment_type: str = None,
        region_id: str = None,
        release_version: str = None,
        resource_group_id: str = None,
        security_mode: str = None,
        subscription_config: SubscriptionConfig = None,
        tags: List[Tag] = None,
    ):
        # The service configurations. Number of elements in the array: 1 to 1,000.
        self.application_configs = application_configs
        # The services. Number of elements in the array: 1 to 100.
        # 
        # This parameter is required.
        self.applications = applications
        # The array of bootstrap scripts. Number of elements in the array: 1 to 10.
        self.bootstrap_scripts = bootstrap_scripts
        # The idempotent client token. If you call the same ClientToken multiple times, the returned results are the same. Only one cluster can be created with the same ClientToken.
        self.client_token = client_token
        # The name of the cluster. The name must be 1 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).
        # 
        # This parameter is required.
        self.cluster_name = cluster_name
        # The type of the cluster. Valid values:
        # 
        # *   DATALAKE: data lake
        # *   OLAP: online analytical processing (OLAP)
        # *   DATAFLOW: Dataflow
        # *   DATASERVING: DataServing
        # *   CUSTOM: a custom hybrid cluster.
        # *   HADOOP: the old data lake. We recommend that you use the new data lake.
        # 
        # If you create an EMR cluster for the first time after 17:00 (UTC +8) on December 19, 2022, you cannot select the HADOOP, DATA_SCIENCE, PRESTO, or ZOOKEEPER cluster type.
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # Specifies whether to enable release protection for the cluster. Valid values:
        # 
        # *   true: enables release protection for the cluster.
        # *   false: disables release protection for the cluster.
        # 
        # Default value: false.
        self.deletion_protection = deletion_protection
        # The deployment mode of master nodes in the cluster. Valid values:
        # 
        # *   NORMAL: regular mode. This is the default value. A cluster that contains only one master node is created.
        # *   HA: high availability (HA) mode. A cluster that contains three master nodes is created.
        self.deploy_mode = deploy_mode
        # The cluster description.
        self.description = description
        # The node attributes. The basic attributes of all ECS nodes in the cluster.
        # 
        # This parameter is required.
        self.node_attributes = node_attributes
        # The array of configurations of the node groups. Number of elements in the array: 1 to 100.
        # 
        # This parameter is required.
        self.node_groups = node_groups
        # The billing cycle of the instance. Valid values:
        # 
        # *   PayAsYouGo: pay-as-you-go
        # *   Subscription: subscription
        # 
        # Default value: PayAsYouGo.
        self.payment_type = payment_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The EMR version. You can query available E-MapReduce (EMR) versions in the EMR console.
        # 
        # This parameter is required.
        self.release_version = release_version
        # The ID of the resource group to which to assign the ENI.
        self.resource_group_id = resource_group_id
        # The security mode of the cluster. Valid values:
        # 
        # *   NORMAL: disables Kerberos authentication for the cluster. This is the default value.
        # *   KERBEROS: enables Kerberos authentication for the cluster.
        self.security_mode = security_mode
        # The subscription configurations. This parameter takes effect only if you set the PaymentType parameter to Subscription.
        self.subscription_config = subscription_config
        # The tag. Number of elements in the array: 0 to 20.
        self.tags = tags

    def validate(self):
        if self.application_configs:
            for k in self.application_configs:
                if k:
                    k.validate()
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()
        if self.bootstrap_scripts:
            for k in self.bootstrap_scripts:
                if k:
                    k.validate()
        if self.node_attributes:
            self.node_attributes.validate()
        if self.node_groups:
            for k in self.node_groups:
                if k:
                    k.validate()
        if self.subscription_config:
            self.subscription_config.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationConfigs'] = []
        if self.application_configs is not None:
            for k in self.application_configs:
                result['ApplicationConfigs'].append(k.to_map() if k else None)
        result['Applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['Applications'].append(k.to_map() if k else None)
        result['BootstrapScripts'] = []
        if self.bootstrap_scripts is not None:
            for k in self.bootstrap_scripts:
                result['BootstrapScripts'].append(k.to_map() if k else None)
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.node_attributes is not None:
            result['NodeAttributes'] = self.node_attributes.to_map()
        result['NodeGroups'] = []
        if self.node_groups is not None:
            for k in self.node_groups:
                result['NodeGroups'].append(k.to_map() if k else None)
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_version is not None:
            result['ReleaseVersion'] = self.release_version
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_mode is not None:
            result['SecurityMode'] = self.security_mode
        if self.subscription_config is not None:
            result['SubscriptionConfig'] = self.subscription_config.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_configs = []
        if m.get('ApplicationConfigs') is not None:
            for k in m.get('ApplicationConfigs'):
                temp_model = ApplicationConfig()
                self.application_configs.append(temp_model.from_map(k))
        self.applications = []
        if m.get('Applications') is not None:
            for k in m.get('Applications'):
                temp_model = Application()
                self.applications.append(temp_model.from_map(k))
        self.bootstrap_scripts = []
        if m.get('BootstrapScripts') is not None:
            for k in m.get('BootstrapScripts'):
                temp_model = Script()
                self.bootstrap_scripts.append(temp_model.from_map(k))
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NodeAttributes') is not None:
            temp_model = NodeAttributes()
            self.node_attributes = temp_model.from_map(m['NodeAttributes'])
        self.node_groups = []
        if m.get('NodeGroups') is not None:
            for k in m.get('NodeGroups'):
                temp_model = NodeGroupConfig()
                self.node_groups.append(temp_model.from_map(k))
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseVersion') is not None:
            self.release_version = m.get('ReleaseVersion')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityMode') is not None:
            self.security_mode = m.get('SecurityMode')
        if m.get('SubscriptionConfig') is not None:
            temp_model = SubscriptionConfig()
            self.subscription_config = temp_model.from_map(m['SubscriptionConfig'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class CreateClusterResponseBody(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        operation_id: str = None,
        request_id: str = None,
    ):
        # The ID of cluster.
        self.cluster_id = cluster_id
        # The ID of the operation.
        self.operation_id = operation_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNodeGroupRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        node_group: NodeGroupConfig = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The information about the node group.
        # 
        # This parameter is required.
        self.node_group = node_group
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        if self.node_group:
            self.node_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.node_group is not None:
            result['NodeGroup'] = self.node_group.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('NodeGroup') is not None:
            temp_model = NodeGroupConfig()
            self.node_group = temp_model.from_map(m['NodeGroup'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateNodeGroupResponseBody(TeaModel):
    def __init__(
        self,
        node_group_id: str = None,
        request_id: str = None,
    ):
        # The ID of the machine group.
        self.node_group_id = node_group_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNodeGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNodeGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNodeGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateScriptRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        script_type: str = None,
        scripts: List[Script] = None,
        timeout_secs: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the script. Valid values:
        # 
        # *   BOOTSTRAP: indicates a bootstrap action of the Elastic Compute Service (ECS) instance.
        # *   NORMAL: indicates a common script.
        # 
        # This parameter is required.
        self.script_type = script_type
        # The list of scripts.
        # 
        # This parameter is required.
        self.scripts = scripts
        # The timeout period for a manual execution script. You cannot specify a timeout period for a bootstrap action.
        self.timeout_secs = timeout_secs

    def validate(self):
        if self.scripts:
            for k in self.scripts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.script_type is not None:
            result['ScriptType'] = self.script_type
        result['Scripts'] = []
        if self.scripts is not None:
            for k in self.scripts:
                result['Scripts'].append(k.to_map() if k else None)
        if self.timeout_secs is not None:
            result['TimeoutSecs'] = self.timeout_secs
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScriptType') is not None:
            self.script_type = m.get('ScriptType')
        self.scripts = []
        if m.get('Scripts') is not None:
            for k in m.get('Scripts'):
                temp_model = Script()
                self.scripts.append(temp_model.from_map(k))
        if m.get('TimeoutSecs') is not None:
            self.timeout_secs = m.get('TimeoutSecs')
        return self


class CreateScriptResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        script_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The script ID.
        self.script_id = script_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.script_id is not None:
            result['ScriptId'] = self.script_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScriptId') is not None:
            self.script_id = m.get('ScriptId')
        return self


class CreateScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUsersRequestUsers(TeaModel):
    def __init__(
        self,
        password: str = None,
        user_name: str = None,
    ):
        # 用户密码。
        # 
        # This parameter is required.
        self.password = password
        # 用户名。
        # 
        # This parameter is required.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.password is not None:
            result['Password'] = self.password
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class CreateUsersRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        users: List[CreateUsersRequestUsers] = None,
    ):
        # 集群ID。
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # 区域ID。
        # 
        # This parameter is required.
        self.region_id = region_id
        # 用户列表。
        # 
        # This parameter is required.
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = CreateUsersRequestUsers()
                self.users.append(temp_model.from_map(k))
        return self


class CreateUsersResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DecreaseNodesRequest(TeaModel):
    def __init__(
        self,
        batch_interval: int = None,
        batch_size: int = None,
        cluster_id: str = None,
        decrease_node_count: int = None,
        node_group_id: str = None,
        node_ids: List[str] = None,
        region_id: str = None,
    ):
        # The cooldown interval between two batches.
        self.batch_interval = batch_interval
        # The number of nodes to be removed in a single batch.
        self.batch_size = batch_size
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The number of nodes to scale out. The number of nodes to be scaled out. The value should be less than the number of surviving nodes in the current node group.
        self.decrease_node_count = decrease_node_count
        # The ID of the node group.
        # 
        # This parameter is required.
        self.node_group_id = node_group_id
        # The array of node IDs. Valid values of array element N: 1 to 500.
        self.node_ids = node_ids
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_interval is not None:
            result['BatchInterval'] = self.batch_interval
        if self.batch_size is not None:
            result['BatchSize'] = self.batch_size
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.decrease_node_count is not None:
            result['DecreaseNodeCount'] = self.decrease_node_count
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_ids is not None:
            result['NodeIds'] = self.node_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchInterval') is not None:
            self.batch_interval = m.get('BatchInterval')
        if m.get('BatchSize') is not None:
            self.batch_size = m.get('BatchSize')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DecreaseNodeCount') is not None:
            self.decrease_node_count = m.get('DecreaseNodeCount')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeIds') is not None:
            self.node_ids = m.get('NodeIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DecreaseNodesResponseBody(TeaModel):
    def __init__(
        self,
        operation_id: str = None,
        request_id: str = None,
    ):
        # Operation ID.
        self.operation_id = operation_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DecreaseNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DecreaseNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DecreaseNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteApiTemplateRequest(TeaModel):
    def __init__(
        self,
        api_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        template_id: str = None,
    ):
        # Interface name.
        # 
        # This parameter is required.
        self.api_name = api_name
        # Region ID
        # 
        # This parameter is required.
        self.region_id = region_id
        # Resource group ID.
        self.resource_group_id = resource_group_id
        # Cluster template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_name is not None:
            result['ApiName'] = self.api_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiName') is not None:
            self.api_name = m.get('ApiName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteApiTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Whether the call was successful: - true: Call succeeded - false: Call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteApiTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteApiTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteApiTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteClusterResponseBody(TeaModel):
    def __init__(
        self,
        operation_id: str = None,
        request_id: str = None,
    ):
        # The ID of the operation.
        self.operation_id = operation_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteScriptRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        script_id: str = None,
        script_type: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The script ID.
        # 
        # This parameter is required.
        self.script_id = script_id
        # The type of the script. Valid values:
        # 
        # *   BOOTSTRAP: indicates a bootstrap action of the Elastic Compute Service (ECS) instance.
        # *   NORMAL: indicates a common script.
        # 
        # This parameter is required.
        self.script_type = script_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.script_id is not None:
            result['ScriptId'] = self.script_id
        if self.script_type is not None:
            result['ScriptType'] = self.script_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScriptId') is not None:
            self.script_id = m.get('ScriptId')
        if m.get('ScriptType') is not None:
            self.script_type = m.get('ScriptType')
        return self


class DeleteScriptResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUsersRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        user_names: List[str] = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The usernames. Number of elements in the array: 0 to 10.
        self.user_names = user_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_names is not None:
            result['UserNames'] = self.user_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserNames') is not None:
            self.user_names = m.get('UserNames')
        return self


class DeleteUsersShrinkRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        user_names_shrink: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The usernames. Number of elements in the array: 0 to 10.
        self.user_names_shrink = user_names_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_names_shrink is not None:
            result['UserNames'] = self.user_names_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserNames') is not None:
            self.user_names_shrink = m.get('UserNames')
        return self


class DeleteUsersResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the request was successful. Valid values: true and false.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetApiTemplateRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        template_id: str = None,
    ):
        # Region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Cluster template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetApiTemplateResponseBody(TeaModel):
    def __init__(
        self,
        data: ApiTemplate = None,
        request_id: str = None,
    ):
        # The content of the API operation template.
        self.data = data
        # Request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ApiTemplate()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetApiTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetApiTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetApiTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetApplicationRequest(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # 应用名称。
        # 
        # This parameter is required.
        self.application_name = application_name
        # 集群ID。
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # 地域ID。
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute(TeaModel):
    def __init__(
        self,
        description: str = None,
        value_increment_step: str = None,
        value_maximum: str = None,
        value_minimum: str = None,
        value_type: str = None,
        value_unit: str = None,
    ):
        # 值表述。
        self.description = description
        # 值步长。
        self.value_increment_step = value_increment_step
        # 最大值。
        self.value_maximum = value_maximum
        # 最小值。
        self.value_minimum = value_minimum
        # 属性值类型。
        self.value_type = value_type
        # 值单位。
        self.value_unit = value_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.value_increment_step is not None:
            result['ValueIncrementStep'] = self.value_increment_step
        if self.value_maximum is not None:
            result['ValueMaximum'] = self.value_maximum
        if self.value_minimum is not None:
            result['ValueMinimum'] = self.value_minimum
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        if self.value_unit is not None:
            result['ValueUnit'] = self.value_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ValueIncrementStep') is not None:
            self.value_increment_step = m.get('ValueIncrementStep')
        if m.get('ValueMaximum') is not None:
            self.value_maximum = m.get('ValueMaximum')
        if m.get('ValueMinimum') is not None:
            self.value_minimum = m.get('ValueMinimum')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        if m.get('ValueUnit') is not None:
            self.value_unit = m.get('ValueUnit')
        return self


class GetApplicationResponseBodyApplicationActionsActionParams(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        value_attribute: GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute = None,
    ):
        # 动作参数描述。
        self.description = description
        # 动作参数KEY。
        self.key = key
        # 动作参数属性。
        self.value_attribute = value_attribute

    def validate(self):
        if self.value_attribute:
            self.value_attribute.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        if self.value_attribute is not None:
            result['ValueAttribute'] = self.value_attribute.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('ValueAttribute') is not None:
            temp_model = GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute()
            self.value_attribute = temp_model.from_map(m['ValueAttribute'])
        return self


class GetApplicationResponseBodyApplicationActions(TeaModel):
    def __init__(
        self,
        action_name: str = None,
        action_params: List[GetApplicationResponseBodyApplicationActionsActionParams] = None,
        command: str = None,
        component_name: str = None,
        description: str = None,
        run_action_scope: str = None,
    ):
        # 操作名称。
        self.action_name = action_name
        # 操作参数。
        self.action_params = action_params
        # 命令。
        self.command = command
        # 组件名称。
        self.component_name = component_name
        # 操作描述。
        self.description = description
        # 执行范围。
        self.run_action_scope = run_action_scope

    def validate(self):
        if self.action_params:
            for k in self.action_params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_name is not None:
            result['ActionName'] = self.action_name
        result['ActionParams'] = []
        if self.action_params is not None:
            for k in self.action_params:
                result['ActionParams'].append(k.to_map() if k else None)
        if self.command is not None:
            result['Command'] = self.command
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.description is not None:
            result['Description'] = self.description
        if self.run_action_scope is not None:
            result['RunActionScope'] = self.run_action_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionName') is not None:
            self.action_name = m.get('ActionName')
        self.action_params = []
        if m.get('ActionParams') is not None:
            for k in m.get('ActionParams'):
                temp_model = GetApplicationResponseBodyApplicationActionsActionParams()
                self.action_params.append(temp_model.from_map(k))
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RunActionScope') is not None:
            self.run_action_scope = m.get('RunActionScope')
        return self


class GetApplicationResponseBodyApplication(TeaModel):
    def __init__(
        self,
        actions: List[GetApplicationResponseBodyApplicationActions] = None,
        application_name: str = None,
        application_state: str = None,
        application_version: str = None,
        community_version: str = None,
    ):
        # 操作列表。
        self.actions = actions
        # 应用名称。
        self.application_name = application_name
        # 应用操作状态。
        self.application_state = application_state
        # 应用版本。
        self.application_version = application_version
        # 社区版本。
        self.community_version = community_version

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['Actions'].append(k.to_map() if k else None)
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.application_state is not None:
            result['ApplicationState'] = self.application_state
        if self.application_version is not None:
            result['ApplicationVersion'] = self.application_version
        if self.community_version is not None:
            result['CommunityVersion'] = self.community_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('Actions') is not None:
            for k in m.get('Actions'):
                temp_model = GetApplicationResponseBodyApplicationActions()
                self.actions.append(temp_model.from_map(k))
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ApplicationState') is not None:
            self.application_state = m.get('ApplicationState')
        if m.get('ApplicationVersion') is not None:
            self.application_version = m.get('ApplicationVersion')
        if m.get('CommunityVersion') is not None:
            self.community_version = m.get('CommunityVersion')
        return self


class GetApplicationResponseBody(TeaModel):
    def __init__(
        self,
        application: GetApplicationResponseBodyApplication = None,
        request_id: str = None,
    ):
        self.application = application
        # 请求ID。
        self.request_id = request_id

    def validate(self):
        if self.application:
            self.application.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application is not None:
            result['Application'] = self.application.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Application') is not None:
            temp_model = GetApplicationResponseBodyApplication()
            self.application = temp_model.from_map(m['Application'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAutoScalingActivityRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        scaling_activity_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the scaling activity.
        # 
        # This parameter is required.
        self.scaling_activity_id = scaling_activity_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scaling_activity_id is not None:
            result['ScalingActivityId'] = self.scaling_activity_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScalingActivityId') is not None:
            self.scaling_activity_id = m.get('ScalingActivityId')
        return self


class GetAutoScalingActivityResponseBodyScalingActivity(TeaModel):
    def __init__(
        self,
        activity_id: str = None,
        activity_results: List[ScalingActivityResult] = None,
        activity_state: str = None,
        activity_type: str = None,
        cluster_id: str = None,
        description: str = None,
        end_time: int = None,
        expect_num: int = None,
        node_group_id: str = None,
        node_group_name: str = None,
        operation_id: str = None,
        policy_type: str = None,
        rule_detail: ScalingRule = None,
        rule_name: str = None,
        start_time: int = None,
    ):
        # The ID of the scaling activity.
        self.activity_id = activity_id
        # The instances that correspond to the scaling activity.
        self.activity_results = activity_results
        # The status of the scaling activity. Valid values:
        # 
        # *   REJECTED
        # *   SUCCESSFUL
        # *   FAILED
        # *   IN_PROGRESS
        self.activity_state = activity_state
        # The type of the scaling activity. Valid value:
        # 
        # *   SCALE_OUT
        # *   SCALE_IN
        self.activity_type = activity_type
        # The cluster ID.
        self.cluster_id = cluster_id
        # The description of the scaling activity.
        self.description = description
        # The time when scaling ended.
        self.end_time = end_time
        # The number of added or removed instances.
        self.expect_num = expect_num
        # The ID of the node group.
        self.node_group_id = node_group_id
        # The name of the node group.
        self.node_group_name = node_group_name
        # The operation ID.
        self.operation_id = operation_id
        # The policy type.
        self.policy_type = policy_type
        # The description of the scaling rule.
        self.rule_detail = rule_detail
        # The name of the scaling rule.
        self.rule_name = rule_name
        # The time when scaling started.
        self.start_time = start_time

    def validate(self):
        if self.activity_results:
            for k in self.activity_results:
                if k:
                    k.validate()
        if self.rule_detail:
            self.rule_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        result['ActivityResults'] = []
        if self.activity_results is not None:
            for k in self.activity_results:
                result['ActivityResults'].append(k.to_map() if k else None)
        if self.activity_state is not None:
            result['ActivityState'] = self.activity_state
        if self.activity_type is not None:
            result['ActivityType'] = self.activity_type
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.expect_num is not None:
            result['ExpectNum'] = self.expect_num
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.policy_type is not None:
            result['PolicyType'] = self.policy_type
        if self.rule_detail is not None:
            result['RuleDetail'] = self.rule_detail.to_map()
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        self.activity_results = []
        if m.get('ActivityResults') is not None:
            for k in m.get('ActivityResults'):
                temp_model = ScalingActivityResult()
                self.activity_results.append(temp_model.from_map(k))
        if m.get('ActivityState') is not None:
            self.activity_state = m.get('ActivityState')
        if m.get('ActivityType') is not None:
            self.activity_type = m.get('ActivityType')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExpectNum') is not None:
            self.expect_num = m.get('ExpectNum')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('PolicyType') is not None:
            self.policy_type = m.get('PolicyType')
        if m.get('RuleDetail') is not None:
            temp_model = ScalingRule()
            self.rule_detail = temp_model.from_map(m['RuleDetail'])
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetAutoScalingActivityResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        scaling_activity: GetAutoScalingActivityResponseBodyScalingActivity = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the scaling activity.
        self.scaling_activity = scaling_activity

    def validate(self):
        if self.scaling_activity:
            self.scaling_activity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scaling_activity is not None:
            result['ScalingActivity'] = self.scaling_activity.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScalingActivity') is not None:
            temp_model = GetAutoScalingActivityResponseBodyScalingActivity()
            self.scaling_activity = temp_model.from_map(m['ScalingActivity'])
        return self


class GetAutoScalingActivityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAutoScalingActivityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAutoScalingActivityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAutoScalingPolicyRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        node_group_id: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the node group.
        # 
        # This parameter is required.
        self.node_group_id = node_group_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetAutoScalingPolicyResponseBodyScalingPolicyConstraints(TeaModel):
    def __init__(
        self,
        max_capacity: int = None,
        min_capacity: int = None,
    ):
        # The maximum number of nodes in the node group. Default value: 2000.
        self.max_capacity = max_capacity
        # The minimum number of nodes in the node group. Default value: 0.
        self.min_capacity = min_capacity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity is not None:
            result['MaxCapacity'] = self.max_capacity
        if self.min_capacity is not None:
            result['MinCapacity'] = self.min_capacity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxCapacity') is not None:
            self.max_capacity = m.get('MaxCapacity')
        if m.get('MinCapacity') is not None:
            self.min_capacity = m.get('MinCapacity')
        return self


class GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules(TeaModel):
    def __init__(
        self,
        activity_type: str = None,
        adjustment_type: str = None,
        adjustment_value: int = None,
        metrics_trigger: MetricsTrigger = None,
        rule_name: str = None,
        time_trigger: TimeTrigger = None,
        trigger_type: str = None,
    ):
        # The scaling type. Valid values:
        # 
        # *   SCALE_OUT
        # *   SCALE_IN
        self.activity_type = activity_type
        # The adjustment type.
        self.adjustment_type = adjustment_type
        # The adjustment value. The parameter value must be a positive integer, which indicates the number of instances that you want to add or remove.
        self.adjustment_value = adjustment_value
        # The description of load-based scaling.
        self.metrics_trigger = metrics_trigger
        # The name of the auto scaling rule.
        self.rule_name = rule_name
        # The description of time-based scaling.
        self.time_trigger = time_trigger
        # The type of the auto scaling rule. Valid values:
        # 
        # *   TIME_TRIGGER: time-based scaling
        # *   METRICS_TRIGGER: load-based scaling
        self.trigger_type = trigger_type

    def validate(self):
        if self.metrics_trigger:
            self.metrics_trigger.validate()
        if self.time_trigger:
            self.time_trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_type is not None:
            result['ActivityType'] = self.activity_type
        if self.adjustment_type is not None:
            result['AdjustmentType'] = self.adjustment_type
        if self.adjustment_value is not None:
            result['AdjustmentValue'] = self.adjustment_value
        if self.metrics_trigger is not None:
            result['MetricsTrigger'] = self.metrics_trigger.to_map()
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.time_trigger is not None:
            result['TimeTrigger'] = self.time_trigger.to_map()
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityType') is not None:
            self.activity_type = m.get('ActivityType')
        if m.get('AdjustmentType') is not None:
            self.adjustment_type = m.get('AdjustmentType')
        if m.get('AdjustmentValue') is not None:
            self.adjustment_value = m.get('AdjustmentValue')
        if m.get('MetricsTrigger') is not None:
            temp_model = MetricsTrigger()
            self.metrics_trigger = temp_model.from_map(m['MetricsTrigger'])
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('TimeTrigger') is not None:
            temp_model = TimeTrigger()
            self.time_trigger = temp_model.from_map(m['TimeTrigger'])
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class GetAutoScalingPolicyResponseBodyScalingPolicy(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        constraints: GetAutoScalingPolicyResponseBodyScalingPolicyConstraints = None,
        node_group_id: str = None,
        scaling_policy_id: str = None,
        scaling_rules: List[GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules] = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The maximum and minimum number of nodes in the node group.
        self.constraints = constraints
        # The ID of the node group.
        self.node_group_id = node_group_id
        # The ID of the scaling policy.
        self.scaling_policy_id = scaling_policy_id
        # The auto scaling rules.
        self.scaling_rules = scaling_rules

    def validate(self):
        if self.constraints:
            self.constraints.validate()
        if self.scaling_rules:
            for k in self.scaling_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.constraints is not None:
            result['Constraints'] = self.constraints.to_map()
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.scaling_policy_id is not None:
            result['ScalingPolicyId'] = self.scaling_policy_id
        result['ScalingRules'] = []
        if self.scaling_rules is not None:
            for k in self.scaling_rules:
                result['ScalingRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Constraints') is not None:
            temp_model = GetAutoScalingPolicyResponseBodyScalingPolicyConstraints()
            self.constraints = temp_model.from_map(m['Constraints'])
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('ScalingPolicyId') is not None:
            self.scaling_policy_id = m.get('ScalingPolicyId')
        self.scaling_rules = []
        if m.get('ScalingRules') is not None:
            for k in m.get('ScalingRules'):
                temp_model = GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules()
                self.scaling_rules.append(temp_model.from_map(k))
        return self


class GetAutoScalingPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        scaling_policy: GetAutoScalingPolicyResponseBodyScalingPolicy = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The auto scaling policy.
        self.scaling_policy = scaling_policy

    def validate(self):
        if self.scaling_policy:
            self.scaling_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scaling_policy is not None:
            result['ScalingPolicy'] = self.scaling_policy.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScalingPolicy') is not None:
            temp_model = GetAutoScalingPolicyResponseBodyScalingPolicy()
            self.scaling_policy = temp_model.from_map(m['ScalingPolicy'])
        return self


class GetAutoScalingPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAutoScalingPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAutoScalingPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetClusterResponseBody(TeaModel):
    def __init__(
        self,
        cluster: Cluster = None,
        request_id: str = None,
    ):
        # The details of the cluster.
        self.cluster = cluster
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.cluster:
            self.cluster.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['Cluster'] = self.cluster.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cluster') is not None:
            temp_model = Cluster()
            self.cluster = temp_model.from_map(m['Cluster'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterCloneMetaRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesConstraints(TeaModel):
    def __init__(
        self,
        max_capacity: int = None,
        max_on_demand_capacity: int = None,
        min_capacity: int = None,
    ):
        # The maximum number of nodes in the node group. Default value: 2000.
        self.max_capacity = max_capacity
        # The maximum number of pay-as-you-go nodes in the node group.
        self.max_on_demand_capacity = max_on_demand_capacity
        # The minimum number of nodes in the node group. Default value: 0.
        self.min_capacity = min_capacity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity is not None:
            result['MaxCapacity'] = self.max_capacity
        if self.max_on_demand_capacity is not None:
            result['MaxOnDemandCapacity'] = self.max_on_demand_capacity
        if self.min_capacity is not None:
            result['MinCapacity'] = self.min_capacity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxCapacity') is not None:
            self.max_capacity = m.get('MaxCapacity')
        if m.get('MaxOnDemandCapacity') is not None:
            self.max_on_demand_capacity = m.get('MaxOnDemandCapacity')
        if m.get('MinCapacity') is not None:
            self.min_capacity = m.get('MinCapacity')
        return self


class GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesScalingRules(TeaModel):
    def __init__(
        self,
        activity_type: str = None,
        adjustment_value: int = None,
        metrics_trigger: MetricsTrigger = None,
        rule_name: str = None,
        time_trigger: TimeTrigger = None,
        trigger_type: str = None,
    ):
        # The scaling type. This parameter is required. Valid values:
        # 
        # *   SCALE_OUT
        # *   SCALE_IN
        self.activity_type = activity_type
        # The adjustment value of the auto scaling rule. This parameter is required. The parameter value must be a positive integer, which indicates the number of instances to be added or removed.
        self.adjustment_value = adjustment_value
        # The description of load-based scaling.
        self.metrics_trigger = metrics_trigger
        # The name of the auto scaling rule.
        self.rule_name = rule_name
        # The description of time-based scaling.
        self.time_trigger = time_trigger
        # The trigger mode of the auto scaling rule. This parameter is required. Valid values:
        # 
        # *   TIME_TRIGGER: time-based scaling.
        # *   METRICS_TRIGGER: load-based scaling.
        self.trigger_type = trigger_type

    def validate(self):
        if self.metrics_trigger:
            self.metrics_trigger.validate()
        if self.time_trigger:
            self.time_trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_type is not None:
            result['ActivityType'] = self.activity_type
        if self.adjustment_value is not None:
            result['AdjustmentValue'] = self.adjustment_value
        if self.metrics_trigger is not None:
            result['MetricsTrigger'] = self.metrics_trigger.to_map()
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.time_trigger is not None:
            result['TimeTrigger'] = self.time_trigger.to_map()
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityType') is not None:
            self.activity_type = m.get('ActivityType')
        if m.get('AdjustmentValue') is not None:
            self.adjustment_value = m.get('AdjustmentValue')
        if m.get('MetricsTrigger') is not None:
            temp_model = MetricsTrigger()
            self.metrics_trigger = temp_model.from_map(m['MetricsTrigger'])
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('TimeTrigger') is not None:
            temp_model = TimeTrigger()
            self.time_trigger = temp_model.from_map(m['TimeTrigger'])
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPolicies(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        constraints: GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesConstraints = None,
        node_group_id: str = None,
        node_group_name: str = None,
        scaling_policy_id: str = None,
        scaling_policy_type: str = None,
        scaling_rules: List[GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesScalingRules] = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The maximum and minimum number of nodes in the node group.
        self.constraints = constraints
        # The node group ID.
        self.node_group_id = node_group_id
        # The name of the node group.
        self.node_group_name = node_group_name
        # The ID of the auto scaling policy.
        self.scaling_policy_id = scaling_policy_id
        # The type of the auto scaling policy.
        self.scaling_policy_type = scaling_policy_type
        # The auto scaling rules.
        self.scaling_rules = scaling_rules

    def validate(self):
        if self.constraints:
            self.constraints.validate()
        if self.scaling_rules:
            for k in self.scaling_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.constraints is not None:
            result['Constraints'] = self.constraints.to_map()
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.scaling_policy_id is not None:
            result['ScalingPolicyId'] = self.scaling_policy_id
        if self.scaling_policy_type is not None:
            result['ScalingPolicyType'] = self.scaling_policy_type
        result['ScalingRules'] = []
        if self.scaling_rules is not None:
            for k in self.scaling_rules:
                result['ScalingRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Constraints') is not None:
            temp_model = GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesConstraints()
            self.constraints = temp_model.from_map(m['Constraints'])
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('ScalingPolicyId') is not None:
            self.scaling_policy_id = m.get('ScalingPolicyId')
        if m.get('ScalingPolicyType') is not None:
            self.scaling_policy_type = m.get('ScalingPolicyType')
        self.scaling_rules = []
        if m.get('ScalingRules') is not None:
            for k in m.get('ScalingRules'):
                temp_model = GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesScalingRules()
                self.scaling_rules.append(temp_model.from_map(k))
        return self


class GetClusterCloneMetaResponseBodyClusterCloneMeta(TeaModel):
    def __init__(
        self,
        application_configs: List[ApplicationConfig] = None,
        applications: List[Application] = None,
        bootstrap_scripts: List[Script] = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_state: str = None,
        cluster_type: str = None,
        deletion_protection: bool = None,
        deploy_mode: str = None,
        emr_default_role: str = None,
        exist_clone_config: bool = None,
        node_attributes: NodeAttributes = None,
        node_groups: List[NodeGroup] = None,
        payment_type: str = None,
        region_id: str = None,
        release_version: str = None,
        resource_group_id: str = None,
        scaling_policies: List[GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPolicies] = None,
        security_mode: str = None,
        subscription_config: SubscriptionConfig = None,
        tags: List[Tag] = None,
    ):
        # The modified configuration items.
        self.application_configs = application_configs
        # The cluster applications.
        self.applications = applications
        # An array of bootstrap scripts. The number of elements in the array: 1 to 10.
        self.bootstrap_scripts = bootstrap_scripts
        # The cluster ID.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The status of the cluster. Valid values:
        # 
        # *   STARTING
        # *   START_FAILED
        # *   BOOTSTRAPPING
        # *   RUNNING
        # *   TERMINATING
        # *   TERMINATED
        # *   TERMINATED_WITH_ERRORS
        # *   TERMINATE_FAILED
        self.cluster_state = cluster_state
        # The cluster type. Valid values:
        # 
        # *   DATALAKE
        # *   OLAP
        # *   DATAFLOW
        # *   DATASERVING
        # *   CUSTOM
        # *   HADOOP
        self.cluster_type = cluster_type
        # Indicates whether release protection is enabled for the cluster. Valid values:
        # 
        # *   true: Release protection is enabled for the cluster.
        # *   false: Release protection is disabled for the cluster.
        # 
        # Default value: false.
        self.deletion_protection = deletion_protection
        # The deployment mode of master nodes in the cluster. Valid values:
        # 
        # *   NORMAL: regular mode.
        # *   HA: high availability mode.
        self.deploy_mode = deploy_mode
        # The EMR service role.
        self.emr_default_role = emr_default_role
        # Indicates whether the service configurations of a Hadoop cluster that you made during cluster creation can be cloned. Valid values:
        # 
        # *   False
        # *   True
        self.exist_clone_config = exist_clone_config
        # The node attributes.
        self.node_attributes = node_attributes
        # The node groups. The number of elements in the array: 1 to 100.
        self.node_groups = node_groups
        # The billing method of the cluster. Valid values:
        # 
        # *   PayAsYouGo
        # *   Subscription
        self.payment_type = payment_type
        # The region ID.
        self.region_id = region_id
        # The EMR version.
        self.release_version = release_version
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The auto scaling policies of each node group in the cluster.
        self.scaling_policies = scaling_policies
        # The security mode of the cluster. Valid values:
        # 
        # *   NORMAL: regular mode. Kerberos is not enabled.
        # *   KERBEROS: Kerberos mode. Kerberos is enabled.
        self.security_mode = security_mode
        # The subscription configurations.
        self.subscription_config = subscription_config
        # The list of cluster tags.
        self.tags = tags

    def validate(self):
        if self.application_configs:
            for k in self.application_configs:
                if k:
                    k.validate()
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()
        if self.bootstrap_scripts:
            for k in self.bootstrap_scripts:
                if k:
                    k.validate()
        if self.node_attributes:
            self.node_attributes.validate()
        if self.node_groups:
            for k in self.node_groups:
                if k:
                    k.validate()
        if self.scaling_policies:
            for k in self.scaling_policies:
                if k:
                    k.validate()
        if self.subscription_config:
            self.subscription_config.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationConfigs'] = []
        if self.application_configs is not None:
            for k in self.application_configs:
                result['ApplicationConfigs'].append(k.to_map() if k else None)
        result['Applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['Applications'].append(k.to_map() if k else None)
        result['BootstrapScripts'] = []
        if self.bootstrap_scripts is not None:
            for k in self.bootstrap_scripts:
                result['BootstrapScripts'].append(k.to_map() if k else None)
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_state is not None:
            result['ClusterState'] = self.cluster_state
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.emr_default_role is not None:
            result['EmrDefaultRole'] = self.emr_default_role
        if self.exist_clone_config is not None:
            result['ExistCloneConfig'] = self.exist_clone_config
        if self.node_attributes is not None:
            result['NodeAttributes'] = self.node_attributes.to_map()
        result['NodeGroups'] = []
        if self.node_groups is not None:
            for k in self.node_groups:
                result['NodeGroups'].append(k.to_map() if k else None)
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_version is not None:
            result['ReleaseVersion'] = self.release_version
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['ScalingPolicies'] = []
        if self.scaling_policies is not None:
            for k in self.scaling_policies:
                result['ScalingPolicies'].append(k.to_map() if k else None)
        if self.security_mode is not None:
            result['SecurityMode'] = self.security_mode
        if self.subscription_config is not None:
            result['SubscriptionConfig'] = self.subscription_config.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_configs = []
        if m.get('ApplicationConfigs') is not None:
            for k in m.get('ApplicationConfigs'):
                temp_model = ApplicationConfig()
                self.application_configs.append(temp_model.from_map(k))
        self.applications = []
        if m.get('Applications') is not None:
            for k in m.get('Applications'):
                temp_model = Application()
                self.applications.append(temp_model.from_map(k))
        self.bootstrap_scripts = []
        if m.get('BootstrapScripts') is not None:
            for k in m.get('BootstrapScripts'):
                temp_model = Script()
                self.bootstrap_scripts.append(temp_model.from_map(k))
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterState') is not None:
            self.cluster_state = m.get('ClusterState')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('EmrDefaultRole') is not None:
            self.emr_default_role = m.get('EmrDefaultRole')
        if m.get('ExistCloneConfig') is not None:
            self.exist_clone_config = m.get('ExistCloneConfig')
        if m.get('NodeAttributes') is not None:
            temp_model = NodeAttributes()
            self.node_attributes = temp_model.from_map(m['NodeAttributes'])
        self.node_groups = []
        if m.get('NodeGroups') is not None:
            for k in m.get('NodeGroups'):
                temp_model = NodeGroup()
                self.node_groups.append(temp_model.from_map(k))
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseVersion') is not None:
            self.release_version = m.get('ReleaseVersion')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.scaling_policies = []
        if m.get('ScalingPolicies') is not None:
            for k in m.get('ScalingPolicies'):
                temp_model = GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPolicies()
                self.scaling_policies.append(temp_model.from_map(k))
        if m.get('SecurityMode') is not None:
            self.security_mode = m.get('SecurityMode')
        if m.get('SubscriptionConfig') is not None:
            temp_model = SubscriptionConfig()
            self.subscription_config = temp_model.from_map(m['SubscriptionConfig'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class GetClusterCloneMetaResponseBody(TeaModel):
    def __init__(
        self,
        cluster_clone_meta: GetClusterCloneMetaResponseBodyClusterCloneMeta = None,
        request_id: str = None,
    ):
        # Cluster clone metadata.
        self.cluster_clone_meta = cluster_clone_meta
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.cluster_clone_meta:
            self.cluster_clone_meta.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_clone_meta is not None:
            result['ClusterCloneMeta'] = self.cluster_clone_meta.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterCloneMeta') is not None:
            temp_model = GetClusterCloneMetaResponseBodyClusterCloneMeta()
            self.cluster_clone_meta = temp_model.from_map(m['ClusterCloneMeta'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetClusterCloneMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClusterCloneMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterCloneMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cluster_id: str = None,
        date_time: str = None,
        region_id: str = None,
    ):
        # The ID of the job that is submitted to YARN.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorApplicationResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        score: int = None,
        suggestion: str = None,
    ):
        # The score of the job.
        self.score = score
        # The suggestion for running the job.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class GetDoctorApplicationResponseBodyDataMetricsMemSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorApplicationResponseBodyDataMetricsMemUtilization(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorApplicationResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        mem_seconds: GetDoctorApplicationResponseBodyDataMetricsMemSeconds = None,
        mem_utilization: GetDoctorApplicationResponseBodyDataMetricsMemUtilization = None,
        vcore_seconds: GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds = None,
        vcore_utilization: GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization = None,
    ):
        # The aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running.
        self.mem_seconds = mem_seconds
        # The memory usage.
        self.mem_utilization = mem_utilization
        # The aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running.
        self.vcore_seconds = vcore_seconds
        # The CPU utilization. The meaning is the same as that of the %CPU command in the output of the Linux top command.
        self.vcore_utilization = vcore_utilization

    def validate(self):
        if self.mem_seconds:
            self.mem_seconds.validate()
        if self.mem_utilization:
            self.mem_utilization.validate()
        if self.vcore_seconds:
            self.vcore_seconds.validate()
        if self.vcore_utilization:
            self.vcore_utilization.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mem_seconds is not None:
            result['MemSeconds'] = self.mem_seconds.to_map()
        if self.mem_utilization is not None:
            result['MemUtilization'] = self.mem_utilization.to_map()
        if self.vcore_seconds is not None:
            result['VcoreSeconds'] = self.vcore_seconds.to_map()
        if self.vcore_utilization is not None:
            result['VcoreUtilization'] = self.vcore_utilization.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemSeconds') is not None:
            temp_model = GetDoctorApplicationResponseBodyDataMetricsMemSeconds()
            self.mem_seconds = temp_model.from_map(m['MemSeconds'])
        if m.get('MemUtilization') is not None:
            temp_model = GetDoctorApplicationResponseBodyDataMetricsMemUtilization()
            self.mem_utilization = temp_model.from_map(m['MemUtilization'])
        if m.get('VcoreSeconds') is not None:
            temp_model = GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds()
            self.vcore_seconds = temp_model.from_map(m['VcoreSeconds'])
        if m.get('VcoreUtilization') is not None:
            temp_model = GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization()
            self.vcore_utilization = temp_model.from_map(m['VcoreUtilization'])
        return self


class GetDoctorApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: GetDoctorApplicationResponseBodyDataAnalysis = None,
        app_name: str = None,
        end_time: int = None,
        ids: List[str] = None,
        metrics: GetDoctorApplicationResponseBodyDataMetrics = None,
        query_sql: str = None,
        queue: str = None,
        start_time: int = None,
        type: str = None,
        user: str = None,
    ):
        # The job analysis result.
        self.analysis = analysis
        # The name of the job.
        self.app_name = app_name
        # The end time of the job. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.end_time = end_time
        # The job IDs. Multiple job IDs are separated with commas (,).
        self.ids = ids
        # The metric information.
        self.metrics = metrics
        # The SQL statement of the job. This parameter is left empty for non-SQL jobs.
        self.query_sql = query_sql
        # The YARN queue to which the job was submitted.
        self.queue = queue
        # The time when the job was submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.start_time = start_time
        # The type of the compute engine.
        self.type = type
        # The username that is used to submit the job.
        self.user = user

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.query_sql is not None:
            result['QuerySql'] = self.query_sql
        if self.queue is not None:
            result['Queue'] = self.queue
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = GetDoctorApplicationResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Metrics') is not None:
            temp_model = GetDoctorApplicationResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('QuerySql') is not None:
            self.query_sql = m.get('QuerySql')
        if m.get('Queue') is not None:
            self.queue = m.get('Queue')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class GetDoctorApplicationResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorApplicationResponseBodyData = None,
        request_id: str = None,
    ):
        # The details of the job.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorComputeSummaryRequestComponentInfo(TeaModel):
    def __init__(
        self,
        component_name: str = None,
        component_type: str = None,
    ):
        # Set the filter condition name based on the value of ComponentType. For example, if you set ComponentType to queue, you can specify a specific queue name to obtain the resource usage of a specific queue.
        self.component_name = component_name
        # The resource type for filtering. Valid values:
        # 
        # *   engine: filters results by engine.
        # *   queue: filters results by queue.
        # *   cluster: displays the results at the cluster level.
        # 
        # If you do not specify this parameter, the information at the cluster level is displayed by default.
        self.component_type = component_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.component_type is not None:
            result['ComponentType'] = self.component_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('ComponentType') is not None:
            self.component_type = m.get('ComponentType')
        return self


class GetDoctorComputeSummaryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        component_info: GetDoctorComputeSummaryRequestComponentInfo = None,
        date_time: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The resource information, which is used to filter the results.
        self.component_info = component_info
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        if self.component_info:
            self.component_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.component_info is not None:
            result['ComponentInfo'] = self.component_info.to_map()
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ComponentInfo') is not None:
            temp_model = GetDoctorComputeSummaryRequestComponentInfo()
            self.component_info = temp_model.from_map(m['ComponentInfo'])
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorComputeSummaryResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        healthy_job_count: int = None,
        need_attention_job_count: int = None,
        score: int = None,
        score_day_growth_ratio: float = None,
        sub_healthy_job_count: int = None,
        unhealthy_job_count: int = None,
    ):
        # The total number of healthy jobs.
        self.healthy_job_count = healthy_job_count
        # The total number of jobs that require attention.
        self.need_attention_job_count = need_attention_job_count
        # The score for jobs.
        self.score = score
        # The day-to-day growth rate of the score for jobs.
        self.score_day_growth_ratio = score_day_growth_ratio
        # The total number of sub-healthy jobs.
        self.sub_healthy_job_count = sub_healthy_job_count
        # The total number of unhealthy jobs.
        self.unhealthy_job_count = unhealthy_job_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.healthy_job_count is not None:
            result['HealthyJobCount'] = self.healthy_job_count
        if self.need_attention_job_count is not None:
            result['NeedAttentionJobCount'] = self.need_attention_job_count
        if self.score is not None:
            result['Score'] = self.score
        if self.score_day_growth_ratio is not None:
            result['ScoreDayGrowthRatio'] = self.score_day_growth_ratio
        if self.sub_healthy_job_count is not None:
            result['SubHealthyJobCount'] = self.sub_healthy_job_count
        if self.unhealthy_job_count is not None:
            result['UnhealthyJobCount'] = self.unhealthy_job_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HealthyJobCount') is not None:
            self.healthy_job_count = m.get('HealthyJobCount')
        if m.get('NeedAttentionJobCount') is not None:
            self.need_attention_job_count = m.get('NeedAttentionJobCount')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('ScoreDayGrowthRatio') is not None:
            self.score_day_growth_ratio = m.get('ScoreDayGrowthRatio')
        if m.get('SubHealthyJobCount') is not None:
            self.sub_healthy_job_count = m.get('SubHealthyJobCount')
        if m.get('UnhealthyJobCount') is not None:
            self.unhealthy_job_count = m.get('UnhealthyJobCount')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetricsReadSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorComputeSummaryResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        mem_seconds: GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds = None,
        mem_seconds_day_growth_ratio: GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio = None,
        mem_utilization: GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization = None,
        read_size: GetDoctorComputeSummaryResponseBodyDataMetricsReadSize = None,
        vcore_seconds: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds = None,
        vcore_seconds_day_growth_ratio: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio = None,
        vcore_utilization: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization = None,
        write_size: GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize = None,
    ):
        # The total memory consumption over time in seconds.
        self.mem_seconds = mem_seconds
        # The day-to-day growth rate of the total memory consumption over time in seconds.
        self.mem_seconds_day_growth_ratio = mem_seconds_day_growth_ratio
        # The average memory usage.
        self.mem_utilization = mem_utilization
        # The total amount of data read from the file system.
        self.read_size = read_size
        # The total CPU consumption over time in seconds.
        self.vcore_seconds = vcore_seconds
        # The day-to-day growth rate of the total CPU consumption over time in seconds.
        self.vcore_seconds_day_growth_ratio = vcore_seconds_day_growth_ratio
        # The average CPU utilization. The meaning is the same as the %CPU parameter in the output of the top command in Linux.
        self.vcore_utilization = vcore_utilization
        # The total amount of data written to the file system.
        self.write_size = write_size

    def validate(self):
        if self.mem_seconds:
            self.mem_seconds.validate()
        if self.mem_seconds_day_growth_ratio:
            self.mem_seconds_day_growth_ratio.validate()
        if self.mem_utilization:
            self.mem_utilization.validate()
        if self.read_size:
            self.read_size.validate()
        if self.vcore_seconds:
            self.vcore_seconds.validate()
        if self.vcore_seconds_day_growth_ratio:
            self.vcore_seconds_day_growth_ratio.validate()
        if self.vcore_utilization:
            self.vcore_utilization.validate()
        if self.write_size:
            self.write_size.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mem_seconds is not None:
            result['MemSeconds'] = self.mem_seconds.to_map()
        if self.mem_seconds_day_growth_ratio is not None:
            result['MemSecondsDayGrowthRatio'] = self.mem_seconds_day_growth_ratio.to_map()
        if self.mem_utilization is not None:
            result['MemUtilization'] = self.mem_utilization.to_map()
        if self.read_size is not None:
            result['ReadSize'] = self.read_size.to_map()
        if self.vcore_seconds is not None:
            result['VcoreSeconds'] = self.vcore_seconds.to_map()
        if self.vcore_seconds_day_growth_ratio is not None:
            result['VcoreSecondsDayGrowthRatio'] = self.vcore_seconds_day_growth_ratio.to_map()
        if self.vcore_utilization is not None:
            result['VcoreUtilization'] = self.vcore_utilization.to_map()
        if self.write_size is not None:
            result['WriteSize'] = self.write_size.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemSeconds') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds()
            self.mem_seconds = temp_model.from_map(m['MemSeconds'])
        if m.get('MemSecondsDayGrowthRatio') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio()
            self.mem_seconds_day_growth_ratio = temp_model.from_map(m['MemSecondsDayGrowthRatio'])
        if m.get('MemUtilization') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization()
            self.mem_utilization = temp_model.from_map(m['MemUtilization'])
        if m.get('ReadSize') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetricsReadSize()
            self.read_size = temp_model.from_map(m['ReadSize'])
        if m.get('VcoreSeconds') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds()
            self.vcore_seconds = temp_model.from_map(m['VcoreSeconds'])
        if m.get('VcoreSecondsDayGrowthRatio') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio()
            self.vcore_seconds_day_growth_ratio = temp_model.from_map(m['VcoreSecondsDayGrowthRatio'])
        if m.get('VcoreUtilization') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization()
            self.vcore_utilization = temp_model.from_map(m['VcoreUtilization'])
        if m.get('WriteSize') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize()
            self.write_size = temp_model.from_map(m['WriteSize'])
        return self


class GetDoctorComputeSummaryResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: GetDoctorComputeSummaryResponseBodyDataAnalysis = None,
        metrics: GetDoctorComputeSummaryResponseBodyDataMetrics = None,
    ):
        # The resource analysis information.
        self.analysis = analysis
        # The metrics.
        self.metrics = metrics

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('Metrics') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class GetDoctorComputeSummaryResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorComputeSummaryResponseBodyData = None,
        request_id: str = None,
    ):
        # The details of resource usage.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorComputeSummaryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorComputeSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorComputeSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorComputeSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHBaseClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorHBaseClusterResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        hbase_score: int = None,
    ):
        # The overall score of the HBase cluster.
        self.hbase_score = hbase_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hbase_score is not None:
            result['HbaseScore'] = self.hbase_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HbaseScore') is not None:
            self.hbase_score = m.get('HbaseScore')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsTableCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseClusterResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        avg_load: GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad = None,
        daily_read_request: GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest = None,
        daily_write_request: GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest = None,
        mem_heap: GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap = None,
        normal_avg_load: GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad = None,
        region_balance: GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance = None,
        region_count: GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount = None,
        region_server_count: GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount = None,
        store_file_count: GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount = None,
        table_count: GetDoctorHBaseClusterResponseBodyDataMetricsTableCount = None,
        total_data_size: GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize = None,
        total_read_request: GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest = None,
        total_request: GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest = None,
        total_write_request: GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest = None,
    ):
        # The average load.
        self.avg_load = avg_load
        # The number of read requests in a day.
        self.daily_read_request = daily_read_request
        # The number of write requests in a day.
        self.daily_write_request = daily_write_request
        # The memory size.
        self.mem_heap = mem_heap
        # The normal average load.
        self.normal_avg_load = normal_avg_load
        # The region balance degree.
        self.region_balance = region_balance
        # The number of regions.
        self.region_count = region_count
        # The number of region servers.
        self.region_server_count = region_server_count
        # The number of StoreFiles.
        self.store_file_count = store_file_count
        # The number of tables.
        self.table_count = table_count
        # The size of the cluster.
        self.total_data_size = total_data_size
        # The total number of read requests.
        self.total_read_request = total_read_request
        # The total number of requests in the cluster.
        self.total_request = total_request
        # The total number of write requests.
        self.total_write_request = total_write_request

    def validate(self):
        if self.avg_load:
            self.avg_load.validate()
        if self.daily_read_request:
            self.daily_read_request.validate()
        if self.daily_write_request:
            self.daily_write_request.validate()
        if self.mem_heap:
            self.mem_heap.validate()
        if self.normal_avg_load:
            self.normal_avg_load.validate()
        if self.region_balance:
            self.region_balance.validate()
        if self.region_count:
            self.region_count.validate()
        if self.region_server_count:
            self.region_server_count.validate()
        if self.store_file_count:
            self.store_file_count.validate()
        if self.table_count:
            self.table_count.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_read_request:
            self.total_read_request.validate()
        if self.total_request:
            self.total_request.validate()
        if self.total_write_request:
            self.total_write_request.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_load is not None:
            result['AvgLoad'] = self.avg_load.to_map()
        if self.daily_read_request is not None:
            result['DailyReadRequest'] = self.daily_read_request.to_map()
        if self.daily_write_request is not None:
            result['DailyWriteRequest'] = self.daily_write_request.to_map()
        if self.mem_heap is not None:
            result['MemHeap'] = self.mem_heap.to_map()
        if self.normal_avg_load is not None:
            result['NormalAvgLoad'] = self.normal_avg_load.to_map()
        if self.region_balance is not None:
            result['RegionBalance'] = self.region_balance.to_map()
        if self.region_count is not None:
            result['RegionCount'] = self.region_count.to_map()
        if self.region_server_count is not None:
            result['RegionServerCount'] = self.region_server_count.to_map()
        if self.store_file_count is not None:
            result['StoreFileCount'] = self.store_file_count.to_map()
        if self.table_count is not None:
            result['TableCount'] = self.table_count.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_read_request is not None:
            result['TotalReadRequest'] = self.total_read_request.to_map()
        if self.total_request is not None:
            result['TotalRequest'] = self.total_request.to_map()
        if self.total_write_request is not None:
            result['TotalWriteRequest'] = self.total_write_request.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgLoad') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad()
            self.avg_load = temp_model.from_map(m['AvgLoad'])
        if m.get('DailyReadRequest') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest()
            self.daily_read_request = temp_model.from_map(m['DailyReadRequest'])
        if m.get('DailyWriteRequest') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest()
            self.daily_write_request = temp_model.from_map(m['DailyWriteRequest'])
        if m.get('MemHeap') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap()
            self.mem_heap = temp_model.from_map(m['MemHeap'])
        if m.get('NormalAvgLoad') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad()
            self.normal_avg_load = temp_model.from_map(m['NormalAvgLoad'])
        if m.get('RegionBalance') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance()
            self.region_balance = temp_model.from_map(m['RegionBalance'])
        if m.get('RegionCount') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount()
            self.region_count = temp_model.from_map(m['RegionCount'])
        if m.get('RegionServerCount') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount()
            self.region_server_count = temp_model.from_map(m['RegionServerCount'])
        if m.get('StoreFileCount') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount()
            self.store_file_count = temp_model.from_map(m['StoreFileCount'])
        if m.get('TableCount') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsTableCount()
            self.table_count = temp_model.from_map(m['TableCount'])
        if m.get('TotalDataSize') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalReadRequest') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest()
            self.total_read_request = temp_model.from_map(m['TotalReadRequest'])
        if m.get('TotalRequest') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest()
            self.total_request = temp_model.from_map(m['TotalRequest'])
        if m.get('TotalWriteRequest') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest()
            self.total_write_request = temp_model.from_map(m['TotalWriteRequest'])
        return self


class GetDoctorHBaseClusterResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: GetDoctorHBaseClusterResponseBodyDataAnalysis = None,
        metrics: GetDoctorHBaseClusterResponseBodyDataMetrics = None,
    ):
        # The analysis result.
        self.analysis = analysis
        # The metric information.
        self.metrics = metrics

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class GetDoctorHBaseClusterResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHBaseClusterResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHBaseClusterResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHBaseClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHBaseClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHBaseClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHBaseRegionRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        hbase_region_id: str = None,
        region_id: str = None,
    ):
        # Cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # Region ID.
        # 
        # This parameter is required.
        self.hbase_region_id = hbase_region_id
        # Region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.hbase_region_id is not None:
            result['HbaseRegionId'] = self.hbase_region_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('HbaseRegionId') is not None:
            self.hbase_region_id = m.get('HbaseRegionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Metric name.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        daily_read_request: GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest = None,
        daily_write_request: GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest = None,
        store_file_count: GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount = None,
        total_read_request: GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest = None,
        total_write_request: GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest = None,
    ):
        # Number of read requests in a single day.
        self.daily_read_request = daily_read_request
        # Number of write requests in a single day.
        self.daily_write_request = daily_write_request
        # Store file count.
        self.store_file_count = store_file_count
        # Total read request count
        self.total_read_request = total_read_request
        # Total write request count
        self.total_write_request = total_write_request

    def validate(self):
        if self.daily_read_request:
            self.daily_read_request.validate()
        if self.daily_write_request:
            self.daily_write_request.validate()
        if self.store_file_count:
            self.store_file_count.validate()
        if self.total_read_request:
            self.total_read_request.validate()
        if self.total_write_request:
            self.total_write_request.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.daily_read_request is not None:
            result['DailyReadRequest'] = self.daily_read_request.to_map()
        if self.daily_write_request is not None:
            result['DailyWriteRequest'] = self.daily_write_request.to_map()
        if self.store_file_count is not None:
            result['StoreFileCount'] = self.store_file_count.to_map()
        if self.total_read_request is not None:
            result['TotalReadRequest'] = self.total_read_request.to_map()
        if self.total_write_request is not None:
            result['TotalWriteRequest'] = self.total_write_request.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DailyReadRequest') is not None:
            temp_model = GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest()
            self.daily_read_request = temp_model.from_map(m['DailyReadRequest'])
        if m.get('DailyWriteRequest') is not None:
            temp_model = GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest()
            self.daily_write_request = temp_model.from_map(m['DailyWriteRequest'])
        if m.get('StoreFileCount') is not None:
            temp_model = GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount()
            self.store_file_count = temp_model.from_map(m['StoreFileCount'])
        if m.get('TotalReadRequest') is not None:
            temp_model = GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest()
            self.total_read_request = temp_model.from_map(m['TotalReadRequest'])
        if m.get('TotalWriteRequest') is not None:
            temp_model = GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest()
            self.total_write_request = temp_model.from_map(m['TotalWriteRequest'])
        return self


class GetDoctorHBaseRegionResponseBodyData(TeaModel):
    def __init__(
        self,
        metrics: GetDoctorHBaseRegionResponseBodyDataMetrics = None,
        region_server_host: str = None,
        table_name: str = None,
    ):
        # Metrics information.
        self.metrics = metrics
        # Host of the RegionServer.
        self.region_server_host = region_server_host
        # Table name.
        self.table_name = table_name

    def validate(self):
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.region_server_host is not None:
            result['RegionServerHost'] = self.region_server_host
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHBaseRegionResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('RegionServerHost') is not None:
            self.region_server_host = m.get('RegionServerHost')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetDoctorHBaseRegionResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHBaseRegionResponseBodyData = None,
        request_id: str = None,
    ):
        # Returned data.
        self.data = data
        # Request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHBaseRegionResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHBaseRegionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHBaseRegionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHBaseRegionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHBaseRegionServerRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        region_id: str = None,
        region_server_host: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The host of the region server.
        # 
        # This parameter is required.
        self.region_server_host = region_server_host

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_server_host is not None:
            result['RegionServerHost'] = self.region_server_host
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionServerHost') is not None:
            self.region_server_host = m.get('RegionServerHost')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseRegionServerResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        avg_gc: GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc = None,
        cache_ratio: GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio = None,
        daily_read_request: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest = None,
        daily_read_request_day_growth_ratio: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio = None,
        daily_write_request: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest = None,
        daily_write_request_day_growth_ratio: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio = None,
        region_count: GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount = None,
        total_read_request: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest = None,
        total_request: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest = None,
        total_write_request: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest = None,
    ):
        # The average garbage collection (GC) duration.
        self.avg_gc = avg_gc
        # The cache hit ratio.
        self.cache_ratio = cache_ratio
        # The number of daily read requests.
        self.daily_read_request = daily_read_request
        # The day-to-day increment rate of the number of daily read requests.
        self.daily_read_request_day_growth_ratio = daily_read_request_day_growth_ratio
        # The number of daily write requests.
        self.daily_write_request = daily_write_request
        # The day-to-day increment rate of the number of daily write requests.
        self.daily_write_request_day_growth_ratio = daily_write_request_day_growth_ratio
        # The number of regions.
        self.region_count = region_count
        # The cumulative number of read requests.
        self.total_read_request = total_read_request
        # The cumulative number of total requests.
        self.total_request = total_request
        # The cumulative number of write requests.
        self.total_write_request = total_write_request

    def validate(self):
        if self.avg_gc:
            self.avg_gc.validate()
        if self.cache_ratio:
            self.cache_ratio.validate()
        if self.daily_read_request:
            self.daily_read_request.validate()
        if self.daily_read_request_day_growth_ratio:
            self.daily_read_request_day_growth_ratio.validate()
        if self.daily_write_request:
            self.daily_write_request.validate()
        if self.daily_write_request_day_growth_ratio:
            self.daily_write_request_day_growth_ratio.validate()
        if self.region_count:
            self.region_count.validate()
        if self.total_read_request:
            self.total_read_request.validate()
        if self.total_request:
            self.total_request.validate()
        if self.total_write_request:
            self.total_write_request.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_gc is not None:
            result['AvgGc'] = self.avg_gc.to_map()
        if self.cache_ratio is not None:
            result['CacheRatio'] = self.cache_ratio.to_map()
        if self.daily_read_request is not None:
            result['DailyReadRequest'] = self.daily_read_request.to_map()
        if self.daily_read_request_day_growth_ratio is not None:
            result['DailyReadRequestDayGrowthRatio'] = self.daily_read_request_day_growth_ratio.to_map()
        if self.daily_write_request is not None:
            result['DailyWriteRequest'] = self.daily_write_request.to_map()
        if self.daily_write_request_day_growth_ratio is not None:
            result['DailyWriteRequestDayGrowthRatio'] = self.daily_write_request_day_growth_ratio.to_map()
        if self.region_count is not None:
            result['RegionCount'] = self.region_count.to_map()
        if self.total_read_request is not None:
            result['TotalReadRequest'] = self.total_read_request.to_map()
        if self.total_request is not None:
            result['TotalRequest'] = self.total_request.to_map()
        if self.total_write_request is not None:
            result['TotalWriteRequest'] = self.total_write_request.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgGc') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc()
            self.avg_gc = temp_model.from_map(m['AvgGc'])
        if m.get('CacheRatio') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio()
            self.cache_ratio = temp_model.from_map(m['CacheRatio'])
        if m.get('DailyReadRequest') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest()
            self.daily_read_request = temp_model.from_map(m['DailyReadRequest'])
        if m.get('DailyReadRequestDayGrowthRatio') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio()
            self.daily_read_request_day_growth_ratio = temp_model.from_map(m['DailyReadRequestDayGrowthRatio'])
        if m.get('DailyWriteRequest') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest()
            self.daily_write_request = temp_model.from_map(m['DailyWriteRequest'])
        if m.get('DailyWriteRequestDayGrowthRatio') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio()
            self.daily_write_request_day_growth_ratio = temp_model.from_map(m['DailyWriteRequestDayGrowthRatio'])
        if m.get('RegionCount') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount()
            self.region_count = temp_model.from_map(m['RegionCount'])
        if m.get('TotalReadRequest') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest()
            self.total_read_request = temp_model.from_map(m['TotalReadRequest'])
        if m.get('TotalRequest') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest()
            self.total_request = temp_model.from_map(m['TotalRequest'])
        if m.get('TotalWriteRequest') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest()
            self.total_write_request = temp_model.from_map(m['TotalWriteRequest'])
        return self


class GetDoctorHBaseRegionServerResponseBodyData(TeaModel):
    def __init__(
        self,
        metrics: GetDoctorHBaseRegionServerResponseBodyDataMetrics = None,
    ):
        # The metric information.
        self.metrics = metrics

    def validate(self):
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class GetDoctorHBaseRegionServerResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHBaseRegionServerResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHBaseRegionServerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHBaseRegionServerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHBaseRegionServerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHBaseTableRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        region_id: str = None,
        table_name: str = None,
    ):
        # Cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # Region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Table name.
        # 
        # This parameter is required.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetDoctorHBaseTableResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        read_request_hotspot_region_list: List[str] = None,
        read_request_unbalance_suggestion: str = None,
        request_hotspot_region_list: List[str] = None,
        request_unbalance_suggestion: str = None,
        table_score: int = None,
        write_request_hotspot_region_list: List[str] = None,
        write_request_unbalance_suggestion: str = None,
    ):
        # List of read hotspot regions.
        self.read_request_hotspot_region_list = read_request_hotspot_region_list
        # Description of read imbalance.
        self.read_request_unbalance_suggestion = read_request_unbalance_suggestion
        # List of read/write hotspot regions.
        self.request_hotspot_region_list = request_hotspot_region_list
        # Description of read/write imbalance.
        self.request_unbalance_suggestion = request_unbalance_suggestion
        # Table score.
        self.table_score = table_score
        # List of write hotspot regions.
        self.write_request_hotspot_region_list = write_request_hotspot_region_list
        # Description of write imbalance.
        self.write_request_unbalance_suggestion = write_request_unbalance_suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.read_request_hotspot_region_list is not None:
            result['ReadRequestHotspotRegionList'] = self.read_request_hotspot_region_list
        if self.read_request_unbalance_suggestion is not None:
            result['ReadRequestUnbalanceSuggestion'] = self.read_request_unbalance_suggestion
        if self.request_hotspot_region_list is not None:
            result['RequestHotspotRegionList'] = self.request_hotspot_region_list
        if self.request_unbalance_suggestion is not None:
            result['RequestUnbalanceSuggestion'] = self.request_unbalance_suggestion
        if self.table_score is not None:
            result['TableScore'] = self.table_score
        if self.write_request_hotspot_region_list is not None:
            result['WriteRequestHotspotRegionList'] = self.write_request_hotspot_region_list
        if self.write_request_unbalance_suggestion is not None:
            result['WriteRequestUnbalanceSuggestion'] = self.write_request_unbalance_suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReadRequestHotspotRegionList') is not None:
            self.read_request_hotspot_region_list = m.get('ReadRequestHotspotRegionList')
        if m.get('ReadRequestUnbalanceSuggestion') is not None:
            self.read_request_unbalance_suggestion = m.get('ReadRequestUnbalanceSuggestion')
        if m.get('RequestHotspotRegionList') is not None:
            self.request_hotspot_region_list = m.get('RequestHotspotRegionList')
        if m.get('RequestUnbalanceSuggestion') is not None:
            self.request_unbalance_suggestion = m.get('RequestUnbalanceSuggestion')
        if m.get('TableScore') is not None:
            self.table_score = m.get('TableScore')
        if m.get('WriteRequestHotspotRegionList') is not None:
            self.write_request_hotspot_region_list = m.get('WriteRequestHotspotRegionList')
        if m.get('WriteRequestUnbalanceSuggestion') is not None:
            self.write_request_unbalance_suggestion = m.get('WriteRequestUnbalanceSuggestion')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # Unit of the metric.
        self.unit = unit
        # Value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Metric name.
        self.name = name
        # Unit of the metric.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the item.
        self.name = name
        # Unit of the metric.
        self.unit = unit
        # Value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Description of the metric.
        self.description = description
        # Metric name.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # Unit of the metric.
        self.unit = unit
        # Value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # Unit of the metric.
        self.unit = unit
        # Value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsLocality(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # Unit of the metric.
        self.unit = unit
        # Value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Description of the metric.
        self.description = description
        # Metric name.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsRegionCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Usage.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # Unit of the metric.
        self.unit = unit
        # Value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsTableSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Metric name.
        self.name = name
        # Unit of the metric
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Metric description.
        self.description = description
        # Metric name.
        self.name = name
        # Metric unit.
        self.unit = unit
        # Metric value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # Usage rate.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # Description of the metric.
        self.description = description
        # Name of the metric.
        self.name = name
        # Unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHBaseTableResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_access_day: GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay = None,
        cold_config_day: GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay = None,
        cold_data_size: GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize = None,
        daily_read_request: GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest = None,
        daily_read_request_day_growth_ratio: GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio = None,
        daily_write_request: GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest = None,
        daily_write_request_day_growth_ratio: GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio = None,
        freeze_config_day: GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay = None,
        freeze_data_size: GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize = None,
        hot_data_size: GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize = None,
        locality: GetDoctorHBaseTableResponseBodyDataMetricsLocality = None,
        read_request_balance: GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance = None,
        region_balance: GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance = None,
        region_count: GetDoctorHBaseTableResponseBodyDataMetricsRegionCount = None,
        region_count_day_growth_ratio: GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio = None,
        region_server_count: GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount = None,
        request_balance: GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance = None,
        store_file_count: GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount = None,
        store_file_count_day_growth_ratio: GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio = None,
        table_size: GetDoctorHBaseTableResponseBodyDataMetricsTableSize = None,
        table_size_day_growth_ratio: GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio = None,
        warm_config_day: GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay = None,
        warm_data_size: GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize = None,
        write_request_balance: GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance = None,
    ):
        # Number of days the table has not been accessed.
        self.cold_access_day = cold_access_day
        # Cold data access days configuration.
        self.cold_config_day = cold_config_day
        # Cold data size.
        self.cold_data_size = cold_data_size
        # Number of read requests per day.
        self.daily_read_request = daily_read_request
        # Daily growth ratio of daily read requests.
        self.daily_read_request_day_growth_ratio = daily_read_request_day_growth_ratio
        # Number of write requests per day.
        self.daily_write_request = daily_write_request
        # Daily write request growth ratio.
        self.daily_write_request_day_growth_ratio = daily_write_request_day_growth_ratio
        # Configuration for the number of days cold data is accessed.
        self.freeze_config_day = freeze_config_day
        # Frozen data size.
        self.freeze_data_size = freeze_data_size
        # Hot data size.
        self.hot_data_size = hot_data_size
        # Locality rate.
        self.locality = locality
        # Read request balance.
        self.read_request_balance = read_request_balance
        # Region balance.
        self.region_balance = region_balance
        # Number of regions.
        self.region_count = region_count
        # Daily incremental ratio of regions
        self.region_count_day_growth_ratio = region_count_day_growth_ratio
        # Number of RegionServers.
        self.region_server_count = region_server_count
        # Request balance.
        self.request_balance = request_balance
        # Number of store files.
        self.store_file_count = store_file_count
        # Daily growth ratio of store file count.
        self.store_file_count_day_growth_ratio = store_file_count_day_growth_ratio
        # Table size.
        self.table_size = table_size
        # Daily growth ratio of table size.
        self.table_size_day_growth_ratio = table_size_day_growth_ratio
        # Warm data access days configuration.
        self.warm_config_day = warm_config_day
        # Warm data size.
        self.warm_data_size = warm_data_size
        # Write request balance.
        self.write_request_balance = write_request_balance

    def validate(self):
        if self.cold_access_day:
            self.cold_access_day.validate()
        if self.cold_config_day:
            self.cold_config_day.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.daily_read_request:
            self.daily_read_request.validate()
        if self.daily_read_request_day_growth_ratio:
            self.daily_read_request_day_growth_ratio.validate()
        if self.daily_write_request:
            self.daily_write_request.validate()
        if self.daily_write_request_day_growth_ratio:
            self.daily_write_request_day_growth_ratio.validate()
        if self.freeze_config_day:
            self.freeze_config_day.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.locality:
            self.locality.validate()
        if self.read_request_balance:
            self.read_request_balance.validate()
        if self.region_balance:
            self.region_balance.validate()
        if self.region_count:
            self.region_count.validate()
        if self.region_count_day_growth_ratio:
            self.region_count_day_growth_ratio.validate()
        if self.region_server_count:
            self.region_server_count.validate()
        if self.request_balance:
            self.request_balance.validate()
        if self.store_file_count:
            self.store_file_count.validate()
        if self.store_file_count_day_growth_ratio:
            self.store_file_count_day_growth_ratio.validate()
        if self.table_size:
            self.table_size.validate()
        if self.table_size_day_growth_ratio:
            self.table_size_day_growth_ratio.validate()
        if self.warm_config_day:
            self.warm_config_day.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.write_request_balance:
            self.write_request_balance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_access_day is not None:
            result['ColdAccessDay'] = self.cold_access_day.to_map()
        if self.cold_config_day is not None:
            result['ColdConfigDay'] = self.cold_config_day.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.daily_read_request is not None:
            result['DailyReadRequest'] = self.daily_read_request.to_map()
        if self.daily_read_request_day_growth_ratio is not None:
            result['DailyReadRequestDayGrowthRatio'] = self.daily_read_request_day_growth_ratio.to_map()
        if self.daily_write_request is not None:
            result['DailyWriteRequest'] = self.daily_write_request.to_map()
        if self.daily_write_request_day_growth_ratio is not None:
            result['DailyWriteRequestDayGrowthRatio'] = self.daily_write_request_day_growth_ratio.to_map()
        if self.freeze_config_day is not None:
            result['FreezeConfigDay'] = self.freeze_config_day.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.locality is not None:
            result['Locality'] = self.locality.to_map()
        if self.read_request_balance is not None:
            result['ReadRequestBalance'] = self.read_request_balance.to_map()
        if self.region_balance is not None:
            result['RegionBalance'] = self.region_balance.to_map()
        if self.region_count is not None:
            result['RegionCount'] = self.region_count.to_map()
        if self.region_count_day_growth_ratio is not None:
            result['RegionCountDayGrowthRatio'] = self.region_count_day_growth_ratio.to_map()
        if self.region_server_count is not None:
            result['RegionServerCount'] = self.region_server_count.to_map()
        if self.request_balance is not None:
            result['RequestBalance'] = self.request_balance.to_map()
        if self.store_file_count is not None:
            result['StoreFileCount'] = self.store_file_count.to_map()
        if self.store_file_count_day_growth_ratio is not None:
            result['StoreFileCountDayGrowthRatio'] = self.store_file_count_day_growth_ratio.to_map()
        if self.table_size is not None:
            result['TableSize'] = self.table_size.to_map()
        if self.table_size_day_growth_ratio is not None:
            result['TableSizeDayGrowthRatio'] = self.table_size_day_growth_ratio.to_map()
        if self.warm_config_day is not None:
            result['WarmConfigDay'] = self.warm_config_day.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.write_request_balance is not None:
            result['WriteRequestBalance'] = self.write_request_balance.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdAccessDay') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay()
            self.cold_access_day = temp_model.from_map(m['ColdAccessDay'])
        if m.get('ColdConfigDay') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay()
            self.cold_config_day = temp_model.from_map(m['ColdConfigDay'])
        if m.get('ColdDataSize') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('DailyReadRequest') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest()
            self.daily_read_request = temp_model.from_map(m['DailyReadRequest'])
        if m.get('DailyReadRequestDayGrowthRatio') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio()
            self.daily_read_request_day_growth_ratio = temp_model.from_map(m['DailyReadRequestDayGrowthRatio'])
        if m.get('DailyWriteRequest') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest()
            self.daily_write_request = temp_model.from_map(m['DailyWriteRequest'])
        if m.get('DailyWriteRequestDayGrowthRatio') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio()
            self.daily_write_request_day_growth_ratio = temp_model.from_map(m['DailyWriteRequestDayGrowthRatio'])
        if m.get('FreezeConfigDay') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay()
            self.freeze_config_day = temp_model.from_map(m['FreezeConfigDay'])
        if m.get('FreezeDataSize') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('HotDataSize') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('Locality') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsLocality()
            self.locality = temp_model.from_map(m['Locality'])
        if m.get('ReadRequestBalance') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance()
            self.read_request_balance = temp_model.from_map(m['ReadRequestBalance'])
        if m.get('RegionBalance') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance()
            self.region_balance = temp_model.from_map(m['RegionBalance'])
        if m.get('RegionCount') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsRegionCount()
            self.region_count = temp_model.from_map(m['RegionCount'])
        if m.get('RegionCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio()
            self.region_count_day_growth_ratio = temp_model.from_map(m['RegionCountDayGrowthRatio'])
        if m.get('RegionServerCount') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount()
            self.region_server_count = temp_model.from_map(m['RegionServerCount'])
        if m.get('RequestBalance') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance()
            self.request_balance = temp_model.from_map(m['RequestBalance'])
        if m.get('StoreFileCount') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount()
            self.store_file_count = temp_model.from_map(m['StoreFileCount'])
        if m.get('StoreFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio()
            self.store_file_count_day_growth_ratio = temp_model.from_map(m['StoreFileCountDayGrowthRatio'])
        if m.get('TableSize') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsTableSize()
            self.table_size = temp_model.from_map(m['TableSize'])
        if m.get('TableSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio()
            self.table_size_day_growth_ratio = temp_model.from_map(m['TableSizeDayGrowthRatio'])
        if m.get('WarmConfigDay') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay()
            self.warm_config_day = temp_model.from_map(m['WarmConfigDay'])
        if m.get('WarmDataSize') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WriteRequestBalance') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance()
            self.write_request_balance = temp_model.from_map(m['WriteRequestBalance'])
        return self


class GetDoctorHBaseTableResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: GetDoctorHBaseTableResponseBodyDataAnalysis = None,
        metrics: GetDoctorHBaseTableResponseBodyDataMetrics = None,
    ):
        # Diagnostic results.
        self.analysis = analysis
        # Metrics information.
        self.metrics = metrics

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class GetDoctorHBaseTableResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHBaseTableResponseBodyData = None,
        request_id: str = None,
    ):
        # Returned data.
        self.data = data
        # Request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHBaseTableResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHBaseTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHBaseTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHBaseTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHDFSClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorHDFSClusterResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        hdfs_score: int = None,
    ):
        # The overall score of HDFS storage resources.
        self.hdfs_score = hdfs_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hdfs_score is not None:
            result['HdfsScore'] = self.hdfs_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HdfsScore') is not None:
            self.hdfs_score = m.get('HdfsScore')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSClusterResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_data_day_growth_size: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize = None,
        cold_data_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio = None,
        cold_data_size: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize = None,
        cold_data_size_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio = None,
        empty_file_count: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount = None,
        empty_file_count_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio = None,
        empty_file_day_growth_count: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount = None,
        empty_file_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio = None,
        freeze_data_day_growth_size: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize = None,
        freeze_data_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio = None,
        freeze_data_size: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize = None,
        freeze_data_size_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio = None,
        hot_data_day_growth_size: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize = None,
        hot_data_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio = None,
        hot_data_size: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize = None,
        hot_data_size_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio = None,
        large_file_count: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount = None,
        large_file_count_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio = None,
        large_file_day_growth_count: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount = None,
        large_file_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio = None,
        medium_file_count: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount = None,
        medium_file_count_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio = None,
        medium_file_day_growth_count: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount = None,
        medium_file_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio = None,
        small_file_count: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount = None,
        small_file_count_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio = None,
        small_file_day_growth_count: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount = None,
        small_file_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio = None,
        tiny_file_count: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount = None,
        tiny_file_count_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio = None,
        tiny_file_day_growth_count: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount = None,
        tiny_file_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio = None,
        total_data_day_growth_size: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize = None,
        total_data_size: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize = None,
        total_data_size_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio = None,
        total_file_count: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount = None,
        total_file_count_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio = None,
        total_file_day_growth_count: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount = None,
        warm_data_day_growth_size: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize = None,
        warm_data_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio = None,
        warm_data_size: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize = None,
        warm_data_size_day_growth_ratio: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio = None,
    ):
        # The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_day_growth_size = cold_data_day_growth_size
        # The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_ratio = cold_data_ratio
        # The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_size = cold_data_size
        # The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_size_day_growth_ratio = cold_data_size_day_growth_ratio
        # The number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count = empty_file_count
        # The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count_day_growth_ratio = empty_file_count_day_growth_ratio
        # The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_day_growth_count = empty_file_day_growth_count
        # The proportion of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_ratio = empty_file_ratio
        # The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_day_growth_size = freeze_data_day_growth_size
        # The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_ratio = freeze_data_ratio
        # The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size = freeze_data_size
        # The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size_day_growth_ratio = freeze_data_size_day_growth_ratio
        # The daily increment of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_day_growth_size = hot_data_day_growth_size
        # The proportion of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_ratio = hot_data_ratio
        # The amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_size = hot_data_size
        # The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_size_day_growth_ratio = hot_data_size_day_growth_ratio
        # The number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count = large_file_count
        # The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count_day_growth_ratio = large_file_count_day_growth_ratio
        # The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_day_growth_count = large_file_day_growth_count
        # The proportion of large files. Large files are those with a size greater than 1 GB.
        self.large_file_ratio = large_file_ratio
        # The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count = medium_file_count
        # The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count_day_growth_ratio = medium_file_count_day_growth_ratio
        # The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_day_growth_count = medium_file_day_growth_count
        # The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_ratio = medium_file_ratio
        # The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count = small_file_count
        # The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count_day_growth_ratio = small_file_count_day_growth_ratio
        # The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_day_growth_count = small_file_day_growth_count
        # The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_ratio = small_file_ratio
        # The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count = tiny_file_count
        # The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count_day_growth_ratio = tiny_file_count_day_growth_ratio
        # The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_day_growth_count = tiny_file_day_growth_count
        # The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_ratio = tiny_file_ratio
        # The daily incremental of the total data volume.
        self.total_data_day_growth_size = total_data_day_growth_size
        # The total amount of data.
        self.total_data_size = total_data_size
        # The day-to-day growth rate of the total data volume.
        self.total_data_size_day_growth_ratio = total_data_size_day_growth_ratio
        # The total number of files.
        self.total_file_count = total_file_count
        # The day-to-day growth rate of the total number of files.
        self.total_file_count_day_growth_ratio = total_file_count_day_growth_ratio
        # The daily increment of the total number of files.
        self.total_file_day_growth_count = total_file_day_growth_count
        # The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_day_growth_size = warm_data_day_growth_size
        # The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_ratio = warm_data_ratio
        # The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_size = warm_data_size
        # The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_size_day_growth_ratio = warm_data_size_day_growth_ratio

    def validate(self):
        if self.cold_data_day_growth_size:
            self.cold_data_day_growth_size.validate()
        if self.cold_data_ratio:
            self.cold_data_ratio.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.cold_data_size_day_growth_ratio:
            self.cold_data_size_day_growth_ratio.validate()
        if self.empty_file_count:
            self.empty_file_count.validate()
        if self.empty_file_count_day_growth_ratio:
            self.empty_file_count_day_growth_ratio.validate()
        if self.empty_file_day_growth_count:
            self.empty_file_day_growth_count.validate()
        if self.empty_file_ratio:
            self.empty_file_ratio.validate()
        if self.freeze_data_day_growth_size:
            self.freeze_data_day_growth_size.validate()
        if self.freeze_data_ratio:
            self.freeze_data_ratio.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.freeze_data_size_day_growth_ratio:
            self.freeze_data_size_day_growth_ratio.validate()
        if self.hot_data_day_growth_size:
            self.hot_data_day_growth_size.validate()
        if self.hot_data_ratio:
            self.hot_data_ratio.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.hot_data_size_day_growth_ratio:
            self.hot_data_size_day_growth_ratio.validate()
        if self.large_file_count:
            self.large_file_count.validate()
        if self.large_file_count_day_growth_ratio:
            self.large_file_count_day_growth_ratio.validate()
        if self.large_file_day_growth_count:
            self.large_file_day_growth_count.validate()
        if self.large_file_ratio:
            self.large_file_ratio.validate()
        if self.medium_file_count:
            self.medium_file_count.validate()
        if self.medium_file_count_day_growth_ratio:
            self.medium_file_count_day_growth_ratio.validate()
        if self.medium_file_day_growth_count:
            self.medium_file_day_growth_count.validate()
        if self.medium_file_ratio:
            self.medium_file_ratio.validate()
        if self.small_file_count:
            self.small_file_count.validate()
        if self.small_file_count_day_growth_ratio:
            self.small_file_count_day_growth_ratio.validate()
        if self.small_file_day_growth_count:
            self.small_file_day_growth_count.validate()
        if self.small_file_ratio:
            self.small_file_ratio.validate()
        if self.tiny_file_count:
            self.tiny_file_count.validate()
        if self.tiny_file_count_day_growth_ratio:
            self.tiny_file_count_day_growth_ratio.validate()
        if self.tiny_file_day_growth_count:
            self.tiny_file_day_growth_count.validate()
        if self.tiny_file_ratio:
            self.tiny_file_ratio.validate()
        if self.total_data_day_growth_size:
            self.total_data_day_growth_size.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_data_size_day_growth_ratio:
            self.total_data_size_day_growth_ratio.validate()
        if self.total_file_count:
            self.total_file_count.validate()
        if self.total_file_count_day_growth_ratio:
            self.total_file_count_day_growth_ratio.validate()
        if self.total_file_day_growth_count:
            self.total_file_day_growth_count.validate()
        if self.warm_data_day_growth_size:
            self.warm_data_day_growth_size.validate()
        if self.warm_data_ratio:
            self.warm_data_ratio.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.warm_data_size_day_growth_ratio:
            self.warm_data_size_day_growth_ratio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_data_day_growth_size is not None:
            result['ColdDataDayGrowthSize'] = self.cold_data_day_growth_size.to_map()
        if self.cold_data_ratio is not None:
            result['ColdDataRatio'] = self.cold_data_ratio.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.cold_data_size_day_growth_ratio is not None:
            result['ColdDataSizeDayGrowthRatio'] = self.cold_data_size_day_growth_ratio.to_map()
        if self.empty_file_count is not None:
            result['EmptyFileCount'] = self.empty_file_count.to_map()
        if self.empty_file_count_day_growth_ratio is not None:
            result['EmptyFileCountDayGrowthRatio'] = self.empty_file_count_day_growth_ratio.to_map()
        if self.empty_file_day_growth_count is not None:
            result['EmptyFileDayGrowthCount'] = self.empty_file_day_growth_count.to_map()
        if self.empty_file_ratio is not None:
            result['EmptyFileRatio'] = self.empty_file_ratio.to_map()
        if self.freeze_data_day_growth_size is not None:
            result['FreezeDataDayGrowthSize'] = self.freeze_data_day_growth_size.to_map()
        if self.freeze_data_ratio is not None:
            result['FreezeDataRatio'] = self.freeze_data_ratio.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.freeze_data_size_day_growth_ratio is not None:
            result['FreezeDataSizeDayGrowthRatio'] = self.freeze_data_size_day_growth_ratio.to_map()
        if self.hot_data_day_growth_size is not None:
            result['HotDataDayGrowthSize'] = self.hot_data_day_growth_size.to_map()
        if self.hot_data_ratio is not None:
            result['HotDataRatio'] = self.hot_data_ratio.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.hot_data_size_day_growth_ratio is not None:
            result['HotDataSizeDayGrowthRatio'] = self.hot_data_size_day_growth_ratio.to_map()
        if self.large_file_count is not None:
            result['LargeFileCount'] = self.large_file_count.to_map()
        if self.large_file_count_day_growth_ratio is not None:
            result['LargeFileCountDayGrowthRatio'] = self.large_file_count_day_growth_ratio.to_map()
        if self.large_file_day_growth_count is not None:
            result['LargeFileDayGrowthCount'] = self.large_file_day_growth_count.to_map()
        if self.large_file_ratio is not None:
            result['LargeFileRatio'] = self.large_file_ratio.to_map()
        if self.medium_file_count is not None:
            result['MediumFileCount'] = self.medium_file_count.to_map()
        if self.medium_file_count_day_growth_ratio is not None:
            result['MediumFileCountDayGrowthRatio'] = self.medium_file_count_day_growth_ratio.to_map()
        if self.medium_file_day_growth_count is not None:
            result['MediumFileDayGrowthCount'] = self.medium_file_day_growth_count.to_map()
        if self.medium_file_ratio is not None:
            result['MediumFileRatio'] = self.medium_file_ratio.to_map()
        if self.small_file_count is not None:
            result['SmallFileCount'] = self.small_file_count.to_map()
        if self.small_file_count_day_growth_ratio is not None:
            result['SmallFileCountDayGrowthRatio'] = self.small_file_count_day_growth_ratio.to_map()
        if self.small_file_day_growth_count is not None:
            result['SmallFileDayGrowthCount'] = self.small_file_day_growth_count.to_map()
        if self.small_file_ratio is not None:
            result['SmallFileRatio'] = self.small_file_ratio.to_map()
        if self.tiny_file_count is not None:
            result['TinyFileCount'] = self.tiny_file_count.to_map()
        if self.tiny_file_count_day_growth_ratio is not None:
            result['TinyFileCountDayGrowthRatio'] = self.tiny_file_count_day_growth_ratio.to_map()
        if self.tiny_file_day_growth_count is not None:
            result['TinyFileDayGrowthCount'] = self.tiny_file_day_growth_count.to_map()
        if self.tiny_file_ratio is not None:
            result['TinyFileRatio'] = self.tiny_file_ratio.to_map()
        if self.total_data_day_growth_size is not None:
            result['TotalDataDayGrowthSize'] = self.total_data_day_growth_size.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_data_size_day_growth_ratio is not None:
            result['TotalDataSizeDayGrowthRatio'] = self.total_data_size_day_growth_ratio.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        if self.total_file_count_day_growth_ratio is not None:
            result['TotalFileCountDayGrowthRatio'] = self.total_file_count_day_growth_ratio.to_map()
        if self.total_file_day_growth_count is not None:
            result['TotalFileDayGrowthCount'] = self.total_file_day_growth_count.to_map()
        if self.warm_data_day_growth_size is not None:
            result['WarmDataDayGrowthSize'] = self.warm_data_day_growth_size.to_map()
        if self.warm_data_ratio is not None:
            result['WarmDataRatio'] = self.warm_data_ratio.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.warm_data_size_day_growth_ratio is not None:
            result['WarmDataSizeDayGrowthRatio'] = self.warm_data_size_day_growth_ratio.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize()
            self.cold_data_day_growth_size = temp_model.from_map(m['ColdDataDayGrowthSize'])
        if m.get('ColdDataRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio()
            self.cold_data_ratio = temp_model.from_map(m['ColdDataRatio'])
        if m.get('ColdDataSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('ColdDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio()
            self.cold_data_size_day_growth_ratio = temp_model.from_map(m['ColdDataSizeDayGrowthRatio'])
        if m.get('EmptyFileCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount()
            self.empty_file_count = temp_model.from_map(m['EmptyFileCount'])
        if m.get('EmptyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio()
            self.empty_file_count_day_growth_ratio = temp_model.from_map(m['EmptyFileCountDayGrowthRatio'])
        if m.get('EmptyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount()
            self.empty_file_day_growth_count = temp_model.from_map(m['EmptyFileDayGrowthCount'])
        if m.get('EmptyFileRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio()
            self.empty_file_ratio = temp_model.from_map(m['EmptyFileRatio'])
        if m.get('FreezeDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize()
            self.freeze_data_day_growth_size = temp_model.from_map(m['FreezeDataDayGrowthSize'])
        if m.get('FreezeDataRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio()
            self.freeze_data_ratio = temp_model.from_map(m['FreezeDataRatio'])
        if m.get('FreezeDataSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('FreezeDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio()
            self.freeze_data_size_day_growth_ratio = temp_model.from_map(m['FreezeDataSizeDayGrowthRatio'])
        if m.get('HotDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize()
            self.hot_data_day_growth_size = temp_model.from_map(m['HotDataDayGrowthSize'])
        if m.get('HotDataRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio()
            self.hot_data_ratio = temp_model.from_map(m['HotDataRatio'])
        if m.get('HotDataSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('HotDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio()
            self.hot_data_size_day_growth_ratio = temp_model.from_map(m['HotDataSizeDayGrowthRatio'])
        if m.get('LargeFileCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount()
            self.large_file_count = temp_model.from_map(m['LargeFileCount'])
        if m.get('LargeFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio()
            self.large_file_count_day_growth_ratio = temp_model.from_map(m['LargeFileCountDayGrowthRatio'])
        if m.get('LargeFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount()
            self.large_file_day_growth_count = temp_model.from_map(m['LargeFileDayGrowthCount'])
        if m.get('LargeFileRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio()
            self.large_file_ratio = temp_model.from_map(m['LargeFileRatio'])
        if m.get('MediumFileCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount()
            self.medium_file_count = temp_model.from_map(m['MediumFileCount'])
        if m.get('MediumFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio()
            self.medium_file_count_day_growth_ratio = temp_model.from_map(m['MediumFileCountDayGrowthRatio'])
        if m.get('MediumFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount()
            self.medium_file_day_growth_count = temp_model.from_map(m['MediumFileDayGrowthCount'])
        if m.get('MediumFileRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio()
            self.medium_file_ratio = temp_model.from_map(m['MediumFileRatio'])
        if m.get('SmallFileCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount()
            self.small_file_count = temp_model.from_map(m['SmallFileCount'])
        if m.get('SmallFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio()
            self.small_file_count_day_growth_ratio = temp_model.from_map(m['SmallFileCountDayGrowthRatio'])
        if m.get('SmallFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount()
            self.small_file_day_growth_count = temp_model.from_map(m['SmallFileDayGrowthCount'])
        if m.get('SmallFileRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio()
            self.small_file_ratio = temp_model.from_map(m['SmallFileRatio'])
        if m.get('TinyFileCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount()
            self.tiny_file_count = temp_model.from_map(m['TinyFileCount'])
        if m.get('TinyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio()
            self.tiny_file_count_day_growth_ratio = temp_model.from_map(m['TinyFileCountDayGrowthRatio'])
        if m.get('TinyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount()
            self.tiny_file_day_growth_count = temp_model.from_map(m['TinyFileDayGrowthCount'])
        if m.get('TinyFileRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio()
            self.tiny_file_ratio = temp_model.from_map(m['TinyFileRatio'])
        if m.get('TotalDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize()
            self.total_data_day_growth_size = temp_model.from_map(m['TotalDataDayGrowthSize'])
        if m.get('TotalDataSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio()
            self.total_data_size_day_growth_ratio = temp_model.from_map(m['TotalDataSizeDayGrowthRatio'])
        if m.get('TotalFileCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        if m.get('TotalFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio()
            self.total_file_count_day_growth_ratio = temp_model.from_map(m['TotalFileCountDayGrowthRatio'])
        if m.get('TotalFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount()
            self.total_file_day_growth_count = temp_model.from_map(m['TotalFileDayGrowthCount'])
        if m.get('WarmDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize()
            self.warm_data_day_growth_size = temp_model.from_map(m['WarmDataDayGrowthSize'])
        if m.get('WarmDataRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio()
            self.warm_data_ratio = temp_model.from_map(m['WarmDataRatio'])
        if m.get('WarmDataSize') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WarmDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio()
            self.warm_data_size_day_growth_ratio = temp_model.from_map(m['WarmDataSizeDayGrowthRatio'])
        return self


class GetDoctorHDFSClusterResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: GetDoctorHDFSClusterResponseBodyDataAnalysis = None,
        metrics: GetDoctorHDFSClusterResponseBodyDataMetrics = None,
    ):
        # The analysis results.
        self.analysis = analysis
        # The metric information.
        self.metrics = metrics

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class GetDoctorHDFSClusterResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHDFSClusterResponseBodyData = None,
        request_id: str = None,
    ):
        # The HDFS analysis results.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHDFSClusterResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHDFSClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHDFSClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHDFSClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHDFSDirectoryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        dir_path: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The directory name. The depth of the directory is not greater than five.
        # 
        # This parameter is required.
        self.dir_path = dir_path
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.dir_path is not None:
            result['DirPath'] = self.dir_path
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('DirPath') is not None:
            self.dir_path = m.get('DirPath')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHDFSDirectoryResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_data_day_growth_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize = None,
        cold_data_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize = None,
        cold_data_size_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio = None,
        empty_file_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount = None,
        empty_file_count_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio = None,
        empty_file_day_growth_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount = None,
        freeze_data_day_growth_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize = None,
        freeze_data_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize = None,
        freeze_data_size_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio = None,
        hot_data_day_growth_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize = None,
        hot_data_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize = None,
        hot_data_size_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio = None,
        large_file_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount = None,
        large_file_count_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio = None,
        large_file_day_growth_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount = None,
        medium_file_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount = None,
        medium_file_count_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio = None,
        medium_file_day_growth_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount = None,
        small_file_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount = None,
        small_file_count_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio = None,
        small_file_day_growth_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount = None,
        tiny_file_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount = None,
        tiny_file_count_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio = None,
        tiny_file_day_growth_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount = None,
        total_data_day_growth_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize = None,
        total_data_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize = None,
        total_data_size_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio = None,
        total_file_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount = None,
        total_file_count_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio = None,
        total_file_day_growth_count: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount = None,
        warm_data_day_growth_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize = None,
        warm_data_size: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize = None,
        warm_data_size_day_growth_ratio: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio = None,
    ):
        # The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_day_growth_size = cold_data_day_growth_size
        # The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_size = cold_data_size
        # The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_size_day_growth_ratio = cold_data_size_day_growth_ratio
        # The number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count = empty_file_count
        # The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count_day_growth_ratio = empty_file_count_day_growth_ratio
        # The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_day_growth_count = empty_file_day_growth_count
        # The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_day_growth_size = freeze_data_day_growth_size
        # The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size = freeze_data_size
        # The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size_day_growth_ratio = freeze_data_size_day_growth_ratio
        # The daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_day_growth_size = hot_data_day_growth_size
        # The amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_size = hot_data_size
        # The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_size_day_growth_ratio = hot_data_size_day_growth_ratio
        # The number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count = large_file_count
        # The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count_day_growth_ratio = large_file_count_day_growth_ratio
        # The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_day_growth_count = large_file_day_growth_count
        # The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count = medium_file_count
        # The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count_day_growth_ratio = medium_file_count_day_growth_ratio
        # The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_day_growth_count = medium_file_day_growth_count
        # The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count = small_file_count
        # The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count_day_growth_ratio = small_file_count_day_growth_ratio
        # The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_day_growth_count = small_file_day_growth_count
        # The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count = tiny_file_count
        # The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count_day_growth_ratio = tiny_file_count_day_growth_ratio
        # The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_day_growth_count = tiny_file_day_growth_count
        # The daily incremental of the total amount of data.
        self.total_data_day_growth_size = total_data_day_growth_size
        # The total amount of data.
        self.total_data_size = total_data_size
        # The day-to-day growth rate of the total data volume.
        self.total_data_size_day_growth_ratio = total_data_size_day_growth_ratio
        # The total number of files.
        self.total_file_count = total_file_count
        # The day-to-day growth rate of the total number of files.
        self.total_file_count_day_growth_ratio = total_file_count_day_growth_ratio
        # The daily increment of the total number of files.
        self.total_file_day_growth_count = total_file_day_growth_count
        # The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_day_growth_size = warm_data_day_growth_size
        # The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_size = warm_data_size
        # The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_size_day_growth_ratio = warm_data_size_day_growth_ratio

    def validate(self):
        if self.cold_data_day_growth_size:
            self.cold_data_day_growth_size.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.cold_data_size_day_growth_ratio:
            self.cold_data_size_day_growth_ratio.validate()
        if self.empty_file_count:
            self.empty_file_count.validate()
        if self.empty_file_count_day_growth_ratio:
            self.empty_file_count_day_growth_ratio.validate()
        if self.empty_file_day_growth_count:
            self.empty_file_day_growth_count.validate()
        if self.freeze_data_day_growth_size:
            self.freeze_data_day_growth_size.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.freeze_data_size_day_growth_ratio:
            self.freeze_data_size_day_growth_ratio.validate()
        if self.hot_data_day_growth_size:
            self.hot_data_day_growth_size.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.hot_data_size_day_growth_ratio:
            self.hot_data_size_day_growth_ratio.validate()
        if self.large_file_count:
            self.large_file_count.validate()
        if self.large_file_count_day_growth_ratio:
            self.large_file_count_day_growth_ratio.validate()
        if self.large_file_day_growth_count:
            self.large_file_day_growth_count.validate()
        if self.medium_file_count:
            self.medium_file_count.validate()
        if self.medium_file_count_day_growth_ratio:
            self.medium_file_count_day_growth_ratio.validate()
        if self.medium_file_day_growth_count:
            self.medium_file_day_growth_count.validate()
        if self.small_file_count:
            self.small_file_count.validate()
        if self.small_file_count_day_growth_ratio:
            self.small_file_count_day_growth_ratio.validate()
        if self.small_file_day_growth_count:
            self.small_file_day_growth_count.validate()
        if self.tiny_file_count:
            self.tiny_file_count.validate()
        if self.tiny_file_count_day_growth_ratio:
            self.tiny_file_count_day_growth_ratio.validate()
        if self.tiny_file_day_growth_count:
            self.tiny_file_day_growth_count.validate()
        if self.total_data_day_growth_size:
            self.total_data_day_growth_size.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_data_size_day_growth_ratio:
            self.total_data_size_day_growth_ratio.validate()
        if self.total_file_count:
            self.total_file_count.validate()
        if self.total_file_count_day_growth_ratio:
            self.total_file_count_day_growth_ratio.validate()
        if self.total_file_day_growth_count:
            self.total_file_day_growth_count.validate()
        if self.warm_data_day_growth_size:
            self.warm_data_day_growth_size.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.warm_data_size_day_growth_ratio:
            self.warm_data_size_day_growth_ratio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_data_day_growth_size is not None:
            result['ColdDataDayGrowthSize'] = self.cold_data_day_growth_size.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.cold_data_size_day_growth_ratio is not None:
            result['ColdDataSizeDayGrowthRatio'] = self.cold_data_size_day_growth_ratio.to_map()
        if self.empty_file_count is not None:
            result['EmptyFileCount'] = self.empty_file_count.to_map()
        if self.empty_file_count_day_growth_ratio is not None:
            result['EmptyFileCountDayGrowthRatio'] = self.empty_file_count_day_growth_ratio.to_map()
        if self.empty_file_day_growth_count is not None:
            result['EmptyFileDayGrowthCount'] = self.empty_file_day_growth_count.to_map()
        if self.freeze_data_day_growth_size is not None:
            result['FreezeDataDayGrowthSize'] = self.freeze_data_day_growth_size.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.freeze_data_size_day_growth_ratio is not None:
            result['FreezeDataSizeDayGrowthRatio'] = self.freeze_data_size_day_growth_ratio.to_map()
        if self.hot_data_day_growth_size is not None:
            result['HotDataDayGrowthSize'] = self.hot_data_day_growth_size.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.hot_data_size_day_growth_ratio is not None:
            result['HotDataSizeDayGrowthRatio'] = self.hot_data_size_day_growth_ratio.to_map()
        if self.large_file_count is not None:
            result['LargeFileCount'] = self.large_file_count.to_map()
        if self.large_file_count_day_growth_ratio is not None:
            result['LargeFileCountDayGrowthRatio'] = self.large_file_count_day_growth_ratio.to_map()
        if self.large_file_day_growth_count is not None:
            result['LargeFileDayGrowthCount'] = self.large_file_day_growth_count.to_map()
        if self.medium_file_count is not None:
            result['MediumFileCount'] = self.medium_file_count.to_map()
        if self.medium_file_count_day_growth_ratio is not None:
            result['MediumFileCountDayGrowthRatio'] = self.medium_file_count_day_growth_ratio.to_map()
        if self.medium_file_day_growth_count is not None:
            result['MediumFileDayGrowthCount'] = self.medium_file_day_growth_count.to_map()
        if self.small_file_count is not None:
            result['SmallFileCount'] = self.small_file_count.to_map()
        if self.small_file_count_day_growth_ratio is not None:
            result['SmallFileCountDayGrowthRatio'] = self.small_file_count_day_growth_ratio.to_map()
        if self.small_file_day_growth_count is not None:
            result['SmallFileDayGrowthCount'] = self.small_file_day_growth_count.to_map()
        if self.tiny_file_count is not None:
            result['TinyFileCount'] = self.tiny_file_count.to_map()
        if self.tiny_file_count_day_growth_ratio is not None:
            result['TinyFileCountDayGrowthRatio'] = self.tiny_file_count_day_growth_ratio.to_map()
        if self.tiny_file_day_growth_count is not None:
            result['TinyFileDayGrowthCount'] = self.tiny_file_day_growth_count.to_map()
        if self.total_data_day_growth_size is not None:
            result['TotalDataDayGrowthSize'] = self.total_data_day_growth_size.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_data_size_day_growth_ratio is not None:
            result['TotalDataSizeDayGrowthRatio'] = self.total_data_size_day_growth_ratio.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        if self.total_file_count_day_growth_ratio is not None:
            result['TotalFileCountDayGrowthRatio'] = self.total_file_count_day_growth_ratio.to_map()
        if self.total_file_day_growth_count is not None:
            result['TotalFileDayGrowthCount'] = self.total_file_day_growth_count.to_map()
        if self.warm_data_day_growth_size is not None:
            result['WarmDataDayGrowthSize'] = self.warm_data_day_growth_size.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.warm_data_size_day_growth_ratio is not None:
            result['WarmDataSizeDayGrowthRatio'] = self.warm_data_size_day_growth_ratio.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize()
            self.cold_data_day_growth_size = temp_model.from_map(m['ColdDataDayGrowthSize'])
        if m.get('ColdDataSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('ColdDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio()
            self.cold_data_size_day_growth_ratio = temp_model.from_map(m['ColdDataSizeDayGrowthRatio'])
        if m.get('EmptyFileCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount()
            self.empty_file_count = temp_model.from_map(m['EmptyFileCount'])
        if m.get('EmptyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio()
            self.empty_file_count_day_growth_ratio = temp_model.from_map(m['EmptyFileCountDayGrowthRatio'])
        if m.get('EmptyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount()
            self.empty_file_day_growth_count = temp_model.from_map(m['EmptyFileDayGrowthCount'])
        if m.get('FreezeDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize()
            self.freeze_data_day_growth_size = temp_model.from_map(m['FreezeDataDayGrowthSize'])
        if m.get('FreezeDataSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('FreezeDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio()
            self.freeze_data_size_day_growth_ratio = temp_model.from_map(m['FreezeDataSizeDayGrowthRatio'])
        if m.get('HotDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize()
            self.hot_data_day_growth_size = temp_model.from_map(m['HotDataDayGrowthSize'])
        if m.get('HotDataSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('HotDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio()
            self.hot_data_size_day_growth_ratio = temp_model.from_map(m['HotDataSizeDayGrowthRatio'])
        if m.get('LargeFileCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount()
            self.large_file_count = temp_model.from_map(m['LargeFileCount'])
        if m.get('LargeFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio()
            self.large_file_count_day_growth_ratio = temp_model.from_map(m['LargeFileCountDayGrowthRatio'])
        if m.get('LargeFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount()
            self.large_file_day_growth_count = temp_model.from_map(m['LargeFileDayGrowthCount'])
        if m.get('MediumFileCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount()
            self.medium_file_count = temp_model.from_map(m['MediumFileCount'])
        if m.get('MediumFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio()
            self.medium_file_count_day_growth_ratio = temp_model.from_map(m['MediumFileCountDayGrowthRatio'])
        if m.get('MediumFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount()
            self.medium_file_day_growth_count = temp_model.from_map(m['MediumFileDayGrowthCount'])
        if m.get('SmallFileCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount()
            self.small_file_count = temp_model.from_map(m['SmallFileCount'])
        if m.get('SmallFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio()
            self.small_file_count_day_growth_ratio = temp_model.from_map(m['SmallFileCountDayGrowthRatio'])
        if m.get('SmallFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount()
            self.small_file_day_growth_count = temp_model.from_map(m['SmallFileDayGrowthCount'])
        if m.get('TinyFileCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount()
            self.tiny_file_count = temp_model.from_map(m['TinyFileCount'])
        if m.get('TinyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio()
            self.tiny_file_count_day_growth_ratio = temp_model.from_map(m['TinyFileCountDayGrowthRatio'])
        if m.get('TinyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount()
            self.tiny_file_day_growth_count = temp_model.from_map(m['TinyFileDayGrowthCount'])
        if m.get('TotalDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize()
            self.total_data_day_growth_size = temp_model.from_map(m['TotalDataDayGrowthSize'])
        if m.get('TotalDataSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio()
            self.total_data_size_day_growth_ratio = temp_model.from_map(m['TotalDataSizeDayGrowthRatio'])
        if m.get('TotalFileCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        if m.get('TotalFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio()
            self.total_file_count_day_growth_ratio = temp_model.from_map(m['TotalFileCountDayGrowthRatio'])
        if m.get('TotalFileDayGrowthCount') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount()
            self.total_file_day_growth_count = temp_model.from_map(m['TotalFileDayGrowthCount'])
        if m.get('WarmDataDayGrowthSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize()
            self.warm_data_day_growth_size = temp_model.from_map(m['WarmDataDayGrowthSize'])
        if m.get('WarmDataSize') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WarmDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio()
            self.warm_data_size_day_growth_ratio = temp_model.from_map(m['WarmDataSizeDayGrowthRatio'])
        return self


class GetDoctorHDFSDirectoryResponseBodyData(TeaModel):
    def __init__(
        self,
        depth: int = None,
        group: str = None,
        metrics: GetDoctorHDFSDirectoryResponseBodyDataMetrics = None,
        user: str = None,
    ):
        # The directory level.
        self.depth = depth
        # The group to which the directory belongs.
        self.group = group
        # The metric information.
        self.metrics = metrics
        # The directory owner.
        self.user = user

    def validate(self):
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.depth is not None:
            result['Depth'] = self.depth
        if self.group is not None:
            result['Group'] = self.group
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Depth') is not None:
            self.depth = m.get('Depth')
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class GetDoctorHDFSDirectoryResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHDFSDirectoryResponseBodyData = None,
        request_id: str = None,
    ):
        # The analysis results of the HDFS directory.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHDFSDirectoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHDFSDirectoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHDFSDirectoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHiveClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorHiveClusterResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        hive_distribution_score: int = None,
        hive_format_score: int = None,
        hive_frequency_score: int = None,
        hive_score: int = None,
    ):
        # The score for the distribution of files of different sizes stored in the Hive cluster.
        self.hive_distribution_score = hive_distribution_score
        # The score for the distribution of files stored in different formats in the Hive cluster.
        self.hive_format_score = hive_format_score
        # The score for the access frequency of the Hive cluster.
        self.hive_frequency_score = hive_frequency_score
        # The overall score of the Hive cluster.
        self.hive_score = hive_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hive_distribution_score is not None:
            result['HiveDistributionScore'] = self.hive_distribution_score
        if self.hive_format_score is not None:
            result['HiveFormatScore'] = self.hive_format_score
        if self.hive_frequency_score is not None:
            result['HiveFrequencyScore'] = self.hive_frequency_score
        if self.hive_score is not None:
            result['HiveScore'] = self.hive_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HiveDistributionScore') is not None:
            self.hive_distribution_score = m.get('HiveDistributionScore')
        if m.get('HiveFormatScore') is not None:
            self.hive_format_score = m.get('HiveFormatScore')
        if m.get('HiveFrequencyScore') is not None:
            self.hive_frequency_score = m.get('HiveFrequencyScore')
        if m.get('HiveScore') is not None:
            self.hive_score = m.get('HiveScore')
        return self


class GetDoctorHiveClusterResponseBodyDataFormats(TeaModel):
    def __init__(
        self,
        format_name: str = None,
        format_ratio: float = None,
        format_size: int = None,
        format_size_unit: str = None,
    ):
        # The name of the storage format.
        self.format_name = format_name
        # The proportion of the data in the format.
        self.format_ratio = format_ratio
        # The amount of data in the format.
        self.format_size = format_size
        # The unit of the amount of data in the format.
        self.format_size_unit = format_size_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.format_ratio is not None:
            result['FormatRatio'] = self.format_ratio
        if self.format_size is not None:
            result['FormatSize'] = self.format_size
        if self.format_size_unit is not None:
            result['FormatSizeUnit'] = self.format_size_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('FormatRatio') is not None:
            self.format_ratio = m.get('FormatRatio')
        if m.get('FormatSize') is not None:
            self.format_size = m.get('FormatSize')
        if m.get('FormatSizeUnit') is not None:
            self.format_size_unit = m.get('FormatSizeUnit')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTableCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveClusterResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_data_day_growth_size: GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize = None,
        cold_data_ratio: GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio = None,
        cold_data_size: GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize = None,
        cold_data_size_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio = None,
        database_count: GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount = None,
        empty_file_count: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount = None,
        empty_file_count_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio = None,
        empty_file_day_growth_count: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount = None,
        empty_file_ratio: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio = None,
        freeze_data_day_growth_size: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize = None,
        freeze_data_ratio: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio = None,
        freeze_data_size: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize = None,
        freeze_data_size_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio = None,
        hot_data_day_growth_size: GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize = None,
        hot_data_ratio: GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio = None,
        hot_data_size: GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize = None,
        hot_data_size_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio = None,
        large_file_count: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount = None,
        large_file_count_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio = None,
        large_file_day_growth_count: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount = None,
        large_file_ratio: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio = None,
        medium_file_count: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount = None,
        medium_file_count_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio = None,
        medium_file_day_growth_count: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount = None,
        medium_file_ratio: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio = None,
        partition_num: GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum = None,
        small_file_count: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount = None,
        small_file_count_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio = None,
        small_file_day_growth_count: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount = None,
        small_file_ratio: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio = None,
        table_count: GetDoctorHiveClusterResponseBodyDataMetricsTableCount = None,
        tiny_file_count: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount = None,
        tiny_file_count_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio = None,
        tiny_file_day_growth_count: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount = None,
        tiny_file_ratio: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio = None,
        total_data_day_growth_size: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize = None,
        total_data_size: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize = None,
        total_data_size_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio = None,
        total_file_count: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount = None,
        total_file_count_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio = None,
        total_file_day_growth_count: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount = None,
        warm_data_day_growth_size: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize = None,
        warm_data_ratio: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio = None,
        warm_data_size: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize = None,
        warm_data_size_day_growth_ratio: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio = None,
    ):
        # The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_day_growth_size = cold_data_day_growth_size
        # The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_ratio = cold_data_ratio
        # The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_size = cold_data_size
        # The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_size_day_growth_ratio = cold_data_size_day_growth_ratio
        # The number of databases.
        self.database_count = database_count
        # The number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count = empty_file_count
        # The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count_day_growth_ratio = empty_file_count_day_growth_ratio
        # The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_day_growth_count = empty_file_day_growth_count
        # The proportion of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_ratio = empty_file_ratio
        # The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_day_growth_size = freeze_data_day_growth_size
        # The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_ratio = freeze_data_ratio
        # The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size = freeze_data_size
        # The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size_day_growth_ratio = freeze_data_size_day_growth_ratio
        # The daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_day_growth_size = hot_data_day_growth_size
        # The proportion of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_ratio = hot_data_ratio
        # The amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_size = hot_data_size
        # The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_size_day_growth_ratio = hot_data_size_day_growth_ratio
        # The number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count = large_file_count
        # The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count_day_growth_ratio = large_file_count_day_growth_ratio
        # The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_day_growth_count = large_file_day_growth_count
        # The proportion of large files. Large files are those with a size greater than 1 GB.
        self.large_file_ratio = large_file_ratio
        # The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count = medium_file_count
        # The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count_day_growth_ratio = medium_file_count_day_growth_ratio
        # The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_day_growth_count = medium_file_day_growth_count
        # The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_ratio = medium_file_ratio
        # The number of partitions.
        self.partition_num = partition_num
        # The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count = small_file_count
        # The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count_day_growth_ratio = small_file_count_day_growth_ratio
        # The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_day_growth_count = small_file_day_growth_count
        # The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_ratio = small_file_ratio
        # The number of tables.
        self.table_count = table_count
        # The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count = tiny_file_count
        # The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count_day_growth_ratio = tiny_file_count_day_growth_ratio
        # The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_day_growth_count = tiny_file_day_growth_count
        # The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_ratio = tiny_file_ratio
        # The daily incremental of the amount of total data.
        self.total_data_day_growth_size = total_data_day_growth_size
        # The total amount of data.
        self.total_data_size = total_data_size
        # The day-to-day growth rate of the total data volume.
        self.total_data_size_day_growth_ratio = total_data_size_day_growth_ratio
        # The total number of files.
        self.total_file_count = total_file_count
        # The day-to-day growth rate of the total number of files.
        self.total_file_count_day_growth_ratio = total_file_count_day_growth_ratio
        # The daily increment of the total number of files.
        self.total_file_day_growth_count = total_file_day_growth_count
        # The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_day_growth_size = warm_data_day_growth_size
        # The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_ratio = warm_data_ratio
        # The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_size = warm_data_size
        # The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_size_day_growth_ratio = warm_data_size_day_growth_ratio

    def validate(self):
        if self.cold_data_day_growth_size:
            self.cold_data_day_growth_size.validate()
        if self.cold_data_ratio:
            self.cold_data_ratio.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.cold_data_size_day_growth_ratio:
            self.cold_data_size_day_growth_ratio.validate()
        if self.database_count:
            self.database_count.validate()
        if self.empty_file_count:
            self.empty_file_count.validate()
        if self.empty_file_count_day_growth_ratio:
            self.empty_file_count_day_growth_ratio.validate()
        if self.empty_file_day_growth_count:
            self.empty_file_day_growth_count.validate()
        if self.empty_file_ratio:
            self.empty_file_ratio.validate()
        if self.freeze_data_day_growth_size:
            self.freeze_data_day_growth_size.validate()
        if self.freeze_data_ratio:
            self.freeze_data_ratio.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.freeze_data_size_day_growth_ratio:
            self.freeze_data_size_day_growth_ratio.validate()
        if self.hot_data_day_growth_size:
            self.hot_data_day_growth_size.validate()
        if self.hot_data_ratio:
            self.hot_data_ratio.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.hot_data_size_day_growth_ratio:
            self.hot_data_size_day_growth_ratio.validate()
        if self.large_file_count:
            self.large_file_count.validate()
        if self.large_file_count_day_growth_ratio:
            self.large_file_count_day_growth_ratio.validate()
        if self.large_file_day_growth_count:
            self.large_file_day_growth_count.validate()
        if self.large_file_ratio:
            self.large_file_ratio.validate()
        if self.medium_file_count:
            self.medium_file_count.validate()
        if self.medium_file_count_day_growth_ratio:
            self.medium_file_count_day_growth_ratio.validate()
        if self.medium_file_day_growth_count:
            self.medium_file_day_growth_count.validate()
        if self.medium_file_ratio:
            self.medium_file_ratio.validate()
        if self.partition_num:
            self.partition_num.validate()
        if self.small_file_count:
            self.small_file_count.validate()
        if self.small_file_count_day_growth_ratio:
            self.small_file_count_day_growth_ratio.validate()
        if self.small_file_day_growth_count:
            self.small_file_day_growth_count.validate()
        if self.small_file_ratio:
            self.small_file_ratio.validate()
        if self.table_count:
            self.table_count.validate()
        if self.tiny_file_count:
            self.tiny_file_count.validate()
        if self.tiny_file_count_day_growth_ratio:
            self.tiny_file_count_day_growth_ratio.validate()
        if self.tiny_file_day_growth_count:
            self.tiny_file_day_growth_count.validate()
        if self.tiny_file_ratio:
            self.tiny_file_ratio.validate()
        if self.total_data_day_growth_size:
            self.total_data_day_growth_size.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_data_size_day_growth_ratio:
            self.total_data_size_day_growth_ratio.validate()
        if self.total_file_count:
            self.total_file_count.validate()
        if self.total_file_count_day_growth_ratio:
            self.total_file_count_day_growth_ratio.validate()
        if self.total_file_day_growth_count:
            self.total_file_day_growth_count.validate()
        if self.warm_data_day_growth_size:
            self.warm_data_day_growth_size.validate()
        if self.warm_data_ratio:
            self.warm_data_ratio.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.warm_data_size_day_growth_ratio:
            self.warm_data_size_day_growth_ratio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_data_day_growth_size is not None:
            result['ColdDataDayGrowthSize'] = self.cold_data_day_growth_size.to_map()
        if self.cold_data_ratio is not None:
            result['ColdDataRatio'] = self.cold_data_ratio.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.cold_data_size_day_growth_ratio is not None:
            result['ColdDataSizeDayGrowthRatio'] = self.cold_data_size_day_growth_ratio.to_map()
        if self.database_count is not None:
            result['DatabaseCount'] = self.database_count.to_map()
        if self.empty_file_count is not None:
            result['EmptyFileCount'] = self.empty_file_count.to_map()
        if self.empty_file_count_day_growth_ratio is not None:
            result['EmptyFileCountDayGrowthRatio'] = self.empty_file_count_day_growth_ratio.to_map()
        if self.empty_file_day_growth_count is not None:
            result['EmptyFileDayGrowthCount'] = self.empty_file_day_growth_count.to_map()
        if self.empty_file_ratio is not None:
            result['EmptyFileRatio'] = self.empty_file_ratio.to_map()
        if self.freeze_data_day_growth_size is not None:
            result['FreezeDataDayGrowthSize'] = self.freeze_data_day_growth_size.to_map()
        if self.freeze_data_ratio is not None:
            result['FreezeDataRatio'] = self.freeze_data_ratio.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.freeze_data_size_day_growth_ratio is not None:
            result['FreezeDataSizeDayGrowthRatio'] = self.freeze_data_size_day_growth_ratio.to_map()
        if self.hot_data_day_growth_size is not None:
            result['HotDataDayGrowthSize'] = self.hot_data_day_growth_size.to_map()
        if self.hot_data_ratio is not None:
            result['HotDataRatio'] = self.hot_data_ratio.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.hot_data_size_day_growth_ratio is not None:
            result['HotDataSizeDayGrowthRatio'] = self.hot_data_size_day_growth_ratio.to_map()
        if self.large_file_count is not None:
            result['LargeFileCount'] = self.large_file_count.to_map()
        if self.large_file_count_day_growth_ratio is not None:
            result['LargeFileCountDayGrowthRatio'] = self.large_file_count_day_growth_ratio.to_map()
        if self.large_file_day_growth_count is not None:
            result['LargeFileDayGrowthCount'] = self.large_file_day_growth_count.to_map()
        if self.large_file_ratio is not None:
            result['LargeFileRatio'] = self.large_file_ratio.to_map()
        if self.medium_file_count is not None:
            result['MediumFileCount'] = self.medium_file_count.to_map()
        if self.medium_file_count_day_growth_ratio is not None:
            result['MediumFileCountDayGrowthRatio'] = self.medium_file_count_day_growth_ratio.to_map()
        if self.medium_file_day_growth_count is not None:
            result['MediumFileDayGrowthCount'] = self.medium_file_day_growth_count.to_map()
        if self.medium_file_ratio is not None:
            result['MediumFileRatio'] = self.medium_file_ratio.to_map()
        if self.partition_num is not None:
            result['PartitionNum'] = self.partition_num.to_map()
        if self.small_file_count is not None:
            result['SmallFileCount'] = self.small_file_count.to_map()
        if self.small_file_count_day_growth_ratio is not None:
            result['SmallFileCountDayGrowthRatio'] = self.small_file_count_day_growth_ratio.to_map()
        if self.small_file_day_growth_count is not None:
            result['SmallFileDayGrowthCount'] = self.small_file_day_growth_count.to_map()
        if self.small_file_ratio is not None:
            result['SmallFileRatio'] = self.small_file_ratio.to_map()
        if self.table_count is not None:
            result['TableCount'] = self.table_count.to_map()
        if self.tiny_file_count is not None:
            result['TinyFileCount'] = self.tiny_file_count.to_map()
        if self.tiny_file_count_day_growth_ratio is not None:
            result['TinyFileCountDayGrowthRatio'] = self.tiny_file_count_day_growth_ratio.to_map()
        if self.tiny_file_day_growth_count is not None:
            result['TinyFileDayGrowthCount'] = self.tiny_file_day_growth_count.to_map()
        if self.tiny_file_ratio is not None:
            result['TinyFileRatio'] = self.tiny_file_ratio.to_map()
        if self.total_data_day_growth_size is not None:
            result['TotalDataDayGrowthSize'] = self.total_data_day_growth_size.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_data_size_day_growth_ratio is not None:
            result['TotalDataSizeDayGrowthRatio'] = self.total_data_size_day_growth_ratio.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        if self.total_file_count_day_growth_ratio is not None:
            result['TotalFileCountDayGrowthRatio'] = self.total_file_count_day_growth_ratio.to_map()
        if self.total_file_day_growth_count is not None:
            result['TotalFileDayGrowthCount'] = self.total_file_day_growth_count.to_map()
        if self.warm_data_day_growth_size is not None:
            result['WarmDataDayGrowthSize'] = self.warm_data_day_growth_size.to_map()
        if self.warm_data_ratio is not None:
            result['WarmDataRatio'] = self.warm_data_ratio.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.warm_data_size_day_growth_ratio is not None:
            result['WarmDataSizeDayGrowthRatio'] = self.warm_data_size_day_growth_ratio.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize()
            self.cold_data_day_growth_size = temp_model.from_map(m['ColdDataDayGrowthSize'])
        if m.get('ColdDataRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio()
            self.cold_data_ratio = temp_model.from_map(m['ColdDataRatio'])
        if m.get('ColdDataSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('ColdDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio()
            self.cold_data_size_day_growth_ratio = temp_model.from_map(m['ColdDataSizeDayGrowthRatio'])
        if m.get('DatabaseCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount()
            self.database_count = temp_model.from_map(m['DatabaseCount'])
        if m.get('EmptyFileCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount()
            self.empty_file_count = temp_model.from_map(m['EmptyFileCount'])
        if m.get('EmptyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio()
            self.empty_file_count_day_growth_ratio = temp_model.from_map(m['EmptyFileCountDayGrowthRatio'])
        if m.get('EmptyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount()
            self.empty_file_day_growth_count = temp_model.from_map(m['EmptyFileDayGrowthCount'])
        if m.get('EmptyFileRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio()
            self.empty_file_ratio = temp_model.from_map(m['EmptyFileRatio'])
        if m.get('FreezeDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize()
            self.freeze_data_day_growth_size = temp_model.from_map(m['FreezeDataDayGrowthSize'])
        if m.get('FreezeDataRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio()
            self.freeze_data_ratio = temp_model.from_map(m['FreezeDataRatio'])
        if m.get('FreezeDataSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('FreezeDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio()
            self.freeze_data_size_day_growth_ratio = temp_model.from_map(m['FreezeDataSizeDayGrowthRatio'])
        if m.get('HotDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize()
            self.hot_data_day_growth_size = temp_model.from_map(m['HotDataDayGrowthSize'])
        if m.get('HotDataRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio()
            self.hot_data_ratio = temp_model.from_map(m['HotDataRatio'])
        if m.get('HotDataSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('HotDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio()
            self.hot_data_size_day_growth_ratio = temp_model.from_map(m['HotDataSizeDayGrowthRatio'])
        if m.get('LargeFileCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount()
            self.large_file_count = temp_model.from_map(m['LargeFileCount'])
        if m.get('LargeFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio()
            self.large_file_count_day_growth_ratio = temp_model.from_map(m['LargeFileCountDayGrowthRatio'])
        if m.get('LargeFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount()
            self.large_file_day_growth_count = temp_model.from_map(m['LargeFileDayGrowthCount'])
        if m.get('LargeFileRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio()
            self.large_file_ratio = temp_model.from_map(m['LargeFileRatio'])
        if m.get('MediumFileCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount()
            self.medium_file_count = temp_model.from_map(m['MediumFileCount'])
        if m.get('MediumFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio()
            self.medium_file_count_day_growth_ratio = temp_model.from_map(m['MediumFileCountDayGrowthRatio'])
        if m.get('MediumFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount()
            self.medium_file_day_growth_count = temp_model.from_map(m['MediumFileDayGrowthCount'])
        if m.get('MediumFileRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio()
            self.medium_file_ratio = temp_model.from_map(m['MediumFileRatio'])
        if m.get('PartitionNum') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum()
            self.partition_num = temp_model.from_map(m['PartitionNum'])
        if m.get('SmallFileCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount()
            self.small_file_count = temp_model.from_map(m['SmallFileCount'])
        if m.get('SmallFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio()
            self.small_file_count_day_growth_ratio = temp_model.from_map(m['SmallFileCountDayGrowthRatio'])
        if m.get('SmallFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount()
            self.small_file_day_growth_count = temp_model.from_map(m['SmallFileDayGrowthCount'])
        if m.get('SmallFileRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio()
            self.small_file_ratio = temp_model.from_map(m['SmallFileRatio'])
        if m.get('TableCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTableCount()
            self.table_count = temp_model.from_map(m['TableCount'])
        if m.get('TinyFileCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount()
            self.tiny_file_count = temp_model.from_map(m['TinyFileCount'])
        if m.get('TinyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio()
            self.tiny_file_count_day_growth_ratio = temp_model.from_map(m['TinyFileCountDayGrowthRatio'])
        if m.get('TinyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount()
            self.tiny_file_day_growth_count = temp_model.from_map(m['TinyFileDayGrowthCount'])
        if m.get('TinyFileRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio()
            self.tiny_file_ratio = temp_model.from_map(m['TinyFileRatio'])
        if m.get('TotalDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize()
            self.total_data_day_growth_size = temp_model.from_map(m['TotalDataDayGrowthSize'])
        if m.get('TotalDataSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio()
            self.total_data_size_day_growth_ratio = temp_model.from_map(m['TotalDataSizeDayGrowthRatio'])
        if m.get('TotalFileCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        if m.get('TotalFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio()
            self.total_file_count_day_growth_ratio = temp_model.from_map(m['TotalFileCountDayGrowthRatio'])
        if m.get('TotalFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount()
            self.total_file_day_growth_count = temp_model.from_map(m['TotalFileDayGrowthCount'])
        if m.get('WarmDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize()
            self.warm_data_day_growth_size = temp_model.from_map(m['WarmDataDayGrowthSize'])
        if m.get('WarmDataRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio()
            self.warm_data_ratio = temp_model.from_map(m['WarmDataRatio'])
        if m.get('WarmDataSize') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WarmDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio()
            self.warm_data_size_day_growth_ratio = temp_model.from_map(m['WarmDataSizeDayGrowthRatio'])
        return self


class GetDoctorHiveClusterResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: GetDoctorHiveClusterResponseBodyDataAnalysis = None,
        formats: List[GetDoctorHiveClusterResponseBodyDataFormats] = None,
        metrics: GetDoctorHiveClusterResponseBodyDataMetrics = None,
    ):
        # The analysis results.
        self.analysis = analysis
        # The information from the perspective of storage formats.
        self.formats = formats
        # The metric information.
        self.metrics = metrics

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.formats:
            for k in self.formats:
                if k:
                    k.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        result['Formats'] = []
        if self.formats is not None:
            for k in self.formats:
                result['Formats'].append(k.to_map() if k else None)
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        self.formats = []
        if m.get('Formats') is not None:
            for k in m.get('Formats'):
                temp_model = GetDoctorHiveClusterResponseBodyDataFormats()
                self.formats.append(temp_model.from_map(k))
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class GetDoctorHiveClusterResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHiveClusterResponseBodyData = None,
        request_id: str = None,
    ):
        # The analysis results of the Hive cluster.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHiveClusterResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHiveClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHiveClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHiveClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHiveDatabaseRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        database_name: str = None,
        date_time: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The database name.
        # 
        # This parameter is required.
        self.database_name = database_name
        # The query date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorHiveDatabaseResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        hive_distribution_score: int = None,
        hive_format_score: int = None,
        hive_frequency_score: int = None,
        hive_score: int = None,
    ):
        # The score for the file sizes of the Hive database.
        self.hive_distribution_score = hive_distribution_score
        # The score for the data formats of the Hive database.
        self.hive_format_score = hive_format_score
        # The score for the access frequency of the Hive database.
        self.hive_frequency_score = hive_frequency_score
        # The overall score of the Hive database.
        self.hive_score = hive_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hive_distribution_score is not None:
            result['HiveDistributionScore'] = self.hive_distribution_score
        if self.hive_format_score is not None:
            result['HiveFormatScore'] = self.hive_format_score
        if self.hive_frequency_score is not None:
            result['HiveFrequencyScore'] = self.hive_frequency_score
        if self.hive_score is not None:
            result['HiveScore'] = self.hive_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HiveDistributionScore') is not None:
            self.hive_distribution_score = m.get('HiveDistributionScore')
        if m.get('HiveFormatScore') is not None:
            self.hive_format_score = m.get('HiveFormatScore')
        if m.get('HiveFrequencyScore') is not None:
            self.hive_frequency_score = m.get('HiveFrequencyScore')
        if m.get('HiveScore') is not None:
            self.hive_score = m.get('HiveScore')
        return self


class GetDoctorHiveDatabaseResponseBodyDataFormats(TeaModel):
    def __init__(
        self,
        format_day_growth_size: int = None,
        format_name: str = None,
        format_ratio: float = None,
        format_size: int = None,
        format_size_day_growth_ratio: float = None,
        format_size_unit: str = None,
    ):
        # The daily increment of data in the format.
        self.format_day_growth_size = format_day_growth_size
        # The name of the storage format.
        self.format_name = format_name
        # The proportion of the data in the format.
        self.format_ratio = format_ratio
        # The amount of data in the format.
        self.format_size = format_size
        # The day-to-day growth rate of data in the format.
        self.format_size_day_growth_ratio = format_size_day_growth_ratio
        # The unit of the amount of data in the format.
        self.format_size_unit = format_size_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format_day_growth_size is not None:
            result['FormatDayGrowthSize'] = self.format_day_growth_size
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.format_ratio is not None:
            result['FormatRatio'] = self.format_ratio
        if self.format_size is not None:
            result['FormatSize'] = self.format_size
        if self.format_size_day_growth_ratio is not None:
            result['FormatSizeDayGrowthRatio'] = self.format_size_day_growth_ratio
        if self.format_size_unit is not None:
            result['FormatSizeUnit'] = self.format_size_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FormatDayGrowthSize') is not None:
            self.format_day_growth_size = m.get('FormatDayGrowthSize')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('FormatRatio') is not None:
            self.format_ratio = m.get('FormatRatio')
        if m.get('FormatSize') is not None:
            self.format_size = m.get('FormatSize')
        if m.get('FormatSizeDayGrowthRatio') is not None:
            self.format_size_day_growth_ratio = m.get('FormatSizeDayGrowthRatio')
        if m.get('FormatSizeUnit') is not None:
            self.format_size_unit = m.get('FormatSizeUnit')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveDatabaseResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_data_day_growth_size: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize = None,
        cold_data_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio = None,
        cold_data_size: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize = None,
        cold_data_size_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio = None,
        empty_file_count: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount = None,
        empty_file_count_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio = None,
        empty_file_day_growth_count: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount = None,
        empty_file_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio = None,
        freeze_data_day_growth_size: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize = None,
        freeze_data_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio = None,
        freeze_data_size: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize = None,
        freeze_data_size_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio = None,
        hot_data_day_growth_size: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize = None,
        hot_data_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio = None,
        hot_data_size: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize = None,
        hot_data_size_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio = None,
        large_file_count: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount = None,
        large_file_count_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio = None,
        large_file_day_growth_count: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount = None,
        large_file_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio = None,
        medium_file_count: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount = None,
        medium_file_count_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio = None,
        medium_file_day_growth_count: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount = None,
        medium_file_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio = None,
        partition_num: GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum = None,
        small_file_count: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount = None,
        small_file_count_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio = None,
        small_file_day_growth_count: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount = None,
        small_file_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio = None,
        table_count: GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount = None,
        tiny_file_count: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount = None,
        tiny_file_count_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio = None,
        tiny_file_day_growth_count: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount = None,
        tiny_file_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio = None,
        total_data_day_growth_size: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize = None,
        total_data_size: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize = None,
        total_data_size_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio = None,
        total_file_count: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount = None,
        total_file_count_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio = None,
        total_file_day_growth_count: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount = None,
        warm_data_day_growth_size: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize = None,
        warm_data_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio = None,
        warm_data_size: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize = None,
        warm_data_size_day_growth_ratio: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio = None,
    ):
        # The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_day_growth_size = cold_data_day_growth_size
        # The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_ratio = cold_data_ratio
        # The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_size = cold_data_size
        # The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_size_day_growth_ratio = cold_data_size_day_growth_ratio
        # The number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count = empty_file_count
        # The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count_day_growth_ratio = empty_file_count_day_growth_ratio
        # The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_day_growth_count = empty_file_day_growth_count
        # The proportion of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_ratio = empty_file_ratio
        # The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_day_growth_size = freeze_data_day_growth_size
        # The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_ratio = freeze_data_ratio
        # The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size = freeze_data_size
        # The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size_day_growth_ratio = freeze_data_size_day_growth_ratio
        # The daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_day_growth_size = hot_data_day_growth_size
        # The proportion of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_ratio = hot_data_ratio
        # The amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_size = hot_data_size
        # The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_size_day_growth_ratio = hot_data_size_day_growth_ratio
        # The number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count = large_file_count
        # The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count_day_growth_ratio = large_file_count_day_growth_ratio
        # The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_day_growth_count = large_file_day_growth_count
        # The proportion of large files. Large files are those with a size greater than 1 GB.
        self.large_file_ratio = large_file_ratio
        # The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count = medium_file_count
        # The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count_day_growth_ratio = medium_file_count_day_growth_ratio
        # The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_day_growth_count = medium_file_day_growth_count
        # The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_ratio = medium_file_ratio
        # The number of partitions.
        self.partition_num = partition_num
        # The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count = small_file_count
        # The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count_day_growth_ratio = small_file_count_day_growth_ratio
        # The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_day_growth_count = small_file_day_growth_count
        # The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_ratio = small_file_ratio
        # The number of tables.
        self.table_count = table_count
        # The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count = tiny_file_count
        # The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count_day_growth_ratio = tiny_file_count_day_growth_ratio
        # The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_day_growth_count = tiny_file_day_growth_count
        # The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_ratio = tiny_file_ratio
        # The daily incremental of the total amount of data.
        self.total_data_day_growth_size = total_data_day_growth_size
        # The total amount of data.
        self.total_data_size = total_data_size
        # The day-to-day growth rate of the total data volume.
        self.total_data_size_day_growth_ratio = total_data_size_day_growth_ratio
        # The total number of files.
        self.total_file_count = total_file_count
        # The day-to-day growth rate of the total number of files.
        self.total_file_count_day_growth_ratio = total_file_count_day_growth_ratio
        # The daily increment of the total number of files.
        self.total_file_day_growth_count = total_file_day_growth_count
        # The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_day_growth_size = warm_data_day_growth_size
        # The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_ratio = warm_data_ratio
        # The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_size = warm_data_size
        # The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_size_day_growth_ratio = warm_data_size_day_growth_ratio

    def validate(self):
        if self.cold_data_day_growth_size:
            self.cold_data_day_growth_size.validate()
        if self.cold_data_ratio:
            self.cold_data_ratio.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.cold_data_size_day_growth_ratio:
            self.cold_data_size_day_growth_ratio.validate()
        if self.empty_file_count:
            self.empty_file_count.validate()
        if self.empty_file_count_day_growth_ratio:
            self.empty_file_count_day_growth_ratio.validate()
        if self.empty_file_day_growth_count:
            self.empty_file_day_growth_count.validate()
        if self.empty_file_ratio:
            self.empty_file_ratio.validate()
        if self.freeze_data_day_growth_size:
            self.freeze_data_day_growth_size.validate()
        if self.freeze_data_ratio:
            self.freeze_data_ratio.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.freeze_data_size_day_growth_ratio:
            self.freeze_data_size_day_growth_ratio.validate()
        if self.hot_data_day_growth_size:
            self.hot_data_day_growth_size.validate()
        if self.hot_data_ratio:
            self.hot_data_ratio.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.hot_data_size_day_growth_ratio:
            self.hot_data_size_day_growth_ratio.validate()
        if self.large_file_count:
            self.large_file_count.validate()
        if self.large_file_count_day_growth_ratio:
            self.large_file_count_day_growth_ratio.validate()
        if self.large_file_day_growth_count:
            self.large_file_day_growth_count.validate()
        if self.large_file_ratio:
            self.large_file_ratio.validate()
        if self.medium_file_count:
            self.medium_file_count.validate()
        if self.medium_file_count_day_growth_ratio:
            self.medium_file_count_day_growth_ratio.validate()
        if self.medium_file_day_growth_count:
            self.medium_file_day_growth_count.validate()
        if self.medium_file_ratio:
            self.medium_file_ratio.validate()
        if self.partition_num:
            self.partition_num.validate()
        if self.small_file_count:
            self.small_file_count.validate()
        if self.small_file_count_day_growth_ratio:
            self.small_file_count_day_growth_ratio.validate()
        if self.small_file_day_growth_count:
            self.small_file_day_growth_count.validate()
        if self.small_file_ratio:
            self.small_file_ratio.validate()
        if self.table_count:
            self.table_count.validate()
        if self.tiny_file_count:
            self.tiny_file_count.validate()
        if self.tiny_file_count_day_growth_ratio:
            self.tiny_file_count_day_growth_ratio.validate()
        if self.tiny_file_day_growth_count:
            self.tiny_file_day_growth_count.validate()
        if self.tiny_file_ratio:
            self.tiny_file_ratio.validate()
        if self.total_data_day_growth_size:
            self.total_data_day_growth_size.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_data_size_day_growth_ratio:
            self.total_data_size_day_growth_ratio.validate()
        if self.total_file_count:
            self.total_file_count.validate()
        if self.total_file_count_day_growth_ratio:
            self.total_file_count_day_growth_ratio.validate()
        if self.total_file_day_growth_count:
            self.total_file_day_growth_count.validate()
        if self.warm_data_day_growth_size:
            self.warm_data_day_growth_size.validate()
        if self.warm_data_ratio:
            self.warm_data_ratio.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.warm_data_size_day_growth_ratio:
            self.warm_data_size_day_growth_ratio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_data_day_growth_size is not None:
            result['ColdDataDayGrowthSize'] = self.cold_data_day_growth_size.to_map()
        if self.cold_data_ratio is not None:
            result['ColdDataRatio'] = self.cold_data_ratio.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.cold_data_size_day_growth_ratio is not None:
            result['ColdDataSizeDayGrowthRatio'] = self.cold_data_size_day_growth_ratio.to_map()
        if self.empty_file_count is not None:
            result['EmptyFileCount'] = self.empty_file_count.to_map()
        if self.empty_file_count_day_growth_ratio is not None:
            result['EmptyFileCountDayGrowthRatio'] = self.empty_file_count_day_growth_ratio.to_map()
        if self.empty_file_day_growth_count is not None:
            result['EmptyFileDayGrowthCount'] = self.empty_file_day_growth_count.to_map()
        if self.empty_file_ratio is not None:
            result['EmptyFileRatio'] = self.empty_file_ratio.to_map()
        if self.freeze_data_day_growth_size is not None:
            result['FreezeDataDayGrowthSize'] = self.freeze_data_day_growth_size.to_map()
        if self.freeze_data_ratio is not None:
            result['FreezeDataRatio'] = self.freeze_data_ratio.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.freeze_data_size_day_growth_ratio is not None:
            result['FreezeDataSizeDayGrowthRatio'] = self.freeze_data_size_day_growth_ratio.to_map()
        if self.hot_data_day_growth_size is not None:
            result['HotDataDayGrowthSize'] = self.hot_data_day_growth_size.to_map()
        if self.hot_data_ratio is not None:
            result['HotDataRatio'] = self.hot_data_ratio.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.hot_data_size_day_growth_ratio is not None:
            result['HotDataSizeDayGrowthRatio'] = self.hot_data_size_day_growth_ratio.to_map()
        if self.large_file_count is not None:
            result['LargeFileCount'] = self.large_file_count.to_map()
        if self.large_file_count_day_growth_ratio is not None:
            result['LargeFileCountDayGrowthRatio'] = self.large_file_count_day_growth_ratio.to_map()
        if self.large_file_day_growth_count is not None:
            result['LargeFileDayGrowthCount'] = self.large_file_day_growth_count.to_map()
        if self.large_file_ratio is not None:
            result['LargeFileRatio'] = self.large_file_ratio.to_map()
        if self.medium_file_count is not None:
            result['MediumFileCount'] = self.medium_file_count.to_map()
        if self.medium_file_count_day_growth_ratio is not None:
            result['MediumFileCountDayGrowthRatio'] = self.medium_file_count_day_growth_ratio.to_map()
        if self.medium_file_day_growth_count is not None:
            result['MediumFileDayGrowthCount'] = self.medium_file_day_growth_count.to_map()
        if self.medium_file_ratio is not None:
            result['MediumFileRatio'] = self.medium_file_ratio.to_map()
        if self.partition_num is not None:
            result['PartitionNum'] = self.partition_num.to_map()
        if self.small_file_count is not None:
            result['SmallFileCount'] = self.small_file_count.to_map()
        if self.small_file_count_day_growth_ratio is not None:
            result['SmallFileCountDayGrowthRatio'] = self.small_file_count_day_growth_ratio.to_map()
        if self.small_file_day_growth_count is not None:
            result['SmallFileDayGrowthCount'] = self.small_file_day_growth_count.to_map()
        if self.small_file_ratio is not None:
            result['SmallFileRatio'] = self.small_file_ratio.to_map()
        if self.table_count is not None:
            result['TableCount'] = self.table_count.to_map()
        if self.tiny_file_count is not None:
            result['TinyFileCount'] = self.tiny_file_count.to_map()
        if self.tiny_file_count_day_growth_ratio is not None:
            result['TinyFileCountDayGrowthRatio'] = self.tiny_file_count_day_growth_ratio.to_map()
        if self.tiny_file_day_growth_count is not None:
            result['TinyFileDayGrowthCount'] = self.tiny_file_day_growth_count.to_map()
        if self.tiny_file_ratio is not None:
            result['TinyFileRatio'] = self.tiny_file_ratio.to_map()
        if self.total_data_day_growth_size is not None:
            result['TotalDataDayGrowthSize'] = self.total_data_day_growth_size.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_data_size_day_growth_ratio is not None:
            result['TotalDataSizeDayGrowthRatio'] = self.total_data_size_day_growth_ratio.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        if self.total_file_count_day_growth_ratio is not None:
            result['TotalFileCountDayGrowthRatio'] = self.total_file_count_day_growth_ratio.to_map()
        if self.total_file_day_growth_count is not None:
            result['TotalFileDayGrowthCount'] = self.total_file_day_growth_count.to_map()
        if self.warm_data_day_growth_size is not None:
            result['WarmDataDayGrowthSize'] = self.warm_data_day_growth_size.to_map()
        if self.warm_data_ratio is not None:
            result['WarmDataRatio'] = self.warm_data_ratio.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.warm_data_size_day_growth_ratio is not None:
            result['WarmDataSizeDayGrowthRatio'] = self.warm_data_size_day_growth_ratio.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize()
            self.cold_data_day_growth_size = temp_model.from_map(m['ColdDataDayGrowthSize'])
        if m.get('ColdDataRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio()
            self.cold_data_ratio = temp_model.from_map(m['ColdDataRatio'])
        if m.get('ColdDataSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('ColdDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio()
            self.cold_data_size_day_growth_ratio = temp_model.from_map(m['ColdDataSizeDayGrowthRatio'])
        if m.get('EmptyFileCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount()
            self.empty_file_count = temp_model.from_map(m['EmptyFileCount'])
        if m.get('EmptyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio()
            self.empty_file_count_day_growth_ratio = temp_model.from_map(m['EmptyFileCountDayGrowthRatio'])
        if m.get('EmptyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount()
            self.empty_file_day_growth_count = temp_model.from_map(m['EmptyFileDayGrowthCount'])
        if m.get('EmptyFileRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio()
            self.empty_file_ratio = temp_model.from_map(m['EmptyFileRatio'])
        if m.get('FreezeDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize()
            self.freeze_data_day_growth_size = temp_model.from_map(m['FreezeDataDayGrowthSize'])
        if m.get('FreezeDataRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio()
            self.freeze_data_ratio = temp_model.from_map(m['FreezeDataRatio'])
        if m.get('FreezeDataSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('FreezeDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio()
            self.freeze_data_size_day_growth_ratio = temp_model.from_map(m['FreezeDataSizeDayGrowthRatio'])
        if m.get('HotDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize()
            self.hot_data_day_growth_size = temp_model.from_map(m['HotDataDayGrowthSize'])
        if m.get('HotDataRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio()
            self.hot_data_ratio = temp_model.from_map(m['HotDataRatio'])
        if m.get('HotDataSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('HotDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio()
            self.hot_data_size_day_growth_ratio = temp_model.from_map(m['HotDataSizeDayGrowthRatio'])
        if m.get('LargeFileCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount()
            self.large_file_count = temp_model.from_map(m['LargeFileCount'])
        if m.get('LargeFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio()
            self.large_file_count_day_growth_ratio = temp_model.from_map(m['LargeFileCountDayGrowthRatio'])
        if m.get('LargeFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount()
            self.large_file_day_growth_count = temp_model.from_map(m['LargeFileDayGrowthCount'])
        if m.get('LargeFileRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio()
            self.large_file_ratio = temp_model.from_map(m['LargeFileRatio'])
        if m.get('MediumFileCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount()
            self.medium_file_count = temp_model.from_map(m['MediumFileCount'])
        if m.get('MediumFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio()
            self.medium_file_count_day_growth_ratio = temp_model.from_map(m['MediumFileCountDayGrowthRatio'])
        if m.get('MediumFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount()
            self.medium_file_day_growth_count = temp_model.from_map(m['MediumFileDayGrowthCount'])
        if m.get('MediumFileRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio()
            self.medium_file_ratio = temp_model.from_map(m['MediumFileRatio'])
        if m.get('PartitionNum') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum()
            self.partition_num = temp_model.from_map(m['PartitionNum'])
        if m.get('SmallFileCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount()
            self.small_file_count = temp_model.from_map(m['SmallFileCount'])
        if m.get('SmallFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio()
            self.small_file_count_day_growth_ratio = temp_model.from_map(m['SmallFileCountDayGrowthRatio'])
        if m.get('SmallFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount()
            self.small_file_day_growth_count = temp_model.from_map(m['SmallFileDayGrowthCount'])
        if m.get('SmallFileRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio()
            self.small_file_ratio = temp_model.from_map(m['SmallFileRatio'])
        if m.get('TableCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount()
            self.table_count = temp_model.from_map(m['TableCount'])
        if m.get('TinyFileCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount()
            self.tiny_file_count = temp_model.from_map(m['TinyFileCount'])
        if m.get('TinyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio()
            self.tiny_file_count_day_growth_ratio = temp_model.from_map(m['TinyFileCountDayGrowthRatio'])
        if m.get('TinyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount()
            self.tiny_file_day_growth_count = temp_model.from_map(m['TinyFileDayGrowthCount'])
        if m.get('TinyFileRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio()
            self.tiny_file_ratio = temp_model.from_map(m['TinyFileRatio'])
        if m.get('TotalDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize()
            self.total_data_day_growth_size = temp_model.from_map(m['TotalDataDayGrowthSize'])
        if m.get('TotalDataSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio()
            self.total_data_size_day_growth_ratio = temp_model.from_map(m['TotalDataSizeDayGrowthRatio'])
        if m.get('TotalFileCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        if m.get('TotalFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio()
            self.total_file_count_day_growth_ratio = temp_model.from_map(m['TotalFileCountDayGrowthRatio'])
        if m.get('TotalFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount()
            self.total_file_day_growth_count = temp_model.from_map(m['TotalFileDayGrowthCount'])
        if m.get('WarmDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize()
            self.warm_data_day_growth_size = temp_model.from_map(m['WarmDataDayGrowthSize'])
        if m.get('WarmDataRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio()
            self.warm_data_ratio = temp_model.from_map(m['WarmDataRatio'])
        if m.get('WarmDataSize') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WarmDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio()
            self.warm_data_size_day_growth_ratio = temp_model.from_map(m['WarmDataSizeDayGrowthRatio'])
        return self


class GetDoctorHiveDatabaseResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: GetDoctorHiveDatabaseResponseBodyDataAnalysis = None,
        formats: List[GetDoctorHiveDatabaseResponseBodyDataFormats] = None,
        metrics: GetDoctorHiveDatabaseResponseBodyDataMetrics = None,
    ):
        # The analysis results.
        self.analysis = analysis
        # The information from the perspective of storage formats.
        self.formats = formats
        # The metric information.
        self.metrics = metrics

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.formats:
            for k in self.formats:
                if k:
                    k.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        result['Formats'] = []
        if self.formats is not None:
            for k in self.formats:
                result['Formats'].append(k.to_map() if k else None)
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        self.formats = []
        if m.get('Formats') is not None:
            for k in m.get('Formats'):
                temp_model = GetDoctorHiveDatabaseResponseBodyDataFormats()
                self.formats.append(temp_model.from_map(k))
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class GetDoctorHiveDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHiveDatabaseResponseBodyData = None,
        request_id: str = None,
    ):
        # The analysis results of the Hive database.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHiveDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHiveDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHiveDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorHiveTableRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        region_id: str = None,
        table_name: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The table name. The table name must follow the rule in Hive. A name in the {database name.table identifier} format uniquely identifies a table.
        # 
        # This parameter is required.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetDoctorHiveTableResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        hive_distribution_score: int = None,
        hive_format_score: int = None,
        hive_frequency_score: int = None,
        hive_score: int = None,
    ):
        # The score for the distribution of files of different sizes stored in the Hive table.
        self.hive_distribution_score = hive_distribution_score
        # The score for the distribution of files stored in different formats in the Hive table.
        self.hive_format_score = hive_format_score
        # The score for the access frequency of the Hive table.
        self.hive_frequency_score = hive_frequency_score
        # The overall score of the Hive table.
        self.hive_score = hive_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hive_distribution_score is not None:
            result['HiveDistributionScore'] = self.hive_distribution_score
        if self.hive_format_score is not None:
            result['HiveFormatScore'] = self.hive_format_score
        if self.hive_frequency_score is not None:
            result['HiveFrequencyScore'] = self.hive_frequency_score
        if self.hive_score is not None:
            result['HiveScore'] = self.hive_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HiveDistributionScore') is not None:
            self.hive_distribution_score = m.get('HiveDistributionScore')
        if m.get('HiveFormatScore') is not None:
            self.hive_format_score = m.get('HiveFormatScore')
        if m.get('HiveFrequencyScore') is not None:
            self.hive_frequency_score = m.get('HiveFrequencyScore')
        if m.get('HiveScore') is not None:
            self.hive_score = m.get('HiveScore')
        return self


class GetDoctorHiveTableResponseBodyDataFormats(TeaModel):
    def __init__(
        self,
        format_day_growth_size: int = None,
        format_name: str = None,
        format_ratio: float = None,
        format_size: int = None,
        format_size_day_growth_ratio: float = None,
        format_size_unit: str = None,
    ):
        # The daily amount increment of the data in a specific storage format.
        self.format_day_growth_size = format_day_growth_size
        # The name of the storage format.
        self.format_name = format_name
        # The ratio of the data in a specific storage format.
        self.format_ratio = format_ratio
        # The size of storage format-specific data.
        self.format_size = format_size
        # The day-to-day growth rate of the amount of the data in a specific storage format.
        self.format_size_day_growth_ratio = format_size_day_growth_ratio
        # The unit of the data size.
        self.format_size_unit = format_size_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format_day_growth_size is not None:
            result['FormatDayGrowthSize'] = self.format_day_growth_size
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.format_ratio is not None:
            result['FormatRatio'] = self.format_ratio
        if self.format_size is not None:
            result['FormatSize'] = self.format_size
        if self.format_size_day_growth_ratio is not None:
            result['FormatSizeDayGrowthRatio'] = self.format_size_day_growth_ratio
        if self.format_size_unit is not None:
            result['FormatSizeUnit'] = self.format_size_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FormatDayGrowthSize') is not None:
            self.format_day_growth_size = m.get('FormatDayGrowthSize')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('FormatRatio') is not None:
            self.format_ratio = m.get('FormatRatio')
        if m.get('FormatSize') is not None:
            self.format_size = m.get('FormatSize')
        if m.get('FormatSizeDayGrowthRatio') is not None:
            self.format_size_day_growth_ratio = m.get('FormatSizeDayGrowthRatio')
        if m.get('FormatSizeUnit') is not None:
            self.format_size_unit = m.get('FormatSizeUnit')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsPartitionNum(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorHiveTableResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_data_day_growth_size: GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize = None,
        cold_data_ratio: GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio = None,
        cold_data_size: GetDoctorHiveTableResponseBodyDataMetricsColdDataSize = None,
        cold_data_size_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio = None,
        empty_file_count: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount = None,
        empty_file_count_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio = None,
        empty_file_day_growth_count: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount = None,
        empty_file_ratio: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio = None,
        freeze_data_day_growth_size: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize = None,
        freeze_data_ratio: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio = None,
        freeze_data_size: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize = None,
        freeze_data_size_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio = None,
        hot_data_day_growth_size: GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize = None,
        hot_data_ratio: GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio = None,
        hot_data_size: GetDoctorHiveTableResponseBodyDataMetricsHotDataSize = None,
        hot_data_size_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio = None,
        large_file_count: GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount = None,
        large_file_count_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio = None,
        large_file_day_growth_count: GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount = None,
        large_file_ratio: GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio = None,
        medium_file_count: GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount = None,
        medium_file_count_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio = None,
        medium_file_day_growth_count: GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount = None,
        medium_file_ratio: GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio = None,
        partition_num: GetDoctorHiveTableResponseBodyDataMetricsPartitionNum = None,
        small_file_count: GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount = None,
        small_file_count_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio = None,
        small_file_day_growth_count: GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount = None,
        small_file_ratio: GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio = None,
        tiny_file_count: GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount = None,
        tiny_file_count_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio = None,
        tiny_file_day_growth_count: GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount = None,
        tiny_file_ratio: GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio = None,
        total_data_day_growth_size: GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize = None,
        total_data_size: GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize = None,
        total_data_size_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio = None,
        total_file_count: GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount = None,
        total_file_count_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio = None,
        total_file_day_growth_count: GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount = None,
        warm_data_day_growth_size: GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize = None,
        warm_data_ratio: GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio = None,
        warm_data_size: GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize = None,
        warm_data_size_day_growth_ratio: GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio = None,
    ):
        # The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_day_growth_size = cold_data_day_growth_size
        # The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_ratio = cold_data_ratio
        # The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_size = cold_data_size
        # The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_size_day_growth_ratio = cold_data_size_day_growth_ratio
        # The number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count = empty_file_count
        # The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count_day_growth_ratio = empty_file_count_day_growth_ratio
        # The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_day_growth_count = empty_file_day_growth_count
        # The proportion of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_ratio = empty_file_ratio
        # The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_day_growth_size = freeze_data_day_growth_size
        # The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_ratio = freeze_data_ratio
        # The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size = freeze_data_size
        # The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size_day_growth_ratio = freeze_data_size_day_growth_ratio
        # The daily increment of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_day_growth_size = hot_data_day_growth_size
        # The proportion of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_ratio = hot_data_ratio
        # The amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_size = hot_data_size
        # The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_size_day_growth_ratio = hot_data_size_day_growth_ratio
        # The number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count = large_file_count
        # The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count_day_growth_ratio = large_file_count_day_growth_ratio
        # The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_day_growth_count = large_file_day_growth_count
        # The proportion of large files. Large files are those with a size greater than 1 GB.
        self.large_file_ratio = large_file_ratio
        # The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count = medium_file_count
        # The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count_day_growth_ratio = medium_file_count_day_growth_ratio
        # The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_day_growth_count = medium_file_day_growth_count
        # The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_ratio = medium_file_ratio
        # The number of partitions.
        self.partition_num = partition_num
        # The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count = small_file_count
        # The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count_day_growth_ratio = small_file_count_day_growth_ratio
        # The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_day_growth_count = small_file_day_growth_count
        # The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_ratio = small_file_ratio
        # The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count = tiny_file_count
        # The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count_day_growth_ratio = tiny_file_count_day_growth_ratio
        # The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_day_growth_count = tiny_file_day_growth_count
        # The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_ratio = tiny_file_ratio
        # The daily incremental of the total data volume.
        self.total_data_day_growth_size = total_data_day_growth_size
        # The total amount of data.
        self.total_data_size = total_data_size
        # The day-to-day growth rate of the total data volume.
        self.total_data_size_day_growth_ratio = total_data_size_day_growth_ratio
        # The total number of files.
        self.total_file_count = total_file_count
        # The day-to-day growth rate of the total number of files.
        self.total_file_count_day_growth_ratio = total_file_count_day_growth_ratio
        # The daily increment of the total number of files.
        self.total_file_day_growth_count = total_file_day_growth_count
        # The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_day_growth_size = warm_data_day_growth_size
        # The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_ratio = warm_data_ratio
        # The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_size = warm_data_size
        # The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_size_day_growth_ratio = warm_data_size_day_growth_ratio

    def validate(self):
        if self.cold_data_day_growth_size:
            self.cold_data_day_growth_size.validate()
        if self.cold_data_ratio:
            self.cold_data_ratio.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.cold_data_size_day_growth_ratio:
            self.cold_data_size_day_growth_ratio.validate()
        if self.empty_file_count:
            self.empty_file_count.validate()
        if self.empty_file_count_day_growth_ratio:
            self.empty_file_count_day_growth_ratio.validate()
        if self.empty_file_day_growth_count:
            self.empty_file_day_growth_count.validate()
        if self.empty_file_ratio:
            self.empty_file_ratio.validate()
        if self.freeze_data_day_growth_size:
            self.freeze_data_day_growth_size.validate()
        if self.freeze_data_ratio:
            self.freeze_data_ratio.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.freeze_data_size_day_growth_ratio:
            self.freeze_data_size_day_growth_ratio.validate()
        if self.hot_data_day_growth_size:
            self.hot_data_day_growth_size.validate()
        if self.hot_data_ratio:
            self.hot_data_ratio.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.hot_data_size_day_growth_ratio:
            self.hot_data_size_day_growth_ratio.validate()
        if self.large_file_count:
            self.large_file_count.validate()
        if self.large_file_count_day_growth_ratio:
            self.large_file_count_day_growth_ratio.validate()
        if self.large_file_day_growth_count:
            self.large_file_day_growth_count.validate()
        if self.large_file_ratio:
            self.large_file_ratio.validate()
        if self.medium_file_count:
            self.medium_file_count.validate()
        if self.medium_file_count_day_growth_ratio:
            self.medium_file_count_day_growth_ratio.validate()
        if self.medium_file_day_growth_count:
            self.medium_file_day_growth_count.validate()
        if self.medium_file_ratio:
            self.medium_file_ratio.validate()
        if self.partition_num:
            self.partition_num.validate()
        if self.small_file_count:
            self.small_file_count.validate()
        if self.small_file_count_day_growth_ratio:
            self.small_file_count_day_growth_ratio.validate()
        if self.small_file_day_growth_count:
            self.small_file_day_growth_count.validate()
        if self.small_file_ratio:
            self.small_file_ratio.validate()
        if self.tiny_file_count:
            self.tiny_file_count.validate()
        if self.tiny_file_count_day_growth_ratio:
            self.tiny_file_count_day_growth_ratio.validate()
        if self.tiny_file_day_growth_count:
            self.tiny_file_day_growth_count.validate()
        if self.tiny_file_ratio:
            self.tiny_file_ratio.validate()
        if self.total_data_day_growth_size:
            self.total_data_day_growth_size.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_data_size_day_growth_ratio:
            self.total_data_size_day_growth_ratio.validate()
        if self.total_file_count:
            self.total_file_count.validate()
        if self.total_file_count_day_growth_ratio:
            self.total_file_count_day_growth_ratio.validate()
        if self.total_file_day_growth_count:
            self.total_file_day_growth_count.validate()
        if self.warm_data_day_growth_size:
            self.warm_data_day_growth_size.validate()
        if self.warm_data_ratio:
            self.warm_data_ratio.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.warm_data_size_day_growth_ratio:
            self.warm_data_size_day_growth_ratio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_data_day_growth_size is not None:
            result['ColdDataDayGrowthSize'] = self.cold_data_day_growth_size.to_map()
        if self.cold_data_ratio is not None:
            result['ColdDataRatio'] = self.cold_data_ratio.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.cold_data_size_day_growth_ratio is not None:
            result['ColdDataSizeDayGrowthRatio'] = self.cold_data_size_day_growth_ratio.to_map()
        if self.empty_file_count is not None:
            result['EmptyFileCount'] = self.empty_file_count.to_map()
        if self.empty_file_count_day_growth_ratio is not None:
            result['EmptyFileCountDayGrowthRatio'] = self.empty_file_count_day_growth_ratio.to_map()
        if self.empty_file_day_growth_count is not None:
            result['EmptyFileDayGrowthCount'] = self.empty_file_day_growth_count.to_map()
        if self.empty_file_ratio is not None:
            result['EmptyFileRatio'] = self.empty_file_ratio.to_map()
        if self.freeze_data_day_growth_size is not None:
            result['FreezeDataDayGrowthSize'] = self.freeze_data_day_growth_size.to_map()
        if self.freeze_data_ratio is not None:
            result['FreezeDataRatio'] = self.freeze_data_ratio.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.freeze_data_size_day_growth_ratio is not None:
            result['FreezeDataSizeDayGrowthRatio'] = self.freeze_data_size_day_growth_ratio.to_map()
        if self.hot_data_day_growth_size is not None:
            result['HotDataDayGrowthSize'] = self.hot_data_day_growth_size.to_map()
        if self.hot_data_ratio is not None:
            result['HotDataRatio'] = self.hot_data_ratio.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.hot_data_size_day_growth_ratio is not None:
            result['HotDataSizeDayGrowthRatio'] = self.hot_data_size_day_growth_ratio.to_map()
        if self.large_file_count is not None:
            result['LargeFileCount'] = self.large_file_count.to_map()
        if self.large_file_count_day_growth_ratio is not None:
            result['LargeFileCountDayGrowthRatio'] = self.large_file_count_day_growth_ratio.to_map()
        if self.large_file_day_growth_count is not None:
            result['LargeFileDayGrowthCount'] = self.large_file_day_growth_count.to_map()
        if self.large_file_ratio is not None:
            result['LargeFileRatio'] = self.large_file_ratio.to_map()
        if self.medium_file_count is not None:
            result['MediumFileCount'] = self.medium_file_count.to_map()
        if self.medium_file_count_day_growth_ratio is not None:
            result['MediumFileCountDayGrowthRatio'] = self.medium_file_count_day_growth_ratio.to_map()
        if self.medium_file_day_growth_count is not None:
            result['MediumFileDayGrowthCount'] = self.medium_file_day_growth_count.to_map()
        if self.medium_file_ratio is not None:
            result['MediumFileRatio'] = self.medium_file_ratio.to_map()
        if self.partition_num is not None:
            result['PartitionNum'] = self.partition_num.to_map()
        if self.small_file_count is not None:
            result['SmallFileCount'] = self.small_file_count.to_map()
        if self.small_file_count_day_growth_ratio is not None:
            result['SmallFileCountDayGrowthRatio'] = self.small_file_count_day_growth_ratio.to_map()
        if self.small_file_day_growth_count is not None:
            result['SmallFileDayGrowthCount'] = self.small_file_day_growth_count.to_map()
        if self.small_file_ratio is not None:
            result['SmallFileRatio'] = self.small_file_ratio.to_map()
        if self.tiny_file_count is not None:
            result['TinyFileCount'] = self.tiny_file_count.to_map()
        if self.tiny_file_count_day_growth_ratio is not None:
            result['TinyFileCountDayGrowthRatio'] = self.tiny_file_count_day_growth_ratio.to_map()
        if self.tiny_file_day_growth_count is not None:
            result['TinyFileDayGrowthCount'] = self.tiny_file_day_growth_count.to_map()
        if self.tiny_file_ratio is not None:
            result['TinyFileRatio'] = self.tiny_file_ratio.to_map()
        if self.total_data_day_growth_size is not None:
            result['TotalDataDayGrowthSize'] = self.total_data_day_growth_size.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_data_size_day_growth_ratio is not None:
            result['TotalDataSizeDayGrowthRatio'] = self.total_data_size_day_growth_ratio.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        if self.total_file_count_day_growth_ratio is not None:
            result['TotalFileCountDayGrowthRatio'] = self.total_file_count_day_growth_ratio.to_map()
        if self.total_file_day_growth_count is not None:
            result['TotalFileDayGrowthCount'] = self.total_file_day_growth_count.to_map()
        if self.warm_data_day_growth_size is not None:
            result['WarmDataDayGrowthSize'] = self.warm_data_day_growth_size.to_map()
        if self.warm_data_ratio is not None:
            result['WarmDataRatio'] = self.warm_data_ratio.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.warm_data_size_day_growth_ratio is not None:
            result['WarmDataSizeDayGrowthRatio'] = self.warm_data_size_day_growth_ratio.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize()
            self.cold_data_day_growth_size = temp_model.from_map(m['ColdDataDayGrowthSize'])
        if m.get('ColdDataRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio()
            self.cold_data_ratio = temp_model.from_map(m['ColdDataRatio'])
        if m.get('ColdDataSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('ColdDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio()
            self.cold_data_size_day_growth_ratio = temp_model.from_map(m['ColdDataSizeDayGrowthRatio'])
        if m.get('EmptyFileCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount()
            self.empty_file_count = temp_model.from_map(m['EmptyFileCount'])
        if m.get('EmptyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio()
            self.empty_file_count_day_growth_ratio = temp_model.from_map(m['EmptyFileCountDayGrowthRatio'])
        if m.get('EmptyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount()
            self.empty_file_day_growth_count = temp_model.from_map(m['EmptyFileDayGrowthCount'])
        if m.get('EmptyFileRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio()
            self.empty_file_ratio = temp_model.from_map(m['EmptyFileRatio'])
        if m.get('FreezeDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize()
            self.freeze_data_day_growth_size = temp_model.from_map(m['FreezeDataDayGrowthSize'])
        if m.get('FreezeDataRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio()
            self.freeze_data_ratio = temp_model.from_map(m['FreezeDataRatio'])
        if m.get('FreezeDataSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('FreezeDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio()
            self.freeze_data_size_day_growth_ratio = temp_model.from_map(m['FreezeDataSizeDayGrowthRatio'])
        if m.get('HotDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize()
            self.hot_data_day_growth_size = temp_model.from_map(m['HotDataDayGrowthSize'])
        if m.get('HotDataRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio()
            self.hot_data_ratio = temp_model.from_map(m['HotDataRatio'])
        if m.get('HotDataSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('HotDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio()
            self.hot_data_size_day_growth_ratio = temp_model.from_map(m['HotDataSizeDayGrowthRatio'])
        if m.get('LargeFileCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount()
            self.large_file_count = temp_model.from_map(m['LargeFileCount'])
        if m.get('LargeFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio()
            self.large_file_count_day_growth_ratio = temp_model.from_map(m['LargeFileCountDayGrowthRatio'])
        if m.get('LargeFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount()
            self.large_file_day_growth_count = temp_model.from_map(m['LargeFileDayGrowthCount'])
        if m.get('LargeFileRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio()
            self.large_file_ratio = temp_model.from_map(m['LargeFileRatio'])
        if m.get('MediumFileCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount()
            self.medium_file_count = temp_model.from_map(m['MediumFileCount'])
        if m.get('MediumFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio()
            self.medium_file_count_day_growth_ratio = temp_model.from_map(m['MediumFileCountDayGrowthRatio'])
        if m.get('MediumFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount()
            self.medium_file_day_growth_count = temp_model.from_map(m['MediumFileDayGrowthCount'])
        if m.get('MediumFileRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio()
            self.medium_file_ratio = temp_model.from_map(m['MediumFileRatio'])
        if m.get('PartitionNum') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsPartitionNum()
            self.partition_num = temp_model.from_map(m['PartitionNum'])
        if m.get('SmallFileCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount()
            self.small_file_count = temp_model.from_map(m['SmallFileCount'])
        if m.get('SmallFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio()
            self.small_file_count_day_growth_ratio = temp_model.from_map(m['SmallFileCountDayGrowthRatio'])
        if m.get('SmallFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount()
            self.small_file_day_growth_count = temp_model.from_map(m['SmallFileDayGrowthCount'])
        if m.get('SmallFileRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio()
            self.small_file_ratio = temp_model.from_map(m['SmallFileRatio'])
        if m.get('TinyFileCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount()
            self.tiny_file_count = temp_model.from_map(m['TinyFileCount'])
        if m.get('TinyFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio()
            self.tiny_file_count_day_growth_ratio = temp_model.from_map(m['TinyFileCountDayGrowthRatio'])
        if m.get('TinyFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount()
            self.tiny_file_day_growth_count = temp_model.from_map(m['TinyFileDayGrowthCount'])
        if m.get('TinyFileRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio()
            self.tiny_file_ratio = temp_model.from_map(m['TinyFileRatio'])
        if m.get('TotalDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize()
            self.total_data_day_growth_size = temp_model.from_map(m['TotalDataDayGrowthSize'])
        if m.get('TotalDataSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio()
            self.total_data_size_day_growth_ratio = temp_model.from_map(m['TotalDataSizeDayGrowthRatio'])
        if m.get('TotalFileCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        if m.get('TotalFileCountDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio()
            self.total_file_count_day_growth_ratio = temp_model.from_map(m['TotalFileCountDayGrowthRatio'])
        if m.get('TotalFileDayGrowthCount') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount()
            self.total_file_day_growth_count = temp_model.from_map(m['TotalFileDayGrowthCount'])
        if m.get('WarmDataDayGrowthSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize()
            self.warm_data_day_growth_size = temp_model.from_map(m['WarmDataDayGrowthSize'])
        if m.get('WarmDataRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio()
            self.warm_data_ratio = temp_model.from_map(m['WarmDataRatio'])
        if m.get('WarmDataSize') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WarmDataSizeDayGrowthRatio') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio()
            self.warm_data_size_day_growth_ratio = temp_model.from_map(m['WarmDataSizeDayGrowthRatio'])
        return self


class GetDoctorHiveTableResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: GetDoctorHiveTableResponseBodyDataAnalysis = None,
        formats: List[GetDoctorHiveTableResponseBodyDataFormats] = None,
        metrics: GetDoctorHiveTableResponseBodyDataMetrics = None,
        owner: str = None,
    ):
        # The analysis results.
        self.analysis = analysis
        # The information from the perspective of formats.
        self.formats = formats
        # The metric information.
        self.metrics = metrics
        # The owner.
        self.owner = owner

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.formats:
            for k in self.formats:
                if k:
                    k.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        result['Formats'] = []
        if self.formats is not None:
            for k in self.formats:
                result['Formats'].append(k.to_map() if k else None)
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        self.formats = []
        if m.get('Formats') is not None:
            for k in m.get('Formats'):
                temp_model = GetDoctorHiveTableResponseBodyDataFormats()
                self.formats.append(temp_model.from_map(k))
        if m.get('Metrics') is not None:
            temp_model = GetDoctorHiveTableResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        return self


class GetDoctorHiveTableResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorHiveTableResponseBodyData = None,
        request_id: str = None,
    ):
        # The analysis results of the Hive table.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorHiveTableResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorHiveTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorHiveTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorHiveTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the job that is submitted to YARN.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorJobResponseBodyDataMetricsMemSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorJobResponseBodyDataMetricsVcoreSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDoctorJobResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        mem_seconds: GetDoctorJobResponseBodyDataMetricsMemSeconds = None,
        vcore_seconds: GetDoctorJobResponseBodyDataMetricsVcoreSeconds = None,
    ):
        # The amount of memory consumed.
        self.mem_seconds = mem_seconds
        # The CPU usage.
        self.vcore_seconds = vcore_seconds

    def validate(self):
        if self.mem_seconds:
            self.mem_seconds.validate()
        if self.vcore_seconds:
            self.vcore_seconds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mem_seconds is not None:
            result['MemSeconds'] = self.mem_seconds.to_map()
        if self.vcore_seconds is not None:
            result['VcoreSeconds'] = self.vcore_seconds.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemSeconds') is not None:
            temp_model = GetDoctorJobResponseBodyDataMetricsMemSeconds()
            self.mem_seconds = temp_model.from_map(m['MemSeconds'])
        if m.get('VcoreSeconds') is not None:
            temp_model = GetDoctorJobResponseBodyDataMetricsVcoreSeconds()
            self.vcore_seconds = temp_model.from_map(m['VcoreSeconds'])
        return self


class GetDoctorJobResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        elapsed_time: int = None,
        final_status: str = None,
        finish_time: int = None,
        launch_time: int = None,
        metrics: GetDoctorJobResponseBodyDataMetrics = None,
        queue: str = None,
        start_time: int = None,
        state: str = None,
        type: str = None,
        user: str = None,
    ):
        # The ID of the job that was submitted to YARN.
        self.app_id = app_id
        # The name of the job.
        self.app_name = app_name
        # The total running time of the job. Unit: milliseconds.
        self.elapsed_time = elapsed_time
        # The final state of the job. Valid values:
        # 
        # *   SUCCEEDED
        # *   FAILED
        # *   KILLED
        # *   ENDED
        # *   UNDEFINED
        self.final_status = final_status
        # The time when the job ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.finish_time = finish_time
        # The time when the job was started. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.launch_time = launch_time
        # The data about metrics.
        self.metrics = metrics
        # The YARN queue to which the job was submitted.
        self.queue = queue
        # The time when the job was submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.start_time = start_time
        # The running state of the job. Valid values:
        # 
        # *   FINISHED
        # *   FAILED
        # *   KILLED
        self.state = state
        # The type of the compute engine.
        self.type = type
        # The username that was used to submit the job.
        self.user = user

    def validate(self):
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.final_status is not None:
            result['FinalStatus'] = self.final_status
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.launch_time is not None:
            result['LaunchTime'] = self.launch_time
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.queue is not None:
            result['Queue'] = self.queue
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.type is not None:
            result['Type'] = self.type
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('FinalStatus') is not None:
            self.final_status = m.get('FinalStatus')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('LaunchTime') is not None:
            self.launch_time = m.get('LaunchTime')
        if m.get('Metrics') is not None:
            temp_model = GetDoctorJobResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('Queue') is not None:
            self.queue = m.get('Queue')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class GetDoctorJobResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorJobResponseBodyData = None,
        request_id: str = None,
    ):
        # The information about the job.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDoctorReportComponentSummaryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        component_type: str = None,
        date_time: str = None,
        region_id: str = None,
    ):
        # Cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Select component filter type. Values: 
        # - compute 
        # - hive
        # - hdfs
        # - yarn
        # - oss
        # - hbase
        # 
        # This parameter is required.
        self.component_type = component_type
        # Report date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # Region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.component_type is not None:
            result['ComponentType'] = self.component_type
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ComponentType') is not None:
            self.component_type = m.get('ComponentType')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDoctorReportComponentSummaryResponseBodyData(TeaModel):
    def __init__(
        self,
        score: int = None,
        suggestion: str = None,
        summary: str = None,
    ):
        # Score.
        self.score = score
        # Optimization suggestions.
        self.suggestion = suggestion
        # The summary of the report.
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetDoctorReportComponentSummaryResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDoctorReportComponentSummaryResponseBodyData = None,
        request_id: str = None,
    ):
        # The content of the report.
        self.data = data
        # Request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDoctorReportComponentSummaryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDoctorReportComponentSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDoctorReportComponentSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDoctorReportComponentSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetManagedScalingPolicyRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # 集群ID。
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # 区域ID。
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetManagedScalingPolicyResponseBodyScalingPolicyConstraints(TeaModel):
    def __init__(
        self,
        max_capacity: int = None,
        max_on_demand_capacity: int = None,
        min_capacity: int = None,
    ):
        # 最大值
        self.max_capacity = max_capacity
        # 最大按量数量
        self.max_on_demand_capacity = max_on_demand_capacity
        # 最小值
        self.min_capacity = min_capacity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_capacity is not None:
            result['MaxCapacity'] = self.max_capacity
        if self.max_on_demand_capacity is not None:
            result['MaxOnDemandCapacity'] = self.max_on_demand_capacity
        if self.min_capacity is not None:
            result['MinCapacity'] = self.min_capacity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxCapacity') is not None:
            self.max_capacity = m.get('MaxCapacity')
        if m.get('MaxOnDemandCapacity') is not None:
            self.max_on_demand_capacity = m.get('MaxOnDemandCapacity')
        if m.get('MinCapacity') is not None:
            self.min_capacity = m.get('MinCapacity')
        return self


class GetManagedScalingPolicyResponseBodyScalingPolicy(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        constraints: GetManagedScalingPolicyResponseBodyScalingPolicyConstraints = None,
        scaling_policy_id: str = None,
    ):
        # 集群ID。
        self.cluster_id = cluster_id
        # 最大最小值约束
        self.constraints = constraints
        # 伸缩策略ID。
        self.scaling_policy_id = scaling_policy_id

    def validate(self):
        if self.constraints:
            self.constraints.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.constraints is not None:
            result['Constraints'] = self.constraints.to_map()
        if self.scaling_policy_id is not None:
            result['ScalingPolicyId'] = self.scaling_policy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Constraints') is not None:
            temp_model = GetManagedScalingPolicyResponseBodyScalingPolicyConstraints()
            self.constraints = temp_model.from_map(m['Constraints'])
        if m.get('ScalingPolicyId') is not None:
            self.scaling_policy_id = m.get('ScalingPolicyId')
        return self


class GetManagedScalingPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        scaling_policy: GetManagedScalingPolicyResponseBodyScalingPolicy = None,
    ):
        # 请求ID。
        self.request_id = request_id
        self.scaling_policy = scaling_policy

    def validate(self):
        if self.scaling_policy:
            self.scaling_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scaling_policy is not None:
            result['ScalingPolicy'] = self.scaling_policy.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScalingPolicy') is not None:
            temp_model = GetManagedScalingPolicyResponseBodyScalingPolicy()
            self.scaling_policy = temp_model.from_map(m['ScalingPolicy'])
        return self


class GetManagedScalingPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetManagedScalingPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetManagedScalingPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNodeGroupRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        node_group_id: str = None,
        region_id: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the node group.
        # 
        # This parameter is required.
        self.node_group_id = node_group_id
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetNodeGroupResponseBody(TeaModel):
    def __init__(
        self,
        node_group: NodeGroup = None,
        request_id: str = None,
    ):
        # The node group.
        self.node_group = node_group
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.node_group:
            self.node_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_group is not None:
            result['NodeGroup'] = self.node_group.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeGroup') is not None:
            temp_model = NodeGroup()
            self.node_group = temp_model.from_map(m['NodeGroup'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetNodeGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNodeGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNodeGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOperationRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        operation_id: str = None,
        region_id: str = None,
    ):
        # The ID of the cluster that you want to query.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The operation ID.
        # 
        # References:
        # 
        # *   [CreateCluster](https://help.aliyun.com/document_detail/454393.html)
        # *   [IncreaseNodes](https://help.aliyun.com/document_detail/454397.html)
        # 
        # This parameter is required.
        self.operation_id = operation_id
        # The district ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetOperationResponseBody(TeaModel):
    def __init__(
        self,
        operation: Operation = None,
        request_id: str = None,
    ):
        # The operation that was performed.
        self.operation = operation
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.operation:
            self.operation.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation is not None:
            result['Operation'] = self.operation.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operation') is not None:
            temp_model = Operation()
            self.operation = temp_model.from_map(m['Operation'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetOperationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOperationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOperationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class IncreaseNodesRequest(TeaModel):
    def __init__(
        self,
        application_configs: List[ApplicationConfig] = None,
        auto_pay_order: bool = None,
        auto_renew: bool = None,
        cluster_id: str = None,
        increase_node_count: int = None,
        min_increase_node_count: int = None,
        node_group_id: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        promotions: List[Promotion] = None,
        region_id: str = None,
    ):
        # The application configurations. Number of elements in the array: 1 to 1,000.
        self.application_configs = application_configs
        # Indicates whether to automatically pay for the orders involved in the scale-out operation. This parameter takes effect only when the PaymentType parameter is set to Subscription. Valid values:
        # 
        # *   true: automatically pays for the order involved in this operation.
        # *   false: does not automatically pay for the orders involved in this operation.
        # 
        # Default value: false
        self.auto_pay_order = auto_pay_order
        # Specifies whether to enable auto-renewal for nodes. Valid values:
        # 
        # *   true
        # *   false (default value)
        self.auto_renew = auto_renew
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The number of nodes to add.Valid values: 1 to 500.
        # 
        # This parameter is required.
        self.increase_node_count = increase_node_count
        # The minimum number of nodes that can be added. Valid values: 1 to 500.
        # 
        # *   If you configure this parameter, and the number of available Elastic Compute Service (ECS) instances is less than the value of the IncreaseNodeCount parameter, the system tries to add nodes based on the number specified by the `MinIncreaseNodeCount` parameter. If the minimum number of nodes are added, the scale-out status is `PARTIAL_COMPLETED`.
        # *   If you do not configure this parameter, and the number of available ECS instances is less than the value of the IncreaseNodeCount parameter, the scale-out process fails. The scale-out status is `FAILED`.
        self.min_increase_node_count = min_increase_node_count
        # The ID of the node group. The target node group to which you want to scale out the cluster.
        # 
        # This parameter is required.
        self.node_group_id = node_group_id
        # The subscription duration. Valid values when the PaymentDurationUnit value is Month: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        self.payment_duration = payment_duration
        # The unit of the subscription duration. Valid values:
        # 
        # *   Month
        self.payment_duration_unit = payment_duration_unit
        self.promotions = promotions
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        if self.application_configs:
            for k in self.application_configs:
                if k:
                    k.validate()
        if self.promotions:
            for k in self.promotions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationConfigs'] = []
        if self.application_configs is not None:
            for k in self.application_configs:
                result['ApplicationConfigs'].append(k.to_map() if k else None)
        if self.auto_pay_order is not None:
            result['AutoPayOrder'] = self.auto_pay_order
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.increase_node_count is not None:
            result['IncreaseNodeCount'] = self.increase_node_count
        if self.min_increase_node_count is not None:
            result['MinIncreaseNodeCount'] = self.min_increase_node_count
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        result['Promotions'] = []
        if self.promotions is not None:
            for k in self.promotions:
                result['Promotions'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_configs = []
        if m.get('ApplicationConfigs') is not None:
            for k in m.get('ApplicationConfigs'):
                temp_model = ApplicationConfig()
                self.application_configs.append(temp_model.from_map(k))
        if m.get('AutoPayOrder') is not None:
            self.auto_pay_order = m.get('AutoPayOrder')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('IncreaseNodeCount') is not None:
            self.increase_node_count = m.get('IncreaseNodeCount')
        if m.get('MinIncreaseNodeCount') is not None:
            self.min_increase_node_count = m.get('MinIncreaseNodeCount')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        self.promotions = []
        if m.get('Promotions') is not None:
            for k in m.get('Promotions'):
                temp_model = Promotion()
                self.promotions.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class IncreaseNodesResponseBody(TeaModel):
    def __init__(
        self,
        operation_id: str = None,
        request_id: str = None,
    ):
        # The ID of the operation.
        self.operation_id = operation_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class IncreaseNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: IncreaseNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = IncreaseNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinResourceGroupRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_group_id: str = None,
        resource_id: str = None,
        resource_type: str = None,
    ):
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id
        # The ID of the resource.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the resource. Valid values:
        # 
        # *   cluster: cluster
        # 
        # This parameter is required.
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class JoinResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class JoinResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: JoinResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApiTemplatesRequest(TeaModel):
    def __init__(
        self,
        api_name: str = None,
        max_results: int = None,
        next_token: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        template_id: str = None,
        template_ids: List[str] = None,
        template_name: str = None,
    ):
        # 接口名。
        # 
        # This parameter is required.
        self.api_name = api_name
        # 一次获取的最大记录数。
        self.max_results = max_results
        # 标记当前开始读取的位置，置空表示从头开始。
        self.next_token = next_token
        # 区域ID。
        # 
        # This parameter is required.
        self.region_id = region_id
        # 资源组ID。
        self.resource_group_id = resource_group_id
        # 集群模板id。
        self.template_id = template_id
        # 集群模板id列表。
        self.template_ids = template_ids
        # 集群模板名字。
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_name is not None:
            result['ApiName'] = self.api_name
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiName') is not None:
            self.api_name = m.get('ApiName')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class ListApiTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        api_templates: List[ApiTemplate] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The array of API templates.
        self.api_templates = api_templates
        # 本次请求所返回的最大记录条数。
        self.max_results = max_results
        # 返回读取到的数据位置，空代表数据已经读取完毕。
        self.next_token = next_token
        # 请求ID。
        self.request_id = request_id
        # 本次请求条件下的数据总量。
        self.total_count = total_count

    def validate(self):
        if self.api_templates:
            for k in self.api_templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApiTemplates'] = []
        if self.api_templates is not None:
            for k in self.api_templates:
                result['ApiTemplates'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.api_templates = []
        if m.get('ApiTemplates') is not None:
            for k in m.get('ApiTemplates'):
                temp_model = ApiTemplate()
                self.api_templates.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListApiTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApiTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApiTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationConfigsRequest(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        cluster_id: str = None,
        config_file_name: str = None,
        config_item_key: str = None,
        config_item_value: str = None,
        max_results: int = None,
        next_token: str = None,
        node_group_id: str = None,
        node_id: str = None,
        region_id: str = None,
    ):
        # The name of the application.
        self.application_name = application_name
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The name of the configuration file.
        self.config_file_name = config_file_name
        # The key of the configuration item.
        self.config_item_key = config_item_key
        # The value of the configuration item.
        self.config_item_value = config_item_value
        # The number of entries per page.
        self.max_results = max_results
        # The page number of the next page returned.
        self.next_token = next_token
        # The ID of the node group.
        self.node_group_id = node_group_id
        # The node ID.
        self.node_id = node_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.config_file_name is not None:
            result['ConfigFileName'] = self.config_file_name
        if self.config_item_key is not None:
            result['ConfigItemKey'] = self.config_item_key
        if self.config_item_value is not None:
            result['ConfigItemValue'] = self.config_item_value
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ConfigFileName') is not None:
            self.config_file_name = m.get('ConfigFileName')
        if m.get('ConfigItemKey') is not None:
            self.config_item_key = m.get('ConfigItemKey')
        if m.get('ConfigItemValue') is not None:
            self.config_item_value = m.get('ConfigItemValue')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListApplicationConfigsResponseBodyApplicationConfigs(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        config_effect_state: str = None,
        config_file_name: str = None,
        config_item_key: str = None,
        config_item_value: str = None,
        create_time: int = None,
        custom: bool = None,
        description: str = None,
        init_value: str = None,
        modifier: str = None,
        node_group_id: str = None,
        node_id: str = None,
        update_time: int = None,
    ):
        # The name of the application.
        self.application_name = application_name
        # The status of the configuration value.
        self.config_effect_state = config_effect_state
        # The name of the configuration file.
        self.config_file_name = config_file_name
        # The key of the configuration item.
        self.config_item_key = config_item_key
        # The value of the configuration item.
        self.config_item_value = config_item_value
        # The creation time.
        self.create_time = create_time
        # Indicates whether the configurations are custom.
        self.custom = custom
        # The description.
        self.description = description
        # The initial value.
        self.init_value = init_value
        # The person who modified the configurations.
        self.modifier = modifier
        # The node group ID.
        self.node_group_id = node_group_id
        # The node ID.
        self.node_id = node_id
        # The update time.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.config_effect_state is not None:
            result['ConfigEffectState'] = self.config_effect_state
        if self.config_file_name is not None:
            result['ConfigFileName'] = self.config_file_name
        if self.config_item_key is not None:
            result['ConfigItemKey'] = self.config_item_key
        if self.config_item_value is not None:
            result['ConfigItemValue'] = self.config_item_value
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.custom is not None:
            result['Custom'] = self.custom
        if self.description is not None:
            result['Description'] = self.description
        if self.init_value is not None:
            result['InitValue'] = self.init_value
        if self.modifier is not None:
            result['Modifier'] = self.modifier
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ConfigEffectState') is not None:
            self.config_effect_state = m.get('ConfigEffectState')
        if m.get('ConfigFileName') is not None:
            self.config_file_name = m.get('ConfigFileName')
        if m.get('ConfigItemKey') is not None:
            self.config_item_key = m.get('ConfigItemKey')
        if m.get('ConfigItemValue') is not None:
            self.config_item_value = m.get('ConfigItemValue')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Custom') is not None:
            self.custom = m.get('Custom')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InitValue') is not None:
            self.init_value = m.get('InitValue')
        if m.get('Modifier') is not None:
            self.modifier = m.get('Modifier')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListApplicationConfigsResponseBody(TeaModel):
    def __init__(
        self,
        application_configs: List[ListApplicationConfigsResponseBodyApplicationConfigs] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The application configurations.
        self.application_configs = application_configs
        # The number of entries per page.
        self.max_results = max_results
        # The page number of the next page returned.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of pages returned.
        self.total_count = total_count

    def validate(self):
        if self.application_configs:
            for k in self.application_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationConfigs'] = []
        if self.application_configs is not None:
            for k in self.application_configs:
                result['ApplicationConfigs'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_configs = []
        if m.get('ApplicationConfigs') is not None:
            for k in m.get('ApplicationConfigs'):
                temp_model = ListApplicationConfigsResponseBodyApplicationConfigs()
                self.application_configs.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListApplicationConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationsRequest(TeaModel):
    def __init__(
        self,
        application_names: List[str] = None,
        cluster_id: str = None,
        max_results: int = None,
        next_token: str = None,
        region_id: str = None,
    ):
        # The application names.
        self.application_names = application_names
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The total number of pages.
        self.max_results = max_results
        # The page number of the next page returned.
        self.next_token = next_token
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_names is not None:
            result['ApplicationNames'] = self.application_names
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationNames') is not None:
            self.application_names = m.get('ApplicationNames')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListApplicationsResponseBodyApplications(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        application_state: str = None,
        application_version: str = None,
        community_version: str = None,
    ):
        # The application name.
        self.application_name = application_name
        # The status of the applications. Valid values:
        # 
        # *   STOPPED: At least one application is in the Stopped state.
        # *   RUNNING: All applications are in the Running state.
        # 
        # This parameter is returned only for DataLake, OLAP, Dataflow, DataServing, and custom clusters. For other types of clusters, no value is returned for this parameter.
        self.application_state = application_state
        # The version of the application.
        self.application_version = application_version
        # The community edition.
        self.community_version = community_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.application_state is not None:
            result['ApplicationState'] = self.application_state
        if self.application_version is not None:
            result['ApplicationVersion'] = self.application_version
        if self.community_version is not None:
            result['CommunityVersion'] = self.community_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ApplicationState') is not None:
            self.application_state = m.get('ApplicationState')
        if m.get('ApplicationVersion') is not None:
            self.application_version = m.get('ApplicationVersion')
        if m.get('CommunityVersion') is not None:
            self.community_version = m.get('CommunityVersion')
        return self


class ListApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        applications: List[ListApplicationsResponseBodyApplications] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The applications.
        self.applications = applications
        # The number of entries per page.
        self.max_results = max_results
        # The page number of the next page returned.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of pages.
        self.total_count = total_count

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['Applications'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.applications = []
        if m.get('Applications') is not None:
            for k in m.get('Applications'):
                temp_model = ListApplicationsResponseBodyApplications()
                self.applications.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAutoScalingActivitiesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        end_time: int = None,
        max_results: int = None,
        next_token: str = None,
        node_group_id: str = None,
        region_id: str = None,
        scaling_activity_states: List[str] = None,
        scaling_activity_type: str = None,
        scaling_policy_type: str = None,
        scaling_rule_name: str = None,
        start_time: int = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The end of the time range to query. Unit: milliseconds.
        self.end_time = end_time
        # The number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The ID of the node group.
        self.node_group_id = node_group_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The status of the scaling activity. Number of elements in the array: 1-20.
        self.scaling_activity_states = scaling_activity_states
        # The type of the scaling activity. Valid values:
        # 
        # *   SCALE_OUT
        # *   SCALE_IN
        self.scaling_activity_type = scaling_activity_type
        self.scaling_policy_type = scaling_policy_type
        # The name of the scaling rule.
        self.scaling_rule_name = scaling_rule_name
        # The beginning of the time range to query. Unit: milliseconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scaling_activity_states is not None:
            result['ScalingActivityStates'] = self.scaling_activity_states
        if self.scaling_activity_type is not None:
            result['ScalingActivityType'] = self.scaling_activity_type
        if self.scaling_policy_type is not None:
            result['ScalingPolicyType'] = self.scaling_policy_type
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScalingActivityStates') is not None:
            self.scaling_activity_states = m.get('ScalingActivityStates')
        if m.get('ScalingActivityType') is not None:
            self.scaling_activity_type = m.get('ScalingActivityType')
        if m.get('ScalingPolicyType') is not None:
            self.scaling_policy_type = m.get('ScalingPolicyType')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListAutoScalingActivitiesResponseBodyScalingActivities(TeaModel):
    def __init__(
        self,
        activity_id: str = None,
        activity_state: str = None,
        activity_type: str = None,
        cluster_id: str = None,
        description: str = None,
        end_time: int = None,
        expect_num: int = None,
        instance_type_to_num: Dict[str, int] = None,
        node_group_id: str = None,
        node_group_name: str = None,
        operation_id: str = None,
        policy_type: str = None,
        rule_name: str = None,
        start_time: int = None,
    ):
        # The ID of the scaling activity.
        self.activity_id = activity_id
        # The status of the scaling activity. Valid values:
        # 
        # *   REJECTED
        # *   SUCCESSFUL
        # *   FAILED
        # *   IN_PROGRESS
        self.activity_state = activity_state
        # The type of the scaling activity. Valid values:
        # 
        # *   SCALE_OUT
        # *   SCALE_IN
        self.activity_type = activity_type
        # The cluster ID.
        self.cluster_id = cluster_id
        # The description of the scaling activity.
        self.description = description
        # The end time of the scaling. Unit: milliseconds.
        self.end_time = end_time
        # The number of added or removed instances.
        self.expect_num = expect_num
        self.instance_type_to_num = instance_type_to_num
        # The ID of the node group.
        self.node_group_id = node_group_id
        # The name of the node group.
        self.node_group_name = node_group_name
        # The operation ID.
        self.operation_id = operation_id
        self.policy_type = policy_type
        # The name of the scaling rule.
        self.rule_name = rule_name
        # The start time of the scaling. Unit: milliseconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.activity_state is not None:
            result['ActivityState'] = self.activity_state
        if self.activity_type is not None:
            result['ActivityType'] = self.activity_type
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.expect_num is not None:
            result['ExpectNum'] = self.expect_num
        if self.instance_type_to_num is not None:
            result['InstanceTypeToNum'] = self.instance_type_to_num
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_name is not None:
            result['NodeGroupName'] = self.node_group_name
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.policy_type is not None:
            result['PolicyType'] = self.policy_type
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('ActivityState') is not None:
            self.activity_state = m.get('ActivityState')
        if m.get('ActivityType') is not None:
            self.activity_type = m.get('ActivityType')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExpectNum') is not None:
            self.expect_num = m.get('ExpectNum')
        if m.get('InstanceTypeToNum') is not None:
            self.instance_type_to_num = m.get('InstanceTypeToNum')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupName') is not None:
            self.node_group_name = m.get('NodeGroupName')
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('PolicyType') is not None:
            self.policy_type = m.get('PolicyType')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListAutoScalingActivitiesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        scaling_activities: List[ListAutoScalingActivitiesResponseBodyScalingActivities] = None,
        total_count: int = None,
    ):
        # The maximum number of entries returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The scaling activities.
        self.scaling_activities = scaling_activities
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.scaling_activities:
            for k in self.scaling_activities:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ScalingActivities'] = []
        if self.scaling_activities is not None:
            for k in self.scaling_activities:
                result['ScalingActivities'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.scaling_activities = []
        if m.get('ScalingActivities') is not None:
            for k in m.get('ScalingActivities'):
                temp_model = ListAutoScalingActivitiesResponseBodyScalingActivities()
                self.scaling_activities.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAutoScalingActivitiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAutoScalingActivitiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAutoScalingActivitiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClustersRequest(TeaModel):
    def __init__(
        self,
        cluster_ids: List[str] = None,
        cluster_name: str = None,
        cluster_states: List[str] = None,
        cluster_types: List[str] = None,
        max_results: int = None,
        next_token: str = None,
        payment_types: List[str] = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[Tag] = None,
    ):
        # The cluster IDs. Number of elements in the array: 1 to 100.
        self.cluster_ids = cluster_ids
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The states of the clusters. Number of elements in the array: 1 to 100.
        self.cluster_states = cluster_states
        # The list of cluster types. Number of elements in the array: 1 to 100.
        self.cluster_types = cluster_types
        # The number of entries to return on each page. Valid values: 1 to 100.
        self.max_results = max_results
        # The starting point of the current query. If you do not configure this parameter, the query starts from the beginning.
        self.next_token = next_token
        # The billing methods. You can specify a maximum of 2 items.
        self.payment_types = payment_types
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tag list. Number of elements in the array: 1 to 20.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ids is not None:
            result['ClusterIds'] = self.cluster_ids
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_states is not None:
            result['ClusterStates'] = self.cluster_states
        if self.cluster_types is not None:
            result['ClusterTypes'] = self.cluster_types
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.payment_types is not None:
            result['PaymentTypes'] = self.payment_types
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterIds') is not None:
            self.cluster_ids = m.get('ClusterIds')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterStates') is not None:
            self.cluster_states = m.get('ClusterStates')
        if m.get('ClusterTypes') is not None:
            self.cluster_types = m.get('ClusterTypes')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PaymentTypes') is not None:
            self.payment_types = m.get('PaymentTypes')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class ListClustersResponseBody(TeaModel):
    def __init__(
        self,
        clusters: List[ClusterSummary] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The clusters.
        self.clusters = clusters
        # The number of entries returned per page.
        self.max_results = max_results
        # The page number of the next page returned.
        self.next_token = next_token
        # The ID of the request.
        self.request_id = request_id
        # The total number of pages.
        self.total_count = total_count

    def validate(self):
        if self.clusters:
            for k in self.clusters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clusters'] = []
        if self.clusters is not None:
            for k in self.clusters:
                result['Clusters'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clusters = []
        if m.get('Clusters') is not None:
            for k in m.get('Clusters'):
                temp_model = ClusterSummary()
                self.clusters.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListClustersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClustersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClustersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListComponentInstancesRequest(TeaModel):
    def __init__(
        self,
        application_names: List[str] = None,
        cluster_id: str = None,
        component_names: List[str] = None,
        component_states: List[str] = None,
        max_results: int = None,
        next_token: str = None,
        node_ids: List[str] = None,
        node_names: List[str] = None,
        region_id: str = None,
        zone_id: str = None,
    ):
        # 应用名称列表。
        self.application_names = application_names
        # 集群ID。
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # 组件名称列表。
        self.component_names = component_names
        self.component_states = component_states
        # 一次获取的最大记录数。取值范围：1~100。
        self.max_results = max_results
        # 标记当前开始读取的位置，置空表示从头开始。
        self.next_token = next_token
        # 节点ID列表。
        self.node_ids = node_ids
        # 节点名称列表。
        self.node_names = node_names
        # 地域ID。
        # 
        # This parameter is required.
        self.region_id = region_id
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_names is not None:
            result['ApplicationNames'] = self.application_names
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.component_names is not None:
            result['ComponentNames'] = self.component_names
        if self.component_states is not None:
            result['ComponentStates'] = self.component_states
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.node_ids is not None:
            result['NodeIds'] = self.node_ids
        if self.node_names is not None:
            result['NodeNames'] = self.node_names
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationNames') is not None:
            self.application_names = m.get('ApplicationNames')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ComponentNames') is not None:
            self.component_names = m.get('ComponentNames')
        if m.get('ComponentStates') is not None:
            self.component_states = m.get('ComponentStates')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('NodeIds') is not None:
            self.node_ids = m.get('NodeIds')
        if m.get('NodeNames') is not None:
            self.node_names = m.get('NodeNames')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListComponentInstancesResponseBodyComponentInstances(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        biz_state: str = None,
        commission_state: str = None,
        component_instance_state: str = None,
        component_name: str = None,
        create_time: int = None,
        desired_state: str = None,
        node_id: str = None,
        node_name: str = None,
        zone_id: str = None,
    ):
        # 应用名称。
        self.application_name = application_name
        # 组件服务状态，取值如下：
        # - active：主服务
        # - standby：备用服务。
        self.biz_state = biz_state
        # Commission状态，取值如下：
        # - COMMISSIONED：已上线
        # - COMMISSIONING：上线中
        # - DECOMMISSIONED：已下线
        # - DECOMMISSIONINPROGRESS：下线进程中
        # - DECOMMISSIONFAILED：下线失败
        # - INSERVICE：服务中
        # - UNKNOWN：未知状态。
        # <p>
        self.commission_state = commission_state
        # 组件实例操作状态，取值如下：
        # - WAITING：等待中
        # - INSTALLING：安装中
        # - INSTALLED：已安装
        # - INSTALL_FAILED：安装失败
        # - STARTING：启动中
        # - STARTED：已启动
        # - START_FAILED：启动失败
        # - STOPPING：停止中
        # - STOPPED：已停止
        # - STOP_FAILED：停止失败
        self.component_instance_state = component_instance_state
        # 组件名称。
        self.component_name = component_name
        # 安装时间戳。
        self.create_time = create_time
        # 期望状态，取值如下：
        # - WAITING：等待中
        # - INSTALLING：安装中
        # - INSTALLED：已安装
        # - INSTALL_FAILED：安装失败
        # - STARTING：启动中
        # - STARTED：已启动
        # - START_FAILED：启动失败
        # - STOPPING：停止中
        # - STOPPED：已停止
        # - STOP_FAILED：停止失败。
        self.desired_state = desired_state
        # 节点ID。
        self.node_id = node_id
        # 节点名称。
        self.node_name = node_name
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.biz_state is not None:
            result['BizState'] = self.biz_state
        if self.commission_state is not None:
            result['CommissionState'] = self.commission_state
        if self.component_instance_state is not None:
            result['ComponentInstanceState'] = self.component_instance_state
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.desired_state is not None:
            result['DesiredState'] = self.desired_state
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('BizState') is not None:
            self.biz_state = m.get('BizState')
        if m.get('CommissionState') is not None:
            self.commission_state = m.get('CommissionState')
        if m.get('ComponentInstanceState') is not None:
            self.component_instance_state = m.get('ComponentInstanceState')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DesiredState') is not None:
            self.desired_state = m.get('DesiredState')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListComponentInstancesResponseBody(TeaModel):
    def __init__(
        self,
        component_instances: List[ListComponentInstancesResponseBodyComponentInstances] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.component_instances = component_instances
        # 本次请求所返回的最大记录条数。
        self.max_results = max_results
        # 返回读取到的数据位置，空代表数据已经读取完毕。
        self.next_token = next_token
        # 请求ID。
        self.request_id = request_id
        # 本次请求条件下的数据总量。
        self.total_count = total_count

    def validate(self):
        if self.component_instances:
            for k in self.component_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ComponentInstances'] = []
        if self.component_instances is not None:
            for k in self.component_instances:
                result['ComponentInstances'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.component_instances = []
        if m.get('ComponentInstances') is not None:
            for k in m.get('ComponentInstances'):
                temp_model = ListComponentInstancesResponseBodyComponentInstances()
                self.component_instances.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListComponentInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListComponentInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListComponentInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListComponentsRequest(TeaModel):
    def __init__(
        self,
        application_names: List[str] = None,
        cluster_id: str = None,
        component_names: List[str] = None,
        component_states: List[str] = None,
        max_results: int = None,
        next_token: str = None,
        region_id: str = None,
    ):
        # 应用名称列表。
        self.application_names = application_names
        # 集群ID。
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # 组件名称列表。
        self.component_names = component_names
        self.component_states = component_states
        # 一次获取的最大记录数。取值范围：1~100。
        self.max_results = max_results
        # 标记当前开始读取的位置，置空表示从头开始。
        self.next_token = next_token
        # 地域ID。
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_names is not None:
            result['ApplicationNames'] = self.application_names
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.component_names is not None:
            result['ComponentNames'] = self.component_names
        if self.component_states is not None:
            result['ComponentStates'] = self.component_states
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationNames') is not None:
            self.application_names = m.get('ApplicationNames')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ComponentNames') is not None:
            self.component_names = m.get('ComponentNames')
        if m.get('ComponentStates') is not None:
            self.component_states = m.get('ComponentStates')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListComponentsResponseBodyComponents(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        attributes: List[Attribute] = None,
        component_name: str = None,
        namespace: str = None,
        replica: int = None,
    ):
        # 应用名称。
        self.application_name = application_name
        # 属性列表。
        self.attributes = attributes
        # 组件名称。
        self.component_name = component_name
        # 命名空间。
        self.namespace = namespace
        # 安装该组件的机器总数。
        self.replica = replica

    def validate(self):
        if self.attributes:
            for k in self.attributes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        result['Attributes'] = []
        if self.attributes is not None:
            for k in self.attributes:
                result['Attributes'].append(k.to_map() if k else None)
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.replica is not None:
            result['Replica'] = self.replica
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        self.attributes = []
        if m.get('Attributes') is not None:
            for k in m.get('Attributes'):
                temp_model = Attribute()
                self.attributes.append(temp_model.from_map(k))
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Replica') is not None:
            self.replica = m.get('Replica')
        return self


class ListComponentsResponseBody(TeaModel):
    def __init__(
        self,
        components: List[ListComponentsResponseBodyComponents] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.components = components
        # 本次请求所返回的最大记录条数。
        self.max_results = max_results
        # 返回读取到的数据位置，空代表数据已经读取完毕。
        self.next_token = next_token
        # 请求ID。
        self.request_id = request_id
        # 本次请求条件下的数据总量。
        self.total_count = total_count

    def validate(self):
        if self.components:
            for k in self.components:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Components'] = []
        if self.components is not None:
            for k in self.components:
                result['Components'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.components = []
        if m.get('Components') is not None:
            for k in m.get('Components'):
                temp_model = ListComponentsResponseBodyComponents()
                self.components.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListComponentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListComponentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListComponentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorApplicationsRequest(TeaModel):
    def __init__(
        self,
        app_ids: List[str] = None,
        cluster_id: str = None,
        date_time: str = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        queues: List[str] = None,
        region_id: str = None,
        types: List[str] = None,
        users: List[str] = None,
    ):
        # The IDs of jobs that are submitted to YARN.
        self.app_ids = app_ids
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The maximum number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The field that you use to sort the query results. Valid values:
        # 
        # 1.  startTime: the time when the job starts
        # 2.  endTime: the time when the job ends
        # 3.  vcoreUtilization: the vCPU utilization of the job
        # 4.  memUtilization: the memory usage of the job
        # 5.  vcoreSeconds: the aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running
        # 6.  memSeconds: the aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running
        # 7.  score: the score of the job
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid values:
        # 
        # *   ASC: the ascending order
        # *   DESC: the descending order
        self.order_type = order_type
        # The YARN queues to which the jobs are submitted.
        self.queues = queues
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The YARN engines to which the jobs are submitted.
        self.types = types
        # The users who submit the jobs.
        self.users = users

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.queues is not None:
            result['Queues'] = self.queues
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.types is not None:
            result['Types'] = self.types
        if self.users is not None:
            result['Users'] = self.users
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('Queues') is not None:
            self.queues = m.get('Queues')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Users') is not None:
            self.users = m.get('Users')
        return self


class ListDoctorApplicationsResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        score: int = None,
        suggestion: str = None,
    ):
        # The score of the job.
        self.score = score
        # The suggestion on executing the job.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class ListDoctorApplicationsResponseBodyDataMetricsMemSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorApplicationsResponseBodyDataMetricsMemUtilization(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorApplicationsResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        mem_seconds: ListDoctorApplicationsResponseBodyDataMetricsMemSeconds = None,
        mem_utilization: ListDoctorApplicationsResponseBodyDataMetricsMemUtilization = None,
        vcore_seconds: ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds = None,
        vcore_utilization: ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization = None,
    ):
        # The amount of memory consumed.
        self.mem_seconds = mem_seconds
        # The memory usage
        self.mem_utilization = mem_utilization
        # The CPU usage.
        self.vcore_seconds = vcore_seconds
        # The CPU utilization. This parameter has the same meaning as %CPU in the Linux top command.
        self.vcore_utilization = vcore_utilization

    def validate(self):
        if self.mem_seconds:
            self.mem_seconds.validate()
        if self.mem_utilization:
            self.mem_utilization.validate()
        if self.vcore_seconds:
            self.vcore_seconds.validate()
        if self.vcore_utilization:
            self.vcore_utilization.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mem_seconds is not None:
            result['MemSeconds'] = self.mem_seconds.to_map()
        if self.mem_utilization is not None:
            result['MemUtilization'] = self.mem_utilization.to_map()
        if self.vcore_seconds is not None:
            result['VcoreSeconds'] = self.vcore_seconds.to_map()
        if self.vcore_utilization is not None:
            result['VcoreUtilization'] = self.vcore_utilization.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemSeconds') is not None:
            temp_model = ListDoctorApplicationsResponseBodyDataMetricsMemSeconds()
            self.mem_seconds = temp_model.from_map(m['MemSeconds'])
        if m.get('MemUtilization') is not None:
            temp_model = ListDoctorApplicationsResponseBodyDataMetricsMemUtilization()
            self.mem_utilization = temp_model.from_map(m['MemUtilization'])
        if m.get('VcoreSeconds') is not None:
            temp_model = ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds()
            self.vcore_seconds = temp_model.from_map(m['VcoreSeconds'])
        if m.get('VcoreUtilization') is not None:
            temp_model = ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization()
            self.vcore_utilization = temp_model.from_map(m['VcoreUtilization'])
        return self


class ListDoctorApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: ListDoctorApplicationsResponseBodyDataAnalysis = None,
        app_id: str = None,
        app_name: str = None,
        end_time: int = None,
        ids: List[str] = None,
        metrics: ListDoctorApplicationsResponseBodyDataMetrics = None,
        query_sql: str = None,
        queue: str = None,
        start_time: int = None,
        type: str = None,
        user: str = None,
    ):
        # The analysis results of the jobs.
        self.analysis = analysis
        # The job ID in YARN. The value of QueryID or SessionID is returned for a Hive job.
        self.app_id = app_id
        # The name of the job.
        self.app_name = app_name
        # The time when the job ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.end_time = end_time
        # The job IDs. Multiple job IDs are separated with commas (,).
        self.ids = ids
        # The data about metrics.
        self.metrics = metrics
        # The query statement. This parameter is left empty for non-SQL jobs.
        self.query_sql = query_sql
        # The YARN queue to which the job was submitted.
        self.queue = queue
        # The time when the job was submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.start_time = start_time
        # The type of the compute engine.
        self.type = type
        # The username that was used to submit the job.
        self.user = user

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.query_sql is not None:
            result['QuerySql'] = self.query_sql
        if self.queue is not None:
            result['Queue'] = self.queue
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = ListDoctorApplicationsResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Metrics') is not None:
            temp_model = ListDoctorApplicationsResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('QuerySql') is not None:
            self.query_sql = m.get('QuerySql')
        if m.get('Queue') is not None:
            self.queue = m.get('Queue')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class ListDoctorApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorApplicationsResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The details of jobs.
        self.data = data
        # The maximum number of entries returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorApplicationsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorComputeSummaryRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        component_types: List[str] = None,
        date_time: str = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The resource types, which are used to filter query results. Valid values:
        # 
        # *   engine: filters results by engine.
        # *   queue: filters results by queue.
        # *   cluster: displays the results at the cluster level.
        # 
        # If you do not specify this parameter, the information at the cluster level is displayed by default. Currently, only one resource type is supported. If you specify multiple resource types, the first resource type is used by default.
        self.component_types = component_types
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The maximum number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The basis on which you want to sort the query results. Valid values:
        # 
        # 1.  vcoreSeconds: the total CPU consumption over time in seconds.
        # 2.  memSeconds: the total memory consumption over time in seconds.
        # 3.  vcoreUtilization: the average CPU utilization. The meaning is the same as the %CPU parameter in the output of the top command in Linux.
        # 4.  memUtilization: the average memory usage.
        # 5.  vcoreSecondsDayGrowthRatio: the day-to-day growth rate of the total CPU consumption over time in seconds.
        # 6.  memSecondsDayGrowthRatio: the day-to-day growth rate of the total memory consumption over time in seconds.
        # 7.  readSize: the total amount of data read from the file system.
        # 8.  writeSize: the total amount of data written to the file system.
        # 9.  healthyJobCount: the total number of healthy jobs.
        # 10. subHealthyJobCount: the total number of sub-healthy jobs.
        # 11. unhealthyJobCount: the total number of unhealthy jobs.
        # 12. needAttentionJobCount: the total number of jobs that require attention.
        # 13. score: the score for jobs.
        # 14. scoreDayGrowthRatio: the day-to-day growth rate of the score for jobs.
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid values:
        # 
        # *   ASC: in ascending order.
        # *   DESC: in descending order.
        self.order_type = order_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.component_types is not None:
            result['ComponentTypes'] = self.component_types
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ComponentTypes') is not None:
            self.component_types = m.get('ComponentTypes')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListDoctorComputeSummaryResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        healthy_job_count: int = None,
        need_attention_job_count: int = None,
        score: int = None,
        score_day_growth_ratio: float = None,
        sub_healthy_job_count: int = None,
        unhealthy_job_count: int = None,
    ):
        # The total number of healthy jobs.
        self.healthy_job_count = healthy_job_count
        # The total number of jobs that require attention.
        self.need_attention_job_count = need_attention_job_count
        # The score for jobs.
        self.score = score
        # The day-to-day growth rate of the score for jobs.
        self.score_day_growth_ratio = score_day_growth_ratio
        # The total number of sub-healthy jobs.
        self.sub_healthy_job_count = sub_healthy_job_count
        # The total number of unhealthy jobs.
        self.unhealthy_job_count = unhealthy_job_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.healthy_job_count is not None:
            result['HealthyJobCount'] = self.healthy_job_count
        if self.need_attention_job_count is not None:
            result['NeedAttentionJobCount'] = self.need_attention_job_count
        if self.score is not None:
            result['Score'] = self.score
        if self.score_day_growth_ratio is not None:
            result['ScoreDayGrowthRatio'] = self.score_day_growth_ratio
        if self.sub_healthy_job_count is not None:
            result['SubHealthyJobCount'] = self.sub_healthy_job_count
        if self.unhealthy_job_count is not None:
            result['UnhealthyJobCount'] = self.unhealthy_job_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HealthyJobCount') is not None:
            self.healthy_job_count = m.get('HealthyJobCount')
        if m.get('NeedAttentionJobCount') is not None:
            self.need_attention_job_count = m.get('NeedAttentionJobCount')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('ScoreDayGrowthRatio') is not None:
            self.score_day_growth_ratio = m.get('ScoreDayGrowthRatio')
        if m.get('SubHealthyJobCount') is not None:
            self.sub_healthy_job_count = m.get('SubHealthyJobCount')
        if m.get('UnhealthyJobCount') is not None:
            self.unhealthy_job_count = m.get('UnhealthyJobCount')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetricsReadSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorComputeSummaryResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        mem_seconds: ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds = None,
        mem_seconds_day_growth_ratio: ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio = None,
        mem_utilization: ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization = None,
        read_size: ListDoctorComputeSummaryResponseBodyDataMetricsReadSize = None,
        vcore_seconds: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds = None,
        vcore_seconds_day_growth_ratio: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio = None,
        vcore_utilization: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization = None,
        write_size: ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize = None,
    ):
        # The total memory consumption over time in seconds.
        self.mem_seconds = mem_seconds
        # The day-to-day growth rate of the total memory consumption over time in seconds.
        self.mem_seconds_day_growth_ratio = mem_seconds_day_growth_ratio
        # The average memory usage.
        self.mem_utilization = mem_utilization
        # The total amount of data read from the file system.
        self.read_size = read_size
        # The total CPU consumption over time in seconds.
        self.vcore_seconds = vcore_seconds
        # The day-to-day growth rate of the total CPU consumption over time in seconds.
        self.vcore_seconds_day_growth_ratio = vcore_seconds_day_growth_ratio
        # The average CPU utilization. The meaning is the same as the %CPU parameter in the output of the top command in Linux.
        self.vcore_utilization = vcore_utilization
        # The total amount of data written to the file system.
        self.write_size = write_size

    def validate(self):
        if self.mem_seconds:
            self.mem_seconds.validate()
        if self.mem_seconds_day_growth_ratio:
            self.mem_seconds_day_growth_ratio.validate()
        if self.mem_utilization:
            self.mem_utilization.validate()
        if self.read_size:
            self.read_size.validate()
        if self.vcore_seconds:
            self.vcore_seconds.validate()
        if self.vcore_seconds_day_growth_ratio:
            self.vcore_seconds_day_growth_ratio.validate()
        if self.vcore_utilization:
            self.vcore_utilization.validate()
        if self.write_size:
            self.write_size.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mem_seconds is not None:
            result['MemSeconds'] = self.mem_seconds.to_map()
        if self.mem_seconds_day_growth_ratio is not None:
            result['MemSecondsDayGrowthRatio'] = self.mem_seconds_day_growth_ratio.to_map()
        if self.mem_utilization is not None:
            result['MemUtilization'] = self.mem_utilization.to_map()
        if self.read_size is not None:
            result['ReadSize'] = self.read_size.to_map()
        if self.vcore_seconds is not None:
            result['VcoreSeconds'] = self.vcore_seconds.to_map()
        if self.vcore_seconds_day_growth_ratio is not None:
            result['VcoreSecondsDayGrowthRatio'] = self.vcore_seconds_day_growth_ratio.to_map()
        if self.vcore_utilization is not None:
            result['VcoreUtilization'] = self.vcore_utilization.to_map()
        if self.write_size is not None:
            result['WriteSize'] = self.write_size.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemSeconds') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds()
            self.mem_seconds = temp_model.from_map(m['MemSeconds'])
        if m.get('MemSecondsDayGrowthRatio') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio()
            self.mem_seconds_day_growth_ratio = temp_model.from_map(m['MemSecondsDayGrowthRatio'])
        if m.get('MemUtilization') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization()
            self.mem_utilization = temp_model.from_map(m['MemUtilization'])
        if m.get('ReadSize') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetricsReadSize()
            self.read_size = temp_model.from_map(m['ReadSize'])
        if m.get('VcoreSeconds') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds()
            self.vcore_seconds = temp_model.from_map(m['VcoreSeconds'])
        if m.get('VcoreSecondsDayGrowthRatio') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio()
            self.vcore_seconds_day_growth_ratio = temp_model.from_map(m['VcoreSecondsDayGrowthRatio'])
        if m.get('VcoreUtilization') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization()
            self.vcore_utilization = temp_model.from_map(m['VcoreUtilization'])
        if m.get('WriteSize') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize()
            self.write_size = temp_model.from_map(m['WriteSize'])
        return self


class ListDoctorComputeSummaryResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: ListDoctorComputeSummaryResponseBodyDataAnalysis = None,
        component_name: str = None,
        metrics: ListDoctorComputeSummaryResponseBodyDataMetrics = None,
    ):
        # The resource analysis results.
        self.analysis = analysis
        # The name of the resource whose details are obtained based on the value of ComponentTypes. For example, if the value of ComponentTypes is Queue, the value of this parameter is a queue, such as DW.
        self.component_name = component_name
        # The metric information.
        self.metrics = metrics

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('Metrics') is not None:
            temp_model = ListDoctorComputeSummaryResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class ListDoctorComputeSummaryResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorComputeSummaryResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The details of resource usage.
        self.data = data
        # The maximum number of entries that are returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorComputeSummaryResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorComputeSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorComputeSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorComputeSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorHBaseRegionServersRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        region_id: str = None,
        region_server_hosts: List[str] = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The query date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The maximum number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The field that you use to sort the query results. Valid value:
        # 
        # *   regionCount: the number of regions.
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid value:
        # 
        # *   ASC: in ascending order
        # *   DESC: in descending order
        self.order_type = order_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The RegionServer hosts.
        self.region_server_hosts = region_server_hosts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_server_hosts is not None:
            result['RegionServerHosts'] = self.region_server_hosts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionServerHosts') is not None:
            self.region_server_hosts = m.get('RegionServerHosts')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseRegionServersResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        avg_gc: ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc = None,
        cache_ratio: ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio = None,
        daily_read_request: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest = None,
        daily_read_request_day_growth_ratio: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio = None,
        daily_write_request: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest = None,
        daily_write_request_day_growth_ratio: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio = None,
        region_count: ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount = None,
        total_read_request: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest = None,
        total_request: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest = None,
        total_write_request: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest = None,
    ):
        # The average garbage collection (GC) duration.
        self.avg_gc = avg_gc
        # The cache hit ratio.
        self.cache_ratio = cache_ratio
        # The number of daily read requests.
        self.daily_read_request = daily_read_request
        # The growth rate of the number of daily read requests.
        self.daily_read_request_day_growth_ratio = daily_read_request_day_growth_ratio
        # The number of daily write requests.
        self.daily_write_request = daily_write_request
        # The growth rate of the number of daily write requests.
        self.daily_write_request_day_growth_ratio = daily_write_request_day_growth_ratio
        # The number of regions.
        self.region_count = region_count
        # The cumulative number of read requests.
        self.total_read_request = total_read_request
        # The cumulative number of all requests.
        self.total_request = total_request
        # The cumulative number of write requests.
        self.total_write_request = total_write_request

    def validate(self):
        if self.avg_gc:
            self.avg_gc.validate()
        if self.cache_ratio:
            self.cache_ratio.validate()
        if self.daily_read_request:
            self.daily_read_request.validate()
        if self.daily_read_request_day_growth_ratio:
            self.daily_read_request_day_growth_ratio.validate()
        if self.daily_write_request:
            self.daily_write_request.validate()
        if self.daily_write_request_day_growth_ratio:
            self.daily_write_request_day_growth_ratio.validate()
        if self.region_count:
            self.region_count.validate()
        if self.total_read_request:
            self.total_read_request.validate()
        if self.total_request:
            self.total_request.validate()
        if self.total_write_request:
            self.total_write_request.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_gc is not None:
            result['AvgGc'] = self.avg_gc.to_map()
        if self.cache_ratio is not None:
            result['CacheRatio'] = self.cache_ratio.to_map()
        if self.daily_read_request is not None:
            result['DailyReadRequest'] = self.daily_read_request.to_map()
        if self.daily_read_request_day_growth_ratio is not None:
            result['DailyReadRequestDayGrowthRatio'] = self.daily_read_request_day_growth_ratio.to_map()
        if self.daily_write_request is not None:
            result['DailyWriteRequest'] = self.daily_write_request.to_map()
        if self.daily_write_request_day_growth_ratio is not None:
            result['DailyWriteRequestDayGrowthRatio'] = self.daily_write_request_day_growth_ratio.to_map()
        if self.region_count is not None:
            result['RegionCount'] = self.region_count.to_map()
        if self.total_read_request is not None:
            result['TotalReadRequest'] = self.total_read_request.to_map()
        if self.total_request is not None:
            result['TotalRequest'] = self.total_request.to_map()
        if self.total_write_request is not None:
            result['TotalWriteRequest'] = self.total_write_request.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgGc') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc()
            self.avg_gc = temp_model.from_map(m['AvgGc'])
        if m.get('CacheRatio') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio()
            self.cache_ratio = temp_model.from_map(m['CacheRatio'])
        if m.get('DailyReadRequest') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest()
            self.daily_read_request = temp_model.from_map(m['DailyReadRequest'])
        if m.get('DailyReadRequestDayGrowthRatio') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio()
            self.daily_read_request_day_growth_ratio = temp_model.from_map(m['DailyReadRequestDayGrowthRatio'])
        if m.get('DailyWriteRequest') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest()
            self.daily_write_request = temp_model.from_map(m['DailyWriteRequest'])
        if m.get('DailyWriteRequestDayGrowthRatio') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio()
            self.daily_write_request_day_growth_ratio = temp_model.from_map(m['DailyWriteRequestDayGrowthRatio'])
        if m.get('RegionCount') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount()
            self.region_count = temp_model.from_map(m['RegionCount'])
        if m.get('TotalReadRequest') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest()
            self.total_read_request = temp_model.from_map(m['TotalReadRequest'])
        if m.get('TotalRequest') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest()
            self.total_request = temp_model.from_map(m['TotalRequest'])
        if m.get('TotalWriteRequest') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest()
            self.total_write_request = temp_model.from_map(m['TotalWriteRequest'])
        return self


class ListDoctorHBaseRegionServersResponseBodyData(TeaModel):
    def __init__(
        self,
        metrics: ListDoctorHBaseRegionServersResponseBodyDataMetrics = None,
        region_server_host: str = None,
    ):
        # The metric information.
        self.metrics = metrics
        # The RegionServer host.
        self.region_server_host = region_server_host

    def validate(self):
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.region_server_host is not None:
            result['RegionServerHost'] = self.region_server_host
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metrics') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('RegionServerHost') is not None:
            self.region_server_host = m.get('RegionServerHost')
        return self


class ListDoctorHBaseRegionServersResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorHBaseRegionServersResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The returned data.
        self.data = data
        # The maximum number of entries that are returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorHBaseRegionServersResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorHBaseRegionServersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorHBaseRegionServersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorHBaseRegionServersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorHBaseTablesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        region_id: str = None,
        table_names: List[str] = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The query date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The maximum number of entries that are returned.
        self.max_results = max_results
        # Marks the current position to start reading. If this field is empty, the data is read from the beginning.
        self.next_token = next_token
        # The field that you use to sort the query results.
        # 
        # Valid values:
        # 
        # *   tableSize
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid value:
        # 
        # *   ASC: in ascending order
        # *   DESC: in descending order
        self.order_type = order_type
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The table names, which are used to filter the query results.
        self.table_names = table_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        return self


class ListDoctorHBaseTablesResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        read_request_hotspot_region_list: List[str] = None,
        read_request_unbalance_suggestion: str = None,
        request_hotspot_region_list: List[str] = None,
        request_unbalance_suggestion: str = None,
        table_score: int = None,
        write_request_hotspot_region_list: List[str] = None,
        write_request_unbalance_suggestion: str = None,
    ):
        # The regions that have read hotspot issues.
        self.read_request_hotspot_region_list = read_request_hotspot_region_list
        # The description of read imbalance.
        self.read_request_unbalance_suggestion = read_request_unbalance_suggestion
        # The regions that have read/write hotspot issues.
        self.request_hotspot_region_list = request_hotspot_region_list
        # The description of read/write imbalance.
        self.request_unbalance_suggestion = request_unbalance_suggestion
        # The score of the table.
        self.table_score = table_score
        # The regions that have write hotspot issues.
        self.write_request_hotspot_region_list = write_request_hotspot_region_list
        # The description of write imbalance.
        self.write_request_unbalance_suggestion = write_request_unbalance_suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.read_request_hotspot_region_list is not None:
            result['ReadRequestHotspotRegionList'] = self.read_request_hotspot_region_list
        if self.read_request_unbalance_suggestion is not None:
            result['ReadRequestUnbalanceSuggestion'] = self.read_request_unbalance_suggestion
        if self.request_hotspot_region_list is not None:
            result['RequestHotspotRegionList'] = self.request_hotspot_region_list
        if self.request_unbalance_suggestion is not None:
            result['RequestUnbalanceSuggestion'] = self.request_unbalance_suggestion
        if self.table_score is not None:
            result['TableScore'] = self.table_score
        if self.write_request_hotspot_region_list is not None:
            result['WriteRequestHotspotRegionList'] = self.write_request_hotspot_region_list
        if self.write_request_unbalance_suggestion is not None:
            result['WriteRequestUnbalanceSuggestion'] = self.write_request_unbalance_suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReadRequestHotspotRegionList') is not None:
            self.read_request_hotspot_region_list = m.get('ReadRequestHotspotRegionList')
        if m.get('ReadRequestUnbalanceSuggestion') is not None:
            self.read_request_unbalance_suggestion = m.get('ReadRequestUnbalanceSuggestion')
        if m.get('RequestHotspotRegionList') is not None:
            self.request_hotspot_region_list = m.get('RequestHotspotRegionList')
        if m.get('RequestUnbalanceSuggestion') is not None:
            self.request_unbalance_suggestion = m.get('RequestUnbalanceSuggestion')
        if m.get('TableScore') is not None:
            self.table_score = m.get('TableScore')
        if m.get('WriteRequestHotspotRegionList') is not None:
            self.write_request_hotspot_region_list = m.get('WriteRequestHotspotRegionList')
        if m.get('WriteRequestUnbalanceSuggestion') is not None:
            self.write_request_unbalance_suggestion = m.get('WriteRequestUnbalanceSuggestion')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsLocality(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsTableSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHBaseTablesResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_access_day: ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay = None,
        cold_config_day: ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay = None,
        cold_data_size: ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize = None,
        daily_read_request: ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest = None,
        daily_read_request_day_growth_ratio: ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio = None,
        daily_write_request: ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest = None,
        daily_write_request_day_growth_ratio: ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio = None,
        freeze_config_day: ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay = None,
        freeze_data_size: ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize = None,
        hot_data_size: ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize = None,
        locality: ListDoctorHBaseTablesResponseBodyDataMetricsLocality = None,
        read_request_balance: ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance = None,
        region_balance: ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance = None,
        region_count: ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount = None,
        region_count_day_growth_ratio: ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio = None,
        region_server_count: ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount = None,
        request_balance: ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance = None,
        store_file_count: ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount = None,
        store_file_count_day_growth_ratio: ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio = None,
        table_size: ListDoctorHBaseTablesResponseBodyDataMetricsTableSize = None,
        table_size_day_growth_ratio: ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio = None,
        warm_config_day: ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay = None,
        warm_data_size: ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize = None,
        write_request_balance: ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance = None,
    ):
        # The number of days during which the table was not accessed.
        self.cold_access_day = cold_access_day
        # The number of consecutive days without access to data before the data is considered as very cold data.
        self.cold_config_day = cold_config_day
        # The size of cold data.
        self.cold_data_size = cold_data_size
        # The total number of read requests for the table in a day.
        self.daily_read_request = daily_read_request
        # The daily increment ratio of the number of read requests in a day.
        self.daily_read_request_day_growth_ratio = daily_read_request_day_growth_ratio
        # The total number of write requests for the table in a day.
        self.daily_write_request = daily_write_request
        # The daily increment ratio of the number of write requests in a day.
        self.daily_write_request_day_growth_ratio = daily_write_request_day_growth_ratio
        # The number of consecutive days without access to data before the data was considered as very cold data.
        self.freeze_config_day = freeze_config_day
        # The size of very cold data.
        self.freeze_data_size = freeze_data_size
        # The size of hot data.
        self.hot_data_size = hot_data_size
        # The localization rate.
        self.locality = locality
        # The read balancing degree.
        self.read_request_balance = read_request_balance
        # The balancing degree.
        self.region_balance = region_balance
        # The number of regions that host the table.
        self.region_count = region_count
        # The daily increment ratio of the number of regions.
        self.region_count_day_growth_ratio = region_count_day_growth_ratio
        # The number of region servers that host the table.
        self.region_server_count = region_server_count
        # The request balancing degree.
        self.request_balance = request_balance
        # The number of StoreFiles.
        self.store_file_count = store_file_count
        # The daily increment ratio of the number of StoreFiles.
        self.store_file_count_day_growth_ratio = store_file_count_day_growth_ratio
        # The size of the table.
        self.table_size = table_size
        # The daily increment ratio of the table size.
        self.table_size_day_growth_ratio = table_size_day_growth_ratio
        # The number of consecutive days without access to data before the data is considered as cold data.
        self.warm_config_day = warm_config_day
        # The size of warm data.
        self.warm_data_size = warm_data_size
        # The write balancing degree.
        self.write_request_balance = write_request_balance

    def validate(self):
        if self.cold_access_day:
            self.cold_access_day.validate()
        if self.cold_config_day:
            self.cold_config_day.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.daily_read_request:
            self.daily_read_request.validate()
        if self.daily_read_request_day_growth_ratio:
            self.daily_read_request_day_growth_ratio.validate()
        if self.daily_write_request:
            self.daily_write_request.validate()
        if self.daily_write_request_day_growth_ratio:
            self.daily_write_request_day_growth_ratio.validate()
        if self.freeze_config_day:
            self.freeze_config_day.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.locality:
            self.locality.validate()
        if self.read_request_balance:
            self.read_request_balance.validate()
        if self.region_balance:
            self.region_balance.validate()
        if self.region_count:
            self.region_count.validate()
        if self.region_count_day_growth_ratio:
            self.region_count_day_growth_ratio.validate()
        if self.region_server_count:
            self.region_server_count.validate()
        if self.request_balance:
            self.request_balance.validate()
        if self.store_file_count:
            self.store_file_count.validate()
        if self.store_file_count_day_growth_ratio:
            self.store_file_count_day_growth_ratio.validate()
        if self.table_size:
            self.table_size.validate()
        if self.table_size_day_growth_ratio:
            self.table_size_day_growth_ratio.validate()
        if self.warm_config_day:
            self.warm_config_day.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.write_request_balance:
            self.write_request_balance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_access_day is not None:
            result['ColdAccessDay'] = self.cold_access_day.to_map()
        if self.cold_config_day is not None:
            result['ColdConfigDay'] = self.cold_config_day.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.daily_read_request is not None:
            result['DailyReadRequest'] = self.daily_read_request.to_map()
        if self.daily_read_request_day_growth_ratio is not None:
            result['DailyReadRequestDayGrowthRatio'] = self.daily_read_request_day_growth_ratio.to_map()
        if self.daily_write_request is not None:
            result['DailyWriteRequest'] = self.daily_write_request.to_map()
        if self.daily_write_request_day_growth_ratio is not None:
            result['DailyWriteRequestDayGrowthRatio'] = self.daily_write_request_day_growth_ratio.to_map()
        if self.freeze_config_day is not None:
            result['FreezeConfigDay'] = self.freeze_config_day.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.locality is not None:
            result['Locality'] = self.locality.to_map()
        if self.read_request_balance is not None:
            result['ReadRequestBalance'] = self.read_request_balance.to_map()
        if self.region_balance is not None:
            result['RegionBalance'] = self.region_balance.to_map()
        if self.region_count is not None:
            result['RegionCount'] = self.region_count.to_map()
        if self.region_count_day_growth_ratio is not None:
            result['RegionCountDayGrowthRatio'] = self.region_count_day_growth_ratio.to_map()
        if self.region_server_count is not None:
            result['RegionServerCount'] = self.region_server_count.to_map()
        if self.request_balance is not None:
            result['RequestBalance'] = self.request_balance.to_map()
        if self.store_file_count is not None:
            result['StoreFileCount'] = self.store_file_count.to_map()
        if self.store_file_count_day_growth_ratio is not None:
            result['StoreFileCountDayGrowthRatio'] = self.store_file_count_day_growth_ratio.to_map()
        if self.table_size is not None:
            result['TableSize'] = self.table_size.to_map()
        if self.table_size_day_growth_ratio is not None:
            result['TableSizeDayGrowthRatio'] = self.table_size_day_growth_ratio.to_map()
        if self.warm_config_day is not None:
            result['WarmConfigDay'] = self.warm_config_day.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.write_request_balance is not None:
            result['WriteRequestBalance'] = self.write_request_balance.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdAccessDay') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay()
            self.cold_access_day = temp_model.from_map(m['ColdAccessDay'])
        if m.get('ColdConfigDay') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay()
            self.cold_config_day = temp_model.from_map(m['ColdConfigDay'])
        if m.get('ColdDataSize') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('DailyReadRequest') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest()
            self.daily_read_request = temp_model.from_map(m['DailyReadRequest'])
        if m.get('DailyReadRequestDayGrowthRatio') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio()
            self.daily_read_request_day_growth_ratio = temp_model.from_map(m['DailyReadRequestDayGrowthRatio'])
        if m.get('DailyWriteRequest') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest()
            self.daily_write_request = temp_model.from_map(m['DailyWriteRequest'])
        if m.get('DailyWriteRequestDayGrowthRatio') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio()
            self.daily_write_request_day_growth_ratio = temp_model.from_map(m['DailyWriteRequestDayGrowthRatio'])
        if m.get('FreezeConfigDay') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay()
            self.freeze_config_day = temp_model.from_map(m['FreezeConfigDay'])
        if m.get('FreezeDataSize') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('HotDataSize') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('Locality') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsLocality()
            self.locality = temp_model.from_map(m['Locality'])
        if m.get('ReadRequestBalance') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance()
            self.read_request_balance = temp_model.from_map(m['ReadRequestBalance'])
        if m.get('RegionBalance') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance()
            self.region_balance = temp_model.from_map(m['RegionBalance'])
        if m.get('RegionCount') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount()
            self.region_count = temp_model.from_map(m['RegionCount'])
        if m.get('RegionCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio()
            self.region_count_day_growth_ratio = temp_model.from_map(m['RegionCountDayGrowthRatio'])
        if m.get('RegionServerCount') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount()
            self.region_server_count = temp_model.from_map(m['RegionServerCount'])
        if m.get('RequestBalance') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance()
            self.request_balance = temp_model.from_map(m['RequestBalance'])
        if m.get('StoreFileCount') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount()
            self.store_file_count = temp_model.from_map(m['StoreFileCount'])
        if m.get('StoreFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio()
            self.store_file_count_day_growth_ratio = temp_model.from_map(m['StoreFileCountDayGrowthRatio'])
        if m.get('TableSize') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsTableSize()
            self.table_size = temp_model.from_map(m['TableSize'])
        if m.get('TableSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio()
            self.table_size_day_growth_ratio = temp_model.from_map(m['TableSizeDayGrowthRatio'])
        if m.get('WarmConfigDay') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay()
            self.warm_config_day = temp_model.from_map(m['WarmConfigDay'])
        if m.get('WarmDataSize') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WriteRequestBalance') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance()
            self.write_request_balance = temp_model.from_map(m['WriteRequestBalance'])
        return self


class ListDoctorHBaseTablesResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: ListDoctorHBaseTablesResponseBodyDataAnalysis = None,
        metrics: ListDoctorHBaseTablesResponseBodyDataMetrics = None,
        table_name: str = None,
    ):
        # The diagnosis result.
        self.analysis = analysis
        # The metric information.
        self.metrics = metrics
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('Metrics') is not None:
            temp_model = ListDoctorHBaseTablesResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListDoctorHBaseTablesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorHBaseTablesResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The data returned.
        self.data = data
        # The maximum number of entries returned.
        self.max_results = max_results
        # The page number of the next page returned.
        self.next_token = next_token
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorHBaseTablesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorHBaseTablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorHBaseTablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorHBaseTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorHDFSDirectoriesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        dir_path: str = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        region_id: str = None,
    ):
        # 集群ID。
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # This parameter is required.
        self.date_time = date_time
        self.dir_path = dir_path
        # 一次获取的最大记录数。取值范围：1~100。
        self.max_results = max_results
        # 标记当前开始读取的位置，置空表示从头开始。
        self.next_token = next_token
        self.order_by = order_by
        self.order_type = order_type
        # 区域ID。
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.dir_path is not None:
            result['DirPath'] = self.dir_path
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('DirPath') is not None:
            self.dir_path = m.get('DirPath')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        self.description = description
        self.name = name
        self.unit = unit
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSDirectoriesResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_data_day_growth_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize = None,
        cold_data_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize = None,
        cold_data_size_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio = None,
        empty_file_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount = None,
        empty_file_count_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio = None,
        empty_file_day_growth_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount = None,
        freeze_data_day_growth_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize = None,
        freeze_data_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize = None,
        freeze_data_size_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio = None,
        hot_data_day_growth_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize = None,
        hot_data_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize = None,
        hot_data_size_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio = None,
        large_file_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount = None,
        large_file_count_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio = None,
        large_file_day_growth_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount = None,
        medium_file_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount = None,
        medium_file_count_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio = None,
        medium_file_day_growth_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount = None,
        small_file_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount = None,
        small_file_count_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio = None,
        small_file_day_growth_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount = None,
        tiny_file_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount = None,
        tiny_file_count_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio = None,
        tiny_file_day_growth_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount = None,
        total_data_day_growth_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize = None,
        total_data_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize = None,
        total_data_size_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio = None,
        total_file_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount = None,
        total_file_count_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio = None,
        total_file_day_growth_count: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount = None,
        warm_data_day_growth_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize = None,
        warm_data_size: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize = None,
        warm_data_size_day_growth_ratio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio = None,
    ):
        self.cold_data_day_growth_size = cold_data_day_growth_size
        self.cold_data_size = cold_data_size
        self.cold_data_size_day_growth_ratio = cold_data_size_day_growth_ratio
        self.empty_file_count = empty_file_count
        self.empty_file_count_day_growth_ratio = empty_file_count_day_growth_ratio
        self.empty_file_day_growth_count = empty_file_day_growth_count
        self.freeze_data_day_growth_size = freeze_data_day_growth_size
        self.freeze_data_size = freeze_data_size
        self.freeze_data_size_day_growth_ratio = freeze_data_size_day_growth_ratio
        self.hot_data_day_growth_size = hot_data_day_growth_size
        self.hot_data_size = hot_data_size
        self.hot_data_size_day_growth_ratio = hot_data_size_day_growth_ratio
        self.large_file_count = large_file_count
        self.large_file_count_day_growth_ratio = large_file_count_day_growth_ratio
        self.large_file_day_growth_count = large_file_day_growth_count
        self.medium_file_count = medium_file_count
        self.medium_file_count_day_growth_ratio = medium_file_count_day_growth_ratio
        self.medium_file_day_growth_count = medium_file_day_growth_count
        self.small_file_count = small_file_count
        self.small_file_count_day_growth_ratio = small_file_count_day_growth_ratio
        self.small_file_day_growth_count = small_file_day_growth_count
        self.tiny_file_count = tiny_file_count
        self.tiny_file_count_day_growth_ratio = tiny_file_count_day_growth_ratio
        self.tiny_file_day_growth_count = tiny_file_day_growth_count
        self.total_data_day_growth_size = total_data_day_growth_size
        self.total_data_size = total_data_size
        self.total_data_size_day_growth_ratio = total_data_size_day_growth_ratio
        self.total_file_count = total_file_count
        self.total_file_count_day_growth_ratio = total_file_count_day_growth_ratio
        self.total_file_day_growth_count = total_file_day_growth_count
        self.warm_data_day_growth_size = warm_data_day_growth_size
        self.warm_data_size = warm_data_size
        self.warm_data_size_day_growth_ratio = warm_data_size_day_growth_ratio

    def validate(self):
        if self.cold_data_day_growth_size:
            self.cold_data_day_growth_size.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.cold_data_size_day_growth_ratio:
            self.cold_data_size_day_growth_ratio.validate()
        if self.empty_file_count:
            self.empty_file_count.validate()
        if self.empty_file_count_day_growth_ratio:
            self.empty_file_count_day_growth_ratio.validate()
        if self.empty_file_day_growth_count:
            self.empty_file_day_growth_count.validate()
        if self.freeze_data_day_growth_size:
            self.freeze_data_day_growth_size.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.freeze_data_size_day_growth_ratio:
            self.freeze_data_size_day_growth_ratio.validate()
        if self.hot_data_day_growth_size:
            self.hot_data_day_growth_size.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.hot_data_size_day_growth_ratio:
            self.hot_data_size_day_growth_ratio.validate()
        if self.large_file_count:
            self.large_file_count.validate()
        if self.large_file_count_day_growth_ratio:
            self.large_file_count_day_growth_ratio.validate()
        if self.large_file_day_growth_count:
            self.large_file_day_growth_count.validate()
        if self.medium_file_count:
            self.medium_file_count.validate()
        if self.medium_file_count_day_growth_ratio:
            self.medium_file_count_day_growth_ratio.validate()
        if self.medium_file_day_growth_count:
            self.medium_file_day_growth_count.validate()
        if self.small_file_count:
            self.small_file_count.validate()
        if self.small_file_count_day_growth_ratio:
            self.small_file_count_day_growth_ratio.validate()
        if self.small_file_day_growth_count:
            self.small_file_day_growth_count.validate()
        if self.tiny_file_count:
            self.tiny_file_count.validate()
        if self.tiny_file_count_day_growth_ratio:
            self.tiny_file_count_day_growth_ratio.validate()
        if self.tiny_file_day_growth_count:
            self.tiny_file_day_growth_count.validate()
        if self.total_data_day_growth_size:
            self.total_data_day_growth_size.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_data_size_day_growth_ratio:
            self.total_data_size_day_growth_ratio.validate()
        if self.total_file_count:
            self.total_file_count.validate()
        if self.total_file_count_day_growth_ratio:
            self.total_file_count_day_growth_ratio.validate()
        if self.total_file_day_growth_count:
            self.total_file_day_growth_count.validate()
        if self.warm_data_day_growth_size:
            self.warm_data_day_growth_size.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.warm_data_size_day_growth_ratio:
            self.warm_data_size_day_growth_ratio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_data_day_growth_size is not None:
            result['ColdDataDayGrowthSize'] = self.cold_data_day_growth_size.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.cold_data_size_day_growth_ratio is not None:
            result['ColdDataSizeDayGrowthRatio'] = self.cold_data_size_day_growth_ratio.to_map()
        if self.empty_file_count is not None:
            result['EmptyFileCount'] = self.empty_file_count.to_map()
        if self.empty_file_count_day_growth_ratio is not None:
            result['EmptyFileCountDayGrowthRatio'] = self.empty_file_count_day_growth_ratio.to_map()
        if self.empty_file_day_growth_count is not None:
            result['EmptyFileDayGrowthCount'] = self.empty_file_day_growth_count.to_map()
        if self.freeze_data_day_growth_size is not None:
            result['FreezeDataDayGrowthSize'] = self.freeze_data_day_growth_size.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.freeze_data_size_day_growth_ratio is not None:
            result['FreezeDataSizeDayGrowthRatio'] = self.freeze_data_size_day_growth_ratio.to_map()
        if self.hot_data_day_growth_size is not None:
            result['HotDataDayGrowthSize'] = self.hot_data_day_growth_size.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.hot_data_size_day_growth_ratio is not None:
            result['HotDataSizeDayGrowthRatio'] = self.hot_data_size_day_growth_ratio.to_map()
        if self.large_file_count is not None:
            result['LargeFileCount'] = self.large_file_count.to_map()
        if self.large_file_count_day_growth_ratio is not None:
            result['LargeFileCountDayGrowthRatio'] = self.large_file_count_day_growth_ratio.to_map()
        if self.large_file_day_growth_count is not None:
            result['LargeFileDayGrowthCount'] = self.large_file_day_growth_count.to_map()
        if self.medium_file_count is not None:
            result['MediumFileCount'] = self.medium_file_count.to_map()
        if self.medium_file_count_day_growth_ratio is not None:
            result['MediumFileCountDayGrowthRatio'] = self.medium_file_count_day_growth_ratio.to_map()
        if self.medium_file_day_growth_count is not None:
            result['MediumFileDayGrowthCount'] = self.medium_file_day_growth_count.to_map()
        if self.small_file_count is not None:
            result['SmallFileCount'] = self.small_file_count.to_map()
        if self.small_file_count_day_growth_ratio is not None:
            result['SmallFileCountDayGrowthRatio'] = self.small_file_count_day_growth_ratio.to_map()
        if self.small_file_day_growth_count is not None:
            result['SmallFileDayGrowthCount'] = self.small_file_day_growth_count.to_map()
        if self.tiny_file_count is not None:
            result['TinyFileCount'] = self.tiny_file_count.to_map()
        if self.tiny_file_count_day_growth_ratio is not None:
            result['TinyFileCountDayGrowthRatio'] = self.tiny_file_count_day_growth_ratio.to_map()
        if self.tiny_file_day_growth_count is not None:
            result['TinyFileDayGrowthCount'] = self.tiny_file_day_growth_count.to_map()
        if self.total_data_day_growth_size is not None:
            result['TotalDataDayGrowthSize'] = self.total_data_day_growth_size.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_data_size_day_growth_ratio is not None:
            result['TotalDataSizeDayGrowthRatio'] = self.total_data_size_day_growth_ratio.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        if self.total_file_count_day_growth_ratio is not None:
            result['TotalFileCountDayGrowthRatio'] = self.total_file_count_day_growth_ratio.to_map()
        if self.total_file_day_growth_count is not None:
            result['TotalFileDayGrowthCount'] = self.total_file_day_growth_count.to_map()
        if self.warm_data_day_growth_size is not None:
            result['WarmDataDayGrowthSize'] = self.warm_data_day_growth_size.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.warm_data_size_day_growth_ratio is not None:
            result['WarmDataSizeDayGrowthRatio'] = self.warm_data_size_day_growth_ratio.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdDataDayGrowthSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize()
            self.cold_data_day_growth_size = temp_model.from_map(m['ColdDataDayGrowthSize'])
        if m.get('ColdDataSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('ColdDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio()
            self.cold_data_size_day_growth_ratio = temp_model.from_map(m['ColdDataSizeDayGrowthRatio'])
        if m.get('EmptyFileCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount()
            self.empty_file_count = temp_model.from_map(m['EmptyFileCount'])
        if m.get('EmptyFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio()
            self.empty_file_count_day_growth_ratio = temp_model.from_map(m['EmptyFileCountDayGrowthRatio'])
        if m.get('EmptyFileDayGrowthCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount()
            self.empty_file_day_growth_count = temp_model.from_map(m['EmptyFileDayGrowthCount'])
        if m.get('FreezeDataDayGrowthSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize()
            self.freeze_data_day_growth_size = temp_model.from_map(m['FreezeDataDayGrowthSize'])
        if m.get('FreezeDataSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('FreezeDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio()
            self.freeze_data_size_day_growth_ratio = temp_model.from_map(m['FreezeDataSizeDayGrowthRatio'])
        if m.get('HotDataDayGrowthSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize()
            self.hot_data_day_growth_size = temp_model.from_map(m['HotDataDayGrowthSize'])
        if m.get('HotDataSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('HotDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio()
            self.hot_data_size_day_growth_ratio = temp_model.from_map(m['HotDataSizeDayGrowthRatio'])
        if m.get('LargeFileCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount()
            self.large_file_count = temp_model.from_map(m['LargeFileCount'])
        if m.get('LargeFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio()
            self.large_file_count_day_growth_ratio = temp_model.from_map(m['LargeFileCountDayGrowthRatio'])
        if m.get('LargeFileDayGrowthCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount()
            self.large_file_day_growth_count = temp_model.from_map(m['LargeFileDayGrowthCount'])
        if m.get('MediumFileCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount()
            self.medium_file_count = temp_model.from_map(m['MediumFileCount'])
        if m.get('MediumFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio()
            self.medium_file_count_day_growth_ratio = temp_model.from_map(m['MediumFileCountDayGrowthRatio'])
        if m.get('MediumFileDayGrowthCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount()
            self.medium_file_day_growth_count = temp_model.from_map(m['MediumFileDayGrowthCount'])
        if m.get('SmallFileCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount()
            self.small_file_count = temp_model.from_map(m['SmallFileCount'])
        if m.get('SmallFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio()
            self.small_file_count_day_growth_ratio = temp_model.from_map(m['SmallFileCountDayGrowthRatio'])
        if m.get('SmallFileDayGrowthCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount()
            self.small_file_day_growth_count = temp_model.from_map(m['SmallFileDayGrowthCount'])
        if m.get('TinyFileCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount()
            self.tiny_file_count = temp_model.from_map(m['TinyFileCount'])
        if m.get('TinyFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio()
            self.tiny_file_count_day_growth_ratio = temp_model.from_map(m['TinyFileCountDayGrowthRatio'])
        if m.get('TinyFileDayGrowthCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount()
            self.tiny_file_day_growth_count = temp_model.from_map(m['TinyFileDayGrowthCount'])
        if m.get('TotalDataDayGrowthSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize()
            self.total_data_day_growth_size = temp_model.from_map(m['TotalDataDayGrowthSize'])
        if m.get('TotalDataSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio()
            self.total_data_size_day_growth_ratio = temp_model.from_map(m['TotalDataSizeDayGrowthRatio'])
        if m.get('TotalFileCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        if m.get('TotalFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio()
            self.total_file_count_day_growth_ratio = temp_model.from_map(m['TotalFileCountDayGrowthRatio'])
        if m.get('TotalFileDayGrowthCount') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount()
            self.total_file_day_growth_count = temp_model.from_map(m['TotalFileDayGrowthCount'])
        if m.get('WarmDataDayGrowthSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize()
            self.warm_data_day_growth_size = temp_model.from_map(m['WarmDataDayGrowthSize'])
        if m.get('WarmDataSize') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WarmDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio()
            self.warm_data_size_day_growth_ratio = temp_model.from_map(m['WarmDataSizeDayGrowthRatio'])
        return self


class ListDoctorHDFSDirectoriesResponseBodyData(TeaModel):
    def __init__(
        self,
        depth: int = None,
        dir_path: str = None,
        group: str = None,
        metrics: ListDoctorHDFSDirectoriesResponseBodyDataMetrics = None,
        user: str = None,
    ):
        self.depth = depth
        self.dir_path = dir_path
        self.group = group
        self.metrics = metrics
        self.user = user

    def validate(self):
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.depth is not None:
            result['Depth'] = self.depth
        if self.dir_path is not None:
            result['DirPath'] = self.dir_path
        if self.group is not None:
            result['Group'] = self.group
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Depth') is not None:
            self.depth = m.get('Depth')
        if m.get('DirPath') is not None:
            self.dir_path = m.get('DirPath')
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Metrics') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class ListDoctorHDFSDirectoriesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorHDFSDirectoriesResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.data = data
        # 本次请求所返回的最大记录条数。
        self.max_results = max_results
        # 返回读取到的数据位置，空代表数据已经读取完毕。
        self.next_token = next_token
        # 请求ID。
        self.request_id = request_id
        # 本次请求条件下的数据总量。
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorHDFSDirectoriesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorHDFSDirectoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorHDFSDirectoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorHDFSDirectoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorHDFSUGIRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The maximum number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The basis on which you want to sort the query results. Valid values:
        # 
        # *   totalFileCount: the total number of files
        # *   totalDataSize: the total data size
        # *   totalDirCount: the total number of directories
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid values:
        # 
        # *   ASC: in ascending order
        # *   DESC: in descending order
        self.order_type = order_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The filter condition. Valid values:
        # 
        # *   user
        # *   group
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHDFSUGIResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        total_data_size: ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize = None,
        total_dir_count: ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount = None,
        total_file_count: ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount = None,
    ):
        # The total data size.
        self.total_data_size = total_data_size
        # The total number of directories.
        self.total_dir_count = total_dir_count
        # The total number of files.
        self.total_file_count = total_file_count

    def validate(self):
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_dir_count:
            self.total_dir_count.validate()
        if self.total_file_count:
            self.total_file_count.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_dir_count is not None:
            result['TotalDirCount'] = self.total_dir_count.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TotalDataSize') is not None:
            temp_model = ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDirCount') is not None:
            temp_model = ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount()
            self.total_dir_count = temp_model.from_map(m['TotalDirCount'])
        if m.get('TotalFileCount') is not None:
            temp_model = ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        return self


class ListDoctorHDFSUGIResponseBodyData(TeaModel):
    def __init__(
        self,
        metrics: ListDoctorHDFSUGIResponseBodyDataMetrics = None,
        name: str = None,
    ):
        # The metric information.
        self.metrics = metrics
        # The actual name of the owner or group returned based on the value of Type.
        self.name = name

    def validate(self):
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metrics') is not None:
            temp_model = ListDoctorHDFSUGIResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListDoctorHDFSUGIResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorHDFSUGIResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The results of batch HDFS analysis.
        self.data = data
        # The maximum number of entries that are returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorHDFSUGIResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorHDFSUGIResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorHDFSUGIResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorHDFSUGIResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorHiveDatabasesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        database_names: List[str] = None,
        date_time: str = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The database names.
        self.database_names = database_names
        # The query date.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The maximum number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The basis on which you want to sort the query results. Valid values:
        # 
        # *   tableCount: the number of tables
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid values:
        # 
        # *   ASC: in ascending order
        # *   DESC: in descending order
        self.order_type = order_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.database_names is not None:
            result['DatabaseNames'] = self.database_names
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DatabaseNames') is not None:
            self.database_names = m.get('DatabaseNames')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListDoctorHiveDatabasesResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        hive_distribution_score: int = None,
        hive_format_score: int = None,
        hive_frequency_score: int = None,
        hive_score: int = None,
    ):
        # The score for the distribution of files of different sizes stored in the Hive database.
        self.hive_distribution_score = hive_distribution_score
        # The score for the distribution of files stored in different formats in the Hive database.
        self.hive_format_score = hive_format_score
        # The score for the access frequency of the Hive database.
        self.hive_frequency_score = hive_frequency_score
        # The overall score of the Hive database.
        self.hive_score = hive_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hive_distribution_score is not None:
            result['HiveDistributionScore'] = self.hive_distribution_score
        if self.hive_format_score is not None:
            result['HiveFormatScore'] = self.hive_format_score
        if self.hive_frequency_score is not None:
            result['HiveFrequencyScore'] = self.hive_frequency_score
        if self.hive_score is not None:
            result['HiveScore'] = self.hive_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HiveDistributionScore') is not None:
            self.hive_distribution_score = m.get('HiveDistributionScore')
        if m.get('HiveFormatScore') is not None:
            self.hive_format_score = m.get('HiveFormatScore')
        if m.get('HiveFrequencyScore') is not None:
            self.hive_frequency_score = m.get('HiveFrequencyScore')
        if m.get('HiveScore') is not None:
            self.hive_score = m.get('HiveScore')
        return self


class ListDoctorHiveDatabasesResponseBodyDataFormats(TeaModel):
    def __init__(
        self,
        format_day_growth_size: int = None,
        format_name: str = None,
        format_ratio: float = None,
        format_size: int = None,
        format_size_day_growth_ratio: float = None,
        format_size_unit: str = None,
    ):
        # The daily increment of storage format-specific data.
        self.format_day_growth_size = format_day_growth_size
        # The name of the storage format.
        self.format_name = format_name
        # The proportion of data in a specific storage format.
        self.format_ratio = format_ratio
        # The amount of storage format-specific data.
        self.format_size = format_size
        # The day-to-day growth rate of storage format-specific data.
        self.format_size_day_growth_ratio = format_size_day_growth_ratio
        # The unit of the amount of storage format-specific data.
        self.format_size_unit = format_size_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format_day_growth_size is not None:
            result['FormatDayGrowthSize'] = self.format_day_growth_size
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.format_ratio is not None:
            result['FormatRatio'] = self.format_ratio
        if self.format_size is not None:
            result['FormatSize'] = self.format_size
        if self.format_size_day_growth_ratio is not None:
            result['FormatSizeDayGrowthRatio'] = self.format_size_day_growth_ratio
        if self.format_size_unit is not None:
            result['FormatSizeUnit'] = self.format_size_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FormatDayGrowthSize') is not None:
            self.format_day_growth_size = m.get('FormatDayGrowthSize')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('FormatRatio') is not None:
            self.format_ratio = m.get('FormatRatio')
        if m.get('FormatSize') is not None:
            self.format_size = m.get('FormatSize')
        if m.get('FormatSizeDayGrowthRatio') is not None:
            self.format_size_day_growth_ratio = m.get('FormatSizeDayGrowthRatio')
        if m.get('FormatSizeUnit') is not None:
            self.format_size_unit = m.get('FormatSizeUnit')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveDatabasesResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_data_day_growth_size: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize = None,
        cold_data_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio = None,
        cold_data_size: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize = None,
        cold_data_size_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio = None,
        empty_file_count: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount = None,
        empty_file_count_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio = None,
        empty_file_day_growth_count: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount = None,
        empty_file_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio = None,
        freeze_data_day_growth_size: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize = None,
        freeze_data_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio = None,
        freeze_data_size: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize = None,
        freeze_data_size_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio = None,
        hot_data_day_growth_size: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize = None,
        hot_data_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio = None,
        hot_data_size: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize = None,
        hot_data_size_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio = None,
        large_file_count: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount = None,
        large_file_count_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio = None,
        large_file_day_growth_count: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount = None,
        large_file_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio = None,
        medium_file_count: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount = None,
        medium_file_count_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio = None,
        medium_file_day_growth_count: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount = None,
        medium_file_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio = None,
        partition_num: ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum = None,
        small_file_count: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount = None,
        small_file_count_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio = None,
        small_file_day_growth_count: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount = None,
        small_file_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio = None,
        table_count: ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount = None,
        tiny_file_count: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount = None,
        tiny_file_count_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio = None,
        tiny_file_day_growth_count: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount = None,
        tiny_file_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio = None,
        total_data_day_growth_size: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize = None,
        total_data_size: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize = None,
        total_data_size_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio = None,
        total_file_count: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount = None,
        total_file_count_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio = None,
        total_file_day_growth_count: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount = None,
        warm_data_day_growth_size: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize = None,
        warm_data_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio = None,
        warm_data_size: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize = None,
        warm_data_size_day_growth_ratio: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio = None,
    ):
        # The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_day_growth_size = cold_data_day_growth_size
        # The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_ratio = cold_data_ratio
        # The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_size = cold_data_size
        # The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
        self.cold_data_size_day_growth_ratio = cold_data_size_day_growth_ratio
        # The number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count = empty_file_count
        # The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count_day_growth_ratio = empty_file_count_day_growth_ratio
        # The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_day_growth_count = empty_file_day_growth_count
        # The proportion of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_ratio = empty_file_ratio
        # The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_day_growth_size = freeze_data_day_growth_size
        # The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_ratio = freeze_data_ratio
        # The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size = freeze_data_size
        # The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size_day_growth_ratio = freeze_data_size_day_growth_ratio
        # The daily increment of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_day_growth_size = hot_data_day_growth_size
        # The proportion of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_ratio = hot_data_ratio
        # The amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_size = hot_data_size
        # The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
        self.hot_data_size_day_growth_ratio = hot_data_size_day_growth_ratio
        # The number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count = large_file_count
        # The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count_day_growth_ratio = large_file_count_day_growth_ratio
        # The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_day_growth_count = large_file_day_growth_count
        # The proportion of large files. Large files are those with a size greater than 1 GB.
        self.large_file_ratio = large_file_ratio
        # The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count = medium_file_count
        # The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count_day_growth_ratio = medium_file_count_day_growth_ratio
        # The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_day_growth_count = medium_file_day_growth_count
        # The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_ratio = medium_file_ratio
        # The number of partitions.
        self.partition_num = partition_num
        # The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count = small_file_count
        # The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count_day_growth_ratio = small_file_count_day_growth_ratio
        # The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_day_growth_count = small_file_day_growth_count
        # The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_ratio = small_file_ratio
        # The number of tables.
        self.table_count = table_count
        # The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count = tiny_file_count
        # The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count_day_growth_ratio = tiny_file_count_day_growth_ratio
        # The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_day_growth_count = tiny_file_day_growth_count
        # The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_ratio = tiny_file_ratio
        # The daily increment of the total data volume.
        self.total_data_day_growth_size = total_data_day_growth_size
        # The total amount of data.
        self.total_data_size = total_data_size
        # The day-to-day growth rate of the total data volume.
        self.total_data_size_day_growth_ratio = total_data_size_day_growth_ratio
        # The total number of files.
        self.total_file_count = total_file_count
        # The day-to-day growth rate of the total number of files.
        self.total_file_count_day_growth_ratio = total_file_count_day_growth_ratio
        # The daily increment of the total number of files.
        self.total_file_day_growth_count = total_file_day_growth_count
        # The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_day_growth_size = warm_data_day_growth_size
        # The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_ratio = warm_data_ratio
        # The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_size = warm_data_size
        # The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
        self.warm_data_size_day_growth_ratio = warm_data_size_day_growth_ratio

    def validate(self):
        if self.cold_data_day_growth_size:
            self.cold_data_day_growth_size.validate()
        if self.cold_data_ratio:
            self.cold_data_ratio.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.cold_data_size_day_growth_ratio:
            self.cold_data_size_day_growth_ratio.validate()
        if self.empty_file_count:
            self.empty_file_count.validate()
        if self.empty_file_count_day_growth_ratio:
            self.empty_file_count_day_growth_ratio.validate()
        if self.empty_file_day_growth_count:
            self.empty_file_day_growth_count.validate()
        if self.empty_file_ratio:
            self.empty_file_ratio.validate()
        if self.freeze_data_day_growth_size:
            self.freeze_data_day_growth_size.validate()
        if self.freeze_data_ratio:
            self.freeze_data_ratio.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.freeze_data_size_day_growth_ratio:
            self.freeze_data_size_day_growth_ratio.validate()
        if self.hot_data_day_growth_size:
            self.hot_data_day_growth_size.validate()
        if self.hot_data_ratio:
            self.hot_data_ratio.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.hot_data_size_day_growth_ratio:
            self.hot_data_size_day_growth_ratio.validate()
        if self.large_file_count:
            self.large_file_count.validate()
        if self.large_file_count_day_growth_ratio:
            self.large_file_count_day_growth_ratio.validate()
        if self.large_file_day_growth_count:
            self.large_file_day_growth_count.validate()
        if self.large_file_ratio:
            self.large_file_ratio.validate()
        if self.medium_file_count:
            self.medium_file_count.validate()
        if self.medium_file_count_day_growth_ratio:
            self.medium_file_count_day_growth_ratio.validate()
        if self.medium_file_day_growth_count:
            self.medium_file_day_growth_count.validate()
        if self.medium_file_ratio:
            self.medium_file_ratio.validate()
        if self.partition_num:
            self.partition_num.validate()
        if self.small_file_count:
            self.small_file_count.validate()
        if self.small_file_count_day_growth_ratio:
            self.small_file_count_day_growth_ratio.validate()
        if self.small_file_day_growth_count:
            self.small_file_day_growth_count.validate()
        if self.small_file_ratio:
            self.small_file_ratio.validate()
        if self.table_count:
            self.table_count.validate()
        if self.tiny_file_count:
            self.tiny_file_count.validate()
        if self.tiny_file_count_day_growth_ratio:
            self.tiny_file_count_day_growth_ratio.validate()
        if self.tiny_file_day_growth_count:
            self.tiny_file_day_growth_count.validate()
        if self.tiny_file_ratio:
            self.tiny_file_ratio.validate()
        if self.total_data_day_growth_size:
            self.total_data_day_growth_size.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_data_size_day_growth_ratio:
            self.total_data_size_day_growth_ratio.validate()
        if self.total_file_count:
            self.total_file_count.validate()
        if self.total_file_count_day_growth_ratio:
            self.total_file_count_day_growth_ratio.validate()
        if self.total_file_day_growth_count:
            self.total_file_day_growth_count.validate()
        if self.warm_data_day_growth_size:
            self.warm_data_day_growth_size.validate()
        if self.warm_data_ratio:
            self.warm_data_ratio.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.warm_data_size_day_growth_ratio:
            self.warm_data_size_day_growth_ratio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_data_day_growth_size is not None:
            result['ColdDataDayGrowthSize'] = self.cold_data_day_growth_size.to_map()
        if self.cold_data_ratio is not None:
            result['ColdDataRatio'] = self.cold_data_ratio.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.cold_data_size_day_growth_ratio is not None:
            result['ColdDataSizeDayGrowthRatio'] = self.cold_data_size_day_growth_ratio.to_map()
        if self.empty_file_count is not None:
            result['EmptyFileCount'] = self.empty_file_count.to_map()
        if self.empty_file_count_day_growth_ratio is not None:
            result['EmptyFileCountDayGrowthRatio'] = self.empty_file_count_day_growth_ratio.to_map()
        if self.empty_file_day_growth_count is not None:
            result['EmptyFileDayGrowthCount'] = self.empty_file_day_growth_count.to_map()
        if self.empty_file_ratio is not None:
            result['EmptyFileRatio'] = self.empty_file_ratio.to_map()
        if self.freeze_data_day_growth_size is not None:
            result['FreezeDataDayGrowthSize'] = self.freeze_data_day_growth_size.to_map()
        if self.freeze_data_ratio is not None:
            result['FreezeDataRatio'] = self.freeze_data_ratio.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.freeze_data_size_day_growth_ratio is not None:
            result['FreezeDataSizeDayGrowthRatio'] = self.freeze_data_size_day_growth_ratio.to_map()
        if self.hot_data_day_growth_size is not None:
            result['HotDataDayGrowthSize'] = self.hot_data_day_growth_size.to_map()
        if self.hot_data_ratio is not None:
            result['HotDataRatio'] = self.hot_data_ratio.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.hot_data_size_day_growth_ratio is not None:
            result['HotDataSizeDayGrowthRatio'] = self.hot_data_size_day_growth_ratio.to_map()
        if self.large_file_count is not None:
            result['LargeFileCount'] = self.large_file_count.to_map()
        if self.large_file_count_day_growth_ratio is not None:
            result['LargeFileCountDayGrowthRatio'] = self.large_file_count_day_growth_ratio.to_map()
        if self.large_file_day_growth_count is not None:
            result['LargeFileDayGrowthCount'] = self.large_file_day_growth_count.to_map()
        if self.large_file_ratio is not None:
            result['LargeFileRatio'] = self.large_file_ratio.to_map()
        if self.medium_file_count is not None:
            result['MediumFileCount'] = self.medium_file_count.to_map()
        if self.medium_file_count_day_growth_ratio is not None:
            result['MediumFileCountDayGrowthRatio'] = self.medium_file_count_day_growth_ratio.to_map()
        if self.medium_file_day_growth_count is not None:
            result['MediumFileDayGrowthCount'] = self.medium_file_day_growth_count.to_map()
        if self.medium_file_ratio is not None:
            result['MediumFileRatio'] = self.medium_file_ratio.to_map()
        if self.partition_num is not None:
            result['PartitionNum'] = self.partition_num.to_map()
        if self.small_file_count is not None:
            result['SmallFileCount'] = self.small_file_count.to_map()
        if self.small_file_count_day_growth_ratio is not None:
            result['SmallFileCountDayGrowthRatio'] = self.small_file_count_day_growth_ratio.to_map()
        if self.small_file_day_growth_count is not None:
            result['SmallFileDayGrowthCount'] = self.small_file_day_growth_count.to_map()
        if self.small_file_ratio is not None:
            result['SmallFileRatio'] = self.small_file_ratio.to_map()
        if self.table_count is not None:
            result['TableCount'] = self.table_count.to_map()
        if self.tiny_file_count is not None:
            result['TinyFileCount'] = self.tiny_file_count.to_map()
        if self.tiny_file_count_day_growth_ratio is not None:
            result['TinyFileCountDayGrowthRatio'] = self.tiny_file_count_day_growth_ratio.to_map()
        if self.tiny_file_day_growth_count is not None:
            result['TinyFileDayGrowthCount'] = self.tiny_file_day_growth_count.to_map()
        if self.tiny_file_ratio is not None:
            result['TinyFileRatio'] = self.tiny_file_ratio.to_map()
        if self.total_data_day_growth_size is not None:
            result['TotalDataDayGrowthSize'] = self.total_data_day_growth_size.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_data_size_day_growth_ratio is not None:
            result['TotalDataSizeDayGrowthRatio'] = self.total_data_size_day_growth_ratio.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        if self.total_file_count_day_growth_ratio is not None:
            result['TotalFileCountDayGrowthRatio'] = self.total_file_count_day_growth_ratio.to_map()
        if self.total_file_day_growth_count is not None:
            result['TotalFileDayGrowthCount'] = self.total_file_day_growth_count.to_map()
        if self.warm_data_day_growth_size is not None:
            result['WarmDataDayGrowthSize'] = self.warm_data_day_growth_size.to_map()
        if self.warm_data_ratio is not None:
            result['WarmDataRatio'] = self.warm_data_ratio.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.warm_data_size_day_growth_ratio is not None:
            result['WarmDataSizeDayGrowthRatio'] = self.warm_data_size_day_growth_ratio.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize()
            self.cold_data_day_growth_size = temp_model.from_map(m['ColdDataDayGrowthSize'])
        if m.get('ColdDataRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio()
            self.cold_data_ratio = temp_model.from_map(m['ColdDataRatio'])
        if m.get('ColdDataSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('ColdDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio()
            self.cold_data_size_day_growth_ratio = temp_model.from_map(m['ColdDataSizeDayGrowthRatio'])
        if m.get('EmptyFileCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount()
            self.empty_file_count = temp_model.from_map(m['EmptyFileCount'])
        if m.get('EmptyFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio()
            self.empty_file_count_day_growth_ratio = temp_model.from_map(m['EmptyFileCountDayGrowthRatio'])
        if m.get('EmptyFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount()
            self.empty_file_day_growth_count = temp_model.from_map(m['EmptyFileDayGrowthCount'])
        if m.get('EmptyFileRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio()
            self.empty_file_ratio = temp_model.from_map(m['EmptyFileRatio'])
        if m.get('FreezeDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize()
            self.freeze_data_day_growth_size = temp_model.from_map(m['FreezeDataDayGrowthSize'])
        if m.get('FreezeDataRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio()
            self.freeze_data_ratio = temp_model.from_map(m['FreezeDataRatio'])
        if m.get('FreezeDataSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('FreezeDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio()
            self.freeze_data_size_day_growth_ratio = temp_model.from_map(m['FreezeDataSizeDayGrowthRatio'])
        if m.get('HotDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize()
            self.hot_data_day_growth_size = temp_model.from_map(m['HotDataDayGrowthSize'])
        if m.get('HotDataRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio()
            self.hot_data_ratio = temp_model.from_map(m['HotDataRatio'])
        if m.get('HotDataSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('HotDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio()
            self.hot_data_size_day_growth_ratio = temp_model.from_map(m['HotDataSizeDayGrowthRatio'])
        if m.get('LargeFileCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount()
            self.large_file_count = temp_model.from_map(m['LargeFileCount'])
        if m.get('LargeFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio()
            self.large_file_count_day_growth_ratio = temp_model.from_map(m['LargeFileCountDayGrowthRatio'])
        if m.get('LargeFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount()
            self.large_file_day_growth_count = temp_model.from_map(m['LargeFileDayGrowthCount'])
        if m.get('LargeFileRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio()
            self.large_file_ratio = temp_model.from_map(m['LargeFileRatio'])
        if m.get('MediumFileCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount()
            self.medium_file_count = temp_model.from_map(m['MediumFileCount'])
        if m.get('MediumFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio()
            self.medium_file_count_day_growth_ratio = temp_model.from_map(m['MediumFileCountDayGrowthRatio'])
        if m.get('MediumFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount()
            self.medium_file_day_growth_count = temp_model.from_map(m['MediumFileDayGrowthCount'])
        if m.get('MediumFileRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio()
            self.medium_file_ratio = temp_model.from_map(m['MediumFileRatio'])
        if m.get('PartitionNum') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum()
            self.partition_num = temp_model.from_map(m['PartitionNum'])
        if m.get('SmallFileCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount()
            self.small_file_count = temp_model.from_map(m['SmallFileCount'])
        if m.get('SmallFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio()
            self.small_file_count_day_growth_ratio = temp_model.from_map(m['SmallFileCountDayGrowthRatio'])
        if m.get('SmallFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount()
            self.small_file_day_growth_count = temp_model.from_map(m['SmallFileDayGrowthCount'])
        if m.get('SmallFileRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio()
            self.small_file_ratio = temp_model.from_map(m['SmallFileRatio'])
        if m.get('TableCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount()
            self.table_count = temp_model.from_map(m['TableCount'])
        if m.get('TinyFileCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount()
            self.tiny_file_count = temp_model.from_map(m['TinyFileCount'])
        if m.get('TinyFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio()
            self.tiny_file_count_day_growth_ratio = temp_model.from_map(m['TinyFileCountDayGrowthRatio'])
        if m.get('TinyFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount()
            self.tiny_file_day_growth_count = temp_model.from_map(m['TinyFileDayGrowthCount'])
        if m.get('TinyFileRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio()
            self.tiny_file_ratio = temp_model.from_map(m['TinyFileRatio'])
        if m.get('TotalDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize()
            self.total_data_day_growth_size = temp_model.from_map(m['TotalDataDayGrowthSize'])
        if m.get('TotalDataSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio()
            self.total_data_size_day_growth_ratio = temp_model.from_map(m['TotalDataSizeDayGrowthRatio'])
        if m.get('TotalFileCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        if m.get('TotalFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio()
            self.total_file_count_day_growth_ratio = temp_model.from_map(m['TotalFileCountDayGrowthRatio'])
        if m.get('TotalFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount()
            self.total_file_day_growth_count = temp_model.from_map(m['TotalFileDayGrowthCount'])
        if m.get('WarmDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize()
            self.warm_data_day_growth_size = temp_model.from_map(m['WarmDataDayGrowthSize'])
        if m.get('WarmDataRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio()
            self.warm_data_ratio = temp_model.from_map(m['WarmDataRatio'])
        if m.get('WarmDataSize') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WarmDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio()
            self.warm_data_size_day_growth_ratio = temp_model.from_map(m['WarmDataSizeDayGrowthRatio'])
        return self


class ListDoctorHiveDatabasesResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: ListDoctorHiveDatabasesResponseBodyDataAnalysis = None,
        database_name: str = None,
        formats: List[ListDoctorHiveDatabasesResponseBodyDataFormats] = None,
        metrics: ListDoctorHiveDatabasesResponseBodyDataMetrics = None,
    ):
        # The analysis results.
        self.analysis = analysis
        # The database name.
        self.database_name = database_name
        # The information from the perspective of storage formats.
        self.formats = formats
        # The metric information.
        self.metrics = metrics

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.formats:
            for k in self.formats:
                if k:
                    k.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        result['Formats'] = []
        if self.formats is not None:
            for k in self.formats:
                result['Formats'].append(k.to_map() if k else None)
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        self.formats = []
        if m.get('Formats') is not None:
            for k in m.get('Formats'):
                temp_model = ListDoctorHiveDatabasesResponseBodyDataFormats()
                self.formats.append(temp_model.from_map(k))
        if m.get('Metrics') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        return self


class ListDoctorHiveDatabasesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorHiveDatabasesResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The analysis results of Hive databases.
        self.data = data
        # The maximum number of entries that are returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorHiveDatabasesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorHiveDatabasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorHiveDatabasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorHiveDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorHiveTablesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        date_time: str = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        region_id: str = None,
        table_names: List[str] = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
        # 
        # This parameter is required.
        self.date_time = date_time
        # The maximum number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The basis on which you want to sort the query results. Valid values:
        # 
        # *   partitionNum: the number of partitions.
        # *   totalFileCount: the total number of files.
        # *   largeFileCount: the number of large files. Large files are those with a size greater than 1 GB.
        # *   mediumFileCount: the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        # *   smallFileCount: the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        # *   tinyFileCount: the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        # *   emptyFileCount: the number of empty files. Empty files are those with a size of 0 MB.
        # *   largeFileRatio: the proportion of large files. Large files are those with a size greater than 1 GB.
        # *   mediumFileRatio: the proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        # *   smallFileRatio: the proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        # *   tinyFileRatio: the proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        # *   emptyFileRatio: the proportion of empty files. Empty files are those with a size of 0 MB.
        # *   hotDataSize: the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        # *   WarmDataSize: the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        # *   coldDataSize: the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        # *   freezeDataSize: the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        # *   totalDataSize: the total amount of data.
        # *   hotDataRatio: the proportion of hot data. Hot data refers to data that is accessed in previous seven days.
        # *   WarmDataRatio: the proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        # *   coldDataRatio: the proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        # *   freezeDataRatio: the proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        # *   totalFileDayGrowthCount: the daily increment of the total number of files.
        # *   largeFileDayGrowthCount: the daily increment of the number of large files. Large files are those with a size greater than 1 GB.
        # *   mediumFileDayGrowthCount: the daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        # *   smallFileDayGrowthCount: the daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        # *   tinyFileDayGrowthCount: the daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        # *   emptyFileDayGrowthCount: the daily increment of the number of empty files. Empty files are those with a size of 0 MB.
        # *   hotDataDayGrowthSize: the daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        # *   warmDataDayGrowthSize: the daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        # *   coldDataDayGrowthSize: the daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        # *   freezeDataDayGrowthSize: the daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        # *   totalDataDayGrowthSize: the daily increment of the amount of total data.
        # *   totalFileCountDayGrowthRatio: the day-to-day growth rate of the total number of files.
        # *   largeFileCountDayGrowthRatio: the day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
        # *   mediumFileCountDayGrowthRatio: the day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        # *   smallFileCountDayGrowthRatio: the day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        # *   tinyFileCountDayGrowthRatio: the day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        # *   emptyFileCountDayGrowthRatio: the day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
        # *   hotDataSizeDayGrowthRatio: the day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        # *   warmDataSizeDayGrowthRatio: the day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        # *   coldDataSizeDayGrowthRatio: the day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        # *   freezeDataSizeDayGrowthRatio: the day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        # *   totalDataSizeDayGrowthRatio: the day-to-day growth rate of the total amount of data.
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid value:
        # 
        # *   ASC: in ascending order
        # *   DESC: in descending order
        self.order_type = order_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The table names, which are used to filter the query results.
        self.table_names = table_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        return self


class ListDoctorHiveTablesResponseBodyDataAnalysis(TeaModel):
    def __init__(
        self,
        hive_distribution_score: int = None,
        hive_format_score: int = None,
        hive_frequency_score: int = None,
        hive_score: int = None,
    ):
        # The score for the file sizes of the Hive table.
        self.hive_distribution_score = hive_distribution_score
        # The score for the data formats of the Hive table.
        self.hive_format_score = hive_format_score
        # The score for the access frequency of the Hive table.
        self.hive_frequency_score = hive_frequency_score
        # The overall score of the Hive table.
        self.hive_score = hive_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hive_distribution_score is not None:
            result['HiveDistributionScore'] = self.hive_distribution_score
        if self.hive_format_score is not None:
            result['HiveFormatScore'] = self.hive_format_score
        if self.hive_frequency_score is not None:
            result['HiveFrequencyScore'] = self.hive_frequency_score
        if self.hive_score is not None:
            result['HiveScore'] = self.hive_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HiveDistributionScore') is not None:
            self.hive_distribution_score = m.get('HiveDistributionScore')
        if m.get('HiveFormatScore') is not None:
            self.hive_format_score = m.get('HiveFormatScore')
        if m.get('HiveFrequencyScore') is not None:
            self.hive_frequency_score = m.get('HiveFrequencyScore')
        if m.get('HiveScore') is not None:
            self.hive_score = m.get('HiveScore')
        return self


class ListDoctorHiveTablesResponseBodyDataFormats(TeaModel):
    def __init__(
        self,
        format_day_growth_size: int = None,
        format_name: str = None,
        format_ratio: float = None,
        format_size: int = None,
        format_size_day_growth_ratio: float = None,
        format_size_unit: str = None,
    ):
        # The daily increment of data in the format.
        self.format_day_growth_size = format_day_growth_size
        # The name of the storage format.
        self.format_name = format_name
        # The proportion of the data in the format.
        self.format_ratio = format_ratio
        # The amount of data in the format.
        self.format_size = format_size
        # The day-to-day growth rate of data in the format.
        self.format_size_day_growth_ratio = format_size_day_growth_ratio
        # The unit of the amount of data in the format.
        self.format_size_unit = format_size_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format_day_growth_size is not None:
            result['FormatDayGrowthSize'] = self.format_day_growth_size
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.format_ratio is not None:
            result['FormatRatio'] = self.format_ratio
        if self.format_size is not None:
            result['FormatSize'] = self.format_size
        if self.format_size_day_growth_ratio is not None:
            result['FormatSizeDayGrowthRatio'] = self.format_size_day_growth_ratio
        if self.format_size_unit is not None:
            result['FormatSizeUnit'] = self.format_size_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FormatDayGrowthSize') is not None:
            self.format_day_growth_size = m.get('FormatDayGrowthSize')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('FormatRatio') is not None:
            self.format_ratio = m.get('FormatRatio')
        if m.get('FormatSize') is not None:
            self.format_size = m.get('FormatSize')
        if m.get('FormatSizeDayGrowthRatio') is not None:
            self.format_size_day_growth_ratio = m.get('FormatSizeDayGrowthRatio')
        if m.get('FormatSizeUnit') is not None:
            self.format_size_unit = m.get('FormatSizeUnit')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: float = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorHiveTablesResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        cold_data_day_growth_size: ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize = None,
        cold_data_ratio: ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio = None,
        cold_data_size: ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize = None,
        cold_data_size_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio = None,
        empty_file_count: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount = None,
        empty_file_count_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio = None,
        empty_file_day_growth_count: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount = None,
        empty_file_ratio: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio = None,
        freeze_data_day_growth_size: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize = None,
        freeze_data_ratio: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio = None,
        freeze_data_size: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize = None,
        freeze_data_size_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio = None,
        hot_data_day_growth_size: ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize = None,
        hot_data_ratio: ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio = None,
        hot_data_size: ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize = None,
        hot_data_size_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio = None,
        large_file_count: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount = None,
        large_file_count_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio = None,
        large_file_day_growth_count: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount = None,
        large_file_ratio: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio = None,
        medium_file_count: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount = None,
        medium_file_count_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio = None,
        medium_file_day_growth_count: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount = None,
        medium_file_ratio: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio = None,
        partition_num: ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum = None,
        small_file_count: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount = None,
        small_file_count_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio = None,
        small_file_day_growth_count: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount = None,
        small_file_ratio: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio = None,
        tiny_file_count: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount = None,
        tiny_file_count_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio = None,
        tiny_file_day_growth_count: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount = None,
        tiny_file_ratio: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio = None,
        total_data_day_growth_size: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize = None,
        total_data_size: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize = None,
        total_data_size_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio = None,
        total_file_count: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount = None,
        total_file_count_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio = None,
        total_file_day_growth_count: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount = None,
        warm_data_day_growth_size: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize = None,
        warm_data_ratio: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio = None,
        warm_data_size: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize = None,
        warm_data_size_day_growth_ratio: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio = None,
    ):
        # The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_day_growth_size = cold_data_day_growth_size
        # The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_ratio = cold_data_ratio
        # The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_size = cold_data_size
        # The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
        self.cold_data_size_day_growth_ratio = cold_data_size_day_growth_ratio
        # The number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count = empty_file_count
        # The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_count_day_growth_ratio = empty_file_count_day_growth_ratio
        # The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_day_growth_count = empty_file_day_growth_count
        # The proportion of empty files. Empty files are those with a size of 0 MB.
        self.empty_file_ratio = empty_file_ratio
        # The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_day_growth_size = freeze_data_day_growth_size
        # The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_ratio = freeze_data_ratio
        # The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size = freeze_data_size
        # The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
        self.freeze_data_size_day_growth_ratio = freeze_data_size_day_growth_ratio
        # The daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_day_growth_size = hot_data_day_growth_size
        # The proportion of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_ratio = hot_data_ratio
        # The amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_size = hot_data_size
        # The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
        self.hot_data_size_day_growth_ratio = hot_data_size_day_growth_ratio
        # The number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count = large_file_count
        # The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_count_day_growth_ratio = large_file_count_day_growth_ratio
        # The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
        self.large_file_day_growth_count = large_file_day_growth_count
        # The proportion of large files. Large files are those with a size greater than 1 GB.
        self.large_file_ratio = large_file_ratio
        # The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count = medium_file_count
        # The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_count_day_growth_ratio = medium_file_count_day_growth_ratio
        # The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_day_growth_count = medium_file_day_growth_count
        # The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
        self.medium_file_ratio = medium_file_ratio
        # The number of partitions.
        self.partition_num = partition_num
        # The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count = small_file_count
        # The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_count_day_growth_ratio = small_file_count_day_growth_ratio
        # The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_day_growth_count = small_file_day_growth_count
        # The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
        self.small_file_ratio = small_file_ratio
        # The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count = tiny_file_count
        # The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_count_day_growth_ratio = tiny_file_count_day_growth_ratio
        # The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_day_growth_count = tiny_file_day_growth_count
        # The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
        self.tiny_file_ratio = tiny_file_ratio
        # The daily increment of the total amount of data.
        self.total_data_day_growth_size = total_data_day_growth_size
        # The total amount of data.
        self.total_data_size = total_data_size
        # The day-to-day growth rate of the total amount of data.
        self.total_data_size_day_growth_ratio = total_data_size_day_growth_ratio
        # The total number of files.
        self.total_file_count = total_file_count
        # The day-to-day growth rate of the total number of files.
        self.total_file_count_day_growth_ratio = total_file_count_day_growth_ratio
        # The daily increment of the total number of files.
        self.total_file_day_growth_count = total_file_day_growth_count
        # The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_day_growth_size = warm_data_day_growth_size
        # The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_ratio = warm_data_ratio
        # The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_size = warm_data_size
        # The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
        self.warm_data_size_day_growth_ratio = warm_data_size_day_growth_ratio

    def validate(self):
        if self.cold_data_day_growth_size:
            self.cold_data_day_growth_size.validate()
        if self.cold_data_ratio:
            self.cold_data_ratio.validate()
        if self.cold_data_size:
            self.cold_data_size.validate()
        if self.cold_data_size_day_growth_ratio:
            self.cold_data_size_day_growth_ratio.validate()
        if self.empty_file_count:
            self.empty_file_count.validate()
        if self.empty_file_count_day_growth_ratio:
            self.empty_file_count_day_growth_ratio.validate()
        if self.empty_file_day_growth_count:
            self.empty_file_day_growth_count.validate()
        if self.empty_file_ratio:
            self.empty_file_ratio.validate()
        if self.freeze_data_day_growth_size:
            self.freeze_data_day_growth_size.validate()
        if self.freeze_data_ratio:
            self.freeze_data_ratio.validate()
        if self.freeze_data_size:
            self.freeze_data_size.validate()
        if self.freeze_data_size_day_growth_ratio:
            self.freeze_data_size_day_growth_ratio.validate()
        if self.hot_data_day_growth_size:
            self.hot_data_day_growth_size.validate()
        if self.hot_data_ratio:
            self.hot_data_ratio.validate()
        if self.hot_data_size:
            self.hot_data_size.validate()
        if self.hot_data_size_day_growth_ratio:
            self.hot_data_size_day_growth_ratio.validate()
        if self.large_file_count:
            self.large_file_count.validate()
        if self.large_file_count_day_growth_ratio:
            self.large_file_count_day_growth_ratio.validate()
        if self.large_file_day_growth_count:
            self.large_file_day_growth_count.validate()
        if self.large_file_ratio:
            self.large_file_ratio.validate()
        if self.medium_file_count:
            self.medium_file_count.validate()
        if self.medium_file_count_day_growth_ratio:
            self.medium_file_count_day_growth_ratio.validate()
        if self.medium_file_day_growth_count:
            self.medium_file_day_growth_count.validate()
        if self.medium_file_ratio:
            self.medium_file_ratio.validate()
        if self.partition_num:
            self.partition_num.validate()
        if self.small_file_count:
            self.small_file_count.validate()
        if self.small_file_count_day_growth_ratio:
            self.small_file_count_day_growth_ratio.validate()
        if self.small_file_day_growth_count:
            self.small_file_day_growth_count.validate()
        if self.small_file_ratio:
            self.small_file_ratio.validate()
        if self.tiny_file_count:
            self.tiny_file_count.validate()
        if self.tiny_file_count_day_growth_ratio:
            self.tiny_file_count_day_growth_ratio.validate()
        if self.tiny_file_day_growth_count:
            self.tiny_file_day_growth_count.validate()
        if self.tiny_file_ratio:
            self.tiny_file_ratio.validate()
        if self.total_data_day_growth_size:
            self.total_data_day_growth_size.validate()
        if self.total_data_size:
            self.total_data_size.validate()
        if self.total_data_size_day_growth_ratio:
            self.total_data_size_day_growth_ratio.validate()
        if self.total_file_count:
            self.total_file_count.validate()
        if self.total_file_count_day_growth_ratio:
            self.total_file_count_day_growth_ratio.validate()
        if self.total_file_day_growth_count:
            self.total_file_day_growth_count.validate()
        if self.warm_data_day_growth_size:
            self.warm_data_day_growth_size.validate()
        if self.warm_data_ratio:
            self.warm_data_ratio.validate()
        if self.warm_data_size:
            self.warm_data_size.validate()
        if self.warm_data_size_day_growth_ratio:
            self.warm_data_size_day_growth_ratio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cold_data_day_growth_size is not None:
            result['ColdDataDayGrowthSize'] = self.cold_data_day_growth_size.to_map()
        if self.cold_data_ratio is not None:
            result['ColdDataRatio'] = self.cold_data_ratio.to_map()
        if self.cold_data_size is not None:
            result['ColdDataSize'] = self.cold_data_size.to_map()
        if self.cold_data_size_day_growth_ratio is not None:
            result['ColdDataSizeDayGrowthRatio'] = self.cold_data_size_day_growth_ratio.to_map()
        if self.empty_file_count is not None:
            result['EmptyFileCount'] = self.empty_file_count.to_map()
        if self.empty_file_count_day_growth_ratio is not None:
            result['EmptyFileCountDayGrowthRatio'] = self.empty_file_count_day_growth_ratio.to_map()
        if self.empty_file_day_growth_count is not None:
            result['EmptyFileDayGrowthCount'] = self.empty_file_day_growth_count.to_map()
        if self.empty_file_ratio is not None:
            result['EmptyFileRatio'] = self.empty_file_ratio.to_map()
        if self.freeze_data_day_growth_size is not None:
            result['FreezeDataDayGrowthSize'] = self.freeze_data_day_growth_size.to_map()
        if self.freeze_data_ratio is not None:
            result['FreezeDataRatio'] = self.freeze_data_ratio.to_map()
        if self.freeze_data_size is not None:
            result['FreezeDataSize'] = self.freeze_data_size.to_map()
        if self.freeze_data_size_day_growth_ratio is not None:
            result['FreezeDataSizeDayGrowthRatio'] = self.freeze_data_size_day_growth_ratio.to_map()
        if self.hot_data_day_growth_size is not None:
            result['HotDataDayGrowthSize'] = self.hot_data_day_growth_size.to_map()
        if self.hot_data_ratio is not None:
            result['HotDataRatio'] = self.hot_data_ratio.to_map()
        if self.hot_data_size is not None:
            result['HotDataSize'] = self.hot_data_size.to_map()
        if self.hot_data_size_day_growth_ratio is not None:
            result['HotDataSizeDayGrowthRatio'] = self.hot_data_size_day_growth_ratio.to_map()
        if self.large_file_count is not None:
            result['LargeFileCount'] = self.large_file_count.to_map()
        if self.large_file_count_day_growth_ratio is not None:
            result['LargeFileCountDayGrowthRatio'] = self.large_file_count_day_growth_ratio.to_map()
        if self.large_file_day_growth_count is not None:
            result['LargeFileDayGrowthCount'] = self.large_file_day_growth_count.to_map()
        if self.large_file_ratio is not None:
            result['LargeFileRatio'] = self.large_file_ratio.to_map()
        if self.medium_file_count is not None:
            result['MediumFileCount'] = self.medium_file_count.to_map()
        if self.medium_file_count_day_growth_ratio is not None:
            result['MediumFileCountDayGrowthRatio'] = self.medium_file_count_day_growth_ratio.to_map()
        if self.medium_file_day_growth_count is not None:
            result['MediumFileDayGrowthCount'] = self.medium_file_day_growth_count.to_map()
        if self.medium_file_ratio is not None:
            result['MediumFileRatio'] = self.medium_file_ratio.to_map()
        if self.partition_num is not None:
            result['PartitionNum'] = self.partition_num.to_map()
        if self.small_file_count is not None:
            result['SmallFileCount'] = self.small_file_count.to_map()
        if self.small_file_count_day_growth_ratio is not None:
            result['SmallFileCountDayGrowthRatio'] = self.small_file_count_day_growth_ratio.to_map()
        if self.small_file_day_growth_count is not None:
            result['SmallFileDayGrowthCount'] = self.small_file_day_growth_count.to_map()
        if self.small_file_ratio is not None:
            result['SmallFileRatio'] = self.small_file_ratio.to_map()
        if self.tiny_file_count is not None:
            result['TinyFileCount'] = self.tiny_file_count.to_map()
        if self.tiny_file_count_day_growth_ratio is not None:
            result['TinyFileCountDayGrowthRatio'] = self.tiny_file_count_day_growth_ratio.to_map()
        if self.tiny_file_day_growth_count is not None:
            result['TinyFileDayGrowthCount'] = self.tiny_file_day_growth_count.to_map()
        if self.tiny_file_ratio is not None:
            result['TinyFileRatio'] = self.tiny_file_ratio.to_map()
        if self.total_data_day_growth_size is not None:
            result['TotalDataDayGrowthSize'] = self.total_data_day_growth_size.to_map()
        if self.total_data_size is not None:
            result['TotalDataSize'] = self.total_data_size.to_map()
        if self.total_data_size_day_growth_ratio is not None:
            result['TotalDataSizeDayGrowthRatio'] = self.total_data_size_day_growth_ratio.to_map()
        if self.total_file_count is not None:
            result['TotalFileCount'] = self.total_file_count.to_map()
        if self.total_file_count_day_growth_ratio is not None:
            result['TotalFileCountDayGrowthRatio'] = self.total_file_count_day_growth_ratio.to_map()
        if self.total_file_day_growth_count is not None:
            result['TotalFileDayGrowthCount'] = self.total_file_day_growth_count.to_map()
        if self.warm_data_day_growth_size is not None:
            result['WarmDataDayGrowthSize'] = self.warm_data_day_growth_size.to_map()
        if self.warm_data_ratio is not None:
            result['WarmDataRatio'] = self.warm_data_ratio.to_map()
        if self.warm_data_size is not None:
            result['WarmDataSize'] = self.warm_data_size.to_map()
        if self.warm_data_size_day_growth_ratio is not None:
            result['WarmDataSizeDayGrowthRatio'] = self.warm_data_size_day_growth_ratio.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColdDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize()
            self.cold_data_day_growth_size = temp_model.from_map(m['ColdDataDayGrowthSize'])
        if m.get('ColdDataRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio()
            self.cold_data_ratio = temp_model.from_map(m['ColdDataRatio'])
        if m.get('ColdDataSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize()
            self.cold_data_size = temp_model.from_map(m['ColdDataSize'])
        if m.get('ColdDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio()
            self.cold_data_size_day_growth_ratio = temp_model.from_map(m['ColdDataSizeDayGrowthRatio'])
        if m.get('EmptyFileCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount()
            self.empty_file_count = temp_model.from_map(m['EmptyFileCount'])
        if m.get('EmptyFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio()
            self.empty_file_count_day_growth_ratio = temp_model.from_map(m['EmptyFileCountDayGrowthRatio'])
        if m.get('EmptyFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount()
            self.empty_file_day_growth_count = temp_model.from_map(m['EmptyFileDayGrowthCount'])
        if m.get('EmptyFileRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio()
            self.empty_file_ratio = temp_model.from_map(m['EmptyFileRatio'])
        if m.get('FreezeDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize()
            self.freeze_data_day_growth_size = temp_model.from_map(m['FreezeDataDayGrowthSize'])
        if m.get('FreezeDataRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio()
            self.freeze_data_ratio = temp_model.from_map(m['FreezeDataRatio'])
        if m.get('FreezeDataSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize()
            self.freeze_data_size = temp_model.from_map(m['FreezeDataSize'])
        if m.get('FreezeDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio()
            self.freeze_data_size_day_growth_ratio = temp_model.from_map(m['FreezeDataSizeDayGrowthRatio'])
        if m.get('HotDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize()
            self.hot_data_day_growth_size = temp_model.from_map(m['HotDataDayGrowthSize'])
        if m.get('HotDataRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio()
            self.hot_data_ratio = temp_model.from_map(m['HotDataRatio'])
        if m.get('HotDataSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize()
            self.hot_data_size = temp_model.from_map(m['HotDataSize'])
        if m.get('HotDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio()
            self.hot_data_size_day_growth_ratio = temp_model.from_map(m['HotDataSizeDayGrowthRatio'])
        if m.get('LargeFileCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount()
            self.large_file_count = temp_model.from_map(m['LargeFileCount'])
        if m.get('LargeFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio()
            self.large_file_count_day_growth_ratio = temp_model.from_map(m['LargeFileCountDayGrowthRatio'])
        if m.get('LargeFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount()
            self.large_file_day_growth_count = temp_model.from_map(m['LargeFileDayGrowthCount'])
        if m.get('LargeFileRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio()
            self.large_file_ratio = temp_model.from_map(m['LargeFileRatio'])
        if m.get('MediumFileCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount()
            self.medium_file_count = temp_model.from_map(m['MediumFileCount'])
        if m.get('MediumFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio()
            self.medium_file_count_day_growth_ratio = temp_model.from_map(m['MediumFileCountDayGrowthRatio'])
        if m.get('MediumFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount()
            self.medium_file_day_growth_count = temp_model.from_map(m['MediumFileDayGrowthCount'])
        if m.get('MediumFileRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio()
            self.medium_file_ratio = temp_model.from_map(m['MediumFileRatio'])
        if m.get('PartitionNum') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum()
            self.partition_num = temp_model.from_map(m['PartitionNum'])
        if m.get('SmallFileCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount()
            self.small_file_count = temp_model.from_map(m['SmallFileCount'])
        if m.get('SmallFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio()
            self.small_file_count_day_growth_ratio = temp_model.from_map(m['SmallFileCountDayGrowthRatio'])
        if m.get('SmallFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount()
            self.small_file_day_growth_count = temp_model.from_map(m['SmallFileDayGrowthCount'])
        if m.get('SmallFileRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio()
            self.small_file_ratio = temp_model.from_map(m['SmallFileRatio'])
        if m.get('TinyFileCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount()
            self.tiny_file_count = temp_model.from_map(m['TinyFileCount'])
        if m.get('TinyFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio()
            self.tiny_file_count_day_growth_ratio = temp_model.from_map(m['TinyFileCountDayGrowthRatio'])
        if m.get('TinyFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount()
            self.tiny_file_day_growth_count = temp_model.from_map(m['TinyFileDayGrowthCount'])
        if m.get('TinyFileRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio()
            self.tiny_file_ratio = temp_model.from_map(m['TinyFileRatio'])
        if m.get('TotalDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize()
            self.total_data_day_growth_size = temp_model.from_map(m['TotalDataDayGrowthSize'])
        if m.get('TotalDataSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize()
            self.total_data_size = temp_model.from_map(m['TotalDataSize'])
        if m.get('TotalDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio()
            self.total_data_size_day_growth_ratio = temp_model.from_map(m['TotalDataSizeDayGrowthRatio'])
        if m.get('TotalFileCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount()
            self.total_file_count = temp_model.from_map(m['TotalFileCount'])
        if m.get('TotalFileCountDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio()
            self.total_file_count_day_growth_ratio = temp_model.from_map(m['TotalFileCountDayGrowthRatio'])
        if m.get('TotalFileDayGrowthCount') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount()
            self.total_file_day_growth_count = temp_model.from_map(m['TotalFileDayGrowthCount'])
        if m.get('WarmDataDayGrowthSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize()
            self.warm_data_day_growth_size = temp_model.from_map(m['WarmDataDayGrowthSize'])
        if m.get('WarmDataRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio()
            self.warm_data_ratio = temp_model.from_map(m['WarmDataRatio'])
        if m.get('WarmDataSize') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize()
            self.warm_data_size = temp_model.from_map(m['WarmDataSize'])
        if m.get('WarmDataSizeDayGrowthRatio') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio()
            self.warm_data_size_day_growth_ratio = temp_model.from_map(m['WarmDataSizeDayGrowthRatio'])
        return self


class ListDoctorHiveTablesResponseBodyData(TeaModel):
    def __init__(
        self,
        analysis: ListDoctorHiveTablesResponseBodyDataAnalysis = None,
        formats: List[ListDoctorHiveTablesResponseBodyDataFormats] = None,
        metrics: ListDoctorHiveTablesResponseBodyDataMetrics = None,
        owner: str = None,
        table_name: str = None,
    ):
        # The analysis results.
        self.analysis = analysis
        # The table format information.
        self.formats = formats
        # The metric information.
        self.metrics = metrics
        # The owner.
        self.owner = owner
        # The table name. The table name must follow the naming rule in Hive. A name in the {Database name.Table name} format uniquely identifies a table.
        self.table_name = table_name

    def validate(self):
        if self.analysis:
            self.analysis.validate()
        if self.formats:
            for k in self.formats:
                if k:
                    k.validate()
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        result['Formats'] = []
        if self.formats is not None:
            for k in self.formats:
                result['Formats'].append(k.to_map() if k else None)
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Analysis') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        self.formats = []
        if m.get('Formats') is not None:
            for k in m.get('Formats'):
                temp_model = ListDoctorHiveTablesResponseBodyDataFormats()
                self.formats.append(temp_model.from_map(k))
        if m.get('Metrics') is not None:
            temp_model = ListDoctorHiveTablesResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListDoctorHiveTablesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorHiveTablesResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The analysis results of Hive tables.
        self.data = data
        # The maximum number of entries that are returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorHiveTablesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorHiveTablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorHiveTablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorHiveTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorJobsRequestEndRange(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
    ):
        # The end of the time range during which jobs ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.end_time = end_time
        # The beginning of the time range during which jobs ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDoctorJobsRequestStartRange(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
    ):
        # The end of the time range during which jobs were submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.end_time = end_time
        # The beginning of the time range during which jobs were submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDoctorJobsRequest(TeaModel):
    def __init__(
        self,
        app_ids: List[str] = None,
        cluster_id: str = None,
        end_range: ListDoctorJobsRequestEndRange = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        queues: List[str] = None,
        region_id: str = None,
        start_range: ListDoctorJobsRequestStartRange = None,
        types: List[str] = None,
        users: List[str] = None,
    ):
        # The IDs of the jobs that are submitted to YARN.
        self.app_ids = app_ids
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The range of end time. You can filter jobs whose end time falls within the specified time range.
        self.end_range = end_range
        # The maximum number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The field that you use to sort the query results. Valid values:
        # 
        # *   vcoreSeconds: the aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running
        # *   memSeconds: the aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid values:
        # 
        # *   ASC: the ascending order
        # *   DESC: the descending order
        self.order_type = order_type
        # The YARN queues to which the jobs are submitted.
        self.queues = queues
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The range of start time. You can filter jobs whose start time falls within the specified time range.
        self.start_range = start_range
        # The YARN engines to which the jobs are submitted.
        self.types = types
        # The users who submit the jobs.
        self.users = users

    def validate(self):
        if self.end_range:
            self.end_range.validate()
        if self.start_range:
            self.start_range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.end_range is not None:
            result['EndRange'] = self.end_range.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.queues is not None:
            result['Queues'] = self.queues
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_range is not None:
            result['StartRange'] = self.start_range.to_map()
        if self.types is not None:
            result['Types'] = self.types
        if self.users is not None:
            result['Users'] = self.users
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('EndRange') is not None:
            temp_model = ListDoctorJobsRequestEndRange()
            self.end_range = temp_model.from_map(m['EndRange'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('Queues') is not None:
            self.queues = m.get('Queues')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartRange') is not None:
            temp_model = ListDoctorJobsRequestStartRange()
            self.start_range = temp_model.from_map(m['StartRange'])
        if m.get('Types') is not None:
            self.types = m.get('Types')
        if m.get('Users') is not None:
            self.users = m.get('Users')
        return self


class ListDoctorJobsResponseBodyDataMetricsMemSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorJobsResponseBodyDataMetricsVcoreSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorJobsResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        mem_seconds: ListDoctorJobsResponseBodyDataMetricsMemSeconds = None,
        vcore_seconds: ListDoctorJobsResponseBodyDataMetricsVcoreSeconds = None,
    ):
        # The amount of memory consumed.
        self.mem_seconds = mem_seconds
        # The CPU usage.
        self.vcore_seconds = vcore_seconds

    def validate(self):
        if self.mem_seconds:
            self.mem_seconds.validate()
        if self.vcore_seconds:
            self.vcore_seconds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mem_seconds is not None:
            result['MemSeconds'] = self.mem_seconds.to_map()
        if self.vcore_seconds is not None:
            result['VcoreSeconds'] = self.vcore_seconds.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemSeconds') is not None:
            temp_model = ListDoctorJobsResponseBodyDataMetricsMemSeconds()
            self.mem_seconds = temp_model.from_map(m['MemSeconds'])
        if m.get('VcoreSeconds') is not None:
            temp_model = ListDoctorJobsResponseBodyDataMetricsVcoreSeconds()
            self.vcore_seconds = temp_model.from_map(m['VcoreSeconds'])
        return self


class ListDoctorJobsResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        elapsed_time: int = None,
        final_status: str = None,
        finish_time: int = None,
        launch_time: int = None,
        metrics: ListDoctorJobsResponseBodyDataMetrics = None,
        queue: str = None,
        start_time: int = None,
        state: str = None,
        type: str = None,
        user: str = None,
    ):
        # The ID of the job that was submitted to YARN.
        self.app_id = app_id
        # The name of the job.
        self.app_name = app_name
        # The total running time of the job. Unit: milliseconds.
        self.elapsed_time = elapsed_time
        # The final state of the job. Valid values:
        # 
        # *   SUCCEEDED
        # *   FAILED
        # *   KILLED
        # *   ENDED
        # *   UNDEFINED
        self.final_status = final_status
        # The end time of the job. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.finish_time = finish_time
        # The time when the job was started. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.launch_time = launch_time
        # The data about the metrics.
        self.metrics = metrics
        # The YARN queue to which the job was submitted.
        self.queue = queue
        # The time when the job was submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.start_time = start_time
        # The running state of the job. Valid values:
        # 
        # *   FINISHED
        # *   FAILED
        # *   KILLED
        self.state = state
        # The type of the compute engine.
        self.type = type
        # The username that was used to submit the job.
        self.user = user

    def validate(self):
        if self.metrics:
            self.metrics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.final_status is not None:
            result['FinalStatus'] = self.final_status
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.launch_time is not None:
            result['LaunchTime'] = self.launch_time
        if self.metrics is not None:
            result['Metrics'] = self.metrics.to_map()
        if self.queue is not None:
            result['Queue'] = self.queue
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.type is not None:
            result['Type'] = self.type
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('FinalStatus') is not None:
            self.final_status = m.get('FinalStatus')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('LaunchTime') is not None:
            self.launch_time = m.get('LaunchTime')
        if m.get('Metrics') is not None:
            temp_model = ListDoctorJobsResponseBodyDataMetrics()
            self.metrics = temp_model.from_map(m['Metrics'])
        if m.get('Queue') is not None:
            self.queue = m.get('Queue')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class ListDoctorJobsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorJobsResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The information about the jobs.
        self.data = data
        # The maximum number of entries returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorJobsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorJobsStatsRequestEndRange(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
    ):
        # The end of the time range during which jobs ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.end_time = end_time
        # The beginning of the time range during which jobs ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDoctorJobsStatsRequestStartRange(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        start_time: int = None,
    ):
        # The end of the time range during which jobs were submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.end_time = end_time
        # The beginning of the time range during which jobs were submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDoctorJobsStatsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        end_range: ListDoctorJobsStatsRequestEndRange = None,
        group_by: List[str] = None,
        max_results: int = None,
        next_token: str = None,
        order_by: str = None,
        order_type: str = None,
        region_id: str = None,
        start_range: ListDoctorJobsStatsRequestStartRange = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The range of end time. You can filter jobs whose end time falls within the specified time range.
        self.end_range = end_range
        # The fields that are used for grouping data.
        # 
        # Currently, only the first value is used for grouping data. Combinations of multiple values will be supported in the future.
        self.group_by = group_by
        # The maximum number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The field that you use to sort the query results. Valid values:
        # 
        # *   vcoreSeconds: the aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running
        # *   memSeconds: the aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running
        self.order_by = order_by
        # The order in which you want to sort the query results. Valid values:
        # 
        # *   ASC: in ascending order
        # *   DESC: in descending order
        self.order_type = order_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The range of start time. You can filter jobs whose start time falls within the specified time range.
        self.start_range = start_range

    def validate(self):
        if self.end_range:
            self.end_range.validate()
        if self.start_range:
            self.start_range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.end_range is not None:
            result['EndRange'] = self.end_range.to_map()
        if self.group_by is not None:
            result['GroupBy'] = self.group_by
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_range is not None:
            result['StartRange'] = self.start_range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('EndRange') is not None:
            temp_model = ListDoctorJobsStatsRequestEndRange()
            self.end_range = temp_model.from_map(m['EndRange'])
        if m.get('GroupBy') is not None:
            self.group_by = m.get('GroupBy')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartRange') is not None:
            temp_model = ListDoctorJobsStatsRequestStartRange()
            self.start_range = temp_model.from_map(m['StartRange'])
        return self


class ListDoctorJobsStatsResponseBodyDataAppsCount(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorJobsStatsResponseBodyDataMemSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorJobsStatsResponseBodyDataVcoreSeconds(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        unit: str = None,
        value: int = None,
    ):
        # The description of the metric.
        self.description = description
        # The name of the metric.
        self.name = name
        # The unit of the metric.
        self.unit = unit
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDoctorJobsStatsResponseBodyData(TeaModel):
    def __init__(
        self,
        apps_count: ListDoctorJobsStatsResponseBodyDataAppsCount = None,
        mem_seconds: ListDoctorJobsStatsResponseBodyDataMemSeconds = None,
        queue: str = None,
        type: str = None,
        user: str = None,
        vcore_seconds: ListDoctorJobsStatsResponseBodyDataVcoreSeconds = None,
    ):
        # The total number of jobs.
        self.apps_count = apps_count
        # The aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running.
        self.mem_seconds = mem_seconds
        # The YARN queue to which the job was submitted.
        self.queue = queue
        # The type of the compute engine.
        self.type = type
        # The username that is used to submit the job.
        self.user = user
        # The aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running.
        self.vcore_seconds = vcore_seconds

    def validate(self):
        if self.apps_count:
            self.apps_count.validate()
        if self.mem_seconds:
            self.mem_seconds.validate()
        if self.vcore_seconds:
            self.vcore_seconds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apps_count is not None:
            result['AppsCount'] = self.apps_count.to_map()
        if self.mem_seconds is not None:
            result['MemSeconds'] = self.mem_seconds.to_map()
        if self.queue is not None:
            result['Queue'] = self.queue
        if self.type is not None:
            result['Type'] = self.type
        if self.user is not None:
            result['User'] = self.user
        if self.vcore_seconds is not None:
            result['VcoreSeconds'] = self.vcore_seconds.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppsCount') is not None:
            temp_model = ListDoctorJobsStatsResponseBodyDataAppsCount()
            self.apps_count = temp_model.from_map(m['AppsCount'])
        if m.get('MemSeconds') is not None:
            temp_model = ListDoctorJobsStatsResponseBodyDataMemSeconds()
            self.mem_seconds = temp_model.from_map(m['MemSeconds'])
        if m.get('Queue') is not None:
            self.queue = m.get('Queue')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('User') is not None:
            self.user = m.get('User')
        if m.get('VcoreSeconds') is not None:
            temp_model = ListDoctorJobsStatsResponseBodyDataVcoreSeconds()
            self.vcore_seconds = temp_model.from_map(m['VcoreSeconds'])
        return self


class ListDoctorJobsStatsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorJobsStatsResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The summary of job information.
        self.data = data
        # The maximum number of entries returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorJobsStatsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorJobsStatsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorJobsStatsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorJobsStatsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDoctorReportsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        max_results: int = None,
        next_token: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The number of entries to return on each page.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListDoctorReportsResponseBodyDataSummaryReport(TeaModel):
    def __init__(
        self,
        score: int = None,
        suggestion: str = None,
        summary: str = None,
    ):
        # The score.
        self.score = score
        # The optimization suggestion.
        self.suggestion = suggestion
        # The summary of the report.
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListDoctorReportsResponseBodyData(TeaModel):
    def __init__(
        self,
        component_types: List[str] = None,
        date_time: str = None,
        summary_report: ListDoctorReportsResponseBodyDataSummaryReport = None,
    ):
        # The component types.
        # 
        # Valid values:
        # 
        # *   compute
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   hive
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   hdfs
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   yarn
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   oss
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   hbase
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.component_types = component_types
        # The date on which the report was generated.
        self.date_time = date_time
        # The summary of the report.
        self.summary_report = summary_report

    def validate(self):
        if self.summary_report:
            self.summary_report.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_types is not None:
            result['ComponentTypes'] = self.component_types
        if self.date_time is not None:
            result['DateTime'] = self.date_time
        if self.summary_report is not None:
            result['SummaryReport'] = self.summary_report.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentTypes') is not None:
            self.component_types = m.get('ComponentTypes')
        if m.get('DateTime') is not None:
            self.date_time = m.get('DateTime')
        if m.get('SummaryReport') is not None:
            temp_model = ListDoctorReportsResponseBodyDataSummaryReport()
            self.summary_report = temp_model.from_map(m['SummaryReport'])
        return self


class ListDoctorReportsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListDoctorReportsResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The reports.
        self.data = data
        # The maximum number of entries returned.
        self.max_results = max_results
        # A pagination token.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDoctorReportsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDoctorReportsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDoctorReportsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDoctorReportsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstanceTypesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_type: str = None,
        deploy_mode: str = None,
        instance_type: str = None,
        is_modification: bool = None,
        node_group_id: str = None,
        node_group_type: str = None,
        payment_type: str = None,
        region_id: str = None,
        release_version: str = None,
        zone_id: str = None,
    ):
        # The ID of cluster.
        self.cluster_id = cluster_id
        # Cluster type.
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # Deployment mode.
        self.deploy_mode = deploy_mode
        # Instance Type
        self.instance_type = instance_type
        # Whether to change the configuration.
        self.is_modification = is_modification
        # Node group ID.
        self.node_group_id = node_group_id
        # Node group type.
        # 
        # This parameter is required.
        self.node_group_type = node_group_type
        # Payment type.
        # 
        # This parameter is required.
        self.payment_type = payment_type
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        # EMR distribution.
        self.release_version = release_version
        # Availability Zone ID
        # 
        # This parameter is required.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.is_modification is not None:
            result['IsModification'] = self.is_modification
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_group_type is not None:
            result['NodeGroupType'] = self.node_group_type
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_version is not None:
            result['ReleaseVersion'] = self.release_version
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IsModification') is not None:
            self.is_modification = m.get('IsModification')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeGroupType') is not None:
            self.node_group_type = m.get('NodeGroupType')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseVersion') is not None:
            self.release_version = m.get('ReleaseVersion')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListInstanceTypesResponseBody(TeaModel):
    def __init__(
        self,
        instance_types: List[InstanceType] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The instance types.
        self.instance_types = instance_types
        # The maximum number of records returned in this request.
        self.max_results = max_results
        # Returns the position of the read data.
        self.next_token = next_token
        # Request ID.
        self.request_id = request_id
        # The total amount of data under the conditions of this request.
        self.total_count = total_count

    def validate(self):
        if self.instance_types:
            for k in self.instance_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceTypes'] = []
        if self.instance_types is not None:
            for k in self.instance_types:
                result['InstanceTypes'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_types = []
        if m.get('InstanceTypes') is not None:
            for k in m.get('InstanceTypes'):
                temp_model = InstanceType()
                self.instance_types.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstanceTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstanceTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstanceTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNodeGroupsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        max_results: int = None,
        next_token: str = None,
        node_group_ids: List[str] = None,
        node_group_names: List[str] = None,
        node_group_states: List[str] = None,
        node_group_types: List[str] = None,
        region_id: str = None,
        zone_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The number of maximum number of records to obtain at a time. Valid values: 1 to 100.
        self.max_results = max_results
        # Marks the current position where reading starts. If you set this value to null, you can start from the beginning.
        self.next_token = next_token
        # The IDs of node groups. Valid values of the number of array elements N: 1 to 100.
        self.node_group_ids = node_group_ids
        # The list of node group names. Valid values of the number of array elements N: 1 to 100.
        self.node_group_names = node_group_names
        # The status of the node group. Valid values of the number of array elements N: 1 to 100.
        self.node_group_states = node_group_states
        # The list of node group types. Valid values of the number of array elements N: 1 to 100.
        self.node_group_types = node_group_types
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.node_group_ids is not None:
            result['NodeGroupIds'] = self.node_group_ids
        if self.node_group_names is not None:
            result['NodeGroupNames'] = self.node_group_names
        if self.node_group_states is not None:
            result['NodeGroupStates'] = self.node_group_states
        if self.node_group_types is not None:
            result['NodeGroupTypes'] = self.node_group_types
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('NodeGroupIds') is not None:
            self.node_group_ids = m.get('NodeGroupIds')
        if m.get('NodeGroupNames') is not None:
            self.node_group_names = m.get('NodeGroupNames')
        if m.get('NodeGroupStates') is not None:
            self.node_group_states = m.get('NodeGroupStates')
        if m.get('NodeGroupTypes') is not None:
            self.node_group_types = m.get('NodeGroupTypes')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListNodeGroupsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        node_groups: List[NodeGroup] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The maximum number of entries returned.
        self.max_results = max_results
        # Returns the location of the data that was read. Empty indicates that the data has been read.
        self.next_token = next_token
        # The array of node groups.
        self.node_groups = node_groups
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.node_groups:
            for k in self.node_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['NodeGroups'] = []
        if self.node_groups is not None:
            for k in self.node_groups:
                result['NodeGroups'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.node_groups = []
        if m.get('NodeGroups') is not None:
            for k in m.get('NodeGroups'):
                temp_model = NodeGroup()
                self.node_groups.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListNodeGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNodeGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNodeGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNodesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        max_results: int = None,
        next_token: str = None,
        node_group_ids: List[str] = None,
        node_ids: List[str] = None,
        node_names: List[str] = None,
        node_states: List[str] = None,
        private_ips: List[str] = None,
        public_ips: List[str] = None,
        region_id: str = None,
        tags: List[Tag] = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The number of maximum number of records to obtain at a time. Valid values: 1 to 100.
        self.max_results = max_results
        # Marks the current position where reading starts. If you set this value to null, you can start from the beginning.
        self.next_token = next_token
        # The IDs of node groups.
        self.node_group_ids = node_group_ids
        # An array that consists of information about the ID of the node.
        self.node_ids = node_ids
        # The names of the nodes.
        self.node_names = node_names
        # The status of the node.
        self.node_states = node_states
        # The private IP address.
        self.private_ips = private_ips
        # The public IP address.
        self.public_ips = public_ips
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.node_group_ids is not None:
            result['NodeGroupIds'] = self.node_group_ids
        if self.node_ids is not None:
            result['NodeIds'] = self.node_ids
        if self.node_names is not None:
            result['NodeNames'] = self.node_names
        if self.node_states is not None:
            result['NodeStates'] = self.node_states
        if self.private_ips is not None:
            result['PrivateIps'] = self.private_ips
        if self.public_ips is not None:
            result['PublicIps'] = self.public_ips
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('NodeGroupIds') is not None:
            self.node_group_ids = m.get('NodeGroupIds')
        if m.get('NodeIds') is not None:
            self.node_ids = m.get('NodeIds')
        if m.get('NodeNames') is not None:
            self.node_names = m.get('NodeNames')
        if m.get('NodeStates') is not None:
            self.node_states = m.get('NodeStates')
        if m.get('PrivateIps') is not None:
            self.private_ips = m.get('PrivateIps')
        if m.get('PublicIps') is not None:
            self.public_ips = m.get('PublicIps')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class ListNodesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        nodes: List[Node] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The maximum number of entries returned.
        self.max_results = max_results
        # The position at which the next read starts. If null is returned, the data has been read.
        self.next_token = next_token
        # The node list.
        self.nodes = nodes
        # The ID of the request.
        self.request_id = request_id
        # The total number of records in this request.
        self.total_count = total_count

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = Node()
                self.nodes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListReleaseVersionsRequest(TeaModel):
    def __init__(
        self,
        cluster_type: str = None,
        iaas_type: str = None,
        region_id: str = None,
    ):
        # The type of the cluster.
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # The type of the IaaS resource.
        self.iaas_type = iaas_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.iaas_type is not None:
            result['IaasType'] = self.iaas_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('IaasType') is not None:
            self.iaas_type = m.get('IaasType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListReleaseVersionsResponseBodyReleaseVersions(TeaModel):
    def __init__(
        self,
        iaas_type: str = None,
        release_version: str = None,
        series: str = None,
    ):
        # The IaaS type.
        self.iaas_type = iaas_type
        # The EMR version.
        self.release_version = release_version
        # The version series.
        self.series = series

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iaas_type is not None:
            result['IaasType'] = self.iaas_type
        if self.release_version is not None:
            result['ReleaseVersion'] = self.release_version
        if self.series is not None:
            result['Series'] = self.series
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IaasType') is not None:
            self.iaas_type = m.get('IaasType')
        if m.get('ReleaseVersion') is not None:
            self.release_version = m.get('ReleaseVersion')
        if m.get('Series') is not None:
            self.series = m.get('Series')
        return self


class ListReleaseVersionsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        release_versions: List[ListReleaseVersionsResponseBodyReleaseVersions] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The maximum number of entries returned.
        self.max_results = max_results
        # Returns the location of the data that was read.
        self.next_token = next_token
        # The major EMR versions.
        self.release_versions = release_versions
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.release_versions:
            for k in self.release_versions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['ReleaseVersions'] = []
        if self.release_versions is not None:
            for k in self.release_versions:
                result['ReleaseVersions'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.release_versions = []
        if m.get('ReleaseVersions') is not None:
            for k in m.get('ReleaseVersions'):
                temp_model = ListReleaseVersionsResponseBodyReleaseVersions()
                self.release_versions.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListReleaseVersionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListReleaseVersionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListReleaseVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListScriptsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        max_results: int = None,
        next_token: str = None,
        region_id: str = None,
        script_id: str = None,
        script_name: str = None,
        script_type: str = None,
        statuses: List[str] = None,
    ):
        # Cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The maximum number of records to retrieve at once.
        self.max_results = max_results
        # Marks the current position to start reading from.
        self.next_token = next_token
        # Region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The script ID. Only common scripts are supported.
        self.script_id = script_id
        # The name of the script. Only common scripts are supported. Fuzzy search is supported.
        self.script_name = script_name
        # Type of cluster script. Possible values:
        # 
        # - BOOTSTRAP: Bootstrap script.
        # - NORMAL: Regular cluster script.
        # 
        # This parameter is required.
        self.script_type = script_type
        # The script status list.
        self.statuses = statuses

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.script_id is not None:
            result['ScriptId'] = self.script_id
        if self.script_name is not None:
            result['ScriptName'] = self.script_name
        if self.script_type is not None:
            result['ScriptType'] = self.script_type
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScriptId') is not None:
            self.script_id = m.get('ScriptId')
        if m.get('ScriptName') is not None:
            self.script_name = m.get('ScriptName')
        if m.get('ScriptType') is not None:
            self.script_type = m.get('ScriptType')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        return self


class ListScriptsResponseBodyScripts(TeaModel):
    def __init__(
        self,
        action: str = None,
        end_time: int = None,
        execution_fail_strategy: str = None,
        execution_moment: str = None,
        execution_state: str = None,
        last_update_time: int = None,
        node_selector: NodeSelector = None,
        region_id: str = None,
        script_args: str = None,
        script_id: str = None,
        script_name: str = None,
        script_path: str = None,
        start_time: int = None,
    ):
        # API name.
        self.action = action
        # End execution time. This value is returned only when `ScriptType` is `NORMAL`.
        self.end_time = end_time
        # Execution failure strategy. Possible values:
        # 
        # - FAILED_CONTINUE: Continue after failure.
        # - FAILED_BLOCK: Block after failure.
        self.execution_fail_strategy = execution_fail_strategy
        # Execution timing. Possible values:
        # 
        # - BEFORE_INSTALL: Before application installation.
        # - AFTER_STARTED: After application startup.
        self.execution_moment = execution_moment
        # Script execution state. This value is returned only when `ScriptType` is `NORMAL`. Possible values:
        # 
        # - SCRIPT_COMPLETED: Script executed successfully.
        # - SCRIPT_SUBMISSION_FAILED: Script execution failed.
        # - SCRIPT_RUNNING: Script is running.
        self.execution_state = execution_state
        # Time of the last update.
        self.last_update_time = last_update_time
        # The node selector.
        self.node_selector = node_selector
        # Region ID.
        self.region_id = region_id
        # Script execution parameters.
        self.script_args = script_args
        # Script ID.
        self.script_id = script_id
        # Script name.
        self.script_name = script_name
        # Script path.
        self.script_path = script_path
        # Start execution time. This value is returned only when `ScriptType` is `NORMAL`.
        self.start_time = start_time

    def validate(self):
        if self.node_selector:
            self.node_selector.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.execution_fail_strategy is not None:
            result['ExecutionFailStrategy'] = self.execution_fail_strategy
        if self.execution_moment is not None:
            result['ExecutionMoment'] = self.execution_moment
        if self.execution_state is not None:
            result['ExecutionState'] = self.execution_state
        if self.last_update_time is not None:
            result['LastUpdateTime'] = self.last_update_time
        if self.node_selector is not None:
            result['NodeSelector'] = self.node_selector.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.script_args is not None:
            result['ScriptArgs'] = self.script_args
        if self.script_id is not None:
            result['ScriptId'] = self.script_id
        if self.script_name is not None:
            result['ScriptName'] = self.script_name
        if self.script_path is not None:
            result['ScriptPath'] = self.script_path
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecutionFailStrategy') is not None:
            self.execution_fail_strategy = m.get('ExecutionFailStrategy')
        if m.get('ExecutionMoment') is not None:
            self.execution_moment = m.get('ExecutionMoment')
        if m.get('ExecutionState') is not None:
            self.execution_state = m.get('ExecutionState')
        if m.get('LastUpdateTime') is not None:
            self.last_update_time = m.get('LastUpdateTime')
        if m.get('NodeSelector') is not None:
            temp_model = NodeSelector()
            self.node_selector = temp_model.from_map(m['NodeSelector'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScriptArgs') is not None:
            self.script_args = m.get('ScriptArgs')
        if m.get('ScriptId') is not None:
            self.script_id = m.get('ScriptId')
        if m.get('ScriptName') is not None:
            self.script_name = m.get('ScriptName')
        if m.get('ScriptPath') is not None:
            self.script_path = m.get('ScriptPath')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListScriptsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        scripts: List[ListScriptsResponseBodyScripts] = None,
        total_count: int = None,
    ):
        # The maximum number of records returned in this request.
        self.max_results = max_results
        # The position of the data read.
        self.next_token = next_token
        # Request ID.
        self.request_id = request_id
        # The scripts.
        self.scripts = scripts
        # The total amount of data under the conditions of this request.
        self.total_count = total_count

    def validate(self):
        if self.scripts:
            for k in self.scripts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Scripts'] = []
        if self.scripts is not None:
            for k in self.scripts:
                result['Scripts'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.scripts = []
        if m.get('Scripts') is not None:
            for k in m.get('Scripts'):
                temp_model = ListScriptsResponseBodyScripts()
                self.scripts.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListScriptsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListScriptsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListScriptsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTagResourcesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        region_id: str = None,
        resource_ids: List[str] = None,
        resource_type: str = None,
        tags: List[Tag] = None,
    ):
        # The number of maximum number of records to obtain at a time.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results. If NextToken is empty, the query starts from the beginning.
        self.next_token = next_token
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The list of resource IDs. Number of array elements N Valid values: 1 to 1
        # 
        # This parameter is required.
        self.resource_ids = resource_ids
        # The type of the resource. Set the value to cluster.
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # An array of tags. The number of elements in the array. Valid values: 1 to 20.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBodyTagResources(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # Indicates the ID of a resource.
        self.resource_id = resource_id
        # The resource type.
        self.resource_type = resource_type
        # The tag key of the ENI.
        self.tag_key = tag_key
        # The tag value of the ENI.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListTagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        tag_resources: List[ListTagResourcesResponseBodyTagResources] = None,
        total_count: int = None,
    ):
        # The maximum number of entries returned.
        self.max_results = max_results
        # Returns the location of the data that was read. Empty indicates that the data has been read.
        self.next_token = next_token
        # The ID of the request.
        self.request_id = request_id
        # The details about the tag. Contains the resource ID, resource type, and tag key-value information.
        self.tag_resources = tag_resources
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.tag_resources:
            for k in self.tag_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TagResources'] = []
        if self.tag_resources is not None:
            for k in self.tag_resources:
                result['TagResources'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tag_resources = []
        if m.get('TagResources') is not None:
            for k in m.get('TagResources'):
                temp_model = ListTagResourcesResponseBodyTagResources()
                self.tag_resources.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUsersRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        max_results: int = None,
        next_token: str = None,
        region_id: str = None,
        user_name: str = None,
        user_names: List[str] = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The maximum number of entries to return.
        self.max_results = max_results
        # The pagination token that is used in the request to retrieve a new page of results.
        self.next_token = next_token
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The username. Fuzzy match is supported.
        self.user_name = user_name
        # The usernames. Number of elements in the array: 0 to 20.
        self.user_names = user_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_names is not None:
            result['UserNames'] = self.user_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserNames') is not None:
            self.user_names = m.get('UserNames')
        return self


class ListUsersResponseBodyUsers(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        description: str = None,
        keytab_hex: str = None,
        ldap_url: str = None,
        user_id: str = None,
        user_name: str = None,
    ):
        # The creation time.
        self.create_time = create_time
        # The remarks.
        self.description = description
        # The Base64-encoded content of the keytab file.
        self.keytab_hex = keytab_hex
        # The Lightweight Directory Access Protocol (LDAP) link.
        self.ldap_url = ldap_url
        # The user ID.
        self.user_id = user_id
        # The username.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.keytab_hex is not None:
            result['KeytabHex'] = self.keytab_hex
        if self.ldap_url is not None:
            result['LdapUrl'] = self.ldap_url
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('KeytabHex') is not None:
            self.keytab_hex = m.get('KeytabHex')
        if m.get('LdapUrl') is not None:
            self.ldap_url = m.get('LdapUrl')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListUsersResponseBody(TeaModel):
    def __init__(
        self,
        is_admin: bool = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
        users: List[ListUsersResponseBodyUsers] = None,
    ):
        # Indicates whether the user is an admin user. Valid values:
        # 
        # *   true
        # *   false
        self.is_admin = is_admin
        # The maximum number of entries returned.
        self.max_results = max_results
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_token = next_token
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count
        # The users.
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_admin is not None:
            result['IsAdmin'] = self.is_admin
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsAdmin') is not None:
            self.is_admin = m.get('IsAdmin')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = ListUsersResponseBodyUsers()
                self.users.append(temp_model.from_map(k))
        return self


class ListUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutAutoScalingPolicyRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        constraints: ScalingConstraints = None,
        node_group_id: str = None,
        region_id: str = None,
        scaling_rules: List[ScalingRule] = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The constraints on the maximum and minimum numbers of nodes in a node group.
        self.constraints = constraints
        # The ID of the node group.
        # 
        # This parameter is required.
        self.node_group_id = node_group_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The description list of auto scaling rules. Number of elements in the array: 0 to 100.
        self.scaling_rules = scaling_rules

    def validate(self):
        if self.constraints:
            self.constraints.validate()
        if self.scaling_rules:
            for k in self.scaling_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.constraints is not None:
            result['Constraints'] = self.constraints.to_map()
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['ScalingRules'] = []
        if self.scaling_rules is not None:
            for k in self.scaling_rules:
                result['ScalingRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Constraints') is not None:
            temp_model = ScalingConstraints()
            self.constraints = temp_model.from_map(m['Constraints'])
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.scaling_rules = []
        if m.get('ScalingRules') is not None:
            for k in m.get('ScalingRules'):
                temp_model = ScalingRule()
                self.scaling_rules.append(temp_model.from_map(k))
        return self


class PutAutoScalingPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PutAutoScalingPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PutAutoScalingPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutAutoScalingPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutManagedScalingPolicyRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        constraints: ManagedScalingConstraints = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The constrains on the maximum and minimum numbers of nodes in a node group.
        self.constraints = constraints
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        if self.constraints:
            self.constraints.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.constraints is not None:
            result['Constraints'] = self.constraints.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Constraints') is not None:
            temp_model = ManagedScalingConstraints()
            self.constraints = temp_model.from_map(m['Constraints'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class PutManagedScalingPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PutManagedScalingPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PutManagedScalingPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutManagedScalingPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveAutoScalingPolicyRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        node_group_id: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the node group.
        # 
        # This parameter is required.
        self.node_group_id = node_group_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RemoveAutoScalingPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveAutoScalingPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveAutoScalingPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveAutoScalingPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunApiTemplateRequest(TeaModel):
    def __init__(
        self,
        api_name: str = None,
        client_token: str = None,
        region_id: str = None,
        template_id: str = None,
    ):
        # 接口名。
        # 
        # This parameter is required.
        self.api_name = api_name
        # 幂等客户端TOKEN。
        self.client_token = client_token
        # 地域ID。
        # 
        # This parameter is required.
        self.region_id = region_id
        # 集群模板id。
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_name is not None:
            result['ApiName'] = self.api_name
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiName') is not None:
            self.api_name = m.get('ApiName')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class RunApiTemplateResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        self.data = data
        # 请求ID。
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunApiTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunApiTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunApiTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunApplicationActionRequest(TeaModel):
    def __init__(
        self,
        action_name: str = None,
        batch_size: int = None,
        cluster_id: str = None,
        component_instance_selector: ComponentInstanceSelector = None,
        description: str = None,
        execute_strategy: str = None,
        interval: int = None,
        region_id: str = None,
        rolling_execute: bool = None,
    ):
        # The name of the action. Valid values:
        # 
        # *   start
        # *   stop
        # *   config
        # *   restart
        # *   refresh_queues
        # *   refresh_labels
        # 
        # This parameter is required.
        self.action_name = action_name
        # The number of applications in each batch.
        self.batch_size = batch_size
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The operation object.
        # 
        # This parameter is required.
        self.component_instance_selector = component_instance_selector
        # The description of the execution.
        self.description = description
        # The execution policy. Valid values:
        # 
        # *   FAILED_BLOCK: The system stops the execution if the execution fails.
        # *   FAILED_CONTINUE: The system continues the execution if the execution fails.
        self.execute_strategy = execute_strategy
        # The interval for rolling execution. Unit: seconds.
        self.interval = interval
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Specifies whether to enable rolling execution.
        self.rolling_execute = rolling_execute

    def validate(self):
        if self.component_instance_selector:
            self.component_instance_selector.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_name is not None:
            result['ActionName'] = self.action_name
        if self.batch_size is not None:
            result['BatchSize'] = self.batch_size
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.component_instance_selector is not None:
            result['ComponentInstanceSelector'] = self.component_instance_selector.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.execute_strategy is not None:
            result['ExecuteStrategy'] = self.execute_strategy
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rolling_execute is not None:
            result['RollingExecute'] = self.rolling_execute
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionName') is not None:
            self.action_name = m.get('ActionName')
        if m.get('BatchSize') is not None:
            self.batch_size = m.get('BatchSize')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ComponentInstanceSelector') is not None:
            temp_model = ComponentInstanceSelector()
            self.component_instance_selector = temp_model.from_map(m['ComponentInstanceSelector'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExecuteStrategy') is not None:
            self.execute_strategy = m.get('ExecuteStrategy')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RollingExecute') is not None:
            self.rolling_execute = m.get('RollingExecute')
        return self


class RunApplicationActionResponseBodyAbnInstances(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        node_name: str = None,
    ):
        # The ID of the abnormal node.
        self.node_id = node_id
        # The name of the abnormal node.
        self.node_name = node_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        return self


class RunApplicationActionResponseBody(TeaModel):
    def __init__(
        self,
        abn_instances: List[RunApplicationActionResponseBodyAbnInstances] = None,
        operation_id: str = None,
        request_id: str = None,
    ):
        # The abnormal nodes.
        self.abn_instances = abn_instances
        # The operation ID.
        self.operation_id = operation_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.abn_instances:
            for k in self.abn_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AbnInstances'] = []
        if self.abn_instances is not None:
            for k in self.abn_instances:
                result['AbnInstances'].append(k.to_map() if k else None)
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.abn_instances = []
        if m.get('AbnInstances') is not None:
            for k in m.get('AbnInstances'):
                temp_model = RunApplicationActionResponseBodyAbnInstances()
                self.abn_instances.append(temp_model.from_map(k))
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunApplicationActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunApplicationActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunApplicationActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunClusterRequest(TeaModel):
    def __init__(
        self,
        application_configs: List[ApplicationConfig] = None,
        applications: List[Application] = None,
        bootstrap_scripts: List[Script] = None,
        client_token: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        deletion_protection: bool = None,
        deploy_mode: str = None,
        description: str = None,
        node_attributes: NodeAttributes = None,
        node_groups: List[NodeGroupConfig] = None,
        payment_type: str = None,
        promotions: List[Promotion] = None,
        region_id: str = None,
        release_version: str = None,
        resource_group_id: str = None,
        security_mode: str = None,
        subscription_config: SubscriptionConfig = None,
        tags: List[Tag] = None,
    ):
        # The application configurations. Number of elements in the array: 1 to 1000.
        self.application_configs = application_configs
        # The list of services. Number of elements in the array: 1 to 100.
        # 
        # This parameter is required.
        self.applications = applications
        # The array of bootstrap scripts. Number of elements in the array: 1 to 10.
        self.bootstrap_scripts = bootstrap_scripts
        # The client token that is used to ensure the idempotence of the request. The same ClientToken value for multiple calls to the RunCluster operation results in identical responses. Only one cluster can be created by using the same ClientToken value.
        self.client_token = client_token
        # The cluster name. The name must be 1 to 128 characters in length. The name must start with a letter but cannot start with http:// or https://. The name can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).
        # 
        # This parameter is required.
        self.cluster_name = cluster_name
        # The type of the cluster. Valid values:
        # 
        # *   DATALAKE
        # *   OLAP
        # *   DATAFLOW
        # *   DATASERVING
        # *   CUSTOM
        # *   HADOOP: We recommend that you set this parameter to DATALAKE rather than HADOOP.
        # 
        # If the first time you create an EMR cluster is after 17:00 (UTC+8) on December 19, 2022, you cannot create a Hadoop, Data Science, Presto, or ZooKeeper cluster.
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # Specifies whether to enable release protection for the cluster. Valid values:
        # 
        # *   true: enables release protection for the cluster.
        # *   false: disables release protection for the cluster.
        # 
        # Default value: false.
        self.deletion_protection = deletion_protection
        # The deployment mode of master nodes in the cluster. Valid values:
        # 
        # *   NORMAL: regular mode. This is the default value. A cluster that contains only one master node is created.
        # *   HA: high availability mode. A cluster that contains at least three master nodes is created.
        self.deploy_mode = deploy_mode
        # The cluster description.
        self.description = description
        # The node attributes. The basic attributes of all ECS nodes in the cluster.
        self.node_attributes = node_attributes
        # The array of configurations of the node groups. Number of elements in the array: 1 to 100.
        # 
        # This parameter is required.
        self.node_groups = node_groups
        # The billing method of the cluster. Valid values:
        # 
        # *   PayAsYouGo
        # *   Subscription
        # 
        # Default value: PayAsYouGo.
        self.payment_type = payment_type
        self.promotions = promotions
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The EMR version. You can query available EMR versions in the EMR console.
        # 
        # This parameter is required.
        self.release_version = release_version
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The security mode of the cluster. Valid values:
        # 
        # *   NORMAL: regular mode. Kerberos authentication is disabled. This is the default value.
        # *   KERBEROS: Kerberos mode. Kerberos authentication is enabled.
        self.security_mode = security_mode
        # The subscription configurations. This parameter is required when the PaymentType parameter is set to Subscription.
        self.subscription_config = subscription_config
        # The tag. Number of elements in the array: 0 to 20.
        self.tags = tags

    def validate(self):
        if self.application_configs:
            for k in self.application_configs:
                if k:
                    k.validate()
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()
        if self.bootstrap_scripts:
            for k in self.bootstrap_scripts:
                if k:
                    k.validate()
        if self.node_attributes:
            self.node_attributes.validate()
        if self.node_groups:
            for k in self.node_groups:
                if k:
                    k.validate()
        if self.promotions:
            for k in self.promotions:
                if k:
                    k.validate()
        if self.subscription_config:
            self.subscription_config.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationConfigs'] = []
        if self.application_configs is not None:
            for k in self.application_configs:
                result['ApplicationConfigs'].append(k.to_map() if k else None)
        result['Applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['Applications'].append(k.to_map() if k else None)
        result['BootstrapScripts'] = []
        if self.bootstrap_scripts is not None:
            for k in self.bootstrap_scripts:
                result['BootstrapScripts'].append(k.to_map() if k else None)
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.node_attributes is not None:
            result['NodeAttributes'] = self.node_attributes.to_map()
        result['NodeGroups'] = []
        if self.node_groups is not None:
            for k in self.node_groups:
                result['NodeGroups'].append(k.to_map() if k else None)
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        result['Promotions'] = []
        if self.promotions is not None:
            for k in self.promotions:
                result['Promotions'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_version is not None:
            result['ReleaseVersion'] = self.release_version
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_mode is not None:
            result['SecurityMode'] = self.security_mode
        if self.subscription_config is not None:
            result['SubscriptionConfig'] = self.subscription_config.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_configs = []
        if m.get('ApplicationConfigs') is not None:
            for k in m.get('ApplicationConfigs'):
                temp_model = ApplicationConfig()
                self.application_configs.append(temp_model.from_map(k))
        self.applications = []
        if m.get('Applications') is not None:
            for k in m.get('Applications'):
                temp_model = Application()
                self.applications.append(temp_model.from_map(k))
        self.bootstrap_scripts = []
        if m.get('BootstrapScripts') is not None:
            for k in m.get('BootstrapScripts'):
                temp_model = Script()
                self.bootstrap_scripts.append(temp_model.from_map(k))
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NodeAttributes') is not None:
            temp_model = NodeAttributes()
            self.node_attributes = temp_model.from_map(m['NodeAttributes'])
        self.node_groups = []
        if m.get('NodeGroups') is not None:
            for k in m.get('NodeGroups'):
                temp_model = NodeGroupConfig()
                self.node_groups.append(temp_model.from_map(k))
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        self.promotions = []
        if m.get('Promotions') is not None:
            for k in m.get('Promotions'):
                temp_model = Promotion()
                self.promotions.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseVersion') is not None:
            self.release_version = m.get('ReleaseVersion')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityMode') is not None:
            self.security_mode = m.get('SecurityMode')
        if m.get('SubscriptionConfig') is not None:
            temp_model = SubscriptionConfig()
            self.subscription_config = temp_model.from_map(m['SubscriptionConfig'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class RunClusterShrinkRequest(TeaModel):
    def __init__(
        self,
        application_configs_shrink: str = None,
        applications_shrink: str = None,
        bootstrap_scripts_shrink: str = None,
        client_token: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        deletion_protection: bool = None,
        deploy_mode: str = None,
        description: str = None,
        node_attributes_shrink: str = None,
        node_groups_shrink: str = None,
        payment_type: str = None,
        promotions_shrink: str = None,
        region_id: str = None,
        release_version: str = None,
        resource_group_id: str = None,
        security_mode: str = None,
        subscription_config_shrink: str = None,
        tags_shrink: str = None,
    ):
        # The application configurations. Number of elements in the array: 1 to 1000.
        self.application_configs_shrink = application_configs_shrink
        # The list of services. Number of elements in the array: 1 to 100.
        # 
        # This parameter is required.
        self.applications_shrink = applications_shrink
        # The array of bootstrap scripts. Number of elements in the array: 1 to 10.
        self.bootstrap_scripts_shrink = bootstrap_scripts_shrink
        # The client token that is used to ensure the idempotence of the request. The same ClientToken value for multiple calls to the RunCluster operation results in identical responses. Only one cluster can be created by using the same ClientToken value.
        self.client_token = client_token
        # The cluster name. The name must be 1 to 128 characters in length. The name must start with a letter but cannot start with http:// or https://. The name can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).
        # 
        # This parameter is required.
        self.cluster_name = cluster_name
        # The type of the cluster. Valid values:
        # 
        # *   DATALAKE
        # *   OLAP
        # *   DATAFLOW
        # *   DATASERVING
        # *   CUSTOM
        # *   HADOOP: We recommend that you set this parameter to DATALAKE rather than HADOOP.
        # 
        # If the first time you create an EMR cluster is after 17:00 (UTC+8) on December 19, 2022, you cannot create a Hadoop, Data Science, Presto, or ZooKeeper cluster.
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # Specifies whether to enable release protection for the cluster. Valid values:
        # 
        # *   true: enables release protection for the cluster.
        # *   false: disables release protection for the cluster.
        # 
        # Default value: false.
        self.deletion_protection = deletion_protection
        # The deployment mode of master nodes in the cluster. Valid values:
        # 
        # *   NORMAL: regular mode. This is the default value. A cluster that contains only one master node is created.
        # *   HA: high availability mode. A cluster that contains at least three master nodes is created.
        self.deploy_mode = deploy_mode
        # The cluster description.
        self.description = description
        # The node attributes. The basic attributes of all ECS nodes in the cluster.
        self.node_attributes_shrink = node_attributes_shrink
        # The array of configurations of the node groups. Number of elements in the array: 1 to 100.
        # 
        # This parameter is required.
        self.node_groups_shrink = node_groups_shrink
        # The billing method of the cluster. Valid values:
        # 
        # *   PayAsYouGo
        # *   Subscription
        # 
        # Default value: PayAsYouGo.
        self.payment_type = payment_type
        self.promotions_shrink = promotions_shrink
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The EMR version. You can query available EMR versions in the EMR console.
        # 
        # This parameter is required.
        self.release_version = release_version
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The security mode of the cluster. Valid values:
        # 
        # *   NORMAL: regular mode. Kerberos authentication is disabled. This is the default value.
        # *   KERBEROS: Kerberos mode. Kerberos authentication is enabled.
        self.security_mode = security_mode
        # The subscription configurations. This parameter is required when the PaymentType parameter is set to Subscription.
        self.subscription_config_shrink = subscription_config_shrink
        # The tag. Number of elements in the array: 0 to 20.
        self.tags_shrink = tags_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_configs_shrink is not None:
            result['ApplicationConfigs'] = self.application_configs_shrink
        if self.applications_shrink is not None:
            result['Applications'] = self.applications_shrink
        if self.bootstrap_scripts_shrink is not None:
            result['BootstrapScripts'] = self.bootstrap_scripts_shrink
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.deploy_mode is not None:
            result['DeployMode'] = self.deploy_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.node_attributes_shrink is not None:
            result['NodeAttributes'] = self.node_attributes_shrink
        if self.node_groups_shrink is not None:
            result['NodeGroups'] = self.node_groups_shrink
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.promotions_shrink is not None:
            result['Promotions'] = self.promotions_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_version is not None:
            result['ReleaseVersion'] = self.release_version
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_mode is not None:
            result['SecurityMode'] = self.security_mode
        if self.subscription_config_shrink is not None:
            result['SubscriptionConfig'] = self.subscription_config_shrink
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationConfigs') is not None:
            self.application_configs_shrink = m.get('ApplicationConfigs')
        if m.get('Applications') is not None:
            self.applications_shrink = m.get('Applications')
        if m.get('BootstrapScripts') is not None:
            self.bootstrap_scripts_shrink = m.get('BootstrapScripts')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('DeployMode') is not None:
            self.deploy_mode = m.get('DeployMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NodeAttributes') is not None:
            self.node_attributes_shrink = m.get('NodeAttributes')
        if m.get('NodeGroups') is not None:
            self.node_groups_shrink = m.get('NodeGroups')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Promotions') is not None:
            self.promotions_shrink = m.get('Promotions')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseVersion') is not None:
            self.release_version = m.get('ReleaseVersion')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityMode') is not None:
            self.security_mode = m.get('SecurityMode')
        if m.get('SubscriptionConfig') is not None:
            self.subscription_config_shrink = m.get('SubscriptionConfig')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        return self


class RunClusterResponseBody(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        operation_id: str = None,
        request_id: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The operation ID.
        self.operation_id = operation_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_ids: List[str] = None,
        resource_type: str = None,
        tags: List[Tag] = None,
    ):
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The list of resource IDs. Valid values of N: 1 to 1.
        # 
        # This parameter is required.
        self.resource_ids = resource_ids
        # The type of the resource to which the tag belongs. Valid values:
        # 
        # *   cluster: cluster
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tags.
        # 
        # This parameter is required.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = Tag()
                self.tags.append(temp_model.from_map(k))
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(
        self,
        all: bool = None,
        region_id: str = None,
        resource_ids: List[str] = None,
        resource_type: str = None,
        tag_keys: List[str] = None,
    ):
        # Specifies whether to remove all tags. This parameter is valid only when the **Tagkeys** is empty. Valid values:
        # 
        # *   true: All the data is deleted.
        # *   false: Not all of them are deleted.
        # 
        # Default value: false
        self.all = all
        # The ID of the region in which you want to create the instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The list of resource IDs.
        # 
        # This parameter is required.
        self.resource_ids = resource_ids
        # The type of the resource. Set the value to cluster.
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The key of the label. Valid values of N: 1 to 20.
        self.tag_keys = tag_keys

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all is not None:
            result['All'] = self.all
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_keys is not None:
            result['TagKeys'] = self.tag_keys
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('All') is not None:
            self.all = m.get('All')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKeys') is not None:
            self.tag_keys = m.get('TagKeys')
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UntagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApiTemplateRequest(TeaModel):
    def __init__(
        self,
        api_name: str = None,
        content: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The name of the API operation. You can create only a cluster API operation template. Set the value to CreateCluster.
        # 
        # This parameter is required.
        self.api_name = api_name
        # The content of the cluster API operation template. Set the value to JSON strings of the request parameters of the [CreateCluster](https://help.aliyun.com/document_detail/454393.html) API operation for creating a cluster.
        # 
        # This parameter is required.
        self.content = content
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Resource group ID.
        self.resource_group_id = resource_group_id
        # Template ID (it is recommended to use the parameter TemplateId).
        # 
        # This parameter is required.
        self.template_id = template_id
        # The name of the template.
        # 
        # This parameter is required.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_name is not None:
            result['ApiName'] = self.api_name
        if self.content is not None:
            result['Content'] = self.content
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiName') is not None:
            self.api_name = m.get('ApiName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class UpdateApiTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Template ID (to be deprecated).
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateApiTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApiTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApiTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationConfigsRequest(TeaModel):
    def __init__(
        self,
        application_configs: List[UpdateApplicationConfig] = None,
        application_name: str = None,
        cluster_id: str = None,
        config_action: str = None,
        config_scope: str = None,
        description: str = None,
        node_group_id: str = None,
        node_id: str = None,
        refresh_config: bool = None,
        region_id: str = None,
    ):
        # 应用配置列表。
        # 
        # This parameter is required.
        self.application_configs = application_configs
        # The application name.
        # 
        # This parameter is required.
        self.application_name = application_name
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The operation performed on configuration items. Valid values:
        # 
        # *   ADD
        # *   UPDATE
        # *   DELETE
        self.config_action = config_action
        # The operation scope. Valid values:
        # 
        # *   CLUSTER
        # *   NODE_GROUP
        self.config_scope = config_scope
        # The description.
        self.description = description
        # The node group ID.
        self.node_group_id = node_group_id
        # The node ID.
        self.node_id = node_id
        # Specifies whether to refresh the configurations. Default value: True.
        self.refresh_config = refresh_config
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        if self.application_configs:
            for k in self.application_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationConfigs'] = []
        if self.application_configs is not None:
            for k in self.application_configs:
                result['ApplicationConfigs'].append(k.to_map() if k else None)
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.config_action is not None:
            result['ConfigAction'] = self.config_action
        if self.config_scope is not None:
            result['ConfigScope'] = self.config_scope
        if self.description is not None:
            result['Description'] = self.description
        if self.node_group_id is not None:
            result['NodeGroupId'] = self.node_group_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.refresh_config is not None:
            result['RefreshConfig'] = self.refresh_config
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_configs = []
        if m.get('ApplicationConfigs') is not None:
            for k in m.get('ApplicationConfigs'):
                temp_model = UpdateApplicationConfig()
                self.application_configs.append(temp_model.from_map(k))
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ConfigAction') is not None:
            self.config_action = m.get('ConfigAction')
        if m.get('ConfigScope') is not None:
            self.config_scope = m.get('ConfigScope')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NodeGroupId') is not None:
            self.node_group_id = m.get('NodeGroupId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RefreshConfig') is not None:
            self.refresh_config = m.get('RefreshConfig')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateApplicationConfigsResponseBody(TeaModel):
    def __init__(
        self,
        operation_id: str = None,
        request_id: str = None,
    ):
        # The operation ID.
        self.operation_id = operation_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateApplicationConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateClusterAttributeRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        deletion_protection: bool = None,
        description: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The cluster name.
        self.cluster_name = cluster_name
        # Specifies whether release protection is enabled.
        self.deletion_protection = deletion_protection
        # The cluster description.
        self.description = description
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.description is not None:
            result['Description'] = self.description
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateClusterAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateClusterAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateClusterAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateClusterAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateScriptRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        script: Script = None,
        script_id: str = None,
        script_type: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The script.
        # 
        # This parameter is required.
        self.script = script
        # The script ID.
        # 
        # This parameter is required.
        self.script_id = script_id
        # The type of the script. Valid values:
        # 
        # *   BOOTSTRAP: indicates a bootstrap action of the Elastic Compute Service (ECS) instance.
        # *   NORMAL: indicates a common script.
        # 
        # This parameter is required.
        self.script_type = script_type

    def validate(self):
        if self.script:
            self.script.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.script_id is not None:
            result['ScriptId'] = self.script_id
        if self.script_type is not None:
            result['ScriptType'] = self.script_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Script') is not None:
            temp_model = Script()
            self.script = temp_model.from_map(m['Script'])
        if m.get('ScriptId') is not None:
            self.script_id = m.get('ScriptId')
        if m.get('ScriptType') is not None:
            self.script_type = m.get('ScriptType')
        return self


class UpdateScriptShrinkRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        script_shrink: str = None,
        script_id: str = None,
        script_type: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The script.
        # 
        # This parameter is required.
        self.script_shrink = script_shrink
        # The script ID.
        # 
        # This parameter is required.
        self.script_id = script_id
        # The type of the script. Valid values:
        # 
        # *   BOOTSTRAP: indicates a bootstrap action of the Elastic Compute Service (ECS) instance.
        # *   NORMAL: indicates a common script.
        # 
        # This parameter is required.
        self.script_type = script_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.script_shrink is not None:
            result['Script'] = self.script_shrink
        if self.script_id is not None:
            result['ScriptId'] = self.script_id
        if self.script_type is not None:
            result['ScriptType'] = self.script_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Script') is not None:
            self.script_shrink = m.get('Script')
        if m.get('ScriptId') is not None:
            self.script_id = m.get('ScriptId')
        if m.get('ScriptType') is not None:
            self.script_type = m.get('ScriptType')
        return self


class UpdateScriptResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateUserAttributeRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        description: str = None,
        password: str = None,
        region_id: str = None,
        user_id: str = None,
        user_name: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The remarks of the user.
        self.description = description
        # The user password.
        self.password = password
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The user ID.
        self.user_id = user_id
        # The username.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.description is not None:
            result['Description'] = self.description
        if self.password is not None:
            result['Password'] = self.password
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class UpdateUserAttributeResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the request was successful. Valid values: true and false.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateUserAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateUserAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateUserAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


