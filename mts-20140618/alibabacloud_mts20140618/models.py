# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import Dict, List, Any


class ActivateMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media workflow. You can obtain the ID from the response of the [AddMediaWorkflow](https://help.aliyun.com/document_detail/44437.html) operation.
        # 
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ActivateMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
    ):
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The ID of the media workflow.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow.
        self.name = name
        # The status of the media workflow. The value is **Active**.
        self.state = state
        # The topology of the media workflow.
        self.topology = topology

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        return self


class ActivateMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: ActivateMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        # The details of the media workflow.
        self.media_workflow = media_workflow
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = ActivateMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ActivateMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ActivateMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ActivateMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cover_url: str = None,
        description: str = None,
        file_url: str = None,
        input_unbind: bool = None,
        media_workflow_id: str = None,
        media_workflow_user_data: str = None,
        override_params: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        tags: str = None,
        title: str = None,
    ):
        # The ID of the category to which the media file belongs. The value cannot be negative.
        self.cate_id = cate_id
        # The URL of the thumbnail. To obtain the URL, you can log on to the **MPS console** and choose **Workflows** > **Media Buckets**. Alternatively, you can log on to the **OSS console** and click **My OSS Paths**.
        # 
        # *   The value can be up to 3,200 bytes in length.
        # *   The URL complies with RFC 2396 and is encoded in UTF-8, with reserved characters being percent-encoded. For more information, see [URL encoding](https://help.aliyun.com/document_detail/423796.html).
        self.cover_url = cover_url
        # The description of the media file.
        # 
        # *   The description can be up to 1,024 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.description = description
        # The URL of the input file. You can obtain the URL in the MPS or OSS console. For more information, see the **Triggering and matching rule for a workflow** section of this topic.
        # 
        # *   Only OSS HTTP URLs are supported. Alibaba Cloud CDN URLs and HTTPS URLs are not supported.
        # *   The value can be up to 3,200 bytes in size.
        # *   The URL complies with RFC 2396 and is encoded in UTF-8. For more information, see [URL encoding](https://help.aliyun.com/document_detail/423796.html).
        # 
        # This parameter is required.
        self.file_url = file_url
        # Specifies whether to check if the media workflow supports the specified input path. We recommend that you set this parameter to true to prevent errors that may result from invalid paths. Valid values:
        # 
        # *   **true**: checks whether the workflow supports the specified input path.
        # *   **false**: does not check whether the workflow supports the specified input path.
        self.input_unbind = input_unbind
        # The ID of the media workflow that you want to run for the media file. To query the ID of a media workflow, you can log on to the MPS console or call the [AddMediaWorkflow](https://help.aliyun.com/document_detail/44437.html) operation.
        self.media_workflow_id = media_workflow_id
        # The custom data of the media workflow.
        # 
        # *   The value can be up to 1,024 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.media_workflow_user_data = media_workflow_user_data
        # The subtitle settings that are used to overwrite the original settings.
        # 
        # *   Example 1: Use `{"WebVTTSubtitleOverrides",[{"RefActivityName":"subtitleNode","WebVTTSubtitleURL":"http://test.oss-cn-hangzhou.aliyuncs.com/example1.vtt"}]}` to overwrite the original subtitle settings during HTTP Live Streaming (HLS) packaging.
        # *   Example 2: Use `{"subtitleTransNodeName":{"InputConfig":{"Format":"stl","InputFile":{"URL":"http://subtitleBucket.oss-cn-hangzhou.aliyuncs.com/package/example/CENG.stl"}}}}` to overwrite the original subtitle settings during Dynamic Adaptive Streaming over HTTP (DASH) packaging.
        self.override_params = override_params
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The tags that you want to add to the media file.
        # 
        # > In MPS, each tag that is specified for a media file is independent. You can search for all the media files that have the same tags in the Media Library.
        # 
        # *   You can specify up to 16 tags for a media file. Separate multiple tags with commas (,).
        # *   Each tag can be up to 32 bytes in size
        # *   The value must be encoded in UTF-8.
        self.tags = tags
        # The title of the media file.
        # 
        # *   The title can be up to 128 bytes in length.
        # *   The value must be encoded in UTF-8.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.input_unbind is not None:
            result['InputUnbind'] = self.input_unbind
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_user_data is not None:
            result['MediaWorkflowUserData'] = self.media_workflow_user_data
        if self.override_params is not None:
            result['OverrideParams'] = self.override_params
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('InputUnbind') is not None:
            self.input_unbind = m.get('InputUnbind')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowUserData') is not None:
            self.media_workflow_user_data = m.get('MediaWorkflowUserData')
        if m.get('OverrideParams') is not None:
            self.override_params = m.get('OverrideParams')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class AddMediaResponseBodyMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the file. The default value is **Normal**.
        self.state = state
        # The URL of the media file.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class AddMediaResponseBodyMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class AddMediaResponseBodyMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class AddMediaResponseBodyMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: AddMediaResponseBodyMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        publish_state: str = None,
        run_id_list: AddMediaResponseBodyMediaRunIdList = None,
        size: str = None,
        tags: AddMediaResponseBodyMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The ID of the category to which the media file belongs.
        self.cate_id = cate_id
        # The review status of the media file. Valid values:
        # 
        # *   **Initiated**: The media file is uploaded but not reviewed.
        # *   **Pass**: The media file is uploaded and passes the review.
        self.censor_state = censor_state
        # The URL of the thumbnail.
        self.cover_url = cover_url
        # The time when the media file was created.
        self.creation_time = creation_time
        # The description of the media file. The description can be up to 1,024 bytes in length.
        self.description = description
        # The duration of the media file.
        self.duration = duration
        # The information about the input file.
        self.file = file
        # The format of the media file. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format = format
        # The frame rate of the media file.
        self.fps = fps
        # The height of the media file.
        self.height = height
        # The ID of the media file.
        self.media_id = media_id
        # The publishing status of the media file. Valid values:
        # 
        # *   **Initiated**: The media file is in the initial state.
        # *   **UnPublish**: The media file has not been published, and the playback permission on the OSS object is Private.
        # *   **Published**: The media file has been published, and the playback permission on the OSS object is Default.
        self.publish_state = publish_state
        # The IDs of the media workflow execution instances.
        self.run_id_list = run_id_list
        # The size of the media file.
        self.size = size
        # The tags of the media file.
        self.tags = tags
        # The title of the media file. The title can be up to 128 bytes in length.
        self.title = title
        # The width of the media file.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = AddMediaResponseBodyMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = AddMediaResponseBodyMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Tags') is not None:
            temp_model = AddMediaResponseBodyMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddMediaResponseBody(TeaModel):
    def __init__(
        self,
        media: AddMediaResponseBodyMedia = None,
        request_id: str = None,
    ):
        # The detailed information about the media file.
        self.media = media
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media:
            self.media.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            temp_model = AddMediaResponseBodyMedia()
            self.media = temp_model.from_map(m['Media'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaTagRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        tag: str = None,
    ):
        # The ID of the media file to which you want to add tags.
        # 
        # > To obtain the ID of a media file, you can call the [AddMedia](https://help.aliyun.com/document_detail/44458.html) operation. Alternatively, perform the following operations in the ApsaraVideo Media Processing (MPS) console: In the left-side navigation pane, choose **Media Management** > **Media List**. Find the file that you want to manage and click **Manage** in the Actions column. The ID of the file is displayed on the Basics tab.
        # 
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The tag that you want to add to the medial file. The value is encoded in UTF-8 and can be up to 32 bytes in length.
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class AddMediaTagResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddMediaTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        # The name of the media workflow.
        # 
        # *   The value cannot be empty.
        # *   The name cannot be the same as that of an existing media workflow within the current Alibaba Cloud account.
        # *   The name can be up to 64 characters in length.
        # *   The value must be encoded in the UTF-8 format.
        # 
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The topology of the media workflow. The value must be a JSON object that contains the activities and activity dependencies. For more information, see the **Sample topology** section of this topic.
        # 
        # >  The Object Storage Service (OSS) bucket must reside in the same region as your MPS service.
        # 
        # This parameter is required.
        self.topology = topology
        # The triggering mode of the media workflow. Valid values:
        # 
        # *   **OssAutoTrigger**: The media workflow is automatically triggered.
        # *   **NotInAuto**: The media workflow is not automatically triggered.
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class AddMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The ID of the media workflow. We recommend that you keep this ID for later operations on this workflow.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow.
        self.name = name
        # The state of the media workflow. By default, the created workflow is in the **Active** state.
        self.state = state
        # The topology of the media workflow. The value is a JSON object that contains the activities and activity dependencies.
        self.topology = topology
        # The triggering mode of the media workflow. Valid values:
        # 
        # *   **OssAutoTrigger**: The media workflow is automatically triggered.
        # *   **NotInAuto**: The media workflow is not automatically triggered.
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class AddMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: AddMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        # The information about the media workflow.
        self.media_workflow = media_workflow
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = AddMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPipelineRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        notify_config: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        role: str = None,
        speed: str = None,
        speed_level: int = None,
    ):
        # The name of the MPS queue. The name can be up to 128 bytes in size.
        # 
        # This parameter is required.
        self.name = name
        # The Message Service (MNS) configuration.
        self.notify_config = notify_config
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The role.
        self.role = role
        # The type of the MPS queue. Valid values:
        # 
        # *   **Boost**: MPS queue with transcoding speed boosted.
        # *   **Standard**: standard MPS queue.
        # *   **NarrowBandHDV2**: MPS queue that supports Narrowband HD 2.0.
        # *   **AIVideoCover**: MPS queue for intelligent snapshot capture.
        # *   **AIVideoTag**: MPS queue for video tagging. The supported regions are China (Shanghai), China (Beijing), and China (Hangzhou).
        # 
        # Default value: **Standard**.
        self.speed = speed
        # The level of the MPS queue. Valid values: **1 to 3**.
        self.speed_level = speed_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.speed_level is not None:
            result['SpeedLevel'] = self.speed_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            self.notify_config = m.get('NotifyConfig')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('SpeedLevel') is not None:
            self.speed_level = m.get('SpeedLevel')
        return self


class AddPipelineResponseBodyPipelineNotifyConfig(TeaModel):
    def __init__(
        self,
        mq_tag: str = None,
        mq_topic: str = None,
        queue_name: str = None,
        topic: str = None,
    ):
        # The tag string.
        self.mq_tag = mq_tag
        # The queue of messages that are received.
        self.mq_topic = mq_topic
        # The name of the queue.
        self.queue_name = queue_name
        # The name of the topic.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mq_tag is not None:
            result['MqTag'] = self.mq_tag
        if self.mq_topic is not None:
            result['MqTopic'] = self.mq_topic
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MqTag') is not None:
            self.mq_tag = m.get('MqTag')
        if m.get('MqTopic') is not None:
            self.mq_topic = m.get('MqTopic')
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class AddPipelineResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        notify_config: AddPipelineResponseBodyPipelineNotifyConfig = None,
        quota_allocate: int = None,
        role: str = None,
        speed: str = None,
        speed_level: int = None,
        state: str = None,
    ):
        # The ID of the MPS queue.
        self.id = id
        # The name of the MPS queue.
        self.name = name
        # The MNS configuration.
        self.notify_config = notify_config
        # The quota that is allocated to the MPS queue.
        self.quota_allocate = quota_allocate
        # The role.
        self.role = role
        # The type of the MPS queue.
        self.speed = speed
        # The level of the MPS queue.
        self.speed_level = speed_level
        # The state of the MPS queue.
        # 
        # *   Active: The MPS queue is active. The jobs in the MPS queue are scheduled and transcoded by MPS.
        # *   Paused: The MPS queue is paused. Jobs in the MPS queue are no longer scheduled for transcoding by MPS. All of the jobs in the MPS queue remain in the Submitted state. Jobs that are being transcoded are not affected.
        self.state = state

    def validate(self):
        if self.notify_config:
            self.notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config.to_map()
        if self.quota_allocate is not None:
            result['QuotaAllocate'] = self.quota_allocate
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.speed_level is not None:
            result['SpeedLevel'] = self.speed_level
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            temp_model = AddPipelineResponseBodyPipelineNotifyConfig()
            self.notify_config = temp_model.from_map(m['NotifyConfig'])
        if m.get('QuotaAllocate') is not None:
            self.quota_allocate = m.get('QuotaAllocate')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('SpeedLevel') is not None:
            self.speed_level = m.get('SpeedLevel')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class AddPipelineResponseBody(TeaModel):
    def __init__(
        self,
        pipeline: AddPipelineResponseBodyPipeline = None,
        request_id: str = None,
    ):
        # The MPS queue.
        self.pipeline = pipeline
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = AddPipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddSmarttagTemplateRequest(TeaModel):
    def __init__(
        self,
        analyse_types: str = None,
        face_category_ids: str = None,
        face_custom_params_config: str = None,
        industry: str = None,
        is_default: bool = None,
        keyword_config: str = None,
        knowledge_config: str = None,
        label_custom_category_ids: str = None,
        label_custom_params_config: str = None,
        label_type: str = None,
        label_version: str = None,
        landmark_group_ids: str = None,
        object_group_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        scene: str = None,
        template_config: str = None,
        template_name: str = None,
    ):
        # This parameter is required.
        self.analyse_types = analyse_types
        self.face_category_ids = face_category_ids
        self.face_custom_params_config = face_custom_params_config
        # This parameter is required.
        self.industry = industry
        self.is_default = is_default
        self.keyword_config = keyword_config
        self.knowledge_config = knowledge_config
        self.label_custom_category_ids = label_custom_category_ids
        self.label_custom_params_config = label_custom_params_config
        self.label_type = label_type
        self.label_version = label_version
        self.landmark_group_ids = landmark_group_ids
        self.object_group_ids = object_group_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # This parameter is required.
        self.scene = scene
        self.template_config = template_config
        # This parameter is required.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analyse_types is not None:
            result['AnalyseTypes'] = self.analyse_types
        if self.face_category_ids is not None:
            result['FaceCategoryIds'] = self.face_category_ids
        if self.face_custom_params_config is not None:
            result['FaceCustomParamsConfig'] = self.face_custom_params_config
        if self.industry is not None:
            result['Industry'] = self.industry
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.keyword_config is not None:
            result['KeywordConfig'] = self.keyword_config
        if self.knowledge_config is not None:
            result['KnowledgeConfig'] = self.knowledge_config
        if self.label_custom_category_ids is not None:
            result['LabelCustomCategoryIds'] = self.label_custom_category_ids
        if self.label_custom_params_config is not None:
            result['LabelCustomParamsConfig'] = self.label_custom_params_config
        if self.label_type is not None:
            result['LabelType'] = self.label_type
        if self.label_version is not None:
            result['LabelVersion'] = self.label_version
        if self.landmark_group_ids is not None:
            result['LandmarkGroupIds'] = self.landmark_group_ids
        if self.object_group_ids is not None:
            result['ObjectGroupIds'] = self.object_group_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalyseTypes') is not None:
            self.analyse_types = m.get('AnalyseTypes')
        if m.get('FaceCategoryIds') is not None:
            self.face_category_ids = m.get('FaceCategoryIds')
        if m.get('FaceCustomParamsConfig') is not None:
            self.face_custom_params_config = m.get('FaceCustomParamsConfig')
        if m.get('Industry') is not None:
            self.industry = m.get('Industry')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('KeywordConfig') is not None:
            self.keyword_config = m.get('KeywordConfig')
        if m.get('KnowledgeConfig') is not None:
            self.knowledge_config = m.get('KnowledgeConfig')
        if m.get('LabelCustomCategoryIds') is not None:
            self.label_custom_category_ids = m.get('LabelCustomCategoryIds')
        if m.get('LabelCustomParamsConfig') is not None:
            self.label_custom_params_config = m.get('LabelCustomParamsConfig')
        if m.get('LabelType') is not None:
            self.label_type = m.get('LabelType')
        if m.get('LabelVersion') is not None:
            self.label_version = m.get('LabelVersion')
        if m.get('LandmarkGroupIds') is not None:
            self.landmark_group_ids = m.get('LandmarkGroupIds')
        if m.get('ObjectGroupIds') is not None:
            self.object_group_ids = m.get('ObjectGroupIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class AddSmarttagTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        self.request_id = request_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class AddSmarttagTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddSmarttagTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddSmarttagTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTemplateRequest(TeaModel):
    def __init__(
        self,
        audio: str = None,
        container: str = None,
        mux_config: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        trans_config: str = None,
        video: str = None,
    ):
        # The audio stream settings. The value must be a JSON object. For more information, see [Audio](https://help.aliyun.com/document_detail/29253.html).
        # 
        # > If you do not specify this parameter, output files do not contain audio streams. This parameter is required if you want to retain the audio streams.
        self.audio = audio
        # The container format. The value must be a JSON object that contains the Format parameter. If you do not specify this parameter, the transcoded media file is in MP4 format by default. This parameter is required if you want to use the transcoding template to generate media files in other formats. For more information, see [Container](https://help.aliyun.com/document_detail/29253.html).
        # 
        # *   Default value: MP4.
        # *   Video transcoding supports the following formats: FLV, MP4, HLS (M3U8 + TS), and MPEG-DASH (MPD + fMP4).
        # 
        # > If the container format is FLV, the video codec cannot be set to H.265.
        # 
        # *   Audio transcoding supports the following formats: MP3, MP4, OGG, FLAC, and M4A.
        # *   Image transcoding supports the GIF and WebP formats.
        # 
        # > 
        # 
        # *   If the container format is GIF, the video codec must be set to GIF.
        # 
        # *   If the container format is WebP, the video codec must be set to WebP.
        self.container = container
        # The segment settings. The value must be a JSON object. For more information, see [MuxConfig](https://help.aliyun.com/document_detail/29253.html). If you do not specify this parameter, media segment files are not generated. This parameter is required if you want to generate media segment files.
        self.mux_config = mux_config
        # The name of the transcoding template. The name can be up to 128 bytes in length.
        # 
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The general transcoding settings. The value must be a JSON object. For more information, see [TransConfig](https://help.aliyun.com/document_detail/29253.html). If you do not specify this parameter, the default settings are used. This parameter is required if the default settings cannot meet your business requirements.
        self.trans_config = trans_config
        # The video stream settings. The value must be a JSON object. For more information, see [Video](https://help.aliyun.com/document_detail/29253.html).
        # 
        # > If you do not specify this parameter, output files do not contain video streams. This parameter is required if you want to retain the video streams.
        self.video = video

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio
        if self.container is not None:
            result['Container'] = self.container
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config
        if self.video is not None:
            result['Video'] = self.video
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            self.audio = m.get('Audio')
        if m.get('Container') is not None:
            self.container = m.get('Container')
        if m.get('MuxConfig') is not None:
            self.mux_config = m.get('MuxConfig')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TransConfig') is not None:
            self.trans_config = m.get('TransConfig')
        if m.get('Video') is not None:
            self.video = m.get('Video')
        return self


class AddTemplateResponseBodyTemplateAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        level: str = None,
        loudness_range_target: str = None,
        method: str = None,
        peak_level: str = None,
        true_peak: str = None,
    ):
        # The output volume.
        # 
        # This parameter takes effect only when the value of Method is dynamic.
        # 
        # Unit: dB.
        # 
        # Valid values: [-70,-5].
        # 
        # Default value: -6.
        self.integrated_loudness_target = integrated_loudness_target
        # The volume adjustment range.
        # 
        # *   Default value: **-20**.
        # *   Unit: dB.
        self.level = level
        # The range of the volume relative to the output volume.
        # 
        # This parameter takes effect only when the value of Method is dynamic.
        # 
        # Unit: dB.
        # 
        # Valid values: [1,20].
        # 
        # Default value: 8.
        self.loudness_range_target = loudness_range_target
        # The volume adjustment method. Valid values:
        # 
        # *   **auto**: The volume is automatically adjusted.
        # *   **dynamic**: The volume is dynamically adjusted.
        # *   **linear**: The volume is linearly adjusted.
        self.method = method
        # The volume adjustment coefficient.
        # 
        # This parameter takes effect only when the value of Method is adaptive.
        # 
        # Valid values: [0,1].
        # 
        # Default value: 0.9.
        self.peak_level = peak_level
        # The peak volume.
        # 
        # This parameter takes effect only when the value of Method is dynamic.
        # 
        # Unit: dB.
        # 
        # Valid values: [-9,0].
        # 
        # Default value: -1.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.level is not None:
            result['Level'] = self.level
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.peak_level is not None:
            result['PeakLevel'] = self.peak_level
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('PeakLevel') is not None:
            self.peak_level = m.get('PeakLevel')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class AddTemplateResponseBodyTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: AddTemplateResponseBodyTemplateAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.bitrate = bitrate
        # The number of sound channels. Default value: **2**.
        self.channels = channels
        # The audio codec format. Default value: **aac**. Valid values:
        # 
        # *   **aac**\
        # *   **mp3**\
        # *   **vorbis**\
        # *   **flac**\
        self.codec = codec
        # The codec profile of the audio. Valid values if the **Codec** parameter is set to **AAC**:
        # 
        # *   **aac_low**\
        # *   **aac_he**\
        # *   **aac_he_v2**\
        # *   **aac_ld**\
        # *   **aac_eld**\
        self.profile = profile
        # The level of the independent denoising algorithm.
        self.qscale = qscale
        # Indicates whether the audio stream is deleted.
        # 
        # *   **true**: The audio stream is deleted.
        # *   **false**: The audio stream is retained.
        # *   Default value: **false**.
        self.remove = remove
        # The sampling rate.
        # 
        # *   Unit: Hz.
        # *   Default value: **44100**.
        self.samplerate = samplerate
        # The volume control configurations
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = AddTemplateResponseBodyTemplateAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class AddTemplateResponseBodyTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class AddTemplateResponseBodyTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        # The color dithering algorithm of the palette. Valid values: sierra and bayer.
        self.dither_mode = dither_mode
        # The duration for which the final frame is paused. Unit: centiseconds.
        self.final_delay = final_delay
        # Indicates whether the custom palette is used.
        self.is_custom_palette = is_custom_palette
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class AddTemplateResponseBodyTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The length of the segment. Unit: seconds.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class AddTemplateResponseBodyTemplateMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class AddTemplateResponseBodyTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: AddTemplateResponseBodyTemplateMuxConfigGif = None,
        segment: AddTemplateResponseBodyTemplateMuxConfigSegment = None,
        webp: AddTemplateResponseBodyTemplateMuxConfigWebp = None,
    ):
        # The transmuxing settings for GIF.
        self.gif = gif
        # The segment settings.
        self.segment = segment
        # The transmuxing settings for WebP.
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = AddTemplateResponseBodyTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = AddTemplateResponseBodyTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = AddTemplateResponseBodyTemplateMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class AddTemplateResponseBodyTemplateTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method of resolution adjustment. Default value: **none**. Valid values:
        # 
        # *   **rescale**: The input video is rescaled.
        # *   **crop**: The input video is cropped.
        # *   **none**: No change is made.
        self.adj_dar_method = adj_dar_method
        # Indicates whether the audio bitrate is checked.
        # 
        # If this feature is enabled and the system detects that the audio bitrate of the output file is greater than that of the input file, the audio bitrate of the input file is retained after transcoding.
        # 
        # *   **true**: The audio bitrate is checked.
        # *   **false**: The audio bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Indicates whether the audio bitrate is checked. If this feature is enabled and the system detects that the audio bitrate of the output file is higher than that of the input file, the input file is not transcoded. This parameter has a higher priority than the **IsCheckAudioBitrate** parameter. Valid values:
        # 
        # *   **true**: The audio bitrate is checked. In this case, if the audio bitrate of the output file is higher than that of the input file, the input file is not transcoded.
        # *   **false**: The audio bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the resolution is checked.
        # 
        # *   **true**: The resolution is checked.
        # *   **false**: The resolution is not checked.
        # *   Default value: **false**.
        # 
        # > If this feature is enabled and the system detects that the resolution of the output file is higher than that of the input file based on the width or height, the resolution of the input file is retained after transcoding.
        self.is_check_reso = is_check_reso
        # Indicates whether the resolution is checked.
        # 
        # *   **true**: The resolution is checked.
        # *   **false**: The resolution is not checked.
        # *   Default value: **false**.
        # 
        # > If this feature is enabled and the system detects that the resolution of the output file is higher than that of the input file based on the width or height, an error that indicates a transcoding failure is returned.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the video bitrate is checked.
        # 
        # *   **true**: The video bitrate is checked.
        # *   **false**: The video bitrate is not checked.
        # *   Default value: **false**.
        # 
        # > If this feature is enabled and the system detects that the video bitrate of the output file is greater than that of the input file, the video bitrate of the input file is retained after transcoding.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Indicates whether the video bitrate is checked. If this feature is enabled and the system detects that the video bitrate of the output file is higher than that of the input file, the input file is not transcoded. This parameter has a higher priority than the IsCheckVideoBitrate parameter.
        # 
        # *   **true**: The video bitrate is checked. In this case, if the video bitrate of the output file is higher than that of the input file, the input file is not transcoded.
        # *   **false**: The video bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The transcoding mode. Valid values:
        # 
        # *   **onepass**\
        # *   **twopass**\
        # *   **CBR**\
        # *   Default value: **onepass**.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class AddTemplateResponseBodyTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The maximum bitrate.
        self.max = max
        # The minimum bitrate.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class AddTemplateResponseBodyTemplateVideoNarrowBand(TeaModel):
    def __init__(
        self,
        abrmax: float = None,
        max_abr_ratio: float = None,
        version: str = None,
    ):
        # The upper limit of the dynamic bitrate. If this parameter is set, the average bitrate is in the range of (0, 1000000].
        self.abrmax = abrmax
        # The maximum ratio of the upper limit of dynamic bitrate. If this parameter is set, the value of Abrmax does not exceed x times of the source video bitrate. Valid values: (0,1.0].
        self.max_abr_ratio = max_abr_ratio
        # The Narrowband HD version. Only 1.0 may be returned.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abrmax is not None:
            result['Abrmax'] = self.abrmax
        if self.max_abr_ratio is not None:
            result['MaxAbrRatio'] = self.max_abr_ratio
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Abrmax') is not None:
            self.abrmax = m.get('Abrmax')
        if m.get('MaxAbrRatio') is not None:
            self.max_abr_ratio = m.get('MaxAbrRatio')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class AddTemplateResponseBodyTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: AddTemplateResponseBodyTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        hdr_2sdr: str = None,
        height: str = None,
        long_short_mode: str = None,
        max_fps: str = None,
        maxrate: str = None,
        narrow_band: AddTemplateResponseBodyTemplateVideoNarrowBand = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The bitrate of the output video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The bitrate range of the video.
        self.bitrate_bnd = bitrate_bnd
        # The size of the buffer.
        # 
        # *   Default value: **6000**.
        # *   Unit: KB.
        self.bufsize = bufsize
        # The video codec. Valid values: H.264, H.265, GIF, and WebP. Default value: **H.264**.
        self.codec = codec
        # The constant rate factor. Default value if the video codec is set to H.264: **23**. Default value if the video codec is set to H.265: **26**.
        # 
        # > If this parameter is specified, the setting of the Bitrate parameter becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   **border**: automatically detects and removes borders.
        # *   **Value in the format of width:height:left:top**: crops the video image based on the custom settings. Example: 1280:800:0:140.
        self.crop = crop
        # The level of quality control on the video.
        self.degrain = degrain
        # The frame rate. Default value: the frame rate of the input file. The value is 60 if the frame rate of the input file exceeds 60. Unit: frames per second.
        self.fps = fps
        # The GOP size. The GOP size can be the maximum interval of keyframes or the maximum number of frames in a frame group. If the maximum interval is specified, the value contains the unit (s). If the maximum number of frames is specified, the value does not contain a unit. Default value: **10s**.
        self.gop = gop
        # Indicates whether the HDR2SDR conversion feature is enabled. If this feature is enabled, high dynamic range (HDR) videos are transcoded to standard dynamic range (SDR) videos.
        self.hdr_2sdr = hdr_2sdr
        # The height of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: the height of the input video.
        self.height = height
        # Indicates whether the auto-rotate screen feature is enabled. Default value: **false**. Valid values:
        # 
        # *   **true**: The auto-rotate screen feature is enabled.
        # *   **false**: The auto-rotate screen feature is disabled.
        # 
        # > If this feature is enabled, the width of the output video corresponds to the long side of the input video, which is the height of the input video in portrait mode. The height of the output video corresponds to the short side of the input video, which is the width of the input video in portrait mode.
        self.long_short_mode = long_short_mode
        # The maximum frame rate.
        self.max_fps = max_fps
        # The maximum bitrate of the video. Unit: Kbit/s.
        self.maxrate = maxrate
        # The Narrowband HD settings.
        self.narrow_band = narrow_band
        # The black borders to be added to the video. The value is in the width:height:left:top format.
        self.pad = pad
        # The pixel format. Standard pixel formats such as yuv420p and yuvj420p are supported. The default pixel format can be **yuv420p** or the pixel format of the input video.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. Default value: **medium**. Valid values:
        # 
        # *   **veryfast**\
        # *   **fast**\
        # *   **medium**\
        # *   **slow**\
        # *   **slower**\
        # 
        # > This parameter is valid only if the Codec parameter is set to H.264.
        self.preset = preset
        # The codec profile.
        # 
        # *   **baseline**: suitable for mobile devices
        # *   **main**: suitable for standard-definition devices
        # *   **high**: suitable for high-definition devices
        # *   Default value: **high**.
        # 
        # If multiple definitions are available, we recommend that you set this parameter to baseline for the lowest definition to ensure normal playback on low-end devices. Set this parameter to main or high for other definitions.
        # 
        # > This parameter is valid only if the Codec parameter is set to H.264.
        self.profile = profile
        # The level of the independent denoising algorithm.
        self.qscale = qscale
        # Indicates whether the video stream is deleted.
        # 
        # *   **true**: The video stream is deleted.
        # *   **false**: The video stream is retained.
        # *   Default value: **false**.
        self.remove = remove
        # The policy of resolution adjustment.
        self.reso_priority = reso_priority
        # The scan mode. Valid values:
        # 
        # *   **interlaced**\
        # *   **progressive**\
        self.scan_mode = scan_mode
        # The width of the video.
        # 
        # *   Default value: the width of the input video.****\
        # *   Unit: pixel.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()
        if self.narrow_band:
            self.narrow_band.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.hdr_2sdr is not None:
            result['Hdr2sdr'] = self.hdr_2sdr
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.narrow_band is not None:
            result['NarrowBand'] = self.narrow_band.to_map()
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = AddTemplateResponseBodyTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Hdr2sdr') is not None:
            self.hdr_2sdr = m.get('Hdr2sdr')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('NarrowBand') is not None:
            temp_model = AddTemplateResponseBodyTemplateVideoNarrowBand()
            self.narrow_band = temp_model.from_map(m['NarrowBand'])
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddTemplateResponseBodyTemplate(TeaModel):
    def __init__(
        self,
        audio: AddTemplateResponseBodyTemplateAudio = None,
        container: AddTemplateResponseBodyTemplateContainer = None,
        id: str = None,
        mux_config: AddTemplateResponseBodyTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: AddTemplateResponseBodyTemplateTransConfig = None,
        video: AddTemplateResponseBodyTemplateVideo = None,
    ):
        # The audio codec configurations.
        self.audio = audio
        # The container format settings.
        self.container = container
        # The ID of the transcoding template. We recommend that you keep this ID for subsequent operation calls.
        self.id = id
        # The transmuxing settings.
        self.mux_config = mux_config
        # The name of the transcoding template.
        self.name = name
        # The status of the template. Valid values:
        # 
        # *   **Normal**: The template is normal.
        # *   **Deleted**: The template is deleted.
        self.state = state
        # The general transcoding settings.
        self.trans_config = trans_config
        # The video codec configurations.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = AddTemplateResponseBodyTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = AddTemplateResponseBodyTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = AddTemplateResponseBodyTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = AddTemplateResponseBodyTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = AddTemplateResponseBodyTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class AddTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template: AddTemplateResponseBodyTemplate = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The details of the transcoding template.
        self.template = template

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = AddTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class AddTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddWaterMarkTemplateRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The configuration of the watermark template. The value is a JSON object. For more information, see the "WaterMarks" section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        # 
        # > If you do not require a positive correlation between the size of text in the watermark and the resolution, you can enable adaptation for the watermark. To do so, add `[\\"adaptive\\"]=true` to the TextWaterMark parameter.
        # 
        # This parameter is required.
        self.config = config
        # The name of the watermark template. The value can contain letters and digits and can be up to 128 bytes in size.
        # 
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark relative to the output video image. Default value: **0**. The default value indicates no offset. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the vertical offset. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the horizontal offset to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.dx = dx
        # The vertical offset of the watermark relative to the output video image. Default value: **0**. The default value indicates no offset. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the vertical offset. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the vertical offset to the height of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.dy = dy
        # The height of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the height of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the height of the watermark image to the height of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.height = height
        # The width of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the width of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the width of the watermark image to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The display duration of the watermark. Default value: **ToEND**. The default value indicates that the watermark is displayed until the video ends.
        self.duration = duration
        # The beginning of the time range during which the watermark is displayed.
        # 
        # *   Unit: seconds.
        # *   Default value: **0**.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class AddWaterMarkTemplateResponseBodyWaterMarkTemplate(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        id: str = None,
        name: str = None,
        ratio_refer: AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer = None,
        refer_pos: str = None,
        state: str = None,
        timeline: AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline = None,
        type: str = None,
        width: str = None,
    ):
        # The horizontal offset. Unit: pixel.
        self.dx = dx
        # The vertical offset. Unit: pixel.
        self.dy = dy
        # The height of the watermark image. Unit: pixel.
        self.height = height
        # The ID of the watermark template. We recommend that you keep this ID for subsequent operation calls.
        self.id = id
        # The name of the watermark template.
        self.name = name
        # The values of the Height, Width, Dx, and Dy parameters relative to the reference edges. If the values of the Height, Width, Dx, and Dy parameters are decimals between 0 and 1, the values are calculated by referring to the following edges in sequence:
        # 
        # *   **Width**: the width edge.
        # *   **Height**: the height edge.
        # *   **Long**: the long edge.
        # *   **Short**: the short edge.
        self.ratio_refer = ratio_refer
        # The position of the watermark. Valid values:
        # 
        # *   **TopRight**: the upper-right corner.
        # *   **TopLeft**: the upper-left corner.
        # *   **BottomRight**: the lower-right corner.
        # *   **BottomLeft**: the lower-left corner.
        self.refer_pos = refer_pos
        # The status of the watermark template.
        # 
        # *   **Normal**: The watermark template is normal.
        # *   **Deleted**: The watermark template is deleted.
        self.state = state
        # The timeline of the watermark.
        self.timeline = timeline
        # The type of the watermark. Valid values:
        # 
        # *   Image: an image watermark.
        # *   Text: a text watermark.
        self.type = type
        # The width of the watermark image. Unit: pixel.
        self.width = width

    def validate(self):
        if self.ratio_refer:
            self.ratio_refer.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.ratio_refer is not None:
            result['RatioRefer'] = self.ratio_refer.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.state is not None:
            result['State'] = self.state
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RatioRefer') is not None:
            temp_model = AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer()
            self.ratio_refer = temp_model.from_map(m['RatioRefer'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Timeline') is not None:
            temp_model = AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddWaterMarkTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        water_mark_template: AddWaterMarkTemplateResponseBodyWaterMarkTemplate = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The details of the watermark template.
        self.water_mark_template = water_mark_template

    def validate(self):
        if self.water_mark_template:
            self.water_mark_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.water_mark_template is not None:
            result['WaterMarkTemplate'] = self.water_mark_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WaterMarkTemplate') is not None:
            temp_model = AddWaterMarkTemplateResponseBodyWaterMarkTemplate()
            self.water_mark_template = temp_model.from_map(m['WaterMarkTemplate'])
        return self


class AddWaterMarkTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddWaterMarkTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddWaterMarkTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindInputBucketRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        owner_account: str = None,
        owner_id: int = None,
        referer: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The name of the input media bucket to be bound. The name can be up to 64 bytes in size. To obtain the media bucket name, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Media Buckets** in the left-side navigation pane.
        # 
        # > The bucket name can contain lowercase letters, digits, and hyphens (-), and cannot start or end with a hyphen (-).
        # 
        # This parameter is required.
        self.bucket = bucket
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The settings of Object Storage Service (OSS) hotlink protection. For more information, see [Hotlink protection](https://help.aliyun.com/document_detail/31869.html).
        self.referer = referer
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.referer is not None:
            result['Referer'] = self.referer
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Referer') is not None:
            self.referer = m.get('Referer')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class BindInputBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BindInputBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindInputBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindInputBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindOutputBucketRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The name of the Object Storage Service (OSS) bucket that you want to bind. The name can be up to 64 bytes in size and can contain letters, digits, and hyphens (-). The name cannot start with a special character.
        # 
        # This parameter is required.
        self.bucket = bucket
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class BindOutputBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BindOutputBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindOutputBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindOutputBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the transcoding job to be canceled. You can log on to the **MPS console** and click **Tasks** in the left-side navigation pane to obtain job IDs. Alternatively, you can obtain job IDs from the response of the [SubmitJobs](https://help.aliyun.com/document_detail/29226.html) operation.
        # 
        # This parameter is required.
        self.job_id = job_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CancelJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the job.
        self.job_id = job_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomEntityRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        custom_entity_info: str = None,
        custom_entity_name: str = None,
        custom_group_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        self.custom_entity_info = custom_entity_info
        # This parameter is required.
        self.custom_entity_name = custom_entity_name
        # This parameter is required.
        self.custom_group_id = custom_group_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.custom_entity_info is not None:
            result['CustomEntityInfo'] = self.custom_entity_info
        if self.custom_entity_name is not None:
            result['CustomEntityName'] = self.custom_entity_name
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('CustomEntityInfo') is not None:
            self.custom_entity_info = m.get('CustomEntityInfo')
        if m.get('CustomEntityName') is not None:
            self.custom_entity_name = m.get('CustomEntityName')
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateCustomEntityResponseBody(TeaModel):
    def __init__(
        self,
        custom_entity_id: str = None,
        request_id: str = None,
    ):
        self.custom_entity_id = custom_entity_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_entity_id is not None:
            result['CustomEntityId'] = self.custom_entity_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomEntityId') is not None:
            self.custom_entity_id = m.get('CustomEntityId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCustomEntityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCustomEntityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomEntityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomGroupRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        custom_group_description: str = None,
        custom_group_name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        self.custom_group_description = custom_group_description
        # This parameter is required.
        self.custom_group_name = custom_group_name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.custom_group_description is not None:
            result['CustomGroupDescription'] = self.custom_group_description
        if self.custom_group_name is not None:
            result['CustomGroupName'] = self.custom_group_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('CustomGroupDescription') is not None:
            self.custom_group_description = m.get('CustomGroupDescription')
        if m.get('CustomGroupName') is not None:
            self.custom_group_name = m.get('CustomGroupName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateCustomGroupResponseBody(TeaModel):
    def __init__(
        self,
        custom_group_id: str = None,
        request_id: str = None,
    ):
        self.custom_group_id = custom_group_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCustomGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCustomGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFpShotDBRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        description: str = None,
        model_id: int = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The configurations of the media fingerprint library. By default, this parameter is left empty. You can customize the configurations based on your business requirements. The value must be a string in the JSON format.
        self.config = config
        # The description of the media fingerprint library.
        self.description = description
        # The model ID of the media fingerprint library. To create a text fingerprint library, set the parameter to **11**. To create a video fingerprint library, set the parameter to **12**. To create an audio fingerprint library, set the parameter to **13**. To create an image fingerprint library, set the parameter to **14**.
        self.model_id = model_id
        # The name of the media fingerprint library.
        # 
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.description is not None:
            result['Description'] = self.description
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateFpShotDBResponseBodyFpShotDB(TeaModel):
    def __init__(
        self,
        config: str = None,
        description: str = None,
        fp_dbid: str = None,
        model_id: int = None,
        name: str = None,
        state: str = None,
    ):
        # The configurations of the media fingerprint library.
        self.config = config
        # The description of the media fingerprint library.
        self.description = description
        # The ID of the media fingerprint library. We recommend that you keep this ID for subsequent operation calls.
        self.fp_dbid = fp_dbid
        # The model ID of the media fingerprint library.
        self.model_id = model_id
        # The name of the media fingerprint library.
        self.name = name
        # The status of the media fingerprint library. After the media fingerprint library is created, it enters the **offline** state. After the media fingerprint library is processed at the backend, it enters the **active** state.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.description is not None:
            result['Description'] = self.description
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class CreateFpShotDBResponseBody(TeaModel):
    def __init__(
        self,
        fp_shot_db: CreateFpShotDBResponseBodyFpShotDB = None,
        request_id: str = None,
    ):
        # The details of the media fingerprint library.
        self.fp_shot_db = fp_shot_db
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.fp_shot_db:
            self.fp_shot_db.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_shot_db is not None:
            result['FpShotDB'] = self.fp_shot_db.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpShotDB') is not None:
            temp_model = CreateFpShotDBResponseBodyFpShotDB()
            self.fp_shot_db = temp_model.from_map(m['FpShotDB'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateFpShotDBResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFpShotDBResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFpShotDBResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeactivateMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media workflow that is deactivated.
        # 
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeactivateMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
    ):
        # *   After you deactivate a media workflow, you can modify the workflow information.
        # *   After you delete or deactivate a media workflow, the workflow cannot be used. In this case, the workflow is not automatically triggered when you upload a file to the bucket specified by the workflow.
        # 
        # ## Limits on QPS
        # 
        # You can call this operation up to 100 times per second. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation. For more information, see [QPS limits](https://www.alibabacloud.com/help/en/apsaravideo-for-media-processing/latest/qps-limit).
        self.creation_time = creation_time
        # The ID of the media workflow that you want to deactivate. To obtain the ID of the media workflow, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Workflow Settings** in the left-side navigation pane.
        self.media_workflow_id = media_workflow_id
        # The details of the media workflow.
        self.name = name
        # The topology of the media workflow.The status of the media workflow. The value is **Inactive**.
        self.state = state
        # The status of the media workflow. The value is **Inactive**.
        self.topology = topology

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        return self


class DeactivateMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: DeactivateMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        # The topology of the media workflow.
        self.media_workflow = media_workflow
        # The name of the media workflow that is deactivated.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = DeactivateMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeactivateMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeactivateMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeactivateMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomEntityRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        custom_entity_id: str = None,
        custom_group_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.custom_entity_id = custom_entity_id
        # This parameter is required.
        self.custom_group_id = custom_group_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.custom_entity_id is not None:
            result['CustomEntityId'] = self.custom_entity_id
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('CustomEntityId') is not None:
            self.custom_entity_id = m.get('CustomEntityId')
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteCustomEntityResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomEntityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomEntityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomEntityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomGroupRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        custom_group_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The custom type of the image library. Valid values:
        # 
        # *   landmark: custom landmarks.
        # *   object: custom objects.
        # 
        # This parameter is required.
        self.algorithm = algorithm
        # The ID of the custom image library.
        # 
        # This parameter is required.
        self.custom_group_id = custom_group_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteCustomGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request. This parameter is unique.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomViewRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        custom_entity_id: str = None,
        custom_group_id: str = None,
        custom_view_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.custom_entity_id = custom_entity_id
        # This parameter is required.
        self.custom_group_id = custom_group_id
        # This parameter is required.
        self.custom_view_id = custom_view_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.custom_entity_id is not None:
            result['CustomEntityId'] = self.custom_entity_id
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.custom_view_id is not None:
            result['CustomViewId'] = self.custom_view_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('CustomEntityId') is not None:
            self.custom_entity_id = m.get('CustomEntityId')
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('CustomViewId') is not None:
            self.custom_view_id = m.get('CustomViewId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteCustomViewResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaRequest(TeaModel):
    def __init__(
        self,
        media_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The IDs of the media files that you want to remove. Separate multiple IDs with commas (,). You can remove up to 10 media files at a time.
        # 
        # > You can obtain the ID of the media file from the response parameters of the [AddMedia](https://help.aliyun.com/document_detail/44458.html) operation. Alternatively, you can log on to the MPS console. In the left-side navigation pane, choose **Media Management** > **Media List**. Find the required video and click **Manage** in the Actions column. The ID of the video is displayed on the Basics tab.
        # 
        # This parameter is required.
        self.media_ids = media_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteMediaResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaTagRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        tag: str = None,
    ):
        # The ID of the media file for which you want to remove a tag. To obtain the ID of a media file, you can call the [AddMedia](https://help.aliyun.com/document_detail/44458.html) operation. Alternatively, perform the following operations in the ApsaraVideo Media Processing (MPS) console: In the left-side navigation pane, choose **Media Management** > **Media List**. Find the required video and click **Manage** in the Actions column. The ID of the video is displayed on the Basics tab.
        # 
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The media tag that you want to remove. The value is encoded in UTF-8 and can be up to 32 bytes in length.
        # 
        # > You can remove only one tag at a time.
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class DeleteMediaTagResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media workflow that you want to delete. To obtain the ID of the media workflow, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Workflow Settings** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
    ):
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The ID of the media workflow that is deleted.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow that is deleted.
        self.name = name
        # The status of the media workflow. The value is **Deleted**.
        self.state = state
        # The topology of the media workflow.
        self.topology = topology

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        return self


class DeleteMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: DeleteMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        # The information about the media workflow.
        self.media_workflow = media_workflow
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = DeleteMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePipelineRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue that you want to delete. To obtain the ID of the MPS queue, you can log on to the **MPS console** and choose **Global Settings** > **Pipelines** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeletePipelineResponseBody(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
        request_id: str = None,
    ):
        # The ID of the MPS queue that is deleted.
        self.pipeline_id = pipeline_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSmarttagTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The ID of the template that you want to delete. You can obtain the template ID from the response of the [AddSmarttagTemplate](https://help.aliyun.com/document_detail/187759.html) operation.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteSmarttagTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSmarttagTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSmarttagTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSmarttagTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The ID of the custom transcoding template that you want to delete. To obtain the ID of the custom transcoding template, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Global Settings** > **Encoding Templates** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the custom transcoding template that is deleted.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWaterMarkTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        water_mark_template_id: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The ID of the watermark template that you want to delete. To obtain the template ID, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Global Settings** > **Watermark Templates** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.water_mark_template_id = water_mark_template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        return self


class DeleteWaterMarkTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        water_mark_template_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the deleted watermark template.
        self.water_mark_template_id = water_mark_template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        return self


class DeleteWaterMarkTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWaterMarkTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWaterMarkTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImAuditRequest(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        contents: str = None,
        images: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        scenes: str = None,
    ):
        # The business type. By default, the public business type is used.
        self.biz_type = biz_type
        # The custom text entries. You can specify up to 5 text entries. The value must be a JSON array. You must specify at least one of the Images and Contents parameters.
        self.contents = contents
        # The image URLs. You can specify up to 5 image URLs. The value must be a JSON array. To view the URLs of the images, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Media Management** > **Media List** in the left-side navigation pane. You must set at least one of the Images and Contents parameters. The image to be moderated must meet the following limits. Otherwise, the moderation task may fail.
        # 
        # *   The image size cannot exceed 20 MB, the height or width of the image cannot exceed 30,000 pixels, and the image cannot exceed 0.25 billion pixels.
        # *   We recommend that you upload images of at least 256 × 256 pixels to ensure required moderation result.
        self.images = images
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The moderation scenarios. Separate multiple scenarios with commas (,). For example, if you specify {"porn","terrorism"} for this parameter, both pornographic content detection and terrorist content detection are performed on the images and text. Valid values:
        # 
        # *   porn: pornography
        # *   terrorism: terrorist content
        # *   ad: ad violation
        # *   qrcode: QR code
        # *   live: undesirable scene
        # *   logo: special logo
        # *   antispam: text anti-spam (valid only for text)
        # 
        # This parameter is required.
        self.scenes = scenes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.contents is not None:
            result['Contents'] = self.contents
        if self.images is not None:
            result['Images'] = self.images
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.scenes is not None:
            result['Scenes'] = self.scenes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('Contents') is not None:
            self.contents = m.get('Contents')
        if m.get('Images') is not None:
            self.images = m.get('Images')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Scenes') is not None:
            self.scenes = m.get('Scenes')
        return self


class ImAuditResponseBodyImageResultsResultResultsFrames(TeaModel):
    def __init__(
        self,
        rate: float = None,
        url: str = None,
    ):
        # The score of the confidence level. Valid values: 0 to 100. A higher confidence level indicates higher reliability of the moderation result. We recommend that you do not use this score in your business.
        self.rate = rate
        # The temporary access URL of the truncated frame. The URL is valid for 5 minutes.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rate is not None:
            result['rate'] = self.rate
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('rate') is not None:
            self.rate = m.get('rate')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ImAuditResponseBodyImageResultsResultResultsHintWordsInfo(TeaModel):
    def __init__(
        self,
        context: str = None,
    ):
        # The term hit by the detected text.
        self.context = context

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context is not None:
            result['context'] = self.context
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('context') is not None:
            self.context = m.get('context')
        return self


class ImAuditResponseBodyImageResultsResultResultsLogoData(TeaModel):
    def __init__(
        self,
        h: float = None,
        name: str = None,
        type: str = None,
        w: float = None,
        x: float = None,
        y: float = None,
    ):
        # The height of the logo area. Unit: pixel.
        self.h = h
        # The name of the detected logo.
        self.name = name
        # The type of the detected logo. For example, a value of TV indicates a controlled media logo.
        self.type = type
        # The width of the logo area. Unit: pixel.
        self.w = w
        # The distance between the upper-left corner of the logo area and the y-axis, with the upper-left corner of the image being the coordinate origin. Unit: pixel.
        self.x = x
        # The distance between the upper-left corner of the logo area and the x-axis, with the upper-left corner of the image being the coordinate origin. Unit: pixel.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.h is not None:
            result['h'] = self.h
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.w is not None:
            result['w'] = self.w
        if self.x is not None:
            result['x'] = self.x
        if self.y is not None:
            result['y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('h') is not None:
            self.h = m.get('h')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('w') is not None:
            self.w = m.get('w')
        if m.get('x') is not None:
            self.x = m.get('x')
        if m.get('y') is not None:
            self.y = m.get('y')
        return self


class ImAuditResponseBodyImageResultsResultResultsProgramCodeData(TeaModel):
    def __init__(
        self,
        h: float = None,
        w: float = None,
        x: float = None,
        y: float = None,
    ):
        # The height of the mini program code area. Unit: pixel.
        self.h = h
        # The width of the mini program code area. Unit: pixel.
        self.w = w
        # The distance between the upper-left corner of the mini program code area and the y-axis, with the upper-left corner of the image being the coordinate origin. Unit: pixel.
        self.x = x
        # The distance between the upper-left corner of the mini program code area and the x-axis, with the upper-left corner of the image being the coordinate origin. Unit: pixel.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.h is not None:
            result['h'] = self.h
        if self.w is not None:
            result['w'] = self.w
        if self.x is not None:
            result['x'] = self.x
        if self.y is not None:
            result['y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('h') is not None:
            self.h = m.get('h')
        if m.get('w') is not None:
            self.w = m.get('w')
        if m.get('x') is not None:
            self.x = m.get('x')
        if m.get('y') is not None:
            self.y = m.get('y')
        return self


class ImAuditResponseBodyImageResultsResultResultsQrcodeLocations(TeaModel):
    def __init__(
        self,
        h: float = None,
        qrcode: str = None,
        w: float = None,
        x: float = None,
        y: float = None,
    ):
        # The height of the QR code area. Unit: pixel.
        self.h = h
        # The URL that the detected QR code points to.
        self.qrcode = qrcode
        # The width of the QR code area. Unit: pixel.
        self.w = w
        # The distance between the upper-left corner of the QR code area and the y-axis, with the upper-left corner of the image being the coordinate origin. Unit: pixel.
        self.x = x
        # The distance between the upper-left corner of the QR code area and the x-axis, with the upper-left corner of the image being the coordinate origin. Unit: pixel.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.h is not None:
            result['h'] = self.h
        if self.qrcode is not None:
            result['qrcode'] = self.qrcode
        if self.w is not None:
            result['w'] = self.w
        if self.x is not None:
            result['x'] = self.x
        if self.y is not None:
            result['y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('h') is not None:
            self.h = m.get('h')
        if m.get('qrcode') is not None:
            self.qrcode = m.get('qrcode')
        if m.get('w') is not None:
            self.w = m.get('w')
        if m.get('x') is not None:
            self.x = m.get('x')
        if m.get('y') is not None:
            self.y = m.get('y')
        return self


class ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces(TeaModel):
    def __init__(
        self,
        idid: str = None,
        name: str = None,
        re: float = None,
    ):
        # The ID of the detected face. The value is a string.
        self.idid = idid
        # This value is a string, which indicates the name of a similar person.
        self.name = name
        # The score of the confidence level. The value is a float point number. Valid values: 0 to 100. A greater value indicates a higher confidence level for facial recognition.
        self.re = re

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.idid is not None:
            result['idid'] = self.idid
        if self.name is not None:
            result['name'] = self.name
        if self.re is not None:
            result['re'] = self.re
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('idid') is not None:
            self.idid = m.get('idid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('re') is not None:
            self.re = m.get('re')
        return self


class ImAuditResponseBodyImageResultsResultResultsSfaceData(TeaModel):
    def __init__(
        self,
        faces: List[ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces] = None,
        h: float = None,
        w: float = None,
        x: float = None,
        y: float = None,
    ):
        # The information about the face detected in the moderated image.
        self.faces = faces
        # The height of the face area. Unit: pixel.
        self.h = h
        # The width of the face area. Unit: pixel.
        self.w = w
        # The distance between the upper-left corner of the face area and the y-axis, with the upper-left corner of the image being the coordinate origin. Unit: pixel.
        self.x = x
        # The distance between the upper-left corner of the face area and the y-axis, with the upper-left corner of the image being the coordinate origin. Unit: pixel.
        self.y = y

    def validate(self):
        if self.faces:
            for k in self.faces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['faces'] = []
        if self.faces is not None:
            for k in self.faces:
                result['faces'].append(k.to_map() if k else None)
        if self.h is not None:
            result['h'] = self.h
        if self.w is not None:
            result['w'] = self.w
        if self.x is not None:
            result['x'] = self.x
        if self.y is not None:
            result['y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.faces = []
        if m.get('faces') is not None:
            for k in m.get('faces'):
                temp_model = ImAuditResponseBodyImageResultsResultResultsSfaceDataFaces()
                self.faces.append(temp_model.from_map(k))
        if m.get('h') is not None:
            self.h = m.get('h')
        if m.get('w') is not None:
            self.w = m.get('w')
        if m.get('x') is not None:
            self.x = m.get('x')
        if m.get('y') is not None:
            self.y = m.get('y')
        return self


class ImAuditResponseBodyImageResultsResultResults(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: float = None,
        scene: str = None,
        suggestion: str = None,
        frames: List[ImAuditResponseBodyImageResultsResultResultsFrames] = None,
        hint_words_info: List[ImAuditResponseBodyImageResultsResultResultsHintWordsInfo] = None,
        logo_data: List[ImAuditResponseBodyImageResultsResultResultsLogoData] = None,
        ocr_data: List[str] = None,
        program_code_data: List[ImAuditResponseBodyImageResultsResultResultsProgramCodeData] = None,
        qrcode_data: List[str] = None,
        qrcode_locations: List[ImAuditResponseBodyImageResultsResultResultsQrcodeLocations] = None,
        sface_data: List[ImAuditResponseBodyImageResultsResultResultsSfaceData] = None,
    ):
        # The category of the moderation results. Valid values vary based on the specified moderation scenario.
        # 
        # *   If the Scenes parameter is set to porn, the valid values are:
        # 
        #     *   normal: no pornographic content
        #     *   sexy: sexy content
        #     *   porn: pornographic content
        # 
        # *   If the Scenes parameter is set to terrorism, the valid values are:
        # 
        #     *   normal: no pornographic content
        #     *   bloody: bloody content
        #     *   explosion: explosions and smoke
        #     *   outfit: special costume
        #     *   logo: special logo
        #     *   weapon: weapon
        #     *   politics: political content
        #     *   violence: violence
        #     *   crowd: crowd
        #     *   parade: parade
        #     *   carcrash: car accident
        #     *   flag: flag
        #     *   location: landmark
        #     *   others: other content
        # 
        # *   If the Scenes parameter is set to ad, the valid values are:
        # 
        #     *   normal: no pornographic content
        #     *   ad: ad violation
        #     *   politics: politically sensitive content in text
        #     *   porn: pornographic content in text
        #     *   abuse: abuse in text
        #     *   terrorism: terrorist content in text
        #     *   contraband: prohibited content in text
        #     *   spam: junk content in text
        #     *   npx: illegal ad
        #     *   qrcode: QR code
        #     *   programCode: mini program code
        # 
        # *   If the Scenes parameter is set to qrcode, the valid values are:
        # 
        #     *   normal: no pornographic content
        #     *   qrcode: QR code
        #     *   programCode: mini program code
        # 
        # *   If the Scenes parameter is set to live, the valid values are:
        # 
        #     *   normal: no pornographic content
        #     *   meaningless: no content in the image, such as black or white screen
        #     *   PIP: picture-in-picture
        #     *   smoking: smoking
        #     *   drivelive: live broadcasting in a running vehicle
        # 
        # *   If the Scenes parameter is set to logo, the valid values are:
        # 
        #     *   normal: no pornographic content
        #     *   TV: controlled logo
        #     *   trademark: trademark
        self.label = label
        # The score of the confidence level. Valid values: 0 to 100. A greater value indicates a higher confidence level. If a value of pass is returned for the suggestion parameter, a higher confidence level indicates a higher probability that the content is normal. If a value of review or block is returned for the suggestion parameter, a higher confidence level indicates a higher probability that the content contains violations.
        # 
        # >  This score is for reference only. We strongly recommend that you do not use this score in your business. We recommend that you use the values that are returned for the suggestion, label, and sublabel parameters to determine whether the content contains violations. The sublabel parameter is returned by some operations.
        self.rate = rate
        # The image moderation scenario. Valid values:
        # 
        # *   porn: pornography
        # *   terrorism: terrorist content
        # *   ad: ad violation
        # *   qrcode: QR code
        # *   live: undesirable scene
        # *   logo: special logo
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   pass: The content passes the moderation. No further actions are required.
        # *   review: The moderation object contains suspected violations and requires human review.
        # *   block: The moderation object contains violations. We recommend that you delete or block the object.
        self.suggestion = suggestion
        # If the temporary access URL of the image is too long, a truncated temporary access URL is returned for each frame.
        self.frames = frames
        # The information about the term hit by the ad or violation text detected in the moderated image.
        self.hint_words_info = hint_words_info
        # The information about the logo detected in the moderated image.
        self.logo_data = logo_data
        # ocrData
        self.ocr_data = ocr_data
        # The location information of the mini program code detected in the moderated image.
        self.program_code_data = program_code_data
        # The information about the text that is included in the QR code detected in the moderated image.
        self.qrcode_data = qrcode_data
        # The coordinates of the QR code detected in the image.
        self.qrcode_locations = qrcode_locations
        # The information about the terrorist content detected in the moderated image.
        self.sface_data = sface_data

    def validate(self):
        if self.frames:
            for k in self.frames:
                if k:
                    k.validate()
        if self.hint_words_info:
            for k in self.hint_words_info:
                if k:
                    k.validate()
        if self.logo_data:
            for k in self.logo_data:
                if k:
                    k.validate()
        if self.program_code_data:
            for k in self.program_code_data:
                if k:
                    k.validate()
        if self.qrcode_locations:
            for k in self.qrcode_locations:
                if k:
                    k.validate()
        if self.sface_data:
            for k in self.sface_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        result['frames'] = []
        if self.frames is not None:
            for k in self.frames:
                result['frames'].append(k.to_map() if k else None)
        result['hintWordsInfo'] = []
        if self.hint_words_info is not None:
            for k in self.hint_words_info:
                result['hintWordsInfo'].append(k.to_map() if k else None)
        result['logoData'] = []
        if self.logo_data is not None:
            for k in self.logo_data:
                result['logoData'].append(k.to_map() if k else None)
        if self.ocr_data is not None:
            result['ocrData'] = self.ocr_data
        result['programCodeData'] = []
        if self.program_code_data is not None:
            for k in self.program_code_data:
                result['programCodeData'].append(k.to_map() if k else None)
        if self.qrcode_data is not None:
            result['qrcodeData'] = self.qrcode_data
        result['qrcodeLocations'] = []
        if self.qrcode_locations is not None:
            for k in self.qrcode_locations:
                result['qrcodeLocations'].append(k.to_map() if k else None)
        result['sfaceData'] = []
        if self.sface_data is not None:
            for k in self.sface_data:
                result['sfaceData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        self.frames = []
        if m.get('frames') is not None:
            for k in m.get('frames'):
                temp_model = ImAuditResponseBodyImageResultsResultResultsFrames()
                self.frames.append(temp_model.from_map(k))
        self.hint_words_info = []
        if m.get('hintWordsInfo') is not None:
            for k in m.get('hintWordsInfo'):
                temp_model = ImAuditResponseBodyImageResultsResultResultsHintWordsInfo()
                self.hint_words_info.append(temp_model.from_map(k))
        self.logo_data = []
        if m.get('logoData') is not None:
            for k in m.get('logoData'):
                temp_model = ImAuditResponseBodyImageResultsResultResultsLogoData()
                self.logo_data.append(temp_model.from_map(k))
        if m.get('ocrData') is not None:
            self.ocr_data = m.get('ocrData')
        self.program_code_data = []
        if m.get('programCodeData') is not None:
            for k in m.get('programCodeData'):
                temp_model = ImAuditResponseBodyImageResultsResultResultsProgramCodeData()
                self.program_code_data.append(temp_model.from_map(k))
        if m.get('qrcodeData') is not None:
            self.qrcode_data = m.get('qrcodeData')
        self.qrcode_locations = []
        if m.get('qrcodeLocations') is not None:
            for k in m.get('qrcodeLocations'):
                temp_model = ImAuditResponseBodyImageResultsResultResultsQrcodeLocations()
                self.qrcode_locations.append(temp_model.from_map(k))
        self.sface_data = []
        if m.get('sfaceData') is not None:
            for k in m.get('sfaceData'):
                temp_model = ImAuditResponseBodyImageResultsResultResultsSfaceData()
                self.sface_data.append(temp_model.from_map(k))
        return self


class ImAuditResponseBodyImageResultsResult(TeaModel):
    def __init__(
        self,
        code: int = None,
        data_id: str = None,
        extras: Dict[str, Any] = None,
        msg: str = None,
        results: List[ImAuditResponseBodyImageResultsResultResults] = None,
        task_id: str = None,
        url: str = None,
    ):
        # The error code. The error code is the same as the HTTP status code. This parameter is not returned if the request is successful.
        self.code = code
        # The ID of the moderated object.
        # 
        # >  If you set the dataId parameter in the moderation request, the dataId parameter is returned in the response.
        self.data_id = data_id
        # The additional information about the image. If ad is specified for the Scenes parameter, the following content may be returned for this parameter: hitLibInfo: the information about the custom text library that is hit by the text in the image. The value of this parameter is an array. For more information about the structure, see [hitLibInfo](https://help.aliyun.com/document_detail/268644.html).
        self.extras = extras
        # The message that is returned for the request.
        self.msg = msg
        # The returned data. If the call is successful, the array in the returned results contains one or more elements. Each element is a struct.
        self.results = results
        # The ID of the moderation task.
        self.task_id = task_id
        # The URL of the moderated object.
        self.url = url

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_id is not None:
            result['dataId'] = self.data_id
        if self.extras is not None:
            result['extras'] = self.extras
        if self.msg is not None:
            result['msg'] = self.msg
        result['results'] = []
        if self.results is not None:
            for k in self.results:
                result['results'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataId') is not None:
            self.data_id = m.get('dataId')
        if m.get('extras') is not None:
            self.extras = m.get('extras')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        self.results = []
        if m.get('results') is not None:
            for k in m.get('results'):
                temp_model = ImAuditResponseBodyImageResultsResultResults()
                self.results.append(temp_model.from_map(k))
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ImAuditResponseBodyImageResults(TeaModel):
    def __init__(
        self,
        result: List[ImAuditResponseBodyImageResultsResult] = None,
    ):
        # The image moderation results.
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ImAuditResponseBodyImageResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class ImAuditResponseBodyTextResultsResultResultsDetailsContexts(TeaModel):
    def __init__(
        self,
        context: str = None,
        lib_code: str = None,
        lib_name: str = None,
        positions: List[str] = None,
        rule_type: str = None,
    ):
        # The term that the moderated text hits. If the text hits a term, the term is returned. If the text hits the algorithmic model, this parameter is not returned.
        self.context = context
        # The code of the custom text library. This parameter is returned if the moderated text hits a term in the custom text library.
        self.lib_code = lib_code
        # The name of the custom text library. This parameter is returned if the moderated text hits a term in the custom text library.
        self.lib_name = lib_name
        # The position of the term that the moderated text hits in the original text.
        self.positions = positions
        # The behavior rule. This parameter is returned if the moderated text hits the behavior rule. Valid values:
        # 
        # *   user_id
        # *   ip
        # *   umid
        # *   content
        # *   similar_content
        # *   imei
        # *   imsi
        self.rule_type = rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context is not None:
            result['context'] = self.context
        if self.lib_code is not None:
            result['libCode'] = self.lib_code
        if self.lib_name is not None:
            result['libName'] = self.lib_name
        if self.positions is not None:
            result['positions'] = self.positions
        if self.rule_type is not None:
            result['ruleType'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('libCode') is not None:
            self.lib_code = m.get('libCode')
        if m.get('libName') is not None:
            self.lib_name = m.get('libName')
        if m.get('positions') is not None:
            self.positions = m.get('positions')
        if m.get('ruleType') is not None:
            self.rule_type = m.get('ruleType')
        return self


class ImAuditResponseBodyTextResultsResultResultsDetails(TeaModel):
    def __init__(
        self,
        label: str = None,
        contexts: List[ImAuditResponseBodyTextResultsResultResultsDetailsContexts] = None,
    ):
        # The category of the risky content that the moderated text hits. Valid values:
        # 
        # *   spam: spam
        # *   ad: ad
        # *   politics: political content
        # *   terrorism: terrorist content
        # *   abuse: abuse
        # *   porn: pornographic content
        # *   flood: excessive junk content
        # *   contraband: prohibited content
        # *   meaningless: meaningless content
        # *   customized: custom content, such as a custom keyword
        self.label = label
        # The context information of the risky content that the moderated text hits.
        self.contexts = contexts

    def validate(self):
        if self.contexts:
            for k in self.contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        result['contexts'] = []
        if self.contexts is not None:
            for k in self.contexts:
                result['contexts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        self.contexts = []
        if m.get('contexts') is not None:
            for k in m.get('contexts'):
                temp_model = ImAuditResponseBodyTextResultsResultResultsDetailsContexts()
                self.contexts.append(temp_model.from_map(k))
        return self


class ImAuditResponseBodyTextResultsResultResults(TeaModel):
    def __init__(
        self,
        details: List[ImAuditResponseBodyTextResultsResultResultsDetails] = None,
        label: str = None,
        rate: float = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The risky content that the moderated text hits. A text entry can hit multiple pieces of risky content.
        self.details = details
        # The category of the moderation result for the moderated text. Valid values:
        # 
        # *   normal: normal content
        # *   spam: spam
        # *   ad: ad
        # *   politics: political content
        # *   terrorism: terrorist content
        # *   abuse: abuse
        # *   porn: pornographic content
        # *   flood: excessive junk content
        # *   contraband: prohibited content
        # *   meaningless: meaningless content
        # *   customized: custom content, such as a custom keyword
        self.label = label
        # The score of the confidence level. Valid values: 0 to 100. A greater value indicates a higher confidence level. If a value of pass is returned for the suggestion parameter, a higher confidence level indicates a higher probability that the content is normal. If a value of review or block is returned for the suggestion parameter, a higher confidence level indicates a higher probability that the content contains violations.
        # 
        # >  This score is for reference only. We strongly recommend that you do not use this score in your business. We recommend that you use the values that are returned for the suggestion, label, and sublabel parameters to determine whether the content contains violations. The sublabel parameter is returned by some operations.
        self.rate = rate
        # The moderation scenario.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   pass: The content passes the moderation.
        # *   review: The content needs to be manually reviewed again.
        # *   block: The content contains violations. We recommend that you delete or block the content.
        self.suggestion = suggestion

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['details'] = []
        if self.details is not None:
            for k in self.details:
                result['details'].append(k.to_map() if k else None)
        if self.label is not None:
            result['label'] = self.label
        if self.rate is not None:
            result['rate'] = self.rate
        if self.scene is not None:
            result['scene'] = self.scene
        if self.suggestion is not None:
            result['suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.details = []
        if m.get('details') is not None:
            for k in m.get('details'):
                temp_model = ImAuditResponseBodyTextResultsResultResultsDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('rate') is not None:
            self.rate = m.get('rate')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('suggestion') is not None:
            self.suggestion = m.get('suggestion')
        return self


class ImAuditResponseBodyTextResultsResult(TeaModel):
    def __init__(
        self,
        code: int = None,
        content: str = None,
        data_id: str = None,
        msg: str = None,
        results: List[ImAuditResponseBodyTextResultsResultResults] = None,
        task_id: str = None,
    ):
        # The error code. The error code is the same as the HTTP status code. For more information, see [Error codes](https://help.aliyun.com/document_detail/29254.html).
        self.code = code
        # The text that you specify in the moderation request.
        self.content = content
        # The sequence number of the text.
        self.data_id = data_id
        # The message that is returned for the request.
        self.msg = msg
        # The returned data. If the HTTP status code 200 is returned, the array in the returned results contains one or more elements. Each element is a struct.
        self.results = results
        # The ID of the moderation task.
        self.task_id = task_id

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.content is not None:
            result['content'] = self.content
        if self.data_id is not None:
            result['dataId'] = self.data_id
        if self.msg is not None:
            result['msg'] = self.msg
        result['results'] = []
        if self.results is not None:
            for k in self.results:
                result['results'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('dataId') is not None:
            self.data_id = m.get('dataId')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        self.results = []
        if m.get('results') is not None:
            for k in m.get('results'):
                temp_model = ImAuditResponseBodyTextResultsResultResults()
                self.results.append(temp_model.from_map(k))
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class ImAuditResponseBodyTextResults(TeaModel):
    def __init__(
        self,
        result: List[ImAuditResponseBodyTextResultsResult] = None,
    ):
        # The text moderation results.
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ImAuditResponseBodyTextResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class ImAuditResponseBody(TeaModel):
    def __init__(
        self,
        image_quota_exceed: bool = None,
        image_results: ImAuditResponseBodyImageResults = None,
        request_id: str = None,
        text_quota_exceed: bool = None,
        text_results: ImAuditResponseBodyTextResults = None,
    ):
        # Indicates whether the image moderation QPS exceeds the limit. Valid values: true and false. A value of true indicates that the QPS does not exceed the limit. A value of false indicates that the QPS exceeds the limit.
        self.image_quota_exceed = image_quota_exceed
        # The image moderation results. If the HTTP status code 200 is returned, the array in the returned results contains one or more elements. For more information about the parameters, see [Data returned by the ImAudit operation](https://help.aliyun.com/document_detail/268644.html).
        self.image_results = image_results
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the text moderation QPS exceeds the limit. Valid values: true and false.
        self.text_quota_exceed = text_quota_exceed
        # The text moderation results. If the HTTP status code 200 is returned, the array in the returned results contains one or more elements. For more information about the parameters, see [Data returned by the ImAudit operation](https://help.aliyun.com/document_detail/268644.html).
        self.text_results = text_results

    def validate(self):
        if self.image_results:
            self.image_results.validate()
        if self.text_results:
            self.text_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_quota_exceed is not None:
            result['ImageQuotaExceed'] = self.image_quota_exceed
        if self.image_results is not None:
            result['ImageResults'] = self.image_results.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.text_quota_exceed is not None:
            result['TextQuotaExceed'] = self.text_quota_exceed
        if self.text_results is not None:
            result['TextResults'] = self.text_results.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageQuotaExceed') is not None:
            self.image_quota_exceed = m.get('ImageQuotaExceed')
        if m.get('ImageResults') is not None:
            temp_model = ImAuditResponseBodyImageResults()
            self.image_results = temp_model.from_map(m['ImageResults'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TextQuotaExceed') is not None:
            self.text_quota_exceed = m.get('TextQuotaExceed')
        if m.get('TextResults') is not None:
            temp_model = ImAuditResponseBodyTextResults()
            self.text_results = temp_model.from_map(m['TextResults'])
        return self


class ImAuditResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImAuditResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImAuditResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportFpShotJobRequest(TeaModel):
    def __init__(
        self,
        fp_dbid: str = None,
        fp_import_config: str = None,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        user_data: str = None,
    ):
        # The ID of the text fingerprint library to which the text file is imported. You can specify only one job of importing text files to a text fingerprint library at a time. You can obtain the library ID from the response parameters of the [CreateFpShotDB](https://help.aliyun.com/document_detail/170149.html) operation.
        # 
        # This parameter is required.
        self.fp_dbid = fp_dbid
        # The job configurations. The value must be a JSON object. Example: `{"SaveType":"onlysave"}`. The `SaveType` field indicates the storage type. Valid values of the SaveType field:
        # 
        # *   **save**: The fingerprints of the text file are saved to the text fingerprint library only if the text file is not duplicated with content in the text fingerprint library.
        # *   **onlysave**: The fingerprints of the text file are saved to the text fingerprint library.
        # 
        # This parameter is required.
        self.fp_import_config = fp_import_config
        # The Object Storage Service (OSS) URL of the text file to be imported to the text fingerprint library. The value must be a JSON object. Example: {"Bucket":"example-bucket","Location":"oss-cn-shanghai","Object":"example.flv"}.
        # 
        # > The OSS bucket must reside in the same region as your MPS service.
        # 
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the ApsaraVideo Media Processing (MPS) queue. To view the ID of the MPS queue, perform the following steps: Log on to the **MPS console**. In the left-side navigation pane, choose **Global Settings** > **Pipelines**. The MPS queue is associated with a specified Message Service (MNS) topic. You can submit jobs for different services to different MPS queues. If you do not specify this parameter, the job is submitted to the default MPS queue and no MNS topic is associated with the MPS queue.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The user-defined data. The value can contain letters, digits, and special characters. The value can be up to 128 bytes in length.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.fp_import_config is not None:
            result['FpImportConfig'] = self.fp_import_config
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('FpImportConfig') is not None:
            self.fp_import_config = m.get('FpImportConfig')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ImportFpShotJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the import job. We recommend that you save this ID for subsequent operations.
        self.job_id = job_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportFpShotJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportFpShotJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportFpShotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllMediaBucketRequest(TeaModel):
    def __init__(
        self,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The maximum number of media buckets to return. Valid values: 1 to 100. Default value: 50.
        self.maximum_page_size = maximum_page_size
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. The response to the first request contains this parameter, which is added to the next request.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListAllMediaBucketResponseBodyMediaBucketListMediaBucket(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        referer: str = None,
        type: str = None,
    ):
        # The name of the media bucket.
        self.bucket = bucket
        # The settings of Object Storage Service (OSS) hotlink protection. For more information, see [Hotlink protection](https://help.aliyun.com/document_detail/31869.html).
        self.referer = referer
        # The type of the media bucket. Valid values:
        # 
        # *   Input: input media bucket
        # *   Output: output media bucket
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.referer is not None:
            result['Referer'] = self.referer
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Referer') is not None:
            self.referer = m.get('Referer')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAllMediaBucketResponseBodyMediaBucketList(TeaModel):
    def __init__(
        self,
        media_bucket: List[ListAllMediaBucketResponseBodyMediaBucketListMediaBucket] = None,
    ):
        self.media_bucket = media_bucket

    def validate(self):
        if self.media_bucket:
            for k in self.media_bucket:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaBucket'] = []
        if self.media_bucket is not None:
            for k in self.media_bucket:
                result['MediaBucket'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_bucket = []
        if m.get('MediaBucket') is not None:
            for k in m.get('MediaBucket'):
                temp_model = ListAllMediaBucketResponseBodyMediaBucketListMediaBucket()
                self.media_bucket.append(temp_model.from_map(k))
        return self


class ListAllMediaBucketResponseBody(TeaModel):
    def __init__(
        self,
        media_bucket_list: ListAllMediaBucketResponseBodyMediaBucketList = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The media buckets returned.
        self.media_bucket_list = media_bucket_list
        # The returned value of NextPageToken is a pagination token, which can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_bucket_list:
            self.media_bucket_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_bucket_list is not None:
            result['MediaBucketList'] = self.media_bucket_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaBucketList') is not None:
            temp_model = ListAllMediaBucketResponseBodyMediaBucketList()
            self.media_bucket_list = temp_model.from_map(m['MediaBucketList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAllMediaBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAllMediaBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAllMediaBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomEntitiesRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        custom_group_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.custom_group_id = custom_group_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity(TeaModel):
    def __init__(
        self,
        custom_entity_id: str = None,
        custom_entity_info: str = None,
        custom_entity_name: str = None,
    ):
        self.custom_entity_id = custom_entity_id
        self.custom_entity_info = custom_entity_info
        self.custom_entity_name = custom_entity_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_entity_id is not None:
            result['CustomEntityId'] = self.custom_entity_id
        if self.custom_entity_info is not None:
            result['CustomEntityInfo'] = self.custom_entity_info
        if self.custom_entity_name is not None:
            result['CustomEntityName'] = self.custom_entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomEntityId') is not None:
            self.custom_entity_id = m.get('CustomEntityId')
        if m.get('CustomEntityInfo') is not None:
            self.custom_entity_info = m.get('CustomEntityInfo')
        if m.get('CustomEntityName') is not None:
            self.custom_entity_name = m.get('CustomEntityName')
        return self


class ListCustomEntitiesResponseBodyCustomEntities(TeaModel):
    def __init__(
        self,
        custom_entity: List[ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity] = None,
    ):
        self.custom_entity = custom_entity

    def validate(self):
        if self.custom_entity:
            for k in self.custom_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomEntity'] = []
        if self.custom_entity is not None:
            for k in self.custom_entity:
                result['CustomEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_entity = []
        if m.get('CustomEntity') is not None:
            for k in m.get('CustomEntity'):
                temp_model = ListCustomEntitiesResponseBodyCustomEntitiesCustomEntity()
                self.custom_entity.append(temp_model.from_map(k))
        return self


class ListCustomEntitiesResponseBody(TeaModel):
    def __init__(
        self,
        custom_entities: ListCustomEntitiesResponseBodyCustomEntities = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.custom_entities = custom_entities
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.custom_entities:
            self.custom_entities.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_entities is not None:
            result['CustomEntities'] = self.custom_entities.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomEntities') is not None:
            temp_model = ListCustomEntitiesResponseBodyCustomEntities()
            self.custom_entities = temp_model.from_map(m['CustomEntities'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCustomEntitiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomEntitiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomEntitiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomGroupsRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListCustomGroupsResponseBodyCustomGroupsCustomGroup(TeaModel):
    def __init__(
        self,
        custom_group_description: str = None,
        custom_group_id: str = None,
        custom_group_name: str = None,
    ):
        self.custom_group_description = custom_group_description
        self.custom_group_id = custom_group_id
        self.custom_group_name = custom_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_group_description is not None:
            result['CustomGroupDescription'] = self.custom_group_description
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.custom_group_name is not None:
            result['CustomGroupName'] = self.custom_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomGroupDescription') is not None:
            self.custom_group_description = m.get('CustomGroupDescription')
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('CustomGroupName') is not None:
            self.custom_group_name = m.get('CustomGroupName')
        return self


class ListCustomGroupsResponseBodyCustomGroups(TeaModel):
    def __init__(
        self,
        custom_group: List[ListCustomGroupsResponseBodyCustomGroupsCustomGroup] = None,
    ):
        self.custom_group = custom_group

    def validate(self):
        if self.custom_group:
            for k in self.custom_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomGroup'] = []
        if self.custom_group is not None:
            for k in self.custom_group:
                result['CustomGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_group = []
        if m.get('CustomGroup') is not None:
            for k in m.get('CustomGroup'):
                temp_model = ListCustomGroupsResponseBodyCustomGroupsCustomGroup()
                self.custom_group.append(temp_model.from_map(k))
        return self


class ListCustomGroupsResponseBody(TeaModel):
    def __init__(
        self,
        custom_groups: ListCustomGroupsResponseBodyCustomGroups = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.custom_groups = custom_groups
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.custom_groups:
            self.custom_groups.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_groups is not None:
            result['CustomGroups'] = self.custom_groups.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomGroups') is not None:
            temp_model = ListCustomGroupsResponseBodyCustomGroups()
            self.custom_groups = temp_model.from_map(m['CustomGroups'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCustomGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomPersonsRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        person_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the figure library about which you want to query information. The ID is used to uniquely identify a custom figure library. Make sure that the ID is unique. If you do not specify this parameter, the operation returns all the custom figure libraries. The ID can be up to 120 characters in length and is not case-sensitive.
        # 
        # > You cannot specify the ID of the system figure library for this parameter.
        self.category_id = category_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the figure about which you want to query information. The ID is used to uniquely identify a figure. Make sure that the ID is unique. If you do not specify this parameter, the operation returns the information about all the figures in the specified figure library.
        self.person_id = person_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.person_id is not None:
            result['PersonId'] = self.person_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PersonId') is not None:
            self.person_id = m.get('PersonId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace(TeaModel):
    def __init__(
        self,
        face_id: str = None,
        image_url: str = None,
    ):
        # The ID of the face.
        self.face_id = face_id
        # The URL of the facial image that was registered for the figure.
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.face_id is not None:
            result['FaceId'] = self.face_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FaceId') is not None:
            self.face_id = m.get('FaceId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        return self


class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces(TeaModel):
    def __init__(
        self,
        face: List[ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace] = None,
    ):
        self.face = face

    def validate(self):
        if self.face:
            for k in self.face:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Face'] = []
        if self.face is not None:
            for k in self.face:
                result['Face'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.face = []
        if m.get('Face') is not None:
            for k in m.get('Face'):
                temp_model = ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace()
                self.face.append(temp_model.from_map(k))
        return self


class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson(TeaModel):
    def __init__(
        self,
        faces: ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces = None,
        person_description: str = None,
        person_id: str = None,
        person_name: str = None,
    ):
        # The array of the faces.
        self.faces = faces
        # The description of the figure.
        self.person_description = person_description
        # The ID of the figure.
        self.person_id = person_id
        # The name of the figure.
        self.person_name = person_name

    def validate(self):
        if self.faces:
            self.faces.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.faces is not None:
            result['Faces'] = self.faces.to_map()
        if self.person_description is not None:
            result['PersonDescription'] = self.person_description
        if self.person_id is not None:
            result['PersonId'] = self.person_id
        if self.person_name is not None:
            result['PersonName'] = self.person_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Faces') is not None:
            temp_model = ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces()
            self.faces = temp_model.from_map(m['Faces'])
        if m.get('PersonDescription') is not None:
            self.person_description = m.get('PersonDescription')
        if m.get('PersonId') is not None:
            self.person_id = m.get('PersonId')
        if m.get('PersonName') is not None:
            self.person_name = m.get('PersonName')
        return self


class ListCustomPersonsResponseBodyCategoriesCategoryPersons(TeaModel):
    def __init__(
        self,
        person: List[ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson] = None,
    ):
        self.person = person

    def validate(self):
        if self.person:
            for k in self.person:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Person'] = []
        if self.person is not None:
            for k in self.person:
                result['Person'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.person = []
        if m.get('Person') is not None:
            for k in m.get('Person'):
                temp_model = ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson()
                self.person.append(temp_model.from_map(k))
        return self


class ListCustomPersonsResponseBodyCategoriesCategory(TeaModel):
    def __init__(
        self,
        category_description: str = None,
        category_id: str = None,
        category_name: str = None,
        persons: ListCustomPersonsResponseBodyCategoriesCategoryPersons = None,
    ):
        # The description of the figure library.
        self.category_description = category_description
        # The ID of the figure library.
        self.category_id = category_id
        # The name of the figure library.
        self.category_name = category_name
        # The array of the figures.
        self.persons = persons

    def validate(self):
        if self.persons:
            self.persons.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_description is not None:
            result['CategoryDescription'] = self.category_description
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.category_name is not None:
            result['CategoryName'] = self.category_name
        if self.persons is not None:
            result['Persons'] = self.persons.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryDescription') is not None:
            self.category_description = m.get('CategoryDescription')
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('CategoryName') is not None:
            self.category_name = m.get('CategoryName')
        if m.get('Persons') is not None:
            temp_model = ListCustomPersonsResponseBodyCategoriesCategoryPersons()
            self.persons = temp_model.from_map(m['Persons'])
        return self


class ListCustomPersonsResponseBodyCategories(TeaModel):
    def __init__(
        self,
        category: List[ListCustomPersonsResponseBodyCategoriesCategory] = None,
    ):
        self.category = category

    def validate(self):
        if self.category:
            for k in self.category:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Category'] = []
        if self.category is not None:
            for k in self.category:
                result['Category'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.category = []
        if m.get('Category') is not None:
            for k in m.get('Category'):
                temp_model = ListCustomPersonsResponseBodyCategoriesCategory()
                self.category.append(temp_model.from_map(k))
        return self


class ListCustomPersonsResponseBody(TeaModel):
    def __init__(
        self,
        categories: ListCustomPersonsResponseBodyCategories = None,
        request_id: str = None,
    ):
        # The array of the figure libraries.
        self.categories = categories
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.categories:
            self.categories.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories is not None:
            result['Categories'] = self.categories.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            temp_model = ListCustomPersonsResponseBodyCategories()
            self.categories = temp_model.from_map(m['Categories'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCustomPersonsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomPersonsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomPersonsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomViewsRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        custom_entity_id: str = None,
        custom_group_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.custom_entity_id = custom_entity_id
        # This parameter is required.
        self.custom_group_id = custom_group_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.custom_entity_id is not None:
            result['CustomEntityId'] = self.custom_entity_id
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('CustomEntityId') is not None:
            self.custom_entity_id = m.get('CustomEntityId')
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListCustomViewsResponseBodyCustomViewsCustomView(TeaModel):
    def __init__(
        self,
        custom_view_id: str = None,
        image_url: str = None,
    ):
        self.custom_view_id = custom_view_id
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_view_id is not None:
            result['CustomViewId'] = self.custom_view_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomViewId') is not None:
            self.custom_view_id = m.get('CustomViewId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        return self


class ListCustomViewsResponseBodyCustomViews(TeaModel):
    def __init__(
        self,
        custom_view: List[ListCustomViewsResponseBodyCustomViewsCustomView] = None,
    ):
        self.custom_view = custom_view

    def validate(self):
        if self.custom_view:
            for k in self.custom_view:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomView'] = []
        if self.custom_view is not None:
            for k in self.custom_view:
                result['CustomView'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_view = []
        if m.get('CustomView') is not None:
            for k in m.get('CustomView'):
                temp_model = ListCustomViewsResponseBodyCustomViewsCustomView()
                self.custom_view.append(temp_model.from_map(k))
        return self


class ListCustomViewsResponseBody(TeaModel):
    def __init__(
        self,
        custom_views: ListCustomViewsResponseBodyCustomViews = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.custom_views = custom_views
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.custom_views:
            self.custom_views.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_views is not None:
            result['CustomViews'] = self.custom_views.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomViews') is not None:
            temp_model = ListCustomViewsResponseBodyCustomViews()
            self.custom_views = temp_model.from_map(m['CustomViews'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCustomViewsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomViewsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomViewsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFpShotDBRequest(TeaModel):
    def __init__(
        self,
        fp_dbids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media fingerprint library. You can obtain the library ID from the response parameters of the [CreateFpShotDB](https://help.aliyun.com/document_detail/170149.html) operation. You can query up to 10 libraries at a time. Separate multiple library IDs with commas (,).
        self.fp_dbids = fp_dbids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_dbids is not None:
            result['FpDBIds'] = self.fp_dbids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpDBIds') is not None:
            self.fp_dbids = m.get('FpDBIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListFpShotDBResponseBodyFpShotDBListFpShotDB(TeaModel):
    def __init__(
        self,
        description: str = None,
        fp_dbid: str = None,
        model_id: int = None,
        name: str = None,
        status: str = None,
    ):
        # The description of the media fingerprint library.
        self.description = description
        # The ID of the media fingerprint library.
        self.fp_dbid = fp_dbid
        # The model ID of the media fingerprint library. A value of **11** indicates that the library is a text fingerprint library. A value of **12** indicates that the library is a video fingerprint library. A value of **13** indicates that the library is an audio fingerprint library. A value of **14** indicates that the library is an image fingerprint library.
        self.model_id = model_id
        # The name of the media fingerprint library.
        self.name = name
        # The status of the media fingerprint library. Default value: **offline**. ****Valid values:
        # 
        # *   **offline**: The media fingerprint library is offline.
        # *   **active**: The media fingerprint library is online.
        # *   **paused**: The media fingerprint library is paused.
        # *   **deleted**: The media fingerprint library is deleted.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListFpShotDBResponseBodyFpShotDBList(TeaModel):
    def __init__(
        self,
        fp_shot_db: List[ListFpShotDBResponseBodyFpShotDBListFpShotDB] = None,
    ):
        self.fp_shot_db = fp_shot_db

    def validate(self):
        if self.fp_shot_db:
            for k in self.fp_shot_db:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpShotDB'] = []
        if self.fp_shot_db is not None:
            for k in self.fp_shot_db:
                result['FpShotDB'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_shot_db = []
        if m.get('FpShotDB') is not None:
            for k in m.get('FpShotDB'):
                temp_model = ListFpShotDBResponseBodyFpShotDBListFpShotDB()
                self.fp_shot_db.append(temp_model.from_map(k))
        return self


class ListFpShotDBResponseBodyNonExistIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class ListFpShotDBResponseBody(TeaModel):
    def __init__(
        self,
        fp_shot_dblist: ListFpShotDBResponseBodyFpShotDBList = None,
        non_exist_ids: ListFpShotDBResponseBodyNonExistIds = None,
        request_id: str = None,
    ):
        # The media fingerprint libraries.
        self.fp_shot_dblist = fp_shot_dblist
        # The IDs of the media fingerprint libraries that do not exist.
        self.non_exist_ids = non_exist_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.fp_shot_dblist:
            self.fp_shot_dblist.validate()
        if self.non_exist_ids:
            self.non_exist_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_shot_dblist is not None:
            result['FpShotDBList'] = self.fp_shot_dblist.to_map()
        if self.non_exist_ids is not None:
            result['NonExistIds'] = self.non_exist_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpShotDBList') is not None:
            temp_model = ListFpShotDBResponseBodyFpShotDBList()
            self.fp_shot_dblist = temp_model.from_map(m['FpShotDBList'])
        if m.get('NonExistIds') is not None:
            temp_model = ListFpShotDBResponseBodyNonExistIds()
            self.non_exist_ids = temp_model.from_map(m['NonExistIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListFpShotDBResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFpShotDBResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFpShotDBResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFpShotFilesRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        fp_dbid: str = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        start_time: str = None,
    ):
        # The end of the time range to query. The media files to be returned must be stored before the specified end time. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
        # 
        # > This parameter is available only in the China (Beijing), China (Hangzhou), and China (Shanghai) regions.
        self.end_time = end_time
        # The ID of the media fingerprint library whose files you want to query. You can obtain the library ID from the response parameters of the [CreateFpShotDB](https://help.aliyun.com/document_detail/170149.html) operation.
        # 
        # This parameter is required.
        self.fp_dbid = fp_dbid
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The number of entries to return on each page. Default value: 20.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The beginning of the time range to query. The media files to be returned must be stored after the specified start time. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
        # 
        # > This parameter is available only in the China (Beijing), China (Hangzhou), and China (Shanghai) regions.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the input file resides.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListFpShotFilesResponseBodyFpShotFileListFpShotFile(TeaModel):
    def __init__(
        self,
        file_id: str = None,
        input_file: ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile = None,
        primary_key: str = None,
        store_time: str = None,
    ):
        # The ID of the video file.
        self.file_id = file_id
        # The information about the input file.
        self.input_file = input_file
        # The unique primary key of the input video.
        self.primary_key = primary_key
        # The time when the media fingerprint file was stored. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.
        # 
        # > This parameter is available only in the China (Beijing), China (Hangzhou), and China (Shanghai) regions.
        self.store_time = store_time

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.store_time is not None:
            result['StoreTime'] = self.store_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('InputFile') is not None:
            temp_model = ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('StoreTime') is not None:
            self.store_time = m.get('StoreTime')
        return self


class ListFpShotFilesResponseBodyFpShotFileList(TeaModel):
    def __init__(
        self,
        fp_shot_file: List[ListFpShotFilesResponseBodyFpShotFileListFpShotFile] = None,
    ):
        self.fp_shot_file = fp_shot_file

    def validate(self):
        if self.fp_shot_file:
            for k in self.fp_shot_file:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpShotFile'] = []
        if self.fp_shot_file is not None:
            for k in self.fp_shot_file:
                result['FpShotFile'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_shot_file = []
        if m.get('FpShotFile') is not None:
            for k in m.get('FpShotFile'):
                temp_model = ListFpShotFilesResponseBodyFpShotFileListFpShotFile()
                self.fp_shot_file.append(temp_model.from_map(k))
        return self


class ListFpShotFilesResponseBody(TeaModel):
    def __init__(
        self,
        fp_shot_file_list: ListFpShotFilesResponseBodyFpShotFileList = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The media fingerprint files. For more information, see the "FpShotFile" section of the [Data types](https://help.aliyun.com/document_detail/29251.html) topic.
        self.fp_shot_file_list = fp_shot_file_list
        # The returned value of NextPageToken is a pagination token, which can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.fp_shot_file_list:
            self.fp_shot_file_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_shot_file_list is not None:
            result['FpShotFileList'] = self.fp_shot_file_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpShotFileList') is not None:
            temp_model = ListFpShotFilesResponseBodyFpShotFileList()
            self.fp_shot_file_list = temp_model.from_map(m['FpShotFileList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListFpShotFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFpShotFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFpShotFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFpShotImportJobRequest(TeaModel):
    def __init__(
        self,
        job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The job IDs. You can obtain the job IDs from the response to the [ImportFpShotJob](https://help.aliyun.com/document_detail/312262.html) operation. You can specify a maximum of 10 job IDs in a request. Separate multiple job IDs with commas (,).
        # 
        # This parameter is required.
        self.job_ids = job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListFpShotImportJobResponseBodyFpShotImportJobList(TeaModel):
    def __init__(
        self,
        code: str = None,
        create_time: str = None,
        finish_time: str = None,
        fp_dbid: str = None,
        fp_import_config: str = None,
        id: str = None,
        input: str = None,
        message: str = None,
        pipeline_id: str = None,
        process_message: str = None,
        status: str = None,
        user_data: str = None,
    ):
        # The error code returned when the job fails.
        self.code = code
        # The time when the job was created.
        self.create_time = create_time
        # The time when the job was completed.
        self.finish_time = finish_time
        # The ID of the text fingerprint library.
        self.fp_dbid = fp_dbid
        # The import configuration.
        self.fp_import_config = fp_import_config
        # The job ID.
        self.id = id
        # The input file.
        self.input = input
        # The error message returned when the job fails.
        self.message = message
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the job is submitted.
        self.pipeline_id = pipeline_id
        # The processing information of the job.
        self.process_message = process_message
        # The status of the job. Valid values:
        # 
        # *   Processing: The job is in progress.
        # *   Fail: The job fails.
        # *   Success: The job is successful.
        self.status = status
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.fp_import_config is not None:
            result['FpImportConfig'] = self.fp_import_config
        if self.id is not None:
            result['Id'] = self.id
        if self.input is not None:
            result['Input'] = self.input
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.process_message is not None:
            result['ProcessMessage'] = self.process_message
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('FpImportConfig') is not None:
            self.fp_import_config = m.get('FpImportConfig')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ProcessMessage') is not None:
            self.process_message = m.get('ProcessMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListFpShotImportJobResponseBody(TeaModel):
    def __init__(
        self,
        fp_shot_import_job_list: List[ListFpShotImportJobResponseBodyFpShotImportJobList] = None,
        non_exist_ids: List[str] = None,
        request_id: str = None,
    ):
        # The jobs of importing text files to a text fingerprint library.
        self.fp_shot_import_job_list = fp_shot_import_job_list
        # The job IDs that do not exist. This parameter is not returned if all specified job IDs exist.
        self.non_exist_ids = non_exist_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.fp_shot_import_job_list:
            for k in self.fp_shot_import_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpShotImportJobList'] = []
        if self.fp_shot_import_job_list is not None:
            for k in self.fp_shot_import_job_list:
                result['FpShotImportJobList'].append(k.to_map() if k else None)
        if self.non_exist_ids is not None:
            result['NonExistIds'] = self.non_exist_ids
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_shot_import_job_list = []
        if m.get('FpShotImportJobList') is not None:
            for k in m.get('FpShotImportJobList'):
                temp_model = ListFpShotImportJobResponseBodyFpShotImportJobList()
                self.fp_shot_import_job_list.append(temp_model.from_map(k))
        if m.get('NonExistIds') is not None:
            self.non_exist_ids = m.get('NonExistIds')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListFpShotImportJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFpShotImportJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFpShotImportJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListJobRequest(TeaModel):
    def __init__(
        self,
        end_of_job_created_time_range: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        start_of_job_created_time_range: str = None,
        state: str = None,
    ):
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
        self.end_of_job_created_time_range = end_of_job_created_time_range
        # The number of entries per page.
        # 
        # *   Default value: **10**.
        # *   Valid values: **1 to 100**.
        self.maximum_page_size = maximum_page_size
        # The token that is used to retrieve the next page of the query results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextPageToken.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue to which the job is submitted. To obtain the ID of an MPS queue, you can log on to the [MPS console](https://mps.console.aliyun.com/overview) and choose **Global Settings** > **MPS Queue and Callback** in the left-side navigation pane.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
        self.start_of_job_created_time_range = start_of_job_created_time_range
        # The state of the transcoding job. Default value: **All**. Valid values:
        # 
        # *   **All**\
        # *   **Submitted**\
        # *   **Transcoding**\
        # *   **TranscodeSuccess**\
        # *   **TranscodeFail**\
        # *   **TranscodeCancelled**\
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_job_created_time_range is not None:
            result['EndOfJobCreatedTimeRange'] = self.end_of_job_created_time_range
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_of_job_created_time_range is not None:
            result['StartOfJobCreatedTimeRange'] = self.start_of_job_created_time_range
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfJobCreatedTimeRange') is not None:
            self.end_of_job_created_time_range = m.get('EndOfJobCreatedTimeRange')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartOfJobCreatedTimeRange') is not None:
            self.start_of_job_created_time_range = m.get('StartOfJobCreatedTimeRange')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListJobResponseBodyJobListJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the job input is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the job input is stored.
        self.location = location
        # The name of the OSS object that is used as the job input.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListJobResponseBodyJobListJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the job failed. This parameter is not returned if the job was successful.
        self.error_code = error_code
        # The error message returned if the job failed. This parameter is not returned if the job was successful.
        self.error_message = error_message
        # The ID of the message returned if the job was successful.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class ListJobResponseBodyJobListJobOutputAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        # The volume adjustment range.
        # 
        # *   Unit: decibel.
        # *   Default value: **-20**.
        self.level = level
        # The method that is used to adjust the volume. Valid values:
        # 
        # *   **auto**\
        # *   **dynamic**\
        # *   **linear**\
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class ListJobResponseBodyJobListJobOutputAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
        volume: ListJobResponseBodyJobListJobOutputAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.bitrate = bitrate
        # The number of sound channels.
        # 
        # *   If the value of Codec is mp3, the value of this parameter can only be 1 or 2.
        # *   If the value of Codec is aac, the value of this parameter can only be 1, 2, 4, 5, 6, or 8.
        # *   Default value: 2.
        self.channels = channels
        # The audio codec.
        # 
        # *   Valid values: aac, mp3, vorbis, and flac.
        # *   Default value: **aac**.
        self.codec = codec
        # The codec profile of the audio. Valid values if the value of Codec is aac: aaclow, aache, aachev2, aacld, and aaceld.
        self.profile = profile
        # The level of quality control on the audio.
        self.qscale = qscale
        # The sampling rate.
        # 
        # *   Valid values: 22050, 32000, 44100, 48000, and 96000.
        # *   Unit: Hz.
        # *   Default value: 44100.
        # *   If the video container format is FLV and the audio codec is MP3, the value of this parameter cannot be 32000, 48000, or 96000. If the audio codec is MP3, the value of this parameter cannot be 96000.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class ListJobResponseBodyJobListJobOutputClipTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        seek: str = None,
    ):
        # The duration of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Valid values: `[00:00:00.000,23:59:59.999]` or `[0.000,86399.999]`.
        # *   Examples: 01:00:59.999 and 32000.23.
        self.duration = duration
        # The point in time when the clip starts.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Valid values: `[00:00:00.000,23:59:59.999]` or `[0.000,86399.999]`.
        # *   Examples: 01:59:59.999 and 32000.23.
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class ListJobResponseBodyJobListJobOutputClip(TeaModel):
    def __init__(
        self,
        time_span: ListJobResponseBodyJobListJobOutputClipTimeSpan = None,
    ):
        # The time span of the clip.
        self.time_span = time_span

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeSpan') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputClipTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        return self


class ListJobResponseBodyJobListJobOutputContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        # 
        # *   Default value: mp4.
        # *   Video formats include FLV, MP4, HLS (M3U8 + TS), and MPEG-DASH (MPD + fMP4).
        # *   Audio formats include MP3, MP4, Ogg, FLAC, and M4A.
        # *   Image formats include GIF and WebP.
        # *   If the container format is GIF, the video codec must be GIF.
        # *   If the container format is WebP, the video codec must be WebP.
        # *   If the container format is FLV, the video codec cannot be H.265.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class ListJobResponseBodyJobListJobOutputEncryption(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        key_type: str = None,
        key_uri: str = None,
        skip_cnt: str = None,
        type: str = None,
    ):
        # The encryption ID.
        self.id = id
        # The key that is used to encrypt the video.
        self.key = key
        # The key encryption method. Valid values: Base64 and KMS.
        # 
        # >  For example, if the key is encryptionkey128, you can encrypt the key in the Base64 format or use Key Management Service (KMS) to encrypt the key.``````
        self.key_type = key_type
        # The URL that is used to request the key. The URL is Base64-encoded.
        self.key_uri = key_uri
        # The number of unencrypted frames at the beginning of the video. Leaving these frames unencrypted enables video playback to quickly start.
        self.skip_cnt = skip_cnt
        # The encryption type. Only hls-aes-128 may be returned.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.key is not None:
            result['Key'] = self.key
        if self.key_type is not None:
            result['KeyType'] = self.key_type
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.skip_cnt is not None:
            result['SkipCnt'] = self.skip_cnt
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('KeyType') is not None:
            self.key_type = m.get('KeyType')
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('SkipCnt') is not None:
            self.skip_cnt = m.get('SkipCnt')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS(TeaModel):
    def __init__(
        self,
        md_5support: bool = None,
        size_support: bool = None,
    ):
        # Indicates whether the MD5 value of the TS file is included in the M3U8 file. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.md_5support = md_5support
        # Indicates whether the size of the TS file is included in the M3U8 file.
        # 
        # *   **true**\
        # *   **false**\
        self.size_support = size_support

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5support is not None:
            result['Md5Support'] = self.md_5support
        if self.size_support is not None:
            result['SizeSupport'] = self.size_support
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5Support') is not None:
            self.md_5support = m.get('Md5Support')
        if m.get('SizeSupport') is not None:
            self.size_support = m.get('SizeSupport')
        return self


class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport(TeaModel):
    def __init__(
        self,
        ts: ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS = None,
    ):
        # The non-standard support configurations for TS files. The value is a JSON object. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html).
        self.ts = ts

    def validate(self):
        if self.ts:
            self.ts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['TS'] = self.ts.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TS') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS()
            self.ts = temp_model.from_map(m['TS'])
        return self


class ListJobResponseBodyJobListJobOutputMergeListMerge(TeaModel):
    def __init__(
        self,
        duration: str = None,
        merge_url: str = None,
        role_arn: str = None,
        start: str = None,
    ):
        # The duration of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Examples: 01:59:59.999 and 32000.23.
        self.duration = duration
        # The OSS URL of the clip.
        # 
        # *   Example: `http://example-bucket-****.oss-cn-hangzhou.aliyuncs.com/example-object.flv`.
        # *   The object must be URL-encoded by using the UTF-8 standard.
        self.merge_url = merge_url
        # The Alibaba Cloud Resource Name (ARN) of the Resource Access Management (RAM) role used for delegated authorization.
        self.role_arn = role_arn
        # The start point in time of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Examples: 01:59:59.999 and 32000.23.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.merge_url is not None:
            result['MergeURL'] = self.merge_url
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MergeURL') is not None:
            self.merge_url = m.get('MergeURL')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class ListJobResponseBodyJobListJobOutputMergeList(TeaModel):
    def __init__(
        self,
        merge: List[ListJobResponseBodyJobListJobOutputMergeListMerge] = None,
    ):
        self.merge = merge

    def validate(self):
        if self.merge:
            for k in self.merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Merge'] = []
        if self.merge is not None:
            for k in self.merge:
                result['Merge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.merge = []
        if m.get('Merge') is not None:
            for k in m.get('Merge'):
                temp_model = ListJobResponseBodyJobListJobOutputMergeListMerge()
                self.merge.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        # The color dithering algorithm of the palette. Valid values: **sierra** and **bayer**.
        self.dither_mode = dither_mode
        # The duration for which the final frame is paused. Unit: centisecond.
        self.final_delay = final_delay
        # Indicates whether a custom palette is used. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_custom_palette = is_custom_palette
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class ListJobResponseBodyJobListJobOutputMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The length of the segment. The value must be an integer. Unit: seconds.
        # 
        # *   Valid values: [1,10].
        # *   Default value: 10.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class ListJobResponseBodyJobListJobOutputMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class ListJobResponseBodyJobListJobOutputMuxConfig(TeaModel):
    def __init__(
        self,
        gif: ListJobResponseBodyJobListJobOutputMuxConfigGif = None,
        segment: ListJobResponseBodyJobListJobOutputMuxConfigSegment = None,
        webp: ListJobResponseBodyJobListJobOutputMuxConfigWebp = None,
    ):
        # The transmuxing configurations for GIF.
        self.gif = gif
        # The segment configurations. The value is a JSON object.
        self.segment = segment
        # The transmuxing configurations for WebP.
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class ListJobResponseBodyJobListJobOutputOpeningListOpening(TeaModel):
    def __init__(
        self,
        height: str = None,
        start: str = None,
        width: str = None,
        open_url: str = None,
    ):
        # The height of the opening part. Valid values: values in the range of (0, 4096), -1, and full.
        # 
        # *   Default value: **-1**.
        # *   A value of -1 indicates that the height of the source of the opening part is retained.
        # *   A value of full indicates that the height of the opening part equals the height of the main part.
        self.height = height
        # The amount of time after which the opening part is played. The value starts from 0.
        # 
        # *   Unit: seconds.
        # *   Default value: **0**.
        self.start = start
        # The width of the opening part. Valid values: values in the range of (0, 4096), -1, and full.
        # 
        # *   Default value: **-1**.
        # *   A value of -1 indicates that the width of the source of the opening part is retained.
        # *   A value of full indicates that the width of the opening part equals the width of the main part.
        self.width = width
        # The OSS URL of the opening part.
        self.open_url = open_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.start is not None:
            result['Start'] = self.start
        if self.width is not None:
            result['Width'] = self.width
        if self.open_url is not None:
            result['openUrl'] = self.open_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('openUrl') is not None:
            self.open_url = m.get('openUrl')
        return self


class ListJobResponseBodyJobListJobOutputOpeningList(TeaModel):
    def __init__(
        self,
        opening: List[ListJobResponseBodyJobListJobOutputOpeningListOpening] = None,
    ):
        self.opening = opening

    def validate(self):
        if self.opening:
            for k in self.opening:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Opening'] = []
        if self.opening is not None:
            for k in self.opening:
                result['Opening'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.opening = []
        if m.get('Opening') is not None:
            for k in m.get('Opening'):
                temp_model = ListJobResponseBodyJobListJobOutputOpeningListOpening()
                self.opening.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the output file is stored.
        self.location = location
        # The name of the OSS object that is used as the output file.
        self.object = object
        # The ARN of the RAM role used for delegated authorization.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
        message: str = None,
        out_subtitle_file: ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile = None,
        success: bool = None,
    ):
        # The video track. Format: 0:{Stream}:{Stream sequence number}, that is, 0:v:{video_index}. The value of Stream is v, which indicates a video stream. The sequence number is the index of the video stream in the list and starts from 0.
        self.map = map
        # The error message returned if the job failed to be created. This parameter is not returned if the job was created.
        self.message = message
        # The details of the output file.
        self.out_subtitle_file = out_subtitle_file
        # Indicates whether the job was created. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.out_subtitle_file:
            self.out_subtitle_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        if self.message is not None:
            result['Message'] = self.message
        if self.out_subtitle_file is not None:
            result['OutSubtitleFile'] = self.out_subtitle_file.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OutSubtitleFile') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile()
            self.out_subtitle_file = temp_model.from_map(m['OutSubtitleFile'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListJobResponseBodyJobListJobOutputOutSubtitleList(TeaModel):
    def __init__(
        self,
        out_subtitle: List[ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle] = None,
    ):
        self.out_subtitle = out_subtitle

    def validate(self):
        if self.out_subtitle:
            for k in self.out_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OutSubtitle'] = []
        if self.out_subtitle is not None:
            for k in self.out_subtitle:
                result['OutSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.out_subtitle = []
        if m.get('OutSubtitle') is not None:
            for k in m.get('OutSubtitle'):
                temp_model = ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle()
                self.out_subtitle.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the output file is stored.
        self.location = location
        # The name of the OSS object that is used as the output file.
        self.object = object
        # The ARN of the RAM role used for delegated authorization.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        # The total bitrate.
        self.bitrate = bitrate
        # The total duration.
        self.duration = duration
        # The full name of the container format.
        self.format_long_name = format_long_name
        # The short name of the container format. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format_name = format_name
        # The total number of program streams.
        self.num_programs = num_programs
        # The total number of media streams.
        self.num_streams = num_streams
        # The size of the file.
        self.size = size
        # The start time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate of the audio stream.
        self.bitrate = bitrate
        # The output layout of the sound channels.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration of the audio stream.
        self.duration = duration
        # The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
        self.index = index
        # The language of the audio stream. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata) and [ISO 639](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
        self.lang = lang
        # The total number of frames.
        self.num_frames = num_frames
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate of the audio stream.
        self.samplerate = samplerate
        # The start time.
        self.start_time = start_time
        # The time base of the audio stream.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        # The sequence number of the subtitle stream. The value indicates the position of the subtitle stream in all subtitle streams.
        self.index = index
        # The language of the subtitle stream.
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        # The average bitrate of the video stream.
        self.avg_bitrate = avg_bitrate
        # The maximum bandwidth that was consumed.
        self.cost_bandwidth = cost_bandwidth
        # The amount of time consumed to preload the video stream.
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        # The average frame rate of the video stream.
        self.avg_fps = avg_fps
        # The bitrate of the video stream.
        self.bitrate = bitrate
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The display aspect ratio (DAR).
        self.dar = dar
        # The duration of the video stream.
        self.duration = duration
        # The frame rate of the video stream.
        self.fps = fps
        # Indicates whether the video stream contains B-frames.
        self.has_bframes = has_bframes
        # The height of the video stream in pixels.
        self.height = height
        # The sequence number of the video stream. The value indicates the position of the video stream in all video streams.
        self.index = index
        # The language of the video stream. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata) and [ISO 639](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
        self.lang = lang
        # The codec level.
        self.level = level
        # The network bandwidth that was consumed.
        self.network_cost = network_cost
        # The total frame rate.
        self.num_frames = num_frames
        # The pixel format of the video stream.
        self.pix_fmt = pix_fmt
        # The codec profile.
        self.profile = profile
        # The sample aspect ratio (SAR) of the video stream.
        self.sar = sar
        # The start time.
        self.start_time = start_time
        # The time base of the video stream.
        self.timebase = timebase
        # The width of the video stream in pixels.
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList = None,
    ):
        # The audio streams.
        self.audio_stream_list = audio_stream_list
        # The subtitle streams.
        self.subtitle_stream_list = subtitle_stream_list
        # The video streams.
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class ListJobResponseBodyJobListJobOutputProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: ListJobResponseBodyJobListJobOutputPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: ListJobResponseBodyJobListJobOutputPropertiesStreams = None,
        width: str = None,
    ):
        # The bitrate of the video.
        self.bitrate = bitrate
        # The duration of the video.
        self.duration = duration
        # The format of the video.
        self.file_format = file_format
        # The size of the file.
        self.file_size = file_size
        # The format information.
        self.format = format
        # The frame rate of the video.
        self.fps = fps
        # The height of the video.
        self.height = height
        # The stream information.
        self.streams = streams
        # The width of the video.
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the input file is stored.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        font_name: str = None,
        input: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput = None,
    ):
        # The character set used by the external subtitle.
        # 
        # *   Valid values: UTF-8, GBK, BIG5, and auto.
        # *   Default value: **auto**.
        # 
        # >  If this parameter is set to auto, the detected character set may not be the actual character set. We recommend that you set this parameter to another value.
        self.char_enc = char_enc
        # The font of the hardcoded subtitles converted from external subtitles.
        self.font_name = font_name
        # The input subtitle file.
        # 
        # *   Files in the SRT or ASS format are supported. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html).
        # *   Example: `{"Bucket":"example-bucket","Location":"oss-cn-hangzhou","Object":"example.srt"}`.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('Input') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(TeaModel):
    def __init__(
        self,
        ext_subtitle: List[ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle] = None,
    ):
        self.ext_subtitle = ext_subtitle

    def validate(self):
        if self.ext_subtitle:
            for k in self.ext_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExtSubtitle'] = []
        if self.ext_subtitle is not None:
            for k in self.ext_subtitle:
                result['ExtSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ext_subtitle = []
        if m.get('ExtSubtitle') is not None:
            for k in m.get('ExtSubtitle'):
                temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle()
                self.ext_subtitle.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
    ):
        # The sequence number of the video stream. The sequence number is the index of the video stream in the list and starts from 0. If you do not set the corresponding parameter in the request, the default video stream is selected.
        self.map = map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList(TeaModel):
    def __init__(
        self,
        subtitle: List[ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle] = None,
    ):
        self.subtitle = subtitle

    def validate(self):
        if self.subtitle:
            for k in self.subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Subtitle'] = []
        if self.subtitle is not None:
            for k in self.subtitle:
                result['Subtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle = []
        if m.get('Subtitle') is not None:
            for k in m.get('Subtitle'):
                temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle()
                self.subtitle.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputSubtitleConfig(TeaModel):
    def __init__(
        self,
        ext_subtitle_list: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList = None,
        subtitle_list: ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList = None,
    ):
        # The external subtitles. The value is a JSON array.
        self.ext_subtitle_list = ext_subtitle_list
        # The subtitles.
        self.subtitle_list = subtitle_list

    def validate(self):
        if self.ext_subtitle_list:
            self.ext_subtitle_list.validate()
        if self.subtitle_list:
            self.subtitle_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_subtitle_list is not None:
            result['ExtSubtitleList'] = self.ext_subtitle_list.to_map()
        if self.subtitle_list is not None:
            result['SubtitleList'] = self.subtitle_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSubtitleList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList()
            self.ext_subtitle_list = temp_model.from_map(m['ExtSubtitleList'])
        if m.get('SubtitleList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList()
            self.subtitle_list = temp_model.from_map(m['SubtitleList'])
        return self


class ListJobResponseBodyJobListJobOutputSuperReso(TeaModel):
    def __init__(
        self,
        is_half_sample: str = None,
    ):
        # Indicates whether parameters related to the sampling rate are obtained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_half_sample = is_half_sample

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_half_sample is not None:
            result['IsHalfSample'] = self.is_half_sample
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsHalfSample') is not None:
            self.is_half_sample = m.get('IsHalfSample')
        return self


class ListJobResponseBodyJobListJobOutputTailSlateListTailSlate(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        blend_duration: str = None,
        height: str = None,
        is_merge_audio: bool = None,
        start: str = None,
        tail_url: str = None,
        width: str = None,
    ):
        # The color of the bars that are added to the ending part if the size of the ending part is smaller than that of the main part. Default value: **White**. For more information, see [Background colors](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/29253/cn_zh/1502784952344/color.txt?spm=a2c4g.11186623.2.63.1df840f74IH4Eq\\&file=color.txt).
        self.bg_color = bg_color
        # The duration of the transition between the main part and the ending part. A fade transition is used: The last frame of the main part fades out, and the first frame of the ending part fades in. Unit: seconds. Default value: 0.
        self.blend_duration = blend_duration
        # The height of the ending part. Valid values: values in the range of (0, 4096), -1, and full.
        # 
        # *   A value of -1 indicates that the height of the source of the ending part is retained.
        # *   A value of full indicates that the height of the ending part equals the height of the main part.
        # *   Default value: -1.
        self.height = height
        # Indicates whether the audio content of the ending part is merged. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_merge_audio = is_merge_audio
        # The start time.
        self.start = start
        # The OSS URL of the ending part.
        self.tail_url = tail_url
        # The width of the ending part. Valid values: values in the range of (0, 4096), -1, and full.
        # 
        # *   A value of -1 indicates that the width of the source of the ending part is retained. A value of full indicates that the width of the ending part equals the width of the main part.
        # *   Default value: -1.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.blend_duration is not None:
            result['BlendDuration'] = self.blend_duration
        if self.height is not None:
            result['Height'] = self.height
        if self.is_merge_audio is not None:
            result['IsMergeAudio'] = self.is_merge_audio
        if self.start is not None:
            result['Start'] = self.start
        if self.tail_url is not None:
            result['TailUrl'] = self.tail_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BlendDuration') is not None:
            self.blend_duration = m.get('BlendDuration')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('IsMergeAudio') is not None:
            self.is_merge_audio = m.get('IsMergeAudio')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('TailUrl') is not None:
            self.tail_url = m.get('TailUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputTailSlateList(TeaModel):
    def __init__(
        self,
        tail_slate: List[ListJobResponseBodyJobListJobOutputTailSlateListTailSlate] = None,
    ):
        self.tail_slate = tail_slate

    def validate(self):
        if self.tail_slate:
            for k in self.tail_slate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TailSlate'] = []
        if self.tail_slate is not None:
            for k in self.tail_slate:
                result['TailSlate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tail_slate = []
        if m.get('TailSlate') is not None:
            for k in m.get('TailSlate'):
                temp_model = ListJobResponseBodyJobListJobOutputTailSlateListTailSlate()
                self.tail_slate.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutputTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method of resolution adjustment. Default value: **none**. Valid values: rescale, crop, pad, and none.
        self.adj_dar_method = adj_dar_method
        # Indicates whether the audio bitrate is checked. If the bitrate of the output audio is higher than that of the input audio, the input bitrate is retained and the specified audio bitrate does not take effect. This parameter has a lower priority than IsCheckAudioBitrateFail. Valid values:
        # 
        # *   **true**\
        # 
        # *   **false**\
        # 
        # *   Default value:
        # 
        #     *   If this parameter is empty and the codec of the output audio is different from the codec of the input audio, the default value is false.
        #     *   If this parameter is empty and the codec of the output audio is the same as the codec of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Indicates whether the audio bitrate is checked. If the bitrate of the output audio is higher than that of the input audio, a transcoding failure is returned without transcoding the audio. This parameter has a higher priority than IsCheckAudioBitrate. Valid values:
        # 
        # *   **false**: The audio bitrate is checked.
        # *   **true**: The audio bitrate is not checked.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, the input resolution is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso = is_check_reso
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, a transcoding failure is returned. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the video bitrate is checked. If the bitrate of the output video is higher than that of the input video, the input bitrate is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Indicates whether the video bitrate is checked. If the bitrate of the output video is higher than that of the input video, a transcoding failure is returned without transcoding the video. This parameter has a higher priority than IsCheckVideoBitrate. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: false.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The transcoding mode.
        # 
        # *   Valid values: onepass, twopass, and CBR.
        # *   Default value: onepass.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class ListJobResponseBodyJobListJobOutputVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The maximum bitrate. Unit: Kbit/s.
        self.max = max
        # The minimum bitrate. Unit: Kbit/s.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class ListJobResponseBodyJobListJobOutputVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: ListJobResponseBodyJobListJobOutputVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The average bitrate of the video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The bitrate range of the video.
        self.bitrate_bnd = bitrate_bnd
        # The size of the buffer.
        self.bufsize = bufsize
        # The video codec. Valid values: **H.264**, **H.265**, **GIF**, and **WEBP**.
        self.codec = codec
        # The constant rate factor. If this parameter is returned, the value of Bitrate is invalid. Default value: **26**.
        self.crf = crf
        # The video cropping mode. Valid values:
        # 
        # *   **border**: automatically detects and removes black borders.
        # *   A value in the width:height:left:top format: crops the videos based on the custom settings. Example: 1280:800:0:140.
        self.crop = crop
        # The strength of the independent noise reduction algorithm.
        self.degrain = degrain
        # The frame rate.
        # 
        # *   The value is 60 if the frame rate of the input video exceeds 60.
        # *   Default value: the frame rate of the input file.
        self.fps = fps
        # The maximum number of frames between two keyframes. Default value: 250.
        self.gop = gop
        # The height of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: the height of the input video.
        self.height = height
        # The maximum frame rate.
        self.max_fps = max_fps
        # The maximum bitrate of the video. Unit: Kbit/s.
        self.maxrate = maxrate
        # The black borders that are added to the video. Unit: pixel.
        # 
        # *   Format: width:height:left:top.
        # *   Example: 1280:800:0:140.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. Default value: medium. Valid values:
        # 
        # *   **veryfast**\
        # *   **fast**\
        # *   **medium**\
        # *   **slow**\
        # *   **slower**\
        self.preset = preset
        # The codec profile. Valid values:
        # 
        # *   **baseline**: applicable to mobile devices.
        # *   **main**: applicable to standard-definition devices.
        # *   **high**: applicable to high-definition devices.
        # *   Default value: **high**.
        self.profile = profile
        # The level of quality control on the video.
        self.qscale = qscale
        # The priority of the resource.
        self.reso_priority = reso_priority
        # The scan mode. Valid values:
        # 
        # *   If this parameter is **empty**, the scan mode of the input file is used.
        # *   **auto**: automatic deinterlacing.
        # *   **progressive**: progressive scan.
        # *   **interlaced**: interlaced scan.
        # *   **By default**, this parameter is empty.
        # 
        # **Best practice**: Interlaced scan consumes less bandwidth than progressive scan, but the image quality is poor. Therefore, mainstream video production uses progressive scan.
        # 
        # *   If **progressive scan** or **interlaced scan** is used when the scan mode of the input file is neither of them, the transcoding job fails.
        # *   We recommend that you use **the scan mode of the input file** or **automatic deinterlacing** to improve compatibility.
        self.scan_mode = scan_mode
        # The width of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: the width of the input video.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the input file is stored.
        self.location = location
        # The name of the Object Storage Service (OSS) object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        input_file: ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile = None,
        refer_pos: str = None,
        type: str = None,
        water_mark_template_id: str = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark image relative to the output video. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. Default value: 0. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the horizontal offset.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the horizontal offset to the width in the output video resolution.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excess digits are automatically deleted.
        self.dx = dx
        # The vertical offset of the watermark image relative to the output video. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the vertical offset.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixel.
        # 
        # *   A decimal indicates the ratio of the vertical offset to the height in the output video resolution.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excess digits are automatically deleted.
        self.dy = dy
        # The height of the watermark. If this parameter is specified in the request, the corresponding parameter in the specified watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the watermark height.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixel.
        # 
        # *   A decimal indicates the ratio of the watermark height to the height in the output video resolution.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excess digits are automatically deleted.
        self.height = height
        # The watermark input file.
        self.input_file = input_file
        # The position of the watermark.
        # 
        # *   **TopRight**\
        # *   **TopLeft**\
        # *   **BottomRight**\
        # *   **BottomLeft**\
        self.refer_pos = refer_pos
        # The type of the watermark. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html). Valid values:
        # 
        # *   **Image**\
        # *   **Text**\
        self.type = type
        # The ID of the watermark template.
        self.water_mark_template_id = water_mark_template_id
        # The width of the watermark image. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the watermark width.
        # 
        #     *   Valid values: [8,4096].
        #     *   Unit: pixel.
        # 
        # *   A decimal indicates the ratio of the watermark width to the width in the output video resolution.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excess digits are automatically deleted.
        self.width = width

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.type is not None:
            result['Type'] = self.type
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('InputFile') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListJobResponseBodyJobListJobOutputWaterMarkList(TeaModel):
    def __init__(
        self,
        water_mark: List[ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark] = None,
    ):
        self.water_mark = water_mark

    def validate(self):
        if self.water_mark:
            for k in self.water_mark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMark'] = []
        if self.water_mark is not None:
            for k in self.water_mark:
                result['WaterMark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark = []
        if m.get('WaterMark') is not None:
            for k in m.get('WaterMark'):
                temp_model = ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark()
                self.water_mark.append(temp_model.from_map(k))
        return self


class ListJobResponseBodyJobListJobOutput(TeaModel):
    def __init__(
        self,
        audio: ListJobResponseBodyJobListJobOutputAudio = None,
        audio_stream_map: str = None,
        clip: ListJobResponseBodyJobListJobOutputClip = None,
        container: ListJobResponseBodyJobListJobOutputContainer = None,
        de_watermark: str = None,
        encryption: ListJobResponseBodyJobListJobOutputEncryption = None,
        m_3u8non_standard_support: ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport = None,
        merge_config_url: str = None,
        merge_list: ListJobResponseBodyJobListJobOutputMergeList = None,
        mux_config: ListJobResponseBodyJobListJobOutputMuxConfig = None,
        opening_list: ListJobResponseBodyJobListJobOutputOpeningList = None,
        out_subtitle_list: ListJobResponseBodyJobListJobOutputOutSubtitleList = None,
        output_file: ListJobResponseBodyJobListJobOutputOutputFile = None,
        priority: str = None,
        properties: ListJobResponseBodyJobListJobOutputProperties = None,
        rotate: str = None,
        subtitle_config: ListJobResponseBodyJobListJobOutputSubtitleConfig = None,
        super_reso: ListJobResponseBodyJobListJobOutputSuperReso = None,
        tail_slate_list: ListJobResponseBodyJobListJobOutputTailSlateList = None,
        template_id: str = None,
        trans_config: ListJobResponseBodyJobListJobOutputTransConfig = None,
        user_data: str = None,
        video: ListJobResponseBodyJobListJobOutputVideo = None,
        video_stream_map: str = None,
        water_mark_config_url: str = None,
        water_mark_list: ListJobResponseBodyJobListJobOutputWaterMarkList = None,
    ):
        # The audio configurations.
        self.audio = audio
        # The sequence number of the audio stream.
        # 
        # *   Format: `0:a:{Sequence number}`.
        # *   The sequence number is the index of the audio stream in the list and starts from 0. If no sequence number is specified, the default audio stream is used.
        self.audio_stream_map = audio_stream_map
        # The information about the clip.
        self.clip = clip
        # The container format configurations.
        self.container = container
        # The configurations of watermark blurring. The value is a JSON object. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html).
        self.de_watermark = de_watermark
        # The encryption configurations. Only outputs in the M3U8 format are supported.
        self.encryption = encryption
        # The non-standard support configuration for M3U8. The value must be a JSON object. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html).
        self.m_3u8non_standard_support = m_3u8non_standard_support
        # The URL of the merging configuration file. You can specify either MergeList or MergeConfigUrl when you submit the transcoding job.
        # 
        # *   The configuration file specified by MergeConfigUrl can contain up to 50 clips.
        # *   MergeConfigUrl indicates the URL of the configuration file for merging clips.
        # *   Make sure that the configuration file is stored as an object in OSS and that MPS can access the OSS object. For information about the file content, see the details of merging parameters.
        # *   Example of the content of the merging configuration file: `{"MergeList":[{"MergeURL":"http://exampleBucket****.oss-cn-hangzhou.aliyuncs.com/video_01.mp4"}]}`.
        self.merge_config_url = merge_config_url
        # The configurations for merging clips.
        self.merge_list = merge_list
        # The transmuxing configurations.
        self.mux_config = mux_config
        # The opening parts.
        self.opening_list = opening_list
        # The output subtitles.
        self.out_subtitle_list = out_subtitle_list
        # The details of the output file.
        self.output_file = output_file
        # The priority of the job in the MPS queue to which the job is added.
        # 
        # *   A value of 10 indicates the highest priority.
        # *   Default value: **6**.
        self.priority = priority
        # The media properties.
        self.properties = properties
        # The rotation angle of the video.
        self.rotate = rotate
        # The subtitle configurations.
        self.subtitle_config = subtitle_config
        # The configurations for using the resolution of the source video.
        self.super_reso = super_reso
        # The ending parts.
        self.tail_slate_list = tail_slate_list
        # The template ID.
        self.template_id = template_id
        # The general transcoding configurations. If this parameter is specified in the request, the corresponding parameters in the specified transcoding template are overwritten.
        self.trans_config = trans_config
        # The custom data.
        self.user_data = user_data
        # The video configurations.
        self.video = video
        # The sequence number of the video stream.
        # 
        # *   Format: 0:a:{Sequence number}. Example value: 0:a:0.
        # *   The sequence number is the index of the video stream in the list and starts from 0.
        # *   If no sequence number is specified, the default video stream is used.
        self.video_stream_map = video_stream_map
        # The URL of the watermark configuration file.
        self.water_mark_config_url = water_mark_config_url
        # The watermarks.
        self.water_mark_list = water_mark_list

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.clip:
            self.clip.validate()
        if self.container:
            self.container.validate()
        if self.encryption:
            self.encryption.validate()
        if self.m_3u8non_standard_support:
            self.m_3u8non_standard_support.validate()
        if self.merge_list:
            self.merge_list.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.opening_list:
            self.opening_list.validate()
        if self.out_subtitle_list:
            self.out_subtitle_list.validate()
        if self.output_file:
            self.output_file.validate()
        if self.properties:
            self.properties.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()
        if self.super_reso:
            self.super_reso.validate()
        if self.tail_slate_list:
            self.tail_slate_list.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()
        if self.water_mark_list:
            self.water_mark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.audio_stream_map is not None:
            result['AudioStreamMap'] = self.audio_stream_map
        if self.clip is not None:
            result['Clip'] = self.clip.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.de_watermark is not None:
            result['DeWatermark'] = self.de_watermark
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        if self.m_3u8non_standard_support is not None:
            result['M3U8NonStandardSupport'] = self.m_3u8non_standard_support.to_map()
        if self.merge_config_url is not None:
            result['MergeConfigUrl'] = self.merge_config_url
        if self.merge_list is not None:
            result['MergeList'] = self.merge_list.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.opening_list is not None:
            result['OpeningList'] = self.opening_list.to_map()
        if self.out_subtitle_list is not None:
            result['OutSubtitleList'] = self.out_subtitle_list.to_map()
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.subtitle_config is not None:
            result['SubtitleConfig'] = self.subtitle_config.to_map()
        if self.super_reso is not None:
            result['SuperReso'] = self.super_reso.to_map()
        if self.tail_slate_list is not None:
            result['TailSlateList'] = self.tail_slate_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video is not None:
            result['Video'] = self.video.to_map()
        if self.video_stream_map is not None:
            result['VideoStreamMap'] = self.video_stream_map
        if self.water_mark_config_url is not None:
            result['WaterMarkConfigUrl'] = self.water_mark_config_url
        if self.water_mark_list is not None:
            result['WaterMarkList'] = self.water_mark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('AudioStreamMap') is not None:
            self.audio_stream_map = m.get('AudioStreamMap')
        if m.get('Clip') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputClip()
            self.clip = temp_model.from_map(m['Clip'])
        if m.get('Container') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('DeWatermark') is not None:
            self.de_watermark = m.get('DeWatermark')
        if m.get('Encryption') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        if m.get('M3U8NonStandardSupport') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport()
            self.m_3u8non_standard_support = temp_model.from_map(m['M3U8NonStandardSupport'])
        if m.get('MergeConfigUrl') is not None:
            self.merge_config_url = m.get('MergeConfigUrl')
        if m.get('MergeList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMergeList()
            self.merge_list = temp_model.from_map(m['MergeList'])
        if m.get('MuxConfig') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('OpeningList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputOpeningList()
            self.opening_list = temp_model.from_map(m['OpeningList'])
        if m.get('OutSubtitleList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputOutSubtitleList()
            self.out_subtitle_list = temp_model.from_map(m['OutSubtitleList'])
        if m.get('OutputFile') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Properties') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('SubtitleConfig') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['SubtitleConfig'])
        if m.get('SuperReso') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputSuperReso()
            self.super_reso = temp_model.from_map(m['SuperReso'])
        if m.get('TailSlateList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputTailSlateList()
            self.tail_slate_list = temp_model.from_map(m['TailSlateList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Video') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputVideo()
            self.video = temp_model.from_map(m['Video'])
        if m.get('VideoStreamMap') is not None:
            self.video_stream_map = m.get('VideoStreamMap')
        if m.get('WaterMarkConfigUrl') is not None:
            self.water_mark_config_url = m.get('WaterMarkConfigUrl')
        if m.get('WaterMarkList') is not None:
            temp_model = ListJobResponseBodyJobListJobOutputWaterMarkList()
            self.water_mark_list = temp_model.from_map(m['WaterMarkList'])
        return self


class ListJobResponseBodyJobListJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        finish_time: str = None,
        input: ListJobResponseBodyJobListJobInput = None,
        job_id: str = None,
        mnsmessage_result: ListJobResponseBodyJobListJobMNSMessageResult = None,
        message: str = None,
        output: ListJobResponseBodyJobListJobOutput = None,
        percent: int = None,
        pipeline_id: str = None,
        state: str = None,
    ):
        # The error code returned if the job failed. This parameter is not returned if the job was successful.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The information about the job input.
        self.input = input
        # The task ID.
        self.job_id = job_id
        # The message sent by Message Service (MNS) to notify users of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the job failed. This parameter is not returned if the job was successful.
        self.message = message
        # The output of the job.
        self.output = output
        # The transcoding progress.
        self.percent = percent
        # The ID of the MPS queue.
        self.pipeline_id = pipeline_id
        # The state of the job. Valid values:
        # 
        # *   **Submitted**\
        # *   **Transcoding**\
        # *   **TranscodeSuccess**\
        # *   **TranscodeFail**\
        # *   **TranscodeCancelled**\
        self.state = state

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = ListJobResponseBodyJobListJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = ListJobResponseBodyJobListJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            temp_model = ListJobResponseBodyJobListJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListJobResponseBodyJobList(TeaModel):
    def __init__(
        self,
        job: List[ListJobResponseBodyJobListJob] = None,
    ):
        self.job = job

    def validate(self):
        if self.job:
            for k in self.job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Job'] = []
        if self.job is not None:
            for k in self.job:
                result['Job'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job = []
        if m.get('Job') is not None:
            for k in m.get('Job'):
                temp_model = ListJobResponseBodyJobListJob()
                self.job.append(temp_model.from_map(k))
        return self


class ListJobResponseBody(TeaModel):
    def __init__(
        self,
        job_list: ListJobResponseBodyJobList = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The transcoding jobs.
        self.job_list = job_list
        # The pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.job_list:
            self.job_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_list is not None:
            result['JobList'] = self.job_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobList') is not None:
            temp_model = ListJobResponseBodyJobList()
            self.job_list = temp_model.from_map(m['JobList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaWorkflowExecutionsRequest(TeaModel):
    def __init__(
        self,
        input_file_url: str = None,
        maximum_page_size: int = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The Object Storage Service (OSS) URL of the input file of the media workflow. The URL complies with RFC 3986 and is encoded in UTF-8, with reserved characters being percent-encoded. For more information, see [URL encoding](https://help.aliyun.com/document_detail/423796.html).
        self.input_file_url = input_file_url
        # The maximum number of media workflow execution instances to return. Valid values: `[1,100]`. Default value: **10**.
        self.maximum_page_size = maximum_page_size
        # The ID of the media workflow whose execution instances you want to query. To obtain the workflow ID, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Workflow Settings**.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow. To obtain the workflow name, you can log on to the **MPS console** and choose **Workflows** > **Workflow Settings**.
        self.media_workflow_name = media_workflow_name
        # The pagination token that is used in the next request to retrieve a new page of results. The value is a UUID that contains 32 characters. When you request the first page of query results, leave the NextPageToken parameter empty. When you request more query results, specify the value of the NextPageToken parameter returned in the query results on the previous page.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file_url is not None:
            result['InputFileURL'] = self.input_file_url
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFileURL') is not None:
            self.input_file_url = m.get('InputFileURL')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the job failed. If the job was successful, this parameter is not returned.
        self.error_code = error_code
        # The error message returned if the job failed. If the job was successful, this parameter is not returned.
        self.error_message = error_message
        # The ID of the success message. If the job failed, this parameter is not returned.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(TeaModel):
    def __init__(
        self,
        code: str = None,
        end_time: str = None,
        job_id: str = None,
        mnsmessage_result: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult = None,
        message: str = None,
        name: str = None,
        start_time: str = None,
        state: str = None,
        type: str = None,
    ):
        # The error code returned if the request failed.
        # 
        # *   The specific error code appears if the state of the activity is **Fail**.
        # *   This parameter is not returned if the state of the activity is **Success**.
        self.code = code
        # The end time of the activity.
        self.end_time = end_time
        # The ID of the job generated when the activity is executed. We recommend that you keep this ID for subsequent operation calls.
        self.job_id = job_id
        # The message sent by Message Service (MNS) to notify the user of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the request failed.
        # 
        # *   The detailed error message appears if the state of the activity is **Fail**.
        # *   This parameter is not returned if the state of the activity is **Success**.
        self.message = message
        # The name of the media workflow activity.
        # 
        # > The name of an activity in a media workflow is unique.
        self.name = name
        # The start time of the activity.
        self.start_time = start_time
        # The status of the activity. Valid values:
        # 
        # *   **Running**: The activity is being executed.
        # *   **Fail**: The activity failed to be executed.
        # *   **Skipped**: The activity was skipped.
        # *   **Success**: The activity was successfully executed.
        # 
        # > For example, the high-definition and standard-definition transcoding activities are to be run after the analysis activity is complete. The system determines the activity to run based on the analysis result. If the definition of the input video content is insufficient, the high-definition transcoding activity may be skipped.
        self.state = state
        # The type of the media workflow activity. Valid values: Start, Snapshot, Transcode, Analysis, and Report. For more information, see [Methods supported for media workflows](https://help.aliyun.com/document_detail/68494.html).
        self.type = type

    def validate(self):
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(TeaModel):
    def __init__(
        self,
        activity: List[ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity] = None,
    ):
        self.activity = activity

    def validate(self):
        if self.activity:
            for k in self.activity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Activity'] = []
        if self.activity is not None:
            for k in self.activity:
                result['Activity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.activity = []
        if m.get('Activity') is not None:
            for k in m.get('Activity'):
                temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity()
                self.activity.append(temp_model.from_map(k))
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input media file is stored.
        self.bucket = bucket
        # The OSS region in which the input file resides.
        self.location = location
        # The name of the OSS object that is used as the input media file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(TeaModel):
    def __init__(
        self,
        input_file: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile = None,
        user_data: str = None,
    ):
        # The information about the storage location of the input file of the media workflow in OSS.
        self.input_file = input_file
        # The custom data.
        self.user_data = user_data

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFile') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(TeaModel):
    def __init__(
        self,
        activity_list: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList = None,
        creation_time: str = None,
        input: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput = None,
        media_id: str = None,
        media_workflow_id: str = None,
        name: str = None,
        run_id: str = None,
        state: str = None,
    ):
        # The activities that are executed in the media workflow.
        self.activity_list = activity_list
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The custom data of the media workflow.
        self.input = input
        # The ID of the media file. A media file contains all the information about a media workflow.
        self.media_id = media_id
        # The ID of the media workflow.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow.
        self.name = name
        # The ID of the execution instance.
        self.run_id = run_id
        # The status of the media workflow. Valid values:
        # 
        # *   **running**: The execution is in progress.
        # *   **Completed**: The execution is complete.
        # 
        # > A value of Completed indicates that the execution is complete. For the information about whether each activity, such as Transcode or Snapshot, is successful, check the status of the activity.
        # 
        # *   **Fail**: The execution failed.
        # *   **Success**: The execution was successful.
        self.state = state

    def validate(self):
        if self.activity_list:
            self.activity_list.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_list is not None:
            result['ActivityList'] = self.activity_list.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.run_id is not None:
            result['RunId'] = self.run_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityList') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList()
            self.activity_list = temp_model.from_map(m['ActivityList'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Input') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList(TeaModel):
    def __init__(
        self,
        media_workflow_execution: List[ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution] = None,
    ):
        self.media_workflow_execution = media_workflow_execution

    def validate(self):
        if self.media_workflow_execution:
            for k in self.media_workflow_execution:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaWorkflowExecution'] = []
        if self.media_workflow_execution is not None:
            for k in self.media_workflow_execution:
                result['MediaWorkflowExecution'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_workflow_execution = []
        if m.get('MediaWorkflowExecution') is not None:
            for k in m.get('MediaWorkflowExecution'):
                temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution()
                self.media_workflow_execution.append(temp_model.from_map(k))
        return self


class ListMediaWorkflowExecutionsResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow_execution_list: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList = None,
        next_page_token: str = None,
        request_id: str = None,
    ):
        # The details of the media workflows.
        self.media_workflow_execution_list = media_workflow_execution_list
        # The returned value of NextPageToken is a pagination token, which can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow_execution_list:
            self.media_workflow_execution_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_execution_list is not None:
            result['MediaWorkflowExecutionList'] = self.media_workflow_execution_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowExecutionList') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList()
            self.media_workflow_execution_list = temp_model.from_map(m['MediaWorkflowExecutionList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMediaWorkflowExecutionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMediaWorkflowExecutionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaWorkflowExecutionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryAnalysisJobListRequest(TeaModel):
    def __init__(
        self,
        analysis_job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The template analysis job ID list.
        # 
        # This parameter is required.
        self.analysis_job_ids = analysis_job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_job_ids is not None:
            result['AnalysisJobIds'] = self.analysis_job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisJobIds') is not None:
            self.analysis_job_ids = m.get('AnalysisJobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop(TeaModel):
    def __init__(
        self,
        height: str = None,
        left: str = None,
        mode: str = None,
        top: str = None,
        width: str = None,
    ):
        # The height of the video image after the margins are cropped out.
        # 
        # >  This parameter is invalid if the Mode parameter is set to Auto or None.
        self.height = height
        # The left margin to be cropped out.
        # 
        # >  This parameter is invalid if the Mode parameter is set to Auto or None.
        self.left = left
        # The cropping mode. Valid values:
        # 
        # *   **Auto**: Cropping was automatically run.
        # *   **Force**: Cropping was forced to run.
        # *   **None**: Cropping was forced not to run.
        # *   This parameter is required if the value of the Crop parameter is not an empty JSON {}.
        self.mode = mode
        # The top margin to be cropped out.
        # 
        # >  This parameter is invalid if the Mode parameter is set to Auto or None.
        self.top = top
        # The width of the video image after the margins are cropped out.
        # 
        # >  This parameter is invalid if the Mode parameter is set to Auto or None.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.left is not None:
            result['Left'] = self.left
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.top is not None:
            result['Top'] = self.top
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl(TeaModel):
    def __init__(
        self,
        crop: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop = None,
        deinterlace: str = None,
    ):
        # The cropping configuration of the video image.
        self.crop = crop
        # Specifies whether deinterlacing was forced to run. Valid values:
        # 
        # *   **Auto**: Deinterlacing was automatically run.
        # *   **Force**: Deinterlacing was forced to run.
        # *   **None**: Deinterlacing was forced not to run.
        self.deinterlace = deinterlace

    def validate(self):
        if self.crop:
            self.crop.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.crop is not None:
            result['Crop'] = self.crop.to_map()
        if self.deinterlace is not None:
            result['Deinterlace'] = self.deinterlace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Crop') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop()
            self.crop = temp_model.from_map(m['Crop'])
        if m.get('Deinterlace') is not None:
            self.deinterlace = m.get('Deinterlace')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl(TeaModel):
    def __init__(
        self,
        method_streaming: str = None,
        rate_quality: str = None,
    ):
        # The playback mode. Valid values:
        # 
        # *   **network**: online playback.
        # *   **local**: playback on on-premises devices.
        # *   Default value: **network**.
        self.method_streaming = method_streaming
        # The quality level of the job output. Default value: **25**.
        self.rate_quality = rate_quality

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method_streaming is not None:
            result['MethodStreaming'] = self.method_streaming
        if self.rate_quality is not None:
            result['RateQuality'] = self.rate_quality
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MethodStreaming') is not None:
            self.method_streaming = m.get('MethodStreaming')
        if m.get('RateQuality') is not None:
            self.rate_quality = m.get('RateQuality')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig(TeaModel):
    def __init__(
        self,
        properties_control: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl = None,
        quality_control: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl = None,
    ):
        # The control on the attributes of the job output.
        self.properties_control = properties_control
        # The quality control on the job output.
        self.quality_control = quality_control

    def validate(self):
        if self.properties_control:
            self.properties_control.validate()
        if self.quality_control:
            self.quality_control.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.properties_control is not None:
            result['PropertiesControl'] = self.properties_control.to_map()
        if self.quality_control is not None:
            result['QualityControl'] = self.quality_control.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PropertiesControl') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl()
            self.properties_control = temp_model.from_map(m['PropertiesControl'])
        if m.get('QualityControl') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl()
            self.quality_control = temp_model.from_map(m['QualityControl'])
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The region in which OSS resides.
        self.location = location
        # The name of the Object Storage Service (OSS) object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the job failed. This parameter is not returned if the job was successful.
        self.error_code = error_code
        # The error message returned if the job failed. This parameter is not returned if the job was successful.
        self.error_message = error_message
        # The ID of the message returned if the job was successful. This parameter is not returned if the job failed.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Valid values: **8 to 1000**.
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.bitrate = bitrate
        # The number of sound channels. Default value: **2**.
        self.channels = channels
        # The audio codec. Default value: **aac**. Valid values:
        # 
        # *   **aac**\
        # *   **mp3**\
        # *   **vorbis**\
        # *   **flac**\
        self.codec = codec
        # The codec profile of the audio. Valid values when the **Codec** parameter is set to **aac**:
        # 
        # *   **aac_low**\
        # *   **aac_he**\
        # *   **aac_he_v2**\
        # *   **aac_ld**\
        # *   **aac_eld**\
        self.profile = profile
        # The level of quality control on the audio.
        self.qscale = qscale
        # The sampling rate.
        # 
        # *   Unit: Hz.
        # *   Default value: **44100**.
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        final_delay: str = None,
        loop: str = None,
    ):
        # The interval between two consecutive loops for the GIF format. Unit: 0.01 second. For example, a value of 500 indicates 5 seconds.
        self.final_delay = final_delay
        # The number of loops for the GIF or WebP format. Default value: 0.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The segment length. Unit: seconds.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif = None,
        segment: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment = None,
    ):
        # The transmuxing configurations for the GIF format.
        self.gif = gif
        # The segment configurations.
        self.segment = segment

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig(TeaModel):
    def __init__(
        self,
        trans_mode: str = None,
    ):
        # The transcoding mode. Default value: **onepass**. Valid values:
        # 
        # *   **onepass**\
        # *   **twopass**\
        # *   **CBR**\
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The upper limit of the total bitrate. Unit: Kbit/s.
        self.max = max
        # The lower limit of the total bitrate. Unit: Kbit/s.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        maxrate: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The average bitrate of the video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The average bitrate range of the video.
        self.bitrate_bnd = bitrate_bnd
        # The buffer size.
        # 
        # *   Unit: KB.
        # *   Default value: **6000**.
        self.bufsize = bufsize
        # The codec. Valid values: H.264 and H.265. Default value: **H.264**.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Default value when the the Codec parameter is set to H.264: **23**, default value when the the Codec parameter is set to H.265: **26**.
        # *   If this parameter is specified, the value of the Bitrate parameter becomes invalid.
        self.crf = crf
        # The strength of the independent noise reduction algorithm.
        self.degrain = degrain
        # The frame rate of the video.
        # 
        # *   The value is 60 if the frame rate of the input file exceeds 60.
        # *   Default value: **the frame rate of the input video**.
        self.fps = fps
        # The maximum number of frames between two keyframes. Default value: **250**.
        self.gop = gop
        # The height of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: **the height of the input video**.
        self.height = height
        # The maximum bitrate of the video.
        # 
        # *   Valid values: **10 to 50000**.
        # *   Unit: Kbit/s.
        self.maxrate = maxrate
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. Valid values: veryfast, fast, medium, slow, and slower. Default value: **medium**.
        self.preset = preset
        # The codec profile. Valid values:
        # 
        # *   **baseline**: applicable to mobile devices.
        # *   **main**: applicable to standard-definition devices.
        # *   **high**: applicable to high-definition devices.
        # *   Default value: **high**.
        self.profile = profile
        # The level of quality control on the video.
        self.qscale = qscale
        # The scan mode. Valid values:
        # 
        # *   **interlaced**\
        # *   **progressive**\
        self.scan_mode = scan_mode
        # The width of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: **the width of the input video**.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate(TeaModel):
    def __init__(
        self,
        audio: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio = None,
        container: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer = None,
        id: str = None,
        mux_config: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig = None,
        video: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo = None,
    ):
        # The audio codec configurations.
        self.audio = audio
        # The container format configurations.
        self.container = container
        # The transcoding template ID.
        self.id = id
        # The transmuxing configurations.
        self.mux_config = mux_config
        # The name of the template.
        self.name = name
        # The state of the template. Valid values:
        # 
        # *   **Normal**\
        # *   **Deleted**\
        self.state = state
        # The general transcoding configurations.
        self.trans_config = trans_config
        # The video codec configurations.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList(TeaModel):
    def __init__(
        self,
        template: List[QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob(TeaModel):
    def __init__(
        self,
        analysis_config: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig = None,
        code: str = None,
        creation_time: str = None,
        id: str = None,
        input_file: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile = None,
        mnsmessage_result: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult = None,
        message: str = None,
        percent: int = None,
        pipeline_id: str = None,
        priority: str = None,
        state: str = None,
        template_list: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList = None,
        user_data: str = None,
    ):
        # The job configurations.
        self.analysis_config = analysis_config
        # The error code returned if the job fails.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The ID of the template analysis job.
        self.id = id
        # The information about the job input.
        self.input_file = input_file
        # The message sent by Message Service (MNS) to notify users of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the job failed.
        self.message = message
        # The transcoding progress.
        self.percent = percent
        # The ID of the MPS queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job in the ApsaraVideo Media Processing (MPS) queue to which the job was submitted.
        # 
        # *   Valid values: **1 to 10**. The value 10 indicates the highest priority.
        # *   Default value: **10**.
        self.priority = priority
        # The job status.
        # 
        # *   **Submitted**: The job was submitted.
        # *   **Analyzing**: The job is in progress.
        # *   **Success**: The job was successful.
        # *   **Fail**: The job failed.
        self.state = state
        # The matched preset templates.
        self.template_list = template_list
        # The custom data.
        self.user_data = user_data

    def validate(self):
        if self.analysis_config:
            self.analysis_config.validate()
        if self.input_file:
            self.input_file.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_config is not None:
            result['AnalysisConfig'] = self.analysis_config.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.state is not None:
            result['State'] = self.state
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisConfig') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig()
            self.analysis_config = temp_model.from_map(m['AnalysisConfig'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InputFile') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateList') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryAnalysisJobListResponseBodyAnalysisJobList(TeaModel):
    def __init__(
        self,
        analysis_job: List[QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob] = None,
    ):
        self.analysis_job = analysis_job

    def validate(self):
        if self.analysis_job:
            for k in self.analysis_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AnalysisJob'] = []
        if self.analysis_job is not None:
            for k in self.analysis_job:
                result['AnalysisJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.analysis_job = []
        if m.get('AnalysisJob') is not None:
            for k in m.get('AnalysisJob'):
                temp_model = QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob()
                self.analysis_job.append(temp_model.from_map(k))
        return self


class QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryAnalysisJobListResponseBody(TeaModel):
    def __init__(
        self,
        analysis_job_list: QueryAnalysisJobListResponseBodyAnalysisJobList = None,
        non_exist_analysis_job_ids: QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds = None,
        request_id: str = None,
    ):
        # The IDs of template analysis jobs.
        self.analysis_job_list = analysis_job_list
        # The message sent by Message Service (MNS) to notify the user of the job result.
        self.non_exist_analysis_job_ids = non_exist_analysis_job_ids
        # The status of the job. Valid values:
        # 
        # *   **Submitted**: The job has been submitted.
        # *   **Analyzing**: The job is being run.
        # *   **Success**: The job is successful.
        # *   **Fail**: The job fails.
        self.request_id = request_id

    def validate(self):
        if self.analysis_job_list:
            self.analysis_job_list.validate()
        if self.non_exist_analysis_job_ids:
            self.non_exist_analysis_job_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_job_list is not None:
            result['AnalysisJobList'] = self.analysis_job_list.to_map()
        if self.non_exist_analysis_job_ids is not None:
            result['NonExistAnalysisJobIds'] = self.non_exist_analysis_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisJobList') is not None:
            temp_model = QueryAnalysisJobListResponseBodyAnalysisJobList()
            self.analysis_job_list = temp_model.from_map(m['AnalysisJobList'])
        if m.get('NonExistAnalysisJobIds') is not None:
            temp_model = QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds()
            self.non_exist_analysis_job_ids = temp_model.from_map(m['NonExistAnalysisJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryAnalysisJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryAnalysisJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryAnalysisJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCopyrightExtractJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryCopyrightExtractJobResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
    ):
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class QueryCopyrightExtractJobResponseBody(TeaModel):
    def __init__(
        self,
        data: QueryCopyrightExtractJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = QueryCopyrightExtractJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryCopyrightExtractJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCopyrightExtractJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCopyrightExtractJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCopyrightJobRequest(TeaModel):
    def __init__(
        self,
        create_time_end: int = None,
        create_time_start: int = None,
        job_id: str = None,
        level: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.job_id = job_id
        self.level = level
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.level is not None:
            result['Level'] = self.level
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryCopyrightJobResponseBodyData(TeaModel):
    def __init__(
        self,
        callback: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        input: str = None,
        job_id: str = None,
        level: int = None,
        message: str = None,
        output: str = None,
        result: str = None,
        status: str = None,
        user_data: str = None,
        user_id: int = None,
    ):
        self.callback = callback
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.input = input
        self.job_id = job_id
        self.level = level
        self.message = message
        self.output = output
        self.result = result
        self.status = status
        self.user_data = user_data
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback is not None:
            result['Callback'] = self.callback
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.input is not None:
            result['Input'] = self.input
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callback') is not None:
            self.callback = m.get('Callback')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryCopyrightJobResponseBody(TeaModel):
    def __init__(
        self,
        data: List[QueryCopyrightJobResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = QueryCopyrightJobResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryCopyrightJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCopyrightJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCopyrightJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryFpDBDeleteJobListRequest(TeaModel):
    def __init__(
        self,
        job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The IDs of the jobs of clearing or deleting a media fingerprint library. You can obtain the job IDs from the response parameters of the [SubmitFpDBDeleteJob](https://help.aliyun.com/document_detail/209341.html) operation. Separate multiple job IDs with commas (,). If you leave this parameter empty, the system returns the latest 20 jobs that are submitted.
        self.job_ids = job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        del_type: str = None,
        finish_time: str = None,
        fp_dbid: str = None,
        id: str = None,
        message: str = None,
        pipeline_id: str = None,
        status: str = None,
        user_data: str = None,
    ):
        # The error code returned if the job fails. This parameter is not returned if the job is successful.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The type of the operation.
        self.del_type = del_type
        # The time when the job was complete.
        self.finish_time = finish_time
        # The ID of the media fingerprint library.
        self.fp_dbid = fp_dbid
        # The ID of the job.
        self.id = id
        # The error message returned if the job fails. This parameter is not returned if the job is successful.
        self.message = message
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The status of the job. Valid values:
        # 
        # *   **Queuing**: The job is waiting in the queue.
        # *   **Analysing**: The job is in progress.
        # *   **Success**: The job is successful.
        # *   **Fail**: The job fails.
        self.status = status
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.del_type is not None:
            result['DelType'] = self.del_type
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DelType') is not None:
            self.del_type = m.get('DelType')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList(TeaModel):
    def __init__(
        self,
        fp_dbdelete_job: List[QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob] = None,
    ):
        self.fp_dbdelete_job = fp_dbdelete_job

    def validate(self):
        if self.fp_dbdelete_job:
            for k in self.fp_dbdelete_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpDBDeleteJob'] = []
        if self.fp_dbdelete_job is not None:
            for k in self.fp_dbdelete_job:
                result['FpDBDeleteJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_dbdelete_job = []
        if m.get('FpDBDeleteJob') is not None:
            for k in m.get('FpDBDeleteJob'):
                temp_model = QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob()
                self.fp_dbdelete_job.append(temp_model.from_map(k))
        return self


class QueryFpDBDeleteJobListResponseBodyNonExistIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryFpDBDeleteJobListResponseBody(TeaModel):
    def __init__(
        self,
        fp_dbdelete_job_list: QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList = None,
        non_exist_ids: QueryFpDBDeleteJobListResponseBodyNonExistIds = None,
        request_id: str = None,
    ):
        # The jobs of deleting a media fingerprint library. For more information, see the "FpDBDeleteJob" section of the [Data types](https://www.alibabacloud.com/help/en/apsaravideo-for-media-processing/latest/datatypes) topic.
        self.fp_dbdelete_job_list = fp_dbdelete_job_list
        # The IDs of the jobs that do not exist.
        self.non_exist_ids = non_exist_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.fp_dbdelete_job_list:
            self.fp_dbdelete_job_list.validate()
        if self.non_exist_ids:
            self.non_exist_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_dbdelete_job_list is not None:
            result['FpDBDeleteJobList'] = self.fp_dbdelete_job_list.to_map()
        if self.non_exist_ids is not None:
            result['NonExistIds'] = self.non_exist_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpDBDeleteJobList') is not None:
            temp_model = QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList()
            self.fp_dbdelete_job_list = temp_model.from_map(m['FpDBDeleteJobList'])
        if m.get('NonExistIds') is not None:
            temp_model = QueryFpDBDeleteJobListResponseBodyNonExistIds()
            self.non_exist_ids = temp_model.from_map(m['NonExistIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryFpDBDeleteJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryFpDBDeleteJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryFpDBDeleteJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryFpFileDeleteJobListRequest(TeaModel):
    def __init__(
        self,
        job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The IDs of the jobs of deleting media files from a media fingerprint library. You can obtain the job IDs from the response parameters of the [SubmitFpFileDeleteJob](https://help.aliyun.com/document_detail/209274.html) operation. Separate multiple job IDs with commas (,). If you leave this parameter empty, the system returns the latest 20 jobs that are submitted.
        self.job_ids = job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        file_ids: str = None,
        finish_time: str = None,
        fp_dbid: str = None,
        id: str = None,
        message: str = None,
        pipeline_id: str = None,
        status: str = None,
        user_data: str = None,
    ):
        # The error code returned if the job fails. This parameter is not returned if the job is successful.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The ID of the file.
        self.file_ids = file_ids
        # The time when the job was complete.
        self.finish_time = finish_time
        # The ID of the media fingerprint library.
        self.fp_dbid = fp_dbid
        # The ID of the job.
        self.id = id
        # The error message returned if the job fails. This parameter is not returned if the job is successful.
        self.message = message
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the job was submitted.
        self.pipeline_id = pipeline_id
        # The status of the job. Valid values: Valid values:
        # 
        # *   **Queuing**: The job is waiting in the queue.
        # *   **Analysing**: The job is in progress.
        # *   **Success**: The job is successful.
        # *   **Fail**: The job fails.
        self.status = status
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.file_ids is not None:
            result['FileIds'] = self.file_ids
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FileIds') is not None:
            self.file_ids = m.get('FileIds')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList(TeaModel):
    def __init__(
        self,
        fp_file_delete_job: List[QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob] = None,
    ):
        self.fp_file_delete_job = fp_file_delete_job

    def validate(self):
        if self.fp_file_delete_job:
            for k in self.fp_file_delete_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpFileDeleteJob'] = []
        if self.fp_file_delete_job is not None:
            for k in self.fp_file_delete_job:
                result['FpFileDeleteJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_file_delete_job = []
        if m.get('FpFileDeleteJob') is not None:
            for k in m.get('FpFileDeleteJob'):
                temp_model = QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob()
                self.fp_file_delete_job.append(temp_model.from_map(k))
        return self


class QueryFpFileDeleteJobListResponseBodyNonExistIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryFpFileDeleteJobListResponseBody(TeaModel):
    def __init__(
        self,
        fp_file_delete_job_list: QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList = None,
        non_exist_ids: QueryFpFileDeleteJobListResponseBodyNonExistIds = None,
        request_id: str = None,
    ):
        # The jobs of deleting media files from a media fingerprint library. For more information, see the "FpFileDeleteJob" section of the [Data types](https://help.aliyun.com/document_detail/93555.html) topic.
        self.fp_file_delete_job_list = fp_file_delete_job_list
        # The response parameters.
        self.non_exist_ids = non_exist_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.fp_file_delete_job_list:
            self.fp_file_delete_job_list.validate()
        if self.non_exist_ids:
            self.non_exist_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_file_delete_job_list is not None:
            result['FpFileDeleteJobList'] = self.fp_file_delete_job_list.to_map()
        if self.non_exist_ids is not None:
            result['NonExistIds'] = self.non_exist_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpFileDeleteJobList') is not None:
            temp_model = QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList()
            self.fp_file_delete_job_list = temp_model.from_map(m['FpFileDeleteJobList'])
        if m.get('NonExistIds') is not None:
            temp_model = QueryFpFileDeleteJobListResponseBodyNonExistIds()
            self.non_exist_ids = temp_model.from_map(m['NonExistIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryFpFileDeleteJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryFpFileDeleteJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryFpFileDeleteJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryFpShotJobListRequest(TeaModel):
    def __init__(
        self,
        end_of_job_created_time_range: str = None,
        job_ids: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        start_of_job_created_time_range: str = None,
        state: str = None,
    ):
        # The end of the time range within which the jobs to be queried were created. 
        # 
        # *   Specify the time in the ISO 8601 standard in the
        # *   YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        self.end_of_job_created_time_range = end_of_job_created_time_range
        # The ID of the media fingerprint analysis job that you want to query. To view the job ID, log on to the [ApsaraVideo Media Processing (MPS) console](https://mps.console.aliyun.com/overview), click **Tasks** in the left-side navigation pane, and then click the **Video DNA** tab on the Tasks page. You can query up to 10 media fingerprint analysis jobs at a time. Separate multiple job IDs with commas (,).
        self.job_ids = job_ids
        # The maximum number of entries to return on each page. 
        # 
        # *   Default value: **10**.
        # *   Valid values: **1 to 100**.
        self.maximum_page_size = maximum_page_size
        # The token that is used to retrieve the next page of the query results. You do not need to specify this parameter in the first request. The response to the first request contains this parameter, which you add to the next request.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue. To view the ID of the MPS queue, log on to the [MPS console](https://mps.console.aliyun.com/overview) and choose **Global Settings** > **Pipelines** in the left-side navigation pane.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The beginning of the time range within which the jobs to be queried were created. 
        # 
        # *   Specify the time in the ISO 8601 standard in the
        # *   YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        self.start_of_job_created_time_range = start_of_job_created_time_range
        # The status of the jobs to be queried. Valid values:
        # 
        # *   **All**: all jobs.
        # *   **Queuing**: the jobs that are being queued.
        # *   **Analysing**: the jobs that are in progress.
        # *   **Fail**: failed jobs.
        # *   **Success**: successful jobs.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_job_created_time_range is not None:
            result['EndOfJobCreatedTimeRange'] = self.end_of_job_created_time_range
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_of_job_created_time_range is not None:
            result['StartOfJobCreatedTimeRange'] = self.start_of_job_created_time_range
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfJobCreatedTimeRange') is not None:
            self.end_of_job_created_time_range = m.get('EndOfJobCreatedTimeRange')
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartOfJobCreatedTimeRange') is not None:
            self.start_of_job_created_time_range = m.get('StartOfJobCreatedTimeRange')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig(TeaModel):
    def __init__(
        self,
        fp_dbid: str = None,
        primary_key: str = None,
        save_type: str = None,
    ):
        # The ID of the media fingerprint library.
        self.fp_dbid = fp_dbid
        # The unique primary key of the video.
        self.primary_key = primary_key
        # The storage type. Valid values:
        # 
        # *   **nosave**: The fingerprints of the job input are not saved to the media fingerprint library.
        # *   **save**: The fingerprints of the job input are saved to the media fingerprint library only if the job input is not duplicated with media content in the media fingerprint library.
        # *   **forcesave**: The fingerprints of the job input are forcibly saved to the media fingerprint library.
        self.save_type = save_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.save_type is not None:
            result['SaveType'] = self.save_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('SaveType') is not None:
            self.save_type = m.get('SaveType')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The duration of the similar audio clip in the audio file that has similar fingerprints to the input audio in the audio fingerprint library.
        self.duration = duration
        # The start point in time of the similar audio clip in the audio file that has similar fingerprints to the input audio in the audio fingerprint library.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The duration of the similar audio clip in the input audio.
        self.duration = duration
        # The start point in time of the similar audio clip in the input audio.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice(TeaModel):
    def __init__(
        self,
        duplication: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication = None,
        input: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput = None,
        similarity: str = None,
    ):
        # The start point in time and duration of the similar audio clip in the audio file that has similar fingerprints to the input audio in the audio fingerprint library.
        self.duplication = duplication
        # The start point in time and duration of the similar audio clip in the input audio.
        self.input = input
        # The similarity of the input audio against the audio file that has similar fingerprints to the input audio in the audio fingerprint library.
        self.similarity = similarity

    def validate(self):
        if self.duplication:
            self.duplication.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duplication is not None:
            result['Duplication'] = self.duplication.to_map()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.similarity is not None:
            result['Similarity'] = self.similarity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duplication') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication()
            self.duplication = temp_model.from_map(m['Duplication'])
        if m.get('Input') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Similarity') is not None:
            self.similarity = m.get('Similarity')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices(TeaModel):
    def __init__(
        self,
        fp_shot_slice: List[QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice] = None,
    ):
        self.fp_shot_slice = fp_shot_slice

    def validate(self):
        if self.fp_shot_slice:
            for k in self.fp_shot_slice:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpShotSlice'] = []
        if self.fp_shot_slice is not None:
            for k in self.fp_shot_slice:
                result['FpShotSlice'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_shot_slice = []
        if m.get('FpShotSlice') is not None:
            for k in m.get('FpShotSlice'):
                temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice()
                self.fp_shot_slice.append(temp_model.from_map(k))
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot(TeaModel):
    def __init__(
        self,
        fp_shot_slices: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices = None,
        primary_key: str = None,
        similarity: str = None,
    ):
        # The audio files that have similar fingerprints to the input audio in the audio fingerprint library.
        self.fp_shot_slices = fp_shot_slices
        # The unique primary key of the input audio.
        self.primary_key = primary_key
        # The overall similarity of the input audio against audio files that have similar fingerprints to the input audio in the audio fingerprint library.
        self.similarity = similarity

    def validate(self):
        if self.fp_shot_slices:
            self.fp_shot_slices.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_shot_slices is not None:
            result['FpShotSlices'] = self.fp_shot_slices.to_map()
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.similarity is not None:
            result['Similarity'] = self.similarity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpShotSlices') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices()
            self.fp_shot_slices = temp_model.from_map(m['FpShotSlices'])
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('Similarity') is not None:
            self.similarity = m.get('Similarity')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots(TeaModel):
    def __init__(
        self,
        fp_shot: List[QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot] = None,
    ):
        self.fp_shot = fp_shot

    def validate(self):
        if self.fp_shot:
            for k in self.fp_shot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpShot'] = []
        if self.fp_shot is not None:
            for k in self.fp_shot:
                result['FpShot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_shot = []
        if m.get('FpShot') is not None:
            for k in m.get('FpShot'):
                temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot()
                self.fp_shot.append(temp_model.from_map(k))
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The duration of the similar video clip in the video file that has similar fingerprints to the input video in the video fingerprint library.
        self.duration = duration
        # The start point in time of the similar video clip in the video file that has similar fingerprints to the input video in the video fingerprint library.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The duration of the similar video clip in the input video.
        self.duration = duration
        # The start point in time of the similar video clip in the input video.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice(TeaModel):
    def __init__(
        self,
        duplication: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication = None,
        input: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput = None,
        similarity: str = None,
    ):
        # The start point in time and duration of the similar video clip in the video file that has similar fingerprints to the input video in the video fingerprint library.
        self.duplication = duplication
        # The start time and duration of the similar video clip in the input video.
        self.input = input
        # The similarity of the input video clip against the video file that has similar fingerprints to the input video in the video fingerprint library.
        self.similarity = similarity

    def validate(self):
        if self.duplication:
            self.duplication.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duplication is not None:
            result['Duplication'] = self.duplication.to_map()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.similarity is not None:
            result['Similarity'] = self.similarity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duplication') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication()
            self.duplication = temp_model.from_map(m['Duplication'])
        if m.get('Input') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Similarity') is not None:
            self.similarity = m.get('Similarity')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices(TeaModel):
    def __init__(
        self,
        fp_shot_slice: List[QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice] = None,
    ):
        self.fp_shot_slice = fp_shot_slice

    def validate(self):
        if self.fp_shot_slice:
            for k in self.fp_shot_slice:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpShotSlice'] = []
        if self.fp_shot_slice is not None:
            for k in self.fp_shot_slice:
                result['FpShotSlice'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_shot_slice = []
        if m.get('FpShotSlice') is not None:
            for k in m.get('FpShotSlice'):
                temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice()
                self.fp_shot_slice.append(temp_model.from_map(k))
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot(TeaModel):
    def __init__(
        self,
        fp_shot_slices: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices = None,
        primary_key: str = None,
        similarity: str = None,
    ):
        # The video files that have similar fingerprints to the input video in the video fingerprint library.
        self.fp_shot_slices = fp_shot_slices
        # The unique primary key of the input video.
        self.primary_key = primary_key
        # The overall similarity of the input video against video files that have similar fingerprints to the input video in the video fingerprint library.
        # 
        # >  The overall similarity is the average value of the similarities of the input video clips with the clips of the video that has a similar fingerprint. If multiple video files that have similar fingerprints to the input video exist in the video fingerprint library, the similarities of the input video against multiple similar video clips are returned.
        self.similarity = similarity

    def validate(self):
        if self.fp_shot_slices:
            self.fp_shot_slices.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_shot_slices is not None:
            result['FpShotSlices'] = self.fp_shot_slices.to_map()
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.similarity is not None:
            result['Similarity'] = self.similarity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpShotSlices') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices()
            self.fp_shot_slices = temp_model.from_map(m['FpShotSlices'])
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('Similarity') is not None:
            self.similarity = m.get('Similarity')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots(TeaModel):
    def __init__(
        self,
        fp_shot: List[QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot] = None,
    ):
        self.fp_shot = fp_shot

    def validate(self):
        if self.fp_shot:
            for k in self.fp_shot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpShot'] = []
        if self.fp_shot is not None:
            for k in self.fp_shot:
                result['FpShot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_shot = []
        if m.get('FpShot') is not None:
            for k in m.get('FpShot'):
                temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot()
                self.fp_shot.append(temp_model.from_map(k))
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The duration of the similar text snippet in the input text.
        self.duration = duration
        # The start time of the similar text snippet in the input text.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice(TeaModel):
    def __init__(
        self,
        duplication_text: str = None,
        input_fragment: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment = None,
        input_text: str = None,
        similarity: str = None,
    ):
        # The text snippet that has similar fingerprints to the input text in the text fingerprint library.
        self.duplication_text = duplication_text
        # The start point in time and duration of the similar text snippet in the input text.
        self.input_fragment = input_fragment
        # The input text for text fingerprint analysis.
        self.input_text = input_text
        # The similarity of the input text against the text snippet that has similar fingerprints to the input text in the text fingerprint library.
        self.similarity = similarity

    def validate(self):
        if self.input_fragment:
            self.input_fragment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duplication_text is not None:
            result['DuplicationText'] = self.duplication_text
        if self.input_fragment is not None:
            result['InputFragment'] = self.input_fragment.to_map()
        if self.input_text is not None:
            result['InputText'] = self.input_text
        if self.similarity is not None:
            result['Similarity'] = self.similarity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DuplicationText') is not None:
            self.duplication_text = m.get('DuplicationText')
        if m.get('InputFragment') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSliceInputFragment()
            self.input_fragment = temp_model.from_map(m['InputFragment'])
        if m.get('InputText') is not None:
            self.input_text = m.get('InputText')
        if m.get('Similarity') is not None:
            self.similarity = m.get('Similarity')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices(TeaModel):
    def __init__(
        self,
        text_fp_shot_slice: List[QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice] = None,
    ):
        self.text_fp_shot_slice = text_fp_shot_slice

    def validate(self):
        if self.text_fp_shot_slice:
            for k in self.text_fp_shot_slice:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TextFpShotSlice'] = []
        if self.text_fp_shot_slice is not None:
            for k in self.text_fp_shot_slice:
                result['TextFpShotSlice'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.text_fp_shot_slice = []
        if m.get('TextFpShotSlice') is not None:
            for k in m.get('TextFpShotSlice'):
                temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlicesTextFpShotSlice()
                self.text_fp_shot_slice.append(temp_model.from_map(k))
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot(TeaModel):
    def __init__(
        self,
        primary_key: str = None,
        similarity: str = None,
        text_fp_shot_slices: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices = None,
    ):
        # The unique primary key of the input text.
        self.primary_key = primary_key
        # The similarity of the input text against text snippets that have similar fingerprints to the input text in the text fingerprint library.
        self.similarity = similarity
        # The text snippets that have similar fingerprints to the input text in the text fingerprint library.
        self.text_fp_shot_slices = text_fp_shot_slices

    def validate(self):
        if self.text_fp_shot_slices:
            self.text_fp_shot_slices.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.similarity is not None:
            result['Similarity'] = self.similarity
        if self.text_fp_shot_slices is not None:
            result['TextFpShotSlices'] = self.text_fp_shot_slices.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('Similarity') is not None:
            self.similarity = m.get('Similarity')
        if m.get('TextFpShotSlices') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShotTextFpShotSlices()
            self.text_fp_shot_slices = temp_model.from_map(m['TextFpShotSlices'])
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots(TeaModel):
    def __init__(
        self,
        text_fp_shot: List[QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot] = None,
    ):
        self.text_fp_shot = text_fp_shot

    def validate(self):
        if self.text_fp_shot:
            for k in self.text_fp_shot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TextFpShot'] = []
        if self.text_fp_shot is not None:
            for k in self.text_fp_shot:
                result['TextFpShot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.text_fp_shot = []
        if m.get('TextFpShot') is not None:
            for k in m.get('TextFpShot'):
                temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShotsTextFpShot()
                self.text_fp_shot.append(temp_model.from_map(k))
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult(TeaModel):
    def __init__(
        self,
        audio_fp_shots: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots = None,
        fp_shots: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots = None,
        text_fp_shots: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots = None,
    ):
        # The audio fingerprint analysis results.
        self.audio_fp_shots = audio_fp_shots
        # The video fingerprint analysis results.
        self.fp_shots = fp_shots
        # The text fingerprint analysis results.
        self.text_fp_shots = text_fp_shots

    def validate(self):
        if self.audio_fp_shots:
            self.audio_fp_shots.validate()
        if self.fp_shots:
            self.fp_shots.validate()
        if self.text_fp_shots:
            self.text_fp_shots.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_fp_shots is not None:
            result['AudioFpShots'] = self.audio_fp_shots.to_map()
        if self.fp_shots is not None:
            result['FpShots'] = self.fp_shots.to_map()
        if self.text_fp_shots is not None:
            result['TextFpShots'] = self.text_fp_shots.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFpShots') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots()
            self.audio_fp_shots = temp_model.from_map(m['AudioFpShots'])
        if m.get('FpShots') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots()
            self.fp_shots = temp_model.from_map(m['FpShots'])
        if m.get('TextFpShots') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultTextFpShots()
            self.text_fp_shots = temp_model.from_map(m['TextFpShots'])
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket in which the job input resides.
        self.bucket = bucket
        # The OSS region in which the job input resides.
        self.location = location
        # The Object Storage Service (OSS) object that is used as the job input.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryFpShotJobListResponseBodyFpShotJobListFpShotJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        duration: int = None,
        file_id: str = None,
        finish_time: str = None,
        fp_shot_config: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig = None,
        fp_shot_result: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult = None,
        id: str = None,
        input: str = None,
        input_file: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile = None,
        message: str = None,
        pipeline_id: str = None,
        state: str = None,
        user_data: str = None,
    ):
        # The error code returned if the job fails.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The length of the input file.
        # Unit: seconds.
        self.duration = duration
        # The ID of the uploaded file.
        self.file_id = file_id
        # The time when the job was complete.
        self.finish_time = finish_time
        # The configurations of the job.
        self.fp_shot_config = fp_shot_config
        # The results of the media fingerprint analysis job.
        self.fp_shot_result = fp_shot_result
        # The ID of the job.
        self.id = id
        # The information about the job input.
        self.input = input
        # The information about the job input.
        self.input_file = input_file
        # The error message returned if the job fails. This parameter is not returned if the job is successful.
        self.message = message
        # The ID of the MPS queue to which the analysis job is submitted.
        self.pipeline_id = pipeline_id
        # The status of the job. Valid values:
        # 
        # *   **Queuing**: The job is waiting in the queue.
        # *   **Analysing**: The job is in progress.
        # *   **Success**: The job is successful.
        # *   **Fail**: The job fails.
        self.state = state
        # The custom data.
        self.user_data = user_data

    def validate(self):
        if self.fp_shot_config:
            self.fp_shot_config.validate()
        if self.fp_shot_result:
            self.fp_shot_result.validate()
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.fp_shot_config is not None:
            result['FpShotConfig'] = self.fp_shot_config.to_map()
        if self.fp_shot_result is not None:
            result['FpShotResult'] = self.fp_shot_result.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.input is not None:
            result['Input'] = self.input
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('FpShotConfig') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig()
            self.fp_shot_config = temp_model.from_map(m['FpShotConfig'])
        if m.get('FpShotResult') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult()
            self.fp_shot_result = temp_model.from_map(m['FpShotResult'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('InputFile') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryFpShotJobListResponseBodyFpShotJobList(TeaModel):
    def __init__(
        self,
        fp_shot_job: List[QueryFpShotJobListResponseBodyFpShotJobListFpShotJob] = None,
    ):
        self.fp_shot_job = fp_shot_job

    def validate(self):
        if self.fp_shot_job:
            for k in self.fp_shot_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FpShotJob'] = []
        if self.fp_shot_job is not None:
            for k in self.fp_shot_job:
                result['FpShotJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fp_shot_job = []
        if m.get('FpShotJob') is not None:
            for k in m.get('FpShotJob'):
                temp_model = QueryFpShotJobListResponseBodyFpShotJobListFpShotJob()
                self.fp_shot_job.append(temp_model.from_map(k))
        return self


class QueryFpShotJobListResponseBodyNonExistIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryFpShotJobListResponseBody(TeaModel):
    def __init__(
        self,
        fp_shot_job_list: QueryFpShotJobListResponseBodyFpShotJobList = None,
        next_page_token: str = None,
        non_exist_ids: QueryFpShotJobListResponseBodyNonExistIds = None,
        request_id: str = None,
    ):
        # The information about media fingerprint analysis jobs.
        self.fp_shot_job_list = fp_shot_job_list
        # The token that is used to retrieve the next page of the query results. The value is a 32-bit UUID. If the returned query results cannot be displayed within one page, this parameter is returned. The value of this parameter is updated for each query.
        self.next_page_token = next_page_token
        # The IDs of the jobs that do not exist.
        self.non_exist_ids = non_exist_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.fp_shot_job_list:
            self.fp_shot_job_list.validate()
        if self.non_exist_ids:
            self.non_exist_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_shot_job_list is not None:
            result['FpShotJobList'] = self.fp_shot_job_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.non_exist_ids is not None:
            result['NonExistIds'] = self.non_exist_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpShotJobList') is not None:
            temp_model = QueryFpShotJobListResponseBodyFpShotJobList()
            self.fp_shot_job_list = temp_model.from_map(m['FpShotJobList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NonExistIds') is not None:
            temp_model = QueryFpShotJobListResponseBodyNonExistIds()
            self.non_exist_ids = temp_model.from_map(m['NonExistIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryFpShotJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryFpShotJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryFpShotJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryIProductionJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.job_id = job_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryIProductionJobResponseBody(TeaModel):
    def __init__(
        self,
        function_name: str = None,
        input: str = None,
        job_id: str = None,
        job_params: str = None,
        output: str = None,
        pipeline_id: str = None,
        request_id: str = None,
        result: str = None,
        state: str = None,
        user_data: str = None,
    ):
        self.function_name = function_name
        self.input = input
        self.job_id = job_id
        self.job_params = job_params
        self.output = output
        self.pipeline_id = pipeline_id
        self.request_id = request_id
        self.result = result
        self.state = state
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.input is not None:
            result['Input'] = self.input
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.output is not None:
            result['Output'] = self.output
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryIProductionJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryIProductionJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryIProductionJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryJobListRequest(TeaModel):
    def __init__(
        self,
        job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The IDs of transcoding jobs. Separate multiple IDs with commas (,). You can query a maximum of 10 transcoding jobs at a time. You can log on to the [ApsaraVideo Media Processing (MPS) console](https://mps.console.aliyun.com/overview) and click **Tasks** in the left-side navigation pane to obtain job IDs. Alternatively, you can obtain job IDs from the response to the [SubmitJobs](https://help.aliyun.com/document_detail/29226.html) operation.
        # 
        # >  If you do not set the JobIds parameter, the `InvalidParameter` error code is returned.
        self.job_ids = job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryJobListResponseBodyJobListJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The OSS region in which the input file resides.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryJobListResponseBodyJobListJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the job failed. This parameter is not returned if the job was successful.
        self.error_code = error_code
        # The error message returned if the job failed. This parameter is not returned if the job was successful.
        self.error_message = error_message
        # The ID of the message returned if the job was successful.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryJobListResponseBodyJobListJobOutputAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        # The volume adjustment range. Default value: -20. Unit: dB.
        self.level = level
        # The method that is used to adjust the volume. Valid values:
        # 
        # *   **auto**\
        # *   **dynamic**\
        # *   **linear**\
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class QueryJobListResponseBodyJobListJobOutputAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
        volume: QueryJobListResponseBodyJobListJobOutputAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.bitrate = bitrate
        # The number of sound channels.
        # 
        # *   Valid values: 1, 2, 3, 4, 5, 6, 7, and 8.
        # *   Default value: **2**.
        self.channels = channels
        # The audio codec.
        # 
        # *   Valid values: aac, mp3, vorbis, and flac.
        # *   Default value: **aac**.
        self.codec = codec
        # The codec profile of the audio. Valid values when the value of Codec is aac: aaclow, aache, aachev2, aacld, and aaceld.
        self.profile = profile
        # The level of quality control on the audio.
        self.qscale = qscale
        # The sampling rate.
        # 
        # *   Valid values: 22050, 32000, 44100, 48000, and 96000.
        # *   Unit: Hz.
        # *   Default value: 44100.
        # 
        # >  If the video container format is FLV and the audio codec is MP3, the value of this parameter cannot be 32000, 48000, or 96000. If the audio codec is MP3, the value of this parameter cannot be 96000.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class QueryJobListResponseBodyJobListJobOutputClipTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        seek: str = None,
    ):
        # The duration of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]`.
        # *   Example: 01:00:59.999.
        # 
        # Or
        # 
        # *   Format: `sssss[.SSS]`.
        # *   Example: 32000.23.
        self.duration = duration
        # The point in time when the clip starts.
        # 
        # *   Format: `hh:mm:ss[.SSS]`.
        # *   Example: 01:59:59.999.
        # 
        # Or
        # 
        # *   Format: `sssss[.SSS]`.
        # *   Example: 32000.23.
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class QueryJobListResponseBodyJobListJobOutputClip(TeaModel):
    def __init__(
        self,
        time_span: QueryJobListResponseBodyJobListJobOutputClipTimeSpan = None,
    ):
        # The time span of the clip.
        self.time_span = time_span

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeSpan') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputClipTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        return self


class QueryJobListResponseBodyJobListJobOutputContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        # 
        # *   Default value: mp4.
        # *   Video formats include FLV, MP4, HLS (M3U8 + TS), and MPEG-DASH (MPD + fMP4).
        # *   Audio formats include MP3, MP4, Ogg, FLAC, and M4A.
        # *   Image formats include GIF and WebP. If the container format is GIF, the video codec must be GIF.
        # *   If the container format is WebP, the video codec must be WebP.
        # *   If the container format is FLV, the video codec cannot be H.265.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class QueryJobListResponseBodyJobListJobOutputEncryption(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        key_type: str = None,
        key_uri: str = None,
        skip_cnt: str = None,
        type: str = None,
    ):
        # The encryption ID.
        self.id = id
        # The key that is used to encrypt the video.
        self.key = key
        # The key encryption method. Valid values: Base64 and KMS.
        # 
        # >  For example, if the key is `encryptionkey128`, the key can be encrypted as `Base64("encryptionkey128")` or `KMS(Base64("encryptionkey128")` depending on the encryption method used.
        self.key_type = key_type
        # The URL that is used to request the key. The URL is Base64-encoded.
        self.key_uri = key_uri
        # The number of unencrypted frames at the beginning of the video. Leaving these frames unencrypted enables video playback to quickly start.
        self.skip_cnt = skip_cnt
        # The encryption type. Only **hls-aes-128** may be returned.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.key is not None:
            result['Key'] = self.key
        if self.key_type is not None:
            result['KeyType'] = self.key_type
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.skip_cnt is not None:
            result['SkipCnt'] = self.skip_cnt
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('KeyType') is not None:
            self.key_type = m.get('KeyType')
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('SkipCnt') is not None:
            self.skip_cnt = m.get('SkipCnt')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS(TeaModel):
    def __init__(
        self,
        md_5support: bool = None,
        size_support: bool = None,
    ):
        # Indicates whether the output of the MD5 value of the TS file is supported in the M3U8 file. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.md_5support = md_5support
        # Indicates whether the output of the size of the TS file is supported in the M3U8 file. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.size_support = size_support

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5support is not None:
            result['Md5Support'] = self.md_5support
        if self.size_support is not None:
            result['SizeSupport'] = self.size_support
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5Support') is not None:
            self.md_5support = m.get('Md5Support')
        if m.get('SizeSupport') is not None:
            self.size_support = m.get('SizeSupport')
        return self


class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport(TeaModel):
    def __init__(
        self,
        ts: QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS = None,
    ):
        # The non-standard support configurations for TS files. The value is a JSON object. For more information, see the TS section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        self.ts = ts

    def validate(self):
        if self.ts:
            self.ts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['TS'] = self.ts.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TS') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS()
            self.ts = temp_model.from_map(m['TS'])
        return self


class QueryJobListResponseBodyJobListJobOutputMergeListMerge(TeaModel):
    def __init__(
        self,
        duration: str = None,
        merge_url: str = None,
        role_arn: str = None,
        start: str = None,
    ):
        # The duration of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Examples: 01:59:59.999 and 32000.23.
        self.duration = duration
        # The OSS URL of the clip.
        # 
        # *   Example: `http://example-bucket-.oss-cn-hangzhou.aliyuncs.com/example-object.flv`.
        # *   The object must be URL-encoded by using the UTF-8 standard. For more information, see [URL encoding](https://help.aliyun.com/document_detail/423796.html).
        self.merge_url = merge_url
        # The Alibaba Cloud Resource Name (ARN) of the Resource Access Management (RAM) role used for delegated authorization.
        self.role_arn = role_arn
        # The start point in time of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Examples: 01:59:59.999 and 32000.23.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.merge_url is not None:
            result['MergeURL'] = self.merge_url
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MergeURL') is not None:
            self.merge_url = m.get('MergeURL')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryJobListResponseBodyJobListJobOutputMergeList(TeaModel):
    def __init__(
        self,
        merge: List[QueryJobListResponseBodyJobListJobOutputMergeListMerge] = None,
    ):
        self.merge = merge

    def validate(self):
        if self.merge:
            for k in self.merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Merge'] = []
        if self.merge is not None:
            for k in self.merge:
                result['Merge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.merge = []
        if m.get('Merge') is not None:
            for k in m.get('Merge'):
                temp_model = QueryJobListResponseBodyJobListJobOutputMergeListMerge()
                self.merge.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo(TeaModel):
    def __init__(
        self,
        code: str = None,
        downgrade_policy: str = None,
        duration: float = None,
        enable: str = None,
        message: str = None,
        real_speed: float = None,
        setting_speed: int = None,
        time_cost: float = None,
    ):
        # The error code returned if high-speed transcoding is not enabled.
        self.code = code
        # The downgrade policy if high-speed transcoding is not supported.
        self.downgrade_policy = downgrade_policy
        # The duration of the output video.
        self.duration = duration
        # Indicates whether high-speed transcoding is enabled.
        self.enable = enable
        # The error message returned if high-speed transcoding is not enabled.
        self.message = message
        # The actual transcoding speed.
        self.real_speed = real_speed
        # The speed setting.
        self.setting_speed = setting_speed
        # The amount of time consumed.
        self.time_cost = time_cost

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.downgrade_policy is not None:
            result['DowngradePolicy'] = self.downgrade_policy
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.message is not None:
            result['Message'] = self.message
        if self.real_speed is not None:
            result['RealSpeed'] = self.real_speed
        if self.setting_speed is not None:
            result['SettingSpeed'] = self.setting_speed
        if self.time_cost is not None:
            result['TimeCost'] = self.time_cost
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DowngradePolicy') is not None:
            self.downgrade_policy = m.get('DowngradePolicy')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RealSpeed') is not None:
            self.real_speed = m.get('RealSpeed')
        if m.get('SettingSpeed') is not None:
            self.setting_speed = m.get('SettingSpeed')
        if m.get('TimeCost') is not None:
            self.time_cost = m.get('TimeCost')
        return self


class QueryJobListResponseBodyJobListJobOutputMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        # The color dithering algorithm of the palette. Valid values: sierra and bayer.
        self.dither_mode = dither_mode
        # The duration for which the final frame is paused. Unit: centisecond.
        self.final_delay = final_delay
        # Indicates whether a custom palette is used. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_custom_palette = is_custom_palette
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryJobListResponseBodyJobListJobOutputMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The segment length. Unit: seconds.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class QueryJobListResponseBodyJobListJobOutputMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryJobListResponseBodyJobListJobOutputMuxConfig(TeaModel):
    def __init__(
        self,
        gif: QueryJobListResponseBodyJobListJobOutputMuxConfigGif = None,
        segment: QueryJobListResponseBodyJobListJobOutputMuxConfigSegment = None,
        webp: QueryJobListResponseBodyJobListJobOutputMuxConfigWebp = None,
    ):
        # The transmuxing configurations for GIF.
        self.gif = gif
        # The segment configurations. The value is a JSON object.
        self.segment = segment
        # The transmuxing configurations for WebP.
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class QueryJobListResponseBodyJobListJobOutputOpeningListOpening(TeaModel):
    def __init__(
        self,
        height: str = None,
        start: str = None,
        width: str = None,
        open_url: str = None,
    ):
        # The height of the opening part.
        # 
        # *   Valid values: values in the range of (0,4096), -1, and full.
        # *   A value of -1 indicates that the original height of the opening part is retained.
        # *   A value of full indicates that the height of the opening part equals the height of the main part.
        # *   Default value: **-1**.
        self.height = height
        # The amount of time after which the opening part is played.
        # 
        # *   The value starts from 0.
        # *   Unit: seconds.
        # *   Default value: **0**.
        self.start = start
        # The width of the opening part.
        # 
        # *   Valid values: values in the range of (0,4096), -1, and full.
        # *   A value of -1 indicates that the original width of the opening part is retained.
        # *   A value of full indicates that the width of the opening part equals the width of the main part.
        # *   Default value: **-1**.
        self.width = width
        # The OSS URL of the opening part.
        self.open_url = open_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.start is not None:
            result['Start'] = self.start
        if self.width is not None:
            result['Width'] = self.width
        if self.open_url is not None:
            result['openUrl'] = self.open_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('openUrl') is not None:
            self.open_url = m.get('openUrl')
        return self


class QueryJobListResponseBodyJobListJobOutputOpeningList(TeaModel):
    def __init__(
        self,
        opening: List[QueryJobListResponseBodyJobListJobOutputOpeningListOpening] = None,
    ):
        self.opening = opening

    def validate(self):
        if self.opening:
            for k in self.opening:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Opening'] = []
        if self.opening is not None:
            for k in self.opening:
                result['Opening'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.opening = []
        if m.get('Opening') is not None:
            for k in m.get('Opening'):
                temp_model = QueryJobListResponseBodyJobListJobOutputOpeningListOpening()
                self.opening.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The name of the OSS bucket in which the output caption is stored.
        self.bucket = bucket
        # The OSS region in which the output caption resides.
        self.location = location
        # The name of the OSS object that is used as the output caption.
        self.object = object
        # The ARN of the RAM role used for delegated authorization.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
        message: str = None,
        out_subtitle_file: QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile = None,
        success: bool = None,
    ):
        # The video track. Format: `0:{Stream}:{Stream sequence number}`, which is `0:v:{video_index}`. The value of Stream is v, which indicates a video stream. The sequence number is the index of the video stream in the list and starts from 0.
        self.map = map
        # The error message returned if the job failed to be created. This parameter is not returned if the job was created.
        self.message = message
        # The details of the output caption.
        self.out_subtitle_file = out_subtitle_file
        # Indicates whether the job was successful. Valid values:
        # 
        # *   **true**: The job was successful.
        # *   **false**: The job failed.
        self.success = success

    def validate(self):
        if self.out_subtitle_file:
            self.out_subtitle_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        if self.message is not None:
            result['Message'] = self.message
        if self.out_subtitle_file is not None:
            result['OutSubtitleFile'] = self.out_subtitle_file.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OutSubtitleFile') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile()
            self.out_subtitle_file = temp_model.from_map(m['OutSubtitleFile'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryJobListResponseBodyJobListJobOutputOutSubtitleList(TeaModel):
    def __init__(
        self,
        out_subtitle: List[QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle] = None,
    ):
        self.out_subtitle = out_subtitle

    def validate(self):
        if self.out_subtitle:
            for k in self.out_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OutSubtitle'] = []
        if self.out_subtitle is not None:
            for k in self.out_subtitle:
                result['OutSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.out_subtitle = []
        if m.get('OutSubtitle') is not None:
            for k in m.get('OutSubtitle'):
                temp_model = QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle()
                self.out_subtitle.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The name of the OSS bucket in which the output file is stored.
        self.bucket = bucket
        # The OSS region in which the output file resides.
        self.location = location
        # The name of the OSS object that is used as the output file.
        self.object = object
        # The ARN of the RAM role used for delegated authorization.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        # The total bitrate.
        self.bitrate = bitrate
        # The total duration.
        self.duration = duration
        # The full name of the container format.
        self.format_long_name = format_long_name
        # The short name of the container format. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format_name = format_name
        # The total number of program streams.
        self.num_programs = num_programs
        # The total number of media streams.
        self.num_streams = num_streams
        # The size of the media file.
        self.size = size
        # The start time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo(TeaModel):
    def __init__(
        self,
        source: str = None,
    ):
        # The keyword.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos(TeaModel):
    def __init__(
        self,
        source_logo: List[QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo] = None,
    ):
        self.source_logo = source_logo

    def validate(self):
        if self.source_logo:
            for k in self.source_logo:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SourceLogo'] = []
        if self.source_logo is not None:
            for k in self.source_logo:
                result['SourceLogo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.source_logo = []
        if m.get('SourceLogo') is not None:
            for k in m.get('SourceLogo'):
                temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo()
                self.source_logo.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate of the audio stream.
        self.bitrate = bitrate
        # The output layout of the sound channels.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration of the audio stream.
        self.duration = duration
        # The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
        self.index = index
        # The language of the audio stream. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata) and [ISO 639](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
        self.lang = lang
        # The total number of frames.
        self.num_frames = num_frames
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate.
        self.samplerate = samplerate
        # The start time.
        self.start_time = start_time
        # The time base of the audio stream.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        # The sequence number of the caption stream. The value indicates the position of the caption stream in all caption streams.
        self.index = index
        # The language of the caption stream. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata) and [ISO 639](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        # The average bitrate.
        self.avg_bitrate = avg_bitrate
        # The maximum bandwidth that was consumed.
        self.cost_bandwidth = cost_bandwidth
        # The amount of time consumed to preload the video stream.
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
        bits_per_raw_sample: str = None,
        color_primaries: str = None,
        color_transfer: str = None,
    ):
        # The average frame rate of the video stream.
        self.avg_fps = avg_fps
        # The video bitrate.
        self.bitrate = bitrate
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The display aspect ratio (DAR) of the video stream.
        self.dar = dar
        # The duration of the video stream.
        self.duration = duration
        # The frame rate of the video stream.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames).
        self.has_bframes = has_bframes
        # The height of the video stream in pixels.
        self.height = height
        # The sequence number of the video stream. The value indicates the position of the video stream in all video streams.
        self.index = index
        # The language of the video stream. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata) and [ISO 639](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
        self.lang = lang
        # The codec level.
        self.level = level
        # The network bandwidth that was consumed.
        self.network_cost = network_cost
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format of the video stream.
        self.pix_fmt = pix_fmt
        # The codec profile.
        self.profile = profile
        # The sample aspect ratio (SAR) of the video stream.
        self.sar = sar
        # The start time.
        self.start_time = start_time
        # The time base of the video stream.
        self.timebase = timebase
        # The width of the video stream in pixels.
        self.width = width
        # The number of binary bits used by each sample or pixel.
        self.bits_per_raw_sample = bits_per_raw_sample
        # The primary colors.
        self.color_primaries = color_primaries
        # The color transfer configuration.
        self.color_transfer = color_transfer

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        if self.bits_per_raw_sample is not None:
            result['bitsPerRawSample'] = self.bits_per_raw_sample
        if self.color_primaries is not None:
            result['colorPrimaries'] = self.color_primaries
        if self.color_transfer is not None:
            result['colorTransfer'] = self.color_transfer
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('bitsPerRawSample') is not None:
            self.bits_per_raw_sample = m.get('bitsPerRawSample')
        if m.get('colorPrimaries') is not None:
            self.color_primaries = m.get('colorPrimaries')
        if m.get('colorTransfer') is not None:
            self.color_transfer = m.get('colorTransfer')
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList = None,
    ):
        # The audio streams.
        self.audio_stream_list = audio_stream_list
        # The caption streams.
        self.subtitle_stream_list = subtitle_stream_list
        # The video streams.
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryJobListResponseBodyJobListJobOutputProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: QueryJobListResponseBodyJobListJobOutputPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        source_logos: QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos = None,
        streams: QueryJobListResponseBodyJobListJobOutputPropertiesStreams = None,
        width: str = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The video duration.
        self.duration = duration
        # The video format.
        self.file_format = file_format
        # The size of the media file.
        self.file_size = file_size
        # The format information.
        self.format = format
        # The frame rate of the video.
        self.fps = fps
        # The video height.
        self.height = height
        # The non-engine layer keywords.
        self.source_logos = source_logos
        # The stream information.
        self.streams = streams
        # The video width.
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.source_logos:
            self.source_logos.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.source_logos is not None:
            result['SourceLogos'] = self.source_logos.to_map()
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('SourceLogos') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos()
            self.source_logos = temp_model.from_map(m['SourceLogos'])
        if m.get('Streams') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input caption file is stored.
        self.bucket = bucket
        # The OSS region in which the input caption file resides.
        self.location = location
        # The name of the OSS object that is used as the input caption file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        font_name: str = None,
        input: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput = None,
    ):
        # The character set used by the external caption.
        # 
        # *   Valid values: UTF-8, GBK, BIG5, and auto.
        # *   Default value: **auto**.
        # 
        # >  If the value of CharEnc is auto, the detected character set may not be the actual character set. We recommend that you set this parameter to another value.
        self.char_enc = char_enc
        # The font of the hardcoded captions converted from external captions. Default value: SimSum. For more information, see [Fonts](https://help.aliyun.com/document_detail/59950.html).
        self.font_name = font_name
        # The input caption file.
        # 
        # *   SRT and ASS files are supported. For more information, see the Input section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        # *   Example: `{"Bucket":"example-bucket","Location":"oss-cn-hangzhou","Object":"example.srt"}`.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('Input') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(TeaModel):
    def __init__(
        self,
        ext_subtitle: List[QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle] = None,
    ):
        self.ext_subtitle = ext_subtitle

    def validate(self):
        if self.ext_subtitle:
            for k in self.ext_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExtSubtitle'] = []
        if self.ext_subtitle is not None:
            for k in self.ext_subtitle:
                result['ExtSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ext_subtitle = []
        if m.get('ExtSubtitle') is not None:
            for k in m.get('ExtSubtitle'):
                temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle()
                self.ext_subtitle.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
    ):
        # The audio track. Format: `0:{Stream}:{Stream sequence number}`, which is `0:a:{audio_index}`. The value of Stream is a, which indicates an audio stream. The sequence number is the index of the audio stream in the list and starts from 0.
        self.map = map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList(TeaModel):
    def __init__(
        self,
        subtitle: List[QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle] = None,
    ):
        self.subtitle = subtitle

    def validate(self):
        if self.subtitle:
            for k in self.subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Subtitle'] = []
        if self.subtitle is not None:
            for k in self.subtitle:
                result['Subtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle = []
        if m.get('Subtitle') is not None:
            for k in m.get('Subtitle'):
                temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle()
                self.subtitle.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputSubtitleConfig(TeaModel):
    def __init__(
        self,
        ext_subtitle_list: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList = None,
        subtitle_list: QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList = None,
    ):
        # The external captions.
        self.ext_subtitle_list = ext_subtitle_list
        # The captions.
        self.subtitle_list = subtitle_list

    def validate(self):
        if self.ext_subtitle_list:
            self.ext_subtitle_list.validate()
        if self.subtitle_list:
            self.subtitle_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_subtitle_list is not None:
            result['ExtSubtitleList'] = self.ext_subtitle_list.to_map()
        if self.subtitle_list is not None:
            result['SubtitleList'] = self.subtitle_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSubtitleList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList()
            self.ext_subtitle_list = temp_model.from_map(m['ExtSubtitleList'])
        if m.get('SubtitleList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList()
            self.subtitle_list = temp_model.from_map(m['SubtitleList'])
        return self


class QueryJobListResponseBodyJobListJobOutputSuperReso(TeaModel):
    def __init__(
        self,
        is_half_sample: str = None,
    ):
        # Indicates whether parameters related to the sampling rate are obtained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_half_sample = is_half_sample

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_half_sample is not None:
            result['IsHalfSample'] = self.is_half_sample
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsHalfSample') is not None:
            self.is_half_sample = m.get('IsHalfSample')
        return self


class QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        blend_duration: str = None,
        height: str = None,
        is_merge_audio: bool = None,
        start: str = None,
        tail_url: str = None,
        width: str = None,
    ):
        # The color of the bars that are added to the ending part if the size of the ending part is smaller than that of the main part. Default value: White. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html).
        self.bg_color = bg_color
        # The duration of the transition between the main part and the ending part. A fade transition is used: The last frame of the main part fades out, and the first frame of the ending part fades in. Unit: seconds. Default value: 0.
        self.blend_duration = blend_duration
        # The height of the ending part.
        # 
        # *   Valid values: values in the range of (0,4096), -1, and full.
        # *   A value of -1 indicates that the original height of the ending part is retained.
        # *   A value of full indicates that the height of the ending part equals the height of the main part.
        # *   Default value: -1.
        self.height = height
        # Indicates whether the audio content of the ending part is merged. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_merge_audio = is_merge_audio
        # The time when the ending part is played.
        self.start = start
        # The OSS URL of the ending part.
        self.tail_url = tail_url
        # The width of the ending part. Valid values: values in the range of (0,4096), -1, and full.
        # 
        # *   A value of -1 indicates that the original width of the ending part is retained.
        # *   A value of full indicates that the width of the ending part equals the width of the main part.
        # *   Default value: -1.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.blend_duration is not None:
            result['BlendDuration'] = self.blend_duration
        if self.height is not None:
            result['Height'] = self.height
        if self.is_merge_audio is not None:
            result['IsMergeAudio'] = self.is_merge_audio
        if self.start is not None:
            result['Start'] = self.start
        if self.tail_url is not None:
            result['TailUrl'] = self.tail_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BlendDuration') is not None:
            self.blend_duration = m.get('BlendDuration')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('IsMergeAudio') is not None:
            self.is_merge_audio = m.get('IsMergeAudio')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('TailUrl') is not None:
            self.tail_url = m.get('TailUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputTailSlateList(TeaModel):
    def __init__(
        self,
        tail_slate: List[QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate] = None,
    ):
        self.tail_slate = tail_slate

    def validate(self):
        if self.tail_slate:
            for k in self.tail_slate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TailSlate'] = []
        if self.tail_slate is not None:
            for k in self.tail_slate:
                result['TailSlate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tail_slate = []
        if m.get('TailSlate') is not None:
            for k in m.get('TailSlate'):
                temp_model = QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate()
                self.tail_slate.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutputTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method of resolution adjustment. Default value: **none**. Valid values: rescale, crop, pad, and none.
        self.adj_dar_method = adj_dar_method
        # Indicates whether the audio bitrate is checked. If the bitrate of the output audio is higher than that of the input audio, the input bitrate is retained and the specified audio bitrate does not take effect. This parameter has a lower priority than IsCheckAudioBitrateFail. Valid values:
        # 
        # *   **true**\
        # 
        # *   **false**\
        # 
        # *   Default value:
        # 
        #     *   If this parameter is empty and the codec of the output audio is different from that of the input audio, the default value is false.
        #     *   If this parameter is empty and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Indicates whether the audio bitrate is checked. If the bitrate of the output audio is higher than that of the input audio, the input audio is not transcoded and a transcoding failure is returned. This parameter has a higher priority than IsCheckAudioBitrate. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, the input resolution is retained. Valid values:
        # 
        # *   **true**:
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso = is_check_reso
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, a transcoding failure is returned. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the video bitrate is checked. If the bitrate of the output video is higher than that of the input video, the input bitrate is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Indicates whether the video bitrate is checked. If the bitrate of the output video is higher than that of the input video, the input video is not transcoded and a transcoding failure is returned. This parameter has a higher priority than IsCheckVideoBitrate. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The transcoding mode.
        # 
        # *   Valid values: onepass, twopass, and CBR.
        # *   Default value: **onepass**.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The maximum bitrate.
        self.max = max
        # The minimum bitrate.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class QueryJobListResponseBodyJobListJobOutputVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The average bitrate of the video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The average bitrate range of the video.
        self.bitrate_bnd = bitrate_bnd
        # The buffer size.
        # 
        # *   Unit: KB.
        # *   Default value: **6000**.
        self.bufsize = bufsize
        # The video codec.
        # 
        # *   Valid values: H.264 and H.265.
        # *   Default value: H.264.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Default value when the value of Codec is H.264: **23**, default value when the value of Codec is H.265: **26**.
        # *   If the value of this parameter is returned, the value of Bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   **border**: automatically detects and removes borders.
        # *   A value in the width:height:left:top format: The video image is cropped based on custom settings.
        self.crop = crop
        # The strength of the independent noise reduction algorithm.
        self.degrain = degrain
        # The frame rate of the video.
        # 
        # *   Unit: frames per second.
        # *   The value is 60 if the frame rate of the input file exceeds 60.
        # *   Default value: the frame rate of the input video.
        self.fps = fps
        # The maximum interval between keyframes or the maximum number of frames in a frame group. Unit: seconds.
        # 
        # *   Default value: **250**.
        # *   If the maximum number of frames is returned, the value does not contain a unit.
        self.gop = gop
        # The height of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: the height of the input video.
        self.height = height
        # The maximum frame rate.
        self.max_fps = max_fps
        # The maximum bitrate of the video. Unit: Kbit/s.
        self.maxrate = maxrate
        # The black bars that are added to the video.
        # 
        # *   Unit: pixel.
        # *   Format: width:height:left:top.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. Default value: **medium**. Valid values:
        # 
        # *   **veryfast**\
        # *   **fast**\
        # *   **medium**\
        # *   **slow**\
        # *   **slower**\
        self.preset = preset
        # The codec profile of the video. Valid values: baseline, main, and high.
        # 
        # >  If multiple definitions are involved, we recommend that you use baseline for the lowest definition to ensure normal playback on low-end devices, and use main or high for other definitions.
        # 
        # *   **baseline**: applicable to mobile devices.
        # *   **main**: applicable to standard-definition devices.
        # *   **high**: applicable to high-definition devices.
        # *   Default value: **high**.
        self.profile = profile
        # The level of quality control on the video.
        self.qscale = qscale
        # The resource priority.
        self.reso_priority = reso_priority
        # The scan mode. Valid values:
        # 
        # *   If this parameter is left **empty**, the scan mode of the input video is used.
        # *   **auto**: automatic deinterlacing.
        # *   **progressive**: progressive scan.
        # *   **interlaced**: interlaced scan.
        # *   **By default**, this parameter is left empty.
        # 
        # **Best practice**: The interlaced scan mode saves data traffic than the progressive scan mode but provides poor image quality. Therefore, the progressive scan mode is commonly used in mainstream video production.
        # 
        # *   If **progressive** or **interlaced** is used when the scan mode of the input video is neither of them, the transcoding job fails.
        # *   We recommend that you use **the scan mode of the input video** or **automatic deinterlacing** for higher compatibility.
        self.scan_mode = scan_mode
        # The width of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: the width of the input video.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The OSS region in which the input file resides.
        self.location = location
        # The name of the Object Storage Service (OSS) object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        input_file: QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile = None,
        refer_pos: str = None,
        type: str = None,
        water_mark_template_id: str = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark image relative to the output video. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. Default value: 0. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the horizontal offset.
        # 
        #     *   Valid values: **[8,4096]**.
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the horizontal offset to the width in the output video resolution.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.dx = dx
        # The vertical offset of the watermark image relative to the output video. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the vertical offset.
        # 
        #     *   Valid values: **[8,4096]**.
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the vertical offset to the height in the output video resolution.
        # 
        #     *   Valid values: **(0,1)**.
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.dy = dy
        # The height of the watermark image. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the watermark height.
        # 
        #     *   Valid values: **[8,4096]**.
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the watermark height to the height in the output video resolution.
        # 
        #     *   Valid values: **(0,1)**.
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.height = height
        # The watermark input file. PNG images and MOV files are supported.
        self.input_file = input_file
        # The position of the watermark. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. Valid values:
        # 
        # *   TopRight
        # *   TopLeft
        # *   BottomRight
        # *   BottomLeft
        self.refer_pos = refer_pos
        # The type of the watermark. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html). Valid values:
        # 
        # *   Image
        # *   Text
        self.type = type
        # The ID of the watermark template.
        self.water_mark_template_id = water_mark_template_id
        # The width of the watermark image. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the watermark width.
        # 
        #     *   Valid values: **[8,4096]**.
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the watermark width to the width in the output video resolution.
        # 
        #     *   Valid values: **(0,1)**.
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excessive digits are automatically discarded.
        self.width = width

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.type is not None:
            result['Type'] = self.type
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('InputFile') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryJobListResponseBodyJobListJobOutputWaterMarkList(TeaModel):
    def __init__(
        self,
        water_mark: List[QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark] = None,
    ):
        self.water_mark = water_mark

    def validate(self):
        if self.water_mark:
            for k in self.water_mark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMark'] = []
        if self.water_mark is not None:
            for k in self.water_mark:
                result['WaterMark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark = []
        if m.get('WaterMark') is not None:
            for k in m.get('WaterMark'):
                temp_model = QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark()
                self.water_mark.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyJobListJobOutput(TeaModel):
    def __init__(
        self,
        audio: QueryJobListResponseBodyJobListJobOutputAudio = None,
        audio_stream_map: str = None,
        clip: QueryJobListResponseBodyJobListJobOutputClip = None,
        container: QueryJobListResponseBodyJobListJobOutputContainer = None,
        de_watermark: str = None,
        encryption: QueryJobListResponseBodyJobListJobOutputEncryption = None,
        extend_data: str = None,
        m_3u8non_standard_support: QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport = None,
        merge_config_url: str = None,
        merge_list: QueryJobListResponseBodyJobListJobOutputMergeList = None,
        multi_speed_info: QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo = None,
        mux_config: QueryJobListResponseBodyJobListJobOutputMuxConfig = None,
        opening_list: QueryJobListResponseBodyJobListJobOutputOpeningList = None,
        out_subtitle_list: QueryJobListResponseBodyJobListJobOutputOutSubtitleList = None,
        output_file: QueryJobListResponseBodyJobListJobOutputOutputFile = None,
        priority: str = None,
        properties: QueryJobListResponseBodyJobListJobOutputProperties = None,
        rotate: str = None,
        subtitle_config: QueryJobListResponseBodyJobListJobOutputSubtitleConfig = None,
        super_reso: QueryJobListResponseBodyJobListJobOutputSuperReso = None,
        tail_slate_list: QueryJobListResponseBodyJobListJobOutputTailSlateList = None,
        template_id: str = None,
        trans_config: QueryJobListResponseBodyJobListJobOutputTransConfig = None,
        user_data: str = None,
        video: QueryJobListResponseBodyJobListJobOutputVideo = None,
        video_stream_map: str = None,
        water_mark_config_url: str = None,
        water_mark_list: QueryJobListResponseBodyJobListJobOutputWaterMarkList = None,
    ):
        # The audio configurations.
        # 
        # >  If this parameter is specified in the request, the corresponding parameters in the specified transcoding template are overwritten.
        self.audio = audio
        # The sequence number of the audio stream.
        # 
        # *   Format: 0:a:{Sequence number}. Example: 0:a:0.
        # *   The sequence number is the index of the audio stream in the list and starts from 0.
        # *   If no sequence number is specified, the default audio stream is used.
        self.audio_stream_map = audio_stream_map
        # The information about clips.
        self.clip = clip
        # The container format configurations.
        self.container = container
        # The configurations of watermark blurring. The value is a JSON object. For more information, see the DeWatermark section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        self.de_watermark = de_watermark
        # The encryption configurations. The encrypted video file is generated in the M3U8 format.
        self.encryption = encryption
        # The custom fields.
        self.extend_data = extend_data
        # The non-standard support configurations for M3U8. The value is a JSON object. For more information, see the M3U8NonStandardSupport section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        self.m_3u8non_standard_support = m_3u8non_standard_support
        # The URL of the merging configuration file. Only one of MergeList and MergeConfigUrl takes effect.
        # 
        # *   The configuration file specified by MergeConfigUrl can contain up to 50 clips.
        # *   MergeConfigUrl indicates the URL of the configuration file for merging clips. Make sure that the configuration file is stored as an object in OSS and that MPS can access the OSS object. For information about the file content, see the details about merging parameters.
        # *   Example of the content of the merging configuration file: `{"MergeList":[{"MergeURL":"http://exampleBucket****.oss-cn-hangzhou.aliyuncs.com/video_01.mp4"}]}`.
        self.merge_config_url = merge_config_url
        # The configurations of clip merging. Up to four clips can be merged.
        self.merge_list = merge_list
        # The information about the high-speed transcoding job. This information is available only for jobs that are submitted by using an MPS queue for high-speed transcoding. This does not support MPS queues for high-speed transcoding of an earlier version.
        self.multi_speed_info = multi_speed_info
        # The transmuxing configurations. The transmuxing configurations. If this parameter is specified in the request, the corresponding parameters in the specified transcoding template are overwritten.
        self.mux_config = mux_config
        # The opening parts. The value is a JSON object.
        self.opening_list = opening_list
        # The output captions.
        self.out_subtitle_list = out_subtitle_list
        # The details of the output file.
        self.output_file = output_file
        # The priority of the job in the ApsaraVideo Media Processing (MPS) queue to which the job is added.
        # 
        # *   A value of 10 indicates the highest priority.
        # *   Default value: **6**.
        self.priority = priority
        # The media properties.
        self.properties = properties
        # The rotation angle of the video.
        self.rotate = rotate
        # The caption configurations.
        self.subtitle_config = subtitle_config
        # The configurations for using the resolution of the source video.
        self.super_reso = super_reso
        # The ending parts.
        self.tail_slate_list = tail_slate_list
        # The template ID.
        self.template_id = template_id
        # The general transcoding configurations.
        # 
        # >  If this parameter is specified in the request, the corresponding parameters in the specified transcoding template are overwritten.
        self.trans_config = trans_config
        # The custom data.
        self.user_data = user_data
        # The video configurations.
        self.video = video
        # The sequence number of the video stream. The sequence number is the index of the video stream in the list and starts from 0. If no sequence number is specified, the default video stream is used.
        self.video_stream_map = video_stream_map
        # The URL of the watermark configuration file.
        self.water_mark_config_url = water_mark_config_url
        # The watermarks.
        self.water_mark_list = water_mark_list

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.clip:
            self.clip.validate()
        if self.container:
            self.container.validate()
        if self.encryption:
            self.encryption.validate()
        if self.m_3u8non_standard_support:
            self.m_3u8non_standard_support.validate()
        if self.merge_list:
            self.merge_list.validate()
        if self.multi_speed_info:
            self.multi_speed_info.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.opening_list:
            self.opening_list.validate()
        if self.out_subtitle_list:
            self.out_subtitle_list.validate()
        if self.output_file:
            self.output_file.validate()
        if self.properties:
            self.properties.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()
        if self.super_reso:
            self.super_reso.validate()
        if self.tail_slate_list:
            self.tail_slate_list.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()
        if self.water_mark_list:
            self.water_mark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.audio_stream_map is not None:
            result['AudioStreamMap'] = self.audio_stream_map
        if self.clip is not None:
            result['Clip'] = self.clip.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.de_watermark is not None:
            result['DeWatermark'] = self.de_watermark
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        if self.extend_data is not None:
            result['ExtendData'] = self.extend_data
        if self.m_3u8non_standard_support is not None:
            result['M3U8NonStandardSupport'] = self.m_3u8non_standard_support.to_map()
        if self.merge_config_url is not None:
            result['MergeConfigUrl'] = self.merge_config_url
        if self.merge_list is not None:
            result['MergeList'] = self.merge_list.to_map()
        if self.multi_speed_info is not None:
            result['MultiSpeedInfo'] = self.multi_speed_info.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.opening_list is not None:
            result['OpeningList'] = self.opening_list.to_map()
        if self.out_subtitle_list is not None:
            result['OutSubtitleList'] = self.out_subtitle_list.to_map()
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.subtitle_config is not None:
            result['SubtitleConfig'] = self.subtitle_config.to_map()
        if self.super_reso is not None:
            result['SuperReso'] = self.super_reso.to_map()
        if self.tail_slate_list is not None:
            result['TailSlateList'] = self.tail_slate_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video is not None:
            result['Video'] = self.video.to_map()
        if self.video_stream_map is not None:
            result['VideoStreamMap'] = self.video_stream_map
        if self.water_mark_config_url is not None:
            result['WaterMarkConfigUrl'] = self.water_mark_config_url
        if self.water_mark_list is not None:
            result['WaterMarkList'] = self.water_mark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('AudioStreamMap') is not None:
            self.audio_stream_map = m.get('AudioStreamMap')
        if m.get('Clip') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputClip()
            self.clip = temp_model.from_map(m['Clip'])
        if m.get('Container') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('DeWatermark') is not None:
            self.de_watermark = m.get('DeWatermark')
        if m.get('Encryption') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        if m.get('ExtendData') is not None:
            self.extend_data = m.get('ExtendData')
        if m.get('M3U8NonStandardSupport') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport()
            self.m_3u8non_standard_support = temp_model.from_map(m['M3U8NonStandardSupport'])
        if m.get('MergeConfigUrl') is not None:
            self.merge_config_url = m.get('MergeConfigUrl')
        if m.get('MergeList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMergeList()
            self.merge_list = temp_model.from_map(m['MergeList'])
        if m.get('MultiSpeedInfo') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMultiSpeedInfo()
            self.multi_speed_info = temp_model.from_map(m['MultiSpeedInfo'])
        if m.get('MuxConfig') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('OpeningList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputOpeningList()
            self.opening_list = temp_model.from_map(m['OpeningList'])
        if m.get('OutSubtitleList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputOutSubtitleList()
            self.out_subtitle_list = temp_model.from_map(m['OutSubtitleList'])
        if m.get('OutputFile') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Properties') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('SubtitleConfig') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['SubtitleConfig'])
        if m.get('SuperReso') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputSuperReso()
            self.super_reso = temp_model.from_map(m['SuperReso'])
        if m.get('TailSlateList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputTailSlateList()
            self.tail_slate_list = temp_model.from_map(m['TailSlateList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Video') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputVideo()
            self.video = temp_model.from_map(m['Video'])
        if m.get('VideoStreamMap') is not None:
            self.video_stream_map = m.get('VideoStreamMap')
        if m.get('WaterMarkConfigUrl') is not None:
            self.water_mark_config_url = m.get('WaterMarkConfigUrl')
        if m.get('WaterMarkList') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutputWaterMarkList()
            self.water_mark_list = temp_model.from_map(m['WaterMarkList'])
        return self


class QueryJobListResponseBodyJobListJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        finish_time: str = None,
        input: QueryJobListResponseBodyJobListJobInput = None,
        job_id: str = None,
        mnsmessage_result: QueryJobListResponseBodyJobListJobMNSMessageResult = None,
        message: str = None,
        output: QueryJobListResponseBodyJobListJobOutput = None,
        percent: int = None,
        pipeline_id: str = None,
        state: str = None,
        submit_time: str = None,
    ):
        # The error code returned if the job failed. If the job was successful, this parameter is not returned.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The information about the job input.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The message sent by Message Service (MNS) to notify users of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the job failed. If the job was successful, this parameter is not returned.
        self.message = message
        # The job output.
        self.output = output
        # The transcoding progress.
        self.percent = percent
        # The ID of the MPS queue that is used to run the job.
        self.pipeline_id = pipeline_id
        # The job state. Valid values:
        # 
        # *   **Submitted**: The job was submitted.
        # *   **Transcoding**: Transcoding is in process.
        # *   **TranscodeSuccess**: The job was successful.
        # *   **TranscodeFail**: The job failed.
        # *   **TranscodeCancelled**: The job was canceled.
        self.state = state
        # The time when the job was submitted.
        self.submit_time = submit_time

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = QueryJobListResponseBodyJobListJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryJobListResponseBodyJobListJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            temp_model = QueryJobListResponseBodyJobListJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        return self


class QueryJobListResponseBodyJobList(TeaModel):
    def __init__(
        self,
        job: List[QueryJobListResponseBodyJobListJob] = None,
    ):
        self.job = job

    def validate(self):
        if self.job:
            for k in self.job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Job'] = []
        if self.job is not None:
            for k in self.job:
                result['Job'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job = []
        if m.get('Job') is not None:
            for k in m.get('Job'):
                temp_model = QueryJobListResponseBodyJobListJob()
                self.job.append(temp_model.from_map(k))
        return self


class QueryJobListResponseBodyNonExistJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryJobListResponseBody(TeaModel):
    def __init__(
        self,
        job_list: QueryJobListResponseBodyJobList = None,
        non_exist_job_ids: QueryJobListResponseBodyNonExistJobIds = None,
        request_id: str = None,
    ):
        # The transcoding jobs.
        self.job_list = job_list
        # The list of nonexistent job IDs. If all queried job IDs exist, the response does not contain this parameter.
        self.non_exist_job_ids = non_exist_job_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.job_list:
            self.job_list.validate()
        if self.non_exist_job_ids:
            self.non_exist_job_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_list is not None:
            result['JobList'] = self.job_list.to_map()
        if self.non_exist_job_ids is not None:
            result['NonExistJobIds'] = self.non_exist_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobList') is not None:
            temp_model = QueryJobListResponseBodyJobList()
            self.job_list = temp_model.from_map(m['JobList'])
        if m.get('NonExistJobIds') is not None:
            temp_model = QueryJobListResponseBodyNonExistJobIds()
            self.non_exist_job_ids = temp_model.from_map(m['NonExistJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaCensorJobDetailRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the content moderation job. You can obtain the job ID from the response parameters of the [SubmitMediaCensorJob](https://help.aliyun.com/document_detail/91774.html) operation.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The maximum number of entries to return on each page.
        # 
        # *   Default value: **30**.
        # *   Valid values: **1 to 300**.
        self.maximum_page_size = maximum_page_size
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. The token of the next page is returned after you call this operation to query the results of a content moderation job for the first time.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        label: str = None,
        start_time: int = None,
        text: str = None,
    ):
        self.end_time = end_time
        self.label = label
        self.start_time = start_time
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.label is not None:
            result['Label'] = self.label
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList(TeaModel):
    def __init__(
        self,
        audio_detail_result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult] = None,
    ):
        self.audio_detail_result = audio_detail_result

    def validate(self):
        if self.audio_detail_result:
            for k in self.audio_detail_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioDetailResult'] = []
        if self.audio_detail_result is not None:
            for k in self.audio_detail_result:
                result['AudioDetailResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_detail_result = []
        if m.get('AudioDetailResult') is not None:
            for k in m.get('AudioDetailResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultListAudioDetailResult()
                self.audio_detail_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult(TeaModel):
    def __init__(
        self,
        audio_detail_result_list: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList = None,
        label: str = None,
        suggestion: str = None,
    ):
        self.audio_detail_result_list = audio_detail_result_list
        self.label = label
        self.suggestion = suggestion

    def validate(self):
        if self.audio_detail_result_list:
            self.audio_detail_result_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_detail_result_list is not None:
            result['AudioDetailResultList'] = self.audio_detail_result_list.to_map()
        if self.label is not None:
            result['Label'] = self.label
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioDetailResultList') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResultAudioDetailResultList()
            self.audio_detail_result_list = temp_model.from_map(m['AudioDetailResultList'])
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Multiple labels are separated with commas (,). Valid values:
        # 
        # *   **spam**: spam
        # *   **ad**: ads
        # *   **abuse**: abuse
        # *   **flood**: excessive junk content
        # *   **contraband**: prohibited content
        # *   **meaningless**: meaningless content
        # *   **normal**: normal content
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values: The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Multiple labels are separated with commas (,).
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **sexy**: sexy content
        #     *   **porn**: pornographic content
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **narmal**: normal content
        #     *   **bloody**: bloody content
        #     *   **explosion**: explosion and smoke
        #     *   **outfit**: special costume
        #     *   **logo**: special logo
        #     *   **weapon**: weapon
        #     *   **politics**: political content
        #     *   **violence**: violence
        #     *   **crowd**: crowd
        #     *   **parade**: parade
        #     *   **carcrash**: car accident
        #     *   **flag**: flag
        #     *   **location**: landmark
        #     *   **others**: other content
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **ad**: other ads
        #     *   **politics**: political content in text
        #     *   **porn**: pornographic content in text
        #     *   **abuse**: abuse in text
        #     *   **terrorism**: terrorist content in text
        #     *   **contraband**: prohibited content in text
        #     *   **spam**: spam in text
        #     *   **npx**: illegal ads
        #     *   **qrcode**: QR code
        #     *   **programCode**: mini program code
        # 
        # *   Valid values in the live moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **meaningless**: meaningless content, such as a black or white screen
        #     *   **PIP**: picture-in-picture
        #     *   **smoking**: smoking
        #     *   **drivelive**: live broadcasting in a running vehicle
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **TV**: controlled TV station logo
        #     *   **trademark**: trademark
        self.label = label
        # The score. Valid values: **0 to 100**.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation
        # *   **terrorism**: terrorist content moderation
        # *   **ad**: ad violation moderation
        # *   **live**: undesirable scene moderation
        # *   **logo**: logo moderation
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults(TeaModel):
    def __init__(
        self,
        result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult] = None,
    ):
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults = None,
    ):
        # The OSS bucket that stores the video thumbnail.
        self.bucket = bucket
        # The OSS region in which the video thumbnail resides.
        self.location = location
        # The Object Storage Service (OSS) object that is used as the video thumbnail.
        self.object = object
        # The moderation results.
        self.results = results

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.results is not None:
            result['Results'] = self.results.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Results') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults()
            self.results = temp_model.from_map(m['Results'])
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults(TeaModel):
    def __init__(
        self,
        cover_image_censor_result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult] = None,
    ):
        self.cover_image_censor_result = cover_image_censor_result

    def validate(self):
        if self.cover_image_censor_result:
            for k in self.cover_image_censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CoverImageCensorResult'] = []
        if self.cover_image_censor_result is not None:
            for k in self.cover_image_censor_result:
                result['CoverImageCensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cover_image_censor_result = []
        if m.get('CoverImageCensorResult') is not None:
            for k in m.get('CoverImageCensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult()
                self.cover_image_censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Valid values:
        # 
        # *   **spam**: spam
        # *   **ad**: ads
        # *   **abuse**: abuse
        # *   **flood**: excessive junk content
        # *   **contraband**: prohibited content
        # *   **meaningless**: meaningless content
        # *   **normal**: normal content
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values: The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input media file is stored.
        self.bucket = bucket
        # The OSS region in which the input media file resides.
        self.location = location
        # The name of the OSS object that is used as the input media file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Valid values:
        # 
        # *   **normal**: normal content
        # *   **spam**: spam
        # *   **ad**: ads
        # *   **abuse**: abuse
        # *   **flood**: excessive junk content
        # *   **contraband**: prohibited content
        # *   **meaningless**: meaningless content
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values: The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Multiple labels are separated with commas (,). Valid values:
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **porn**: pornographic content
        #     *   **sexy**: sexy content
        #     *   **normal**: normal content
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **bloody**: bloody content
        #     *   **explosion**: explosion and smoke
        #     *   **outfit**: special costume
        #     *   **logo**: special logo
        #     *   **weapon**: weapon
        #     *   **politics**: political content
        #     *   **violence**: violence
        #     *   **crowd**: crowd
        #     *   **parade**: parade
        #     *   **carcrash**: car accident
        #     *   **flag**: flag
        #     *   **location**: landmark
        #     *   **others**: other content
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **ad**: other ads
        #     *   **politics**: political content in text
        #     *   **porn**: pornographic content in text
        #     *   **abuse**: abuse in text
        #     *   **terrorism**: terrorist content in text
        #     *   **contraband**: prohibited content in text
        #     *   **spam**: spam in text
        #     *   **npx**: illegal ads
        #     *   **qrcode**: QR code
        #     *   **programCode**: mini program code
        # 
        # *   Valid values in the live moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **meaningless**: meaningless content, such as a black or white screen
        #     *   **PIP**: picture-in-picture
        #     *   **smoking**: smoking
        #     *   **drivelive**: live broadcasting in a running vehicle
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **TV**: controlled TV station logo
        #     *   **trademark**: trademark
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation
        # *   **terrorism**: terrorist content moderation
        # *   **ad**: ad violation moderation
        # *   **live**: undesirable scene moderation
        # *   **logo**: logo moderation
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults(TeaModel):
    def __init__(
        self,
        censor_result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult] = None,
    ):
        self.censor_result = censor_result

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Multiple labels are separated with commas (,). Valid values:
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **porn**: pornographic content
        #     *   **sexy**: sexy content
        #     *   **normal**: normal content
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **bloody**: bloody content
        #     *   **explosion**: explosion and smoke
        #     *   **outfit**: special costume
        #     *   **logo**: special logo
        #     *   **weapon**: weapon
        #     *   **politics**: political content
        #     *   **violence**: violence
        #     *   **crowd**: crowd
        #     *   **parade**: parade
        #     *   **carcrash**: car accident
        #     *   **flag**: flag
        #     *   **location**: landmark
        #     *   **others**: other content
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **ad**: other ads
        #     *   **politics**: political content in text
        #     *   **porn**: pornographic content in text
        #     *   **abuse**: abuse in text
        #     *   **terrorism**: terrorist content in text
        #     *   **contraband**: prohibited content in text
        #     *   **spam**: spam in text
        #     *   **npx**: illegal ads
        #     *   **qrcode**: QR code
        #     *   **programCode**: mini program code
        # 
        # *   Valid values in the live moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **meaningless**: meaningless content, such as a black or white screen
        #     *   **PIP**: picture-in-picture
        #     *   **smoking**: smoking
        #     *   **drivelive**: live broadcasting in a running vehicle
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **TV**: controlled TV station logo
        #     *   **trademark**: trademark
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation
        # *   **terrorism**: terrorist content moderation
        # *   **ad**: ad violation moderation
        # *   **live**: undesirable scene moderation
        # *   **logo**: logo moderation
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults(TeaModel):
    def __init__(
        self,
        censor_result: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult] = None,
    ):
        self.censor_result = censor_result

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline(TeaModel):
    def __init__(
        self,
        censor_results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults = None,
        object: str = None,
        timestamp: str = None,
    ):
        # The moderation results that include information such as labels and scores.
        self.censor_results = censor_results
        # The one or more OSS objects that are generated as the output snapshots.
        # 
        # > In the example, {Count} is a placeholder. The OSS objects that are generated as output snapshots are named `output00001-****.jpg`, `output00002-****.jpg`, and so on.
        self.object = object
        # The position in the video. Format: `hh:mm:ss[.SSS]`.
        self.timestamp = timestamp

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.object is not None:
            result['Object'] = self.object
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines(TeaModel):
    def __init__(
        self,
        video_timeline: List[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline] = None,
    ):
        self.video_timeline = video_timeline

    def validate(self):
        if self.video_timeline:
            for k in self.video_timeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoTimeline'] = []
        if self.video_timeline is not None:
            for k in self.video_timeline:
                result['VideoTimeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_timeline = []
        if m.get('VideoTimeline') is not None:
            for k in m.get('VideoTimeline'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline()
                self.video_timeline.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult(TeaModel):
    def __init__(
        self,
        censor_results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults = None,
        next_page_token: str = None,
        video_timelines: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines = None,
    ):
        # A collection of the moderation results. The information includes the summary of various scenarios such as pornographic content and terrorist content.
        self.censor_results = censor_results
        # The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The moderation results that are sorted in ascending order by time.
        self.video_timelines = video_timelines

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()
        if self.video_timelines:
            self.video_timelines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.video_timelines is not None:
            result['VideoTimelines'] = self.video_timelines.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('VideoTimelines') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines()
            self.video_timelines = temp_model.from_map(m['VideoTimelines'])
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket that stores the output snapshots.
        self.bucket = bucket
        # The region in which the OSS bucket that stores the output snapshot resides.
        self.location = location
        # The one or more OSS objects that are generated as the output snapshots.
        # 
        # > In the example, {Count} is a placeholder. The OSS objects that are generated as output snapshots are named `output00001-****.jpg`, `output00002-****.jpg`, and so on.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        output_file: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile = None,
        video_censor: str = None,
    ):
        # The custom business type. Default value: common.
        self.biz_type = biz_type
        # The information about output snapshots.
        self.output_file = output_file
        # Indicates whether the video content needs to be moderated. Default value: **true** Valid values:
        # 
        # *   **true**: The video content needs to be moderated.
        # *   **false**: The video content does not need to be moderated.
        self.video_censor = video_censor

    def validate(self):
        if self.output_file:
            self.output_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.video_censor is not None:
            result['VideoCensor'] = self.video_censor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('OutputFile') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('VideoCensor') is not None:
            self.video_censor = m.get('VideoCensor')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail(TeaModel):
    def __init__(
        self,
        audio_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult = None,
        barrage_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult = None,
        code: str = None,
        cover_image_censor_results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults = None,
        creation_time: str = None,
        desc_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult = None,
        finish_time: str = None,
        input: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput = None,
        job_id: str = None,
        message: str = None,
        pipeline_id: str = None,
        state: str = None,
        suggestion: str = None,
        title_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult = None,
        user_data: str = None,
        vensor_censor_result: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult = None,
        video_censor_config: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig = None,
    ):
        self.audio_censor_result = audio_censor_result
        # The moderation result of live comments.
        self.barrage_censor_result = barrage_censor_result
        # The error code returned if the job fails. This parameter is not returned if the job is successful.
        self.code = code
        # The moderation results of thumbnails.
        self.cover_image_censor_results = cover_image_censor_results
        # The time when the job was created.
        self.creation_time = creation_time
        # The moderation result of the description.
        self.desc_censor_result = desc_censor_result
        # The time when the job was complete.
        self.finish_time = finish_time
        # The information about the job input.
        self.input = input
        # The ID of the content moderation job.
        self.job_id = job_id
        # The error message returned if the job fails. This parameter is not returned if the job is successful.
        self.message = message
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the content moderation job is submitted.
        self.pipeline_id = pipeline_id
        # The status of the job. Valid values:
        self.state = state
        # The overall result of the job. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        # 
        # If the moderation result of one type of the moderated content is review, the overall result is review. If the moderation result of one type of the moderated content is block, the overall result is block.
        self.suggestion = suggestion
        # The moderation result of the title.
        self.title_censor_result = title_censor_result
        # The custom data.
        self.user_data = user_data
        # The moderation results of the video.
        self.vensor_censor_result = vensor_censor_result
        # The video moderation configurations.
        self.video_censor_config = video_censor_config

    def validate(self):
        if self.audio_censor_result:
            self.audio_censor_result.validate()
        if self.barrage_censor_result:
            self.barrage_censor_result.validate()
        if self.cover_image_censor_results:
            self.cover_image_censor_results.validate()
        if self.desc_censor_result:
            self.desc_censor_result.validate()
        if self.input:
            self.input.validate()
        if self.title_censor_result:
            self.title_censor_result.validate()
        if self.vensor_censor_result:
            self.vensor_censor_result.validate()
        if self.video_censor_config:
            self.video_censor_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_censor_result is not None:
            result['AudioCensorResult'] = self.audio_censor_result.to_map()
        if self.barrage_censor_result is not None:
            result['BarrageCensorResult'] = self.barrage_censor_result.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.cover_image_censor_results is not None:
            result['CoverImageCensorResults'] = self.cover_image_censor_results.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.desc_censor_result is not None:
            result['DescCensorResult'] = self.desc_censor_result.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.title_censor_result is not None:
            result['TitleCensorResult'] = self.title_censor_result.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.vensor_censor_result is not None:
            result['VensorCensorResult'] = self.vensor_censor_result.to_map()
        if self.video_censor_config is not None:
            result['VideoCensorConfig'] = self.video_censor_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailAudioCensorResult()
            self.audio_censor_result = temp_model.from_map(m['AudioCensorResult'])
        if m.get('BarrageCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult()
            self.barrage_censor_result = temp_model.from_map(m['BarrageCensorResult'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CoverImageCensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults()
            self.cover_image_censor_results = temp_model.from_map(m['CoverImageCensorResults'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DescCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult()
            self.desc_censor_result = temp_model.from_map(m['DescCensorResult'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('TitleCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult()
            self.title_censor_result = temp_model.from_map(m['TitleCensorResult'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VensorCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult()
            self.vensor_censor_result = temp_model.from_map(m['VensorCensorResult'])
        if m.get('VideoCensorConfig') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig()
            self.video_censor_config = temp_model.from_map(m['VideoCensorConfig'])
        return self


class QueryMediaCensorJobDetailResponseBody(TeaModel):
    def __init__(
        self,
        media_censor_job_detail: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail = None,
        request_id: str = None,
    ):
        # The results of the content moderation job.
        self.media_censor_job_detail = media_censor_job_detail
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_censor_job_detail:
            self.media_censor_job_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_censor_job_detail is not None:
            result['MediaCensorJobDetail'] = self.media_censor_job_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaCensorJobDetail') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail()
            self.media_censor_job_detail = temp_model.from_map(m['MediaCensorJobDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaCensorJobDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaCensorJobDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaCensorJobListRequest(TeaModel):
    def __init__(
        self,
        end_of_job_created_time_range: str = None,
        job_ids: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        start_of_job_created_time_range: str = None,
        state: str = None,
    ):
        # The end of the time range within which the jobs to be queried were created.
        # 
        # *   Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format.
        # *   The time must be in UTC.
        self.end_of_job_created_time_range = end_of_job_created_time_range
        # The ID of the content moderation job. You can call the [SubmitMediaCensorJob](https://help.aliyun.com/document_detail/91779.html) operation to query the ID of the content moderation job. Separate multiple IDs with commas (,).
        self.job_ids = job_ids
        # The maximum number of entries to return on each page.
        # 
        # *   Default value: **30**.
        # *   Valid values: **1 to 300**.
        self.maximum_page_size = maximum_page_size
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. The returned value of NextPageToken is a pagination token, which can be used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job. To obtain the ID of the MPS queue, perform the following steps: Log on to the [**MPS console**](https://mps.console.aliyun.com/overview). In the left-side navigation pane, choose **Global Settings** > **Pipelines**.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The beginning of the time range within which the jobs to be queried were created.
        # 
        # *   Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format.
        # *   The time must be in UTC.
        self.start_of_job_created_time_range = start_of_job_created_time_range
        # The status of the jobs to be queried. Valid values:
        # 
        # *   **All**: all jobs.
        # *   **Queuing**: the jobs that are being queued.
        # *   **Analysing**: the jobs that are in progress.
        # *   **Fail**: failed jobs.
        # *   **Success**: successful jobs.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_job_created_time_range is not None:
            result['EndOfJobCreatedTimeRange'] = self.end_of_job_created_time_range
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_of_job_created_time_range is not None:
            result['StartOfJobCreatedTimeRange'] = self.start_of_job_created_time_range
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfJobCreatedTimeRange') is not None:
            self.end_of_job_created_time_range = m.get('EndOfJobCreatedTimeRange')
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartOfJobCreatedTimeRange') is not None:
            self.start_of_job_created_time_range = m.get('StartOfJobCreatedTimeRange')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        suggestion: str = None,
    ):
        self.label = label
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Separate multiple labels with commas (,). Valid values:
        # 
        # *   **spam**: spam
        # *   **ad**: ads
        # *   **abuse**: abuse
        # *   **flood**: excessive junk content
        # *   **contraband**: prohibited content
        # *   **meaningless**: meaningless content
        # *   **normal**: normal content
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Separate multiple labels with commas (,).
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **sexy**: sexy content
        #     *   **porn**: pornographic content
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **bloody**: bloody content
        #     *   **explosion**: explosion and smoke
        #     *   **outfit**: special costume
        #     *   **logo**: special logo
        #     *   **weapon**: weapon
        #     *   **politics**: political content
        #     *   **violence**: violence
        #     *   **crowd**: crowd
        #     *   **parade**: parade
        #     *   **carcrash**: car accident
        #     *   **flag**: flag
        #     *   **location**: landmark
        #     *   **others**: other content
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **ad**: other ads
        #     *   **politics**: political content in text
        #     *   **porn**: pornographic content in text
        #     *   **abuse**: abuse in text
        #     *   **terrorism**: terrorist content in text
        #     *   **contraband**: prohibited content in text
        #     *   **spam**: spam in text
        #     *   **npx**: illegal ads
        #     *   **qrcode**: QR code
        #     *   **programCode**: mini program code
        # 
        # *   Valid values in the live moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **meaningless**: meaningless content, such as a black or white screen
        #     *   **PIP**: picture-in-picture
        #     *   **smoking**: smoking
        #     *   **drivelive**: live broadcasting in a running vehicle
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **TV**: controlled TV station logo
        #     *   **trademark**: trademark
        self.label = label
        # The score. Valid values: 0 to 100.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation
        # *   **terrorism**: terrorist content moderation
        # *   **ad**: ad violation moderation
        # *   **live**: undesirable scene moderation
        # *   **logo**: special logo moderation
        self.scene = scene
        # The overall result of the job. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        # 
        # > If the moderation result of any type of the moderated content is review, the overall result is review. If the moderation result of any type of the moderated content is block, the overall result is block.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults(TeaModel):
    def __init__(
        self,
        result: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult] = None,
    ):
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults = None,
    ):
        # The OSS bucket that stores the video thumbnail.
        self.bucket = bucket
        # The OSS region in which the video thumbnail resides.
        self.location = location
        # The Object Storage Service (OSS) object that is used as the video thumbnail.
        self.object = object
        # The moderation results of the content moderation jobs.
        self.results = results

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.results is not None:
            result['Results'] = self.results.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Results') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults()
            self.results = temp_model.from_map(m['Results'])
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults(TeaModel):
    def __init__(
        self,
        cover_image_censor_result: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult] = None,
    ):
        self.cover_image_censor_result = cover_image_censor_result

    def validate(self):
        if self.cover_image_censor_result:
            for k in self.cover_image_censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CoverImageCensorResult'] = []
        if self.cover_image_censor_result is not None:
            for k in self.cover_image_censor_result:
                result['CoverImageCensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cover_image_censor_result = []
        if m.get('CoverImageCensorResult') is not None:
            for k in m.get('CoverImageCensorResult'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult()
                self.cover_image_censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Separate multiple labels with commas (,). Valid values:
        # 
        # *   **spam**: spam
        # *   **ad**: ads
        # *   **abuse**: abuse
        # *   **flood**: excessive junk content
        # *   **contraband**: prohibited content
        # *   **meaningless**: meaningless content
        # *   **normal**: normal content
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The OSS region in which the input file resides.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Separate multiple labels with commas (,).
        # 
        # *   **normal**: normal content
        # *   **spam**: spam
        # *   **ad**: ads
        # *   **abuse**: abuse content
        # *   **flood**: excessive junk content
        # *   **contraband**: prohibited content
        # *   **meaningless**: meaningless content
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. The value is **antispam**.
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Separate multiple labels with commas (,).
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **porn**: pornographic content
        #     *   **sexy**: sexy content
        #     *   **normal**: normal content
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **bloody**: bloody content
        #     *   **explosion**: explosion and smoke
        #     *   **outfit**: special costume
        #     *   **logo**: special logo
        #     *   **weapon**: weapon
        #     *   **politics**: political content
        #     *   **violence**: violence
        #     *   **crowd**: crowd
        #     *   **parade**: parade
        #     *   **carcrash**: car accident
        #     *   **flag**: flag
        #     *   **location**: landmark
        #     *   **others**: other content
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **ad**: other ads
        #     *   **politics**: political content in text
        #     *   **porn**: pornographic content in text
        #     *   **abuse**: abuse in text
        #     *   **terrorism**: terrorist content in text
        #     *   **contraband**: prohibited content in text
        #     *   **spam**: spam in text
        #     *   **npx**: illegal ads
        #     *   **qrcode**: QR code
        #     *   **programCode**: mini program code
        # 
        # *   Valid values in the live moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **meaningless**: meaningless content, such as a black or white screen
        #     *   **PIP**: picture-in-picture
        #     *   **smoking**: smoking
        #     *   **drivelive**: live broadcasting in a running vehicle
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **TV**: controlled TV station logo
        #     *   **trademark**: trademark
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation
        # *   **terrorism**: terrorist content moderation
        # *   **ad**: ad violation moderation
        # *   **live**: undesirable scene moderation
        # *   **logo**: special logo moderation
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults(TeaModel):
    def __init__(
        self,
        censor_result: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult] = None,
    ):
        self.censor_result = censor_result

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(TeaModel):
    def __init__(
        self,
        label: str = None,
        rate: str = None,
        scene: str = None,
        suggestion: str = None,
    ):
        # The labels of the moderation result. Separate multiple labels with commas (,). Valid values:
        # 
        # *   Valid values in the pornographic content moderation scenario:
        # 
        #     *   **porn**: pornographic content
        #     *   **sexy**: sexy content
        #     *   **normal**: normal content
        # 
        # *   Valid values in the terrorist content moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **bloody**: bloody content
        #     *   **explosion**: explosion and smoke
        #     *   **outfit**: special costume
        #     *   **logo**: special logo
        #     *   **weapon**: weapon
        #     *   **politics**: political content
        #     *   **violence**: violence
        #     *   **crowd**: crowd
        #     *   **parade**: parade
        #     *   **carcrash**: car accident
        #     *   **flag**: flag
        #     *   **location**: landmark
        #     *   **others**: other content
        # 
        # *   Valid values in the ad moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **ad**: other ads
        #     *   **politics**: political content in text
        #     *   **porn**: pornographic content in text
        #     *   **abuse**: abuse in text
        #     *   **terrorism**: terrorist content in text
        #     *   **contraband**: prohibited content in text
        #     *   **spam**: spam in text
        #     *   **npx**: illegal ads
        #     *   **qrcode**: QR code
        #     *   **programCode**: mini program code
        # 
        # *   Valid values in the live moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **meaningless**: meaningless content, such as a black or white screen
        #     *   **PIP**: picture-in-picture
        #     *   **smoking**: smoking
        #     *   **drivelive**: live broadcasting in a running vehicle
        # 
        # *   Valid values in the logo moderation scenario:
        # 
        #     *   **normal**: normal content
        #     *   **TV**: controlled TV station logo
        #     *   **trademark**: trademark
        self.label = label
        # The score.
        self.rate = rate
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornographic content moderation
        # *   **terrorism**: terrorist content moderation
        # *   **ad**: ad violation moderation
        # *   **live**: undesirable scene moderation
        # *   **logo**: special logo moderation
        self.scene = scene
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults(TeaModel):
    def __init__(
        self,
        censor_result: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult] = None,
    ):
        self.censor_result = censor_result

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline(TeaModel):
    def __init__(
        self,
        censor_results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults = None,
        object: str = None,
        timestamp: str = None,
    ):
        # The moderation results that include information such as labels and scores.
        self.censor_results = censor_results
        # The OSS object that is generated as the output snapshot.
        # 
        # > In the example, {Count} is a placeholder. The OSS objects that are generated as output snapshots are named `output00001-****.jpg, output00002-****.jpg`, and so on.
        self.object = object
        # The position in the video. Format: `hh:mm:ss[.SSS]`.
        self.timestamp = timestamp

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.object is not None:
            result['Object'] = self.object
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines(TeaModel):
    def __init__(
        self,
        video_timeline: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline] = None,
    ):
        self.video_timeline = video_timeline

    def validate(self):
        if self.video_timeline:
            for k in self.video_timeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoTimeline'] = []
        if self.video_timeline is not None:
            for k in self.video_timeline:
                result['VideoTimeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_timeline = []
        if m.get('VideoTimeline') is not None:
            for k in m.get('VideoTimeline'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline()
                self.video_timeline.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult(TeaModel):
    def __init__(
        self,
        censor_results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults = None,
        next_page_token: str = None,
        video_timelines: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines = None,
    ):
        # A collection of the moderation results. The information includes the summary about various scenarios such as pornographic content and terrorist content.
        self.censor_results = censor_results
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_page_token = next_page_token
        # The moderation results that are sorted in ascending order by time.
        self.video_timelines = video_timelines

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()
        if self.video_timelines:
            self.video_timelines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.video_timelines is not None:
            result['VideoTimelines'] = self.video_timelines.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('VideoTimelines') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines()
            self.video_timelines = temp_model.from_map(m['VideoTimelines'])
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket that stores the output snapshot.
        self.bucket = bucket
        # The OSS region in which the OSS bucket for storing the output snapshot resides.
        self.location = location
        # The one or more OSS objects that are generated as the output snapshots.
        # 
        # > In the example, {Count} is a placeholder. The OSS objects that are generated as output snapshots are named `output00001-****.jpg, output00002-****.jpg`, and so on.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        output_file: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile = None,
        video_censor: str = None,
    ):
        # The moderation template. Default value: common. The default value indicates that the default template is used.
        # 
        # > If the moderation template is not specified, the default value common is returned. If a custom moderation template that is created by submitting a ticket is specified, a user ID is returned.
        self.biz_type = biz_type
        # The information about output snapshots.
        self.output_file = output_file
        # Indicates whether the video content needs to be moderated. Default value: true. Valid values:
        # 
        # *   **true**: The video content needs to be moderated.
        # *   **false**: The video content does not need to be moderated.
        self.video_censor = video_censor

    def validate(self):
        if self.output_file:
            self.output_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.video_censor is not None:
            result['VideoCensor'] = self.video_censor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('OutputFile') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('VideoCensor') is not None:
            self.video_censor = m.get('VideoCensor')
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob(TeaModel):
    def __init__(
        self,
        audio_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult = None,
        barrage_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult = None,
        code: str = None,
        cover_image_censor_results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults = None,
        creation_time: str = None,
        desc_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult = None,
        finish_time: str = None,
        input: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput = None,
        job_id: str = None,
        message: str = None,
        pipeline_id: str = None,
        state: str = None,
        suggestion: str = None,
        title_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult = None,
        user_data: str = None,
        vensor_censor_result: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult = None,
        video_censor_config: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig = None,
    ):
        self.audio_censor_result = audio_censor_result
        # The moderation result of live comments.
        self.barrage_censor_result = barrage_censor_result
        # The error code returned if the job fails. This parameter is not returned if the job is successful.
        self.code = code
        # The moderation results of thumbnails.
        self.cover_image_censor_results = cover_image_censor_results
        # The time when the job was created.
        self.creation_time = creation_time
        # The moderation result of the description.
        self.desc_censor_result = desc_censor_result
        # The time when the job was completed.
        self.finish_time = finish_time
        # The information about the job input.
        self.input = input
        # The ID of the content moderation job.
        self.job_id = job_id
        # The error message returned if the job fails. This parameter is not returned if the job is successful.
        self.message = message
        # The ID of the MPS queue that is used to run the job.
        self.pipeline_id = pipeline_id
        # The status of the job.
        self.state = state
        # The recommended subsequent operation. Valid values:
        # 
        # *   **pass**: The content passes the moderation.
        # *   **review**: The content needs to be manually reviewed again.
        # *   **block**: The content needs to be blocked.
        self.suggestion = suggestion
        # The moderation result of the title.
        self.title_censor_result = title_censor_result
        # The custom data.
        self.user_data = user_data
        # The moderation results of the video.
        self.vensor_censor_result = vensor_censor_result
        # The video moderation configurations.
        self.video_censor_config = video_censor_config

    def validate(self):
        if self.audio_censor_result:
            self.audio_censor_result.validate()
        if self.barrage_censor_result:
            self.barrage_censor_result.validate()
        if self.cover_image_censor_results:
            self.cover_image_censor_results.validate()
        if self.desc_censor_result:
            self.desc_censor_result.validate()
        if self.input:
            self.input.validate()
        if self.title_censor_result:
            self.title_censor_result.validate()
        if self.vensor_censor_result:
            self.vensor_censor_result.validate()
        if self.video_censor_config:
            self.video_censor_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_censor_result is not None:
            result['AudioCensorResult'] = self.audio_censor_result.to_map()
        if self.barrage_censor_result is not None:
            result['BarrageCensorResult'] = self.barrage_censor_result.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.cover_image_censor_results is not None:
            result['CoverImageCensorResults'] = self.cover_image_censor_results.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.desc_censor_result is not None:
            result['DescCensorResult'] = self.desc_censor_result.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.title_censor_result is not None:
            result['TitleCensorResult'] = self.title_censor_result.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.vensor_censor_result is not None:
            result['VensorCensorResult'] = self.vensor_censor_result.to_map()
        if self.video_censor_config is not None:
            result['VideoCensorConfig'] = self.video_censor_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobAudioCensorResult()
            self.audio_censor_result = temp_model.from_map(m['AudioCensorResult'])
        if m.get('BarrageCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult()
            self.barrage_censor_result = temp_model.from_map(m['BarrageCensorResult'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CoverImageCensorResults') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults()
            self.cover_image_censor_results = temp_model.from_map(m['CoverImageCensorResults'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DescCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult()
            self.desc_censor_result = temp_model.from_map(m['DescCensorResult'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('TitleCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult()
            self.title_censor_result = temp_model.from_map(m['TitleCensorResult'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VensorCensorResult') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult()
            self.vensor_censor_result = temp_model.from_map(m['VensorCensorResult'])
        if m.get('VideoCensorConfig') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig()
            self.video_censor_config = temp_model.from_map(m['VideoCensorConfig'])
        return self


class QueryMediaCensorJobListResponseBodyMediaCensorJobList(TeaModel):
    def __init__(
        self,
        media_censor_job: List[QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob] = None,
    ):
        self.media_censor_job = media_censor_job

    def validate(self):
        if self.media_censor_job:
            for k in self.media_censor_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaCensorJob'] = []
        if self.media_censor_job is not None:
            for k in self.media_censor_job:
                result['MediaCensorJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_censor_job = []
        if m.get('MediaCensorJob') is not None:
            for k in m.get('MediaCensorJob'):
                temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob()
                self.media_censor_job.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobListResponseBodyNonExistIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryMediaCensorJobListResponseBody(TeaModel):
    def __init__(
        self,
        media_censor_job_list: QueryMediaCensorJobListResponseBodyMediaCensorJobList = None,
        next_page_token: str = None,
        non_exist_ids: QueryMediaCensorJobListResponseBodyNonExistIds = None,
        request_id: str = None,
    ):
        # The content moderation jobs.
        self.media_censor_job_list = media_censor_job_list
        # The token that is used to retrieve the next page of the query results. The value is a UUID that contains 32 characters. If the returned query results cannot be displayed within one page, this parameter is returned. The value of this parameter is updated for each query.
        self.next_page_token = next_page_token
        # The IDs of the jobs that do not exist. This parameter is not returned if all specified jobs are found.
        self.non_exist_ids = non_exist_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_censor_job_list:
            self.media_censor_job_list.validate()
        if self.non_exist_ids:
            self.non_exist_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_censor_job_list is not None:
            result['MediaCensorJobList'] = self.media_censor_job_list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.non_exist_ids is not None:
            result['NonExistIds'] = self.non_exist_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaCensorJobList') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyMediaCensorJobList()
            self.media_censor_job_list = temp_model.from_map(m['MediaCensorJobList'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NonExistIds') is not None:
            temp_model = QueryMediaCensorJobListResponseBodyNonExistIds()
            self.non_exist_ids = temp_model.from_map(m['NonExistIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaCensorJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaCensorJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaCensorJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaInfoJobListRequest(TeaModel):
    def __init__(
        self,
        media_info_job_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The IDs of the media information analysis jobs.
        # 
        # *   You can query up to 10 jobs at a time. Separate multiple IDs with commas (,).
        # *   You can obtain the details from the response parameters of the [SubmitMediaInfoJob](https://help.aliyun.com/document_detail/602827.html) operation.
        # 
        # >  If you do not specify the JobIds parameter, the **InvalidParameter** error code is returned.
        # 
        # This parameter is required.
        self.media_info_job_ids = media_info_job_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job_ids is not None:
            result['MediaInfoJobIds'] = self.media_info_job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJobIds') is not None:
            self.media_info_job_ids = m.get('MediaInfoJobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region.
        self.location = location
        # The name of the Object Storage Service (OSS) object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the job failed. This parameter is not returned if the job is successful.
        self.error_code = error_code
        # The error message returned if the job failed. This parameter is not returned if the job is successful.
        self.error_message = error_message
        # The ID of the message returned if the job was successful. This parameter is not returned if the job fails.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        # The total bitrate.
        self.bitrate = bitrate
        # The total duration.
        self.duration = duration
        # The full name of the container format.
        self.format_long_name = format_long_name
        # The short name of the container format.
        self.format_name = format_name
        # The total number of program streams.
        self.num_programs = num_programs
        # The total number of media streams.
        self.num_streams = num_streams
        # The size of the image file.
        self.size = size
        # The start time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        duration_inaccurate: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate of the media file.
        self.bitrate = bitrate
        # The number of sound channels.
        self.channel_layout = channel_layout
        # The output layout of the sound channels.
        self.channels = channels
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values:
        # 
        # *   **acc**\
        # *   **mp3**\
        # *   **mp4**\
        # *   **ogg**\
        # *   **flac**\
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration of the media file.
        self.duration = duration
        self.duration_inaccurate = duration_inaccurate
        # The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
        self.index = index
        # The language. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html?spm=a2c4g.11186623.2.66.243851cd2SntfN#Metadata).
        self.lang = lang
        # The total number of frames.
        self.num_frames = num_frames
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate.
        self.samplerate = samplerate
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.duration_inaccurate is not None:
            result['DurationInaccurate'] = self.duration_inaccurate
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('DurationInaccurate') is not None:
            self.duration_inaccurate = m.get('DurationInaccurate')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values:
        # 
        # *   **srt**\
        # *   **ass**\
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration. Unit: seconds.
        self.duration = duration
        # The sequence number of the subtitle stream. The value indicates the position of the subtitle stream in all subtitle streams.
        self.index = index
        # The language.
        self.lang = lang
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        # The average bitrate of the video stream.
        self.avg_bitrate = avg_bitrate
        # The maximum bandwidth that is consumed.
        self.cost_bandwidth = cost_bandwidth
        # The time consumed to preload the video.
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        color_primaries: str = None,
        color_range: str = None,
        color_transfer: str = None,
        dar: str = None,
        duration: str = None,
        duration_inaccurate: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate of the media file.
        self.bitrate = bitrate
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values:
        # 
        # *   **h264**\
        # *   **h265**\
        # *   **gif**\
        # *   **webp**\
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The level of color reconstruction.
        self.color_primaries = color_primaries
        # The color range.
        self.color_range = color_range
        # The color channel.
        self.color_transfer = color_transfer
        # The display aspect ratio (DAR).
        self.dar = dar
        # The duration of the media file.
        self.duration = duration
        self.duration_inaccurate = duration_inaccurate
        # The frame rate of the media file.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). A value of 1 indicates that the video stream contains B-frames. A value of 0 indicates that the video stream does not contain B-frames.
        self.has_bframes = has_bframes
        # The height of the video stream in pixels.
        self.height = height
        # The sequence number of the video stream. The value indicates the position of the video stream in all video streams.
        self.index = index
        # The language.
        self.lang = lang
        # The codec level.
        self.level = level
        # The network bandwidth that is consumed.
        self.network_cost = network_cost
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The codec profile.
        self.profile = profile
        # The rotation angle of the video.
        self.rotate = rotate
        # The sample aspect ratio (SAR).
        self.sar = sar
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase
        # The width of the video in pixels.
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.color_primaries is not None:
            result['ColorPrimaries'] = self.color_primaries
        if self.color_range is not None:
            result['ColorRange'] = self.color_range
        if self.color_transfer is not None:
            result['ColorTransfer'] = self.color_transfer
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.duration_inaccurate is not None:
            result['DurationInaccurate'] = self.duration_inaccurate
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('ColorPrimaries') is not None:
            self.color_primaries = m.get('ColorPrimaries')
        if m.get('ColorRange') is not None:
            self.color_range = m.get('ColorRange')
        if m.get('ColorTransfer') is not None:
            self.color_transfer = m.get('ColorTransfer')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('DurationInaccurate') is not None:
            self.duration_inaccurate = m.get('DurationInaccurate')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList = None,
    ):
        # The information about each audio stream.
        self.audio_stream_list = audio_stream_list
        # The information about each subtitle stream.
        self.subtitle_stream_list = subtitle_stream_list
        # The information about each video stream.
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_md_5: str = None,
        file_size: str = None,
        format: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams = None,
        width: str = None,
    ):
        # The bitrate of the media file.
        self.bitrate = bitrate
        # The duration of the media file.
        self.duration = duration
        # The format of the input media file.
        self.file_format = file_format
        self.file_md_5 = file_md_5
        # The size of the image file.
        self.file_size = file_size
        # The format information.
        self.format = format
        # The frame rate of the media file.
        self.fps = fps
        # The height of the video. Unit: pixel.
        self.height = height
        # The media streams that are contained in the input media file.
        self.streams = streams
        # The width of the video. Unit: pixel.
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_md_5 is not None:
            result['FileMd5'] = self.file_md_5
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileMd5') is not None:
            self.file_md_5 = m.get('FileMd5')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        code: str = None,
        creation_time: str = None,
        input: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput = None,
        job_id: str = None,
        mnsmessage_result: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult = None,
        message: str = None,
        pipeline_id: str = None,
        properties: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties = None,
        state: str = None,
        user_data: str = None,
    ):
        # Indicates whether the job is in asynchronous mode.
        self.async_ = async_
        # The error code returned if the job fails.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The information about the job input.
        self.input = input
        # The ID of the job.
        self.job_id = job_id
        # The message sent by MNS to notify you of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the job fails.
        self.message = message
        # The ID of the MPS queue.
        self.pipeline_id = pipeline_id
        # The information about the input file. For more information, see [AliyunProperties](https://help.aliyun.com/document_detail/29251.html).
        self.properties = properties
        # The status of the job.
        # 
        # *   **Analyzing**: The job is being run.
        # *   **Success**: The job is successful.
        # *   **Fail**: The job fails.
        self.state = state
        # The custom data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.properties:
            self.properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Properties') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryMediaInfoJobListResponseBodyMediaInfoJobList(TeaModel):
    def __init__(
        self,
        media_info_job: List[QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob] = None,
    ):
        self.media_info_job = media_info_job

    def validate(self):
        if self.media_info_job:
            for k in self.media_info_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaInfoJob'] = []
        if self.media_info_job is not None:
            for k in self.media_info_job:
                result['MediaInfoJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_info_job = []
        if m.get('MediaInfoJob') is not None:
            for k in m.get('MediaInfoJob'):
                temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob()
                self.media_info_job.append(temp_model.from_map(k))
        return self


class QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryMediaInfoJobListResponseBody(TeaModel):
    def __init__(
        self,
        media_info_job_list: QueryMediaInfoJobListResponseBodyMediaInfoJobList = None,
        non_exist_media_info_job_ids: QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds = None,
        request_id: str = None,
    ):
        # The details of each returned media information analysis job.
        self.media_info_job_list = media_info_job_list
        # Nonexistent media information analysis jobs.
        self.non_exist_media_info_job_ids = non_exist_media_info_job_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_info_job_list:
            self.media_info_job_list.validate()
        if self.non_exist_media_info_job_ids:
            self.non_exist_media_info_job_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job_list is not None:
            result['MediaInfoJobList'] = self.media_info_job_list.to_map()
        if self.non_exist_media_info_job_ids is not None:
            result['NonExistMediaInfoJobIds'] = self.non_exist_media_info_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJobList') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyMediaInfoJobList()
            self.media_info_job_list = temp_model.from_map(m['MediaInfoJobList'])
        if m.get('NonExistMediaInfoJobIds') is not None:
            temp_model = QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds()
            self.non_exist_media_info_job_ids = temp_model.from_map(m['NonExistMediaInfoJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaInfoJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaInfoJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaInfoJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaListRequest(TeaModel):
    def __init__(
        self,
        include_media_info: bool = None,
        include_play_list: bool = None,
        include_snapshot_list: bool = None,
        include_summary_list: bool = None,
        media_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # Specifies whether to include media information in the returned result.
        # 
        # *   Valid values: true and false.
        # *   Default value: **false**.
        self.include_media_info = include_media_info
        # Specifies whether to include playback information in the returned result.
        # 
        # *   Valid values: true and false.
        # *   Default value: **false**.
        self.include_play_list = include_play_list
        # Specifies whether to include snapshot information in the returned result.
        # 
        # *   Valid values: true and false.
        # *   Default value: **false**.
        self.include_snapshot_list = include_snapshot_list
        # Specifies whether to include summaries in the returned result.
        # 
        # *   Valid values: true and false.
        # *   Default value: **false**.
        self.include_summary_list = include_summary_list
        # The IDs of the media files. To obtain the ID of a media file, you can perform the following operations in the ApsaraVideo Media Processing (MPS) console: In the left-side navigation pane, choose **Media Management** > **Media List**. Find the required video and click Manage. The ID of the video is displayed on the Basics tab. Separate multiple IDs with commas (,). You can query up to 10 media files at a time.
        # 
        # This parameter is required.
        self.media_ids = media_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.include_media_info is not None:
            result['IncludeMediaInfo'] = self.include_media_info
        if self.include_play_list is not None:
            result['IncludePlayList'] = self.include_play_list
        if self.include_snapshot_list is not None:
            result['IncludeSnapshotList'] = self.include_snapshot_list
        if self.include_summary_list is not None:
            result['IncludeSummaryList'] = self.include_summary_list
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IncludeMediaInfo') is not None:
            self.include_media_info = m.get('IncludeMediaInfo')
        if m.get('IncludePlayList') is not None:
            self.include_play_list = m.get('IncludePlayList')
        if m.get('IncludeSnapshotList') is not None:
            self.include_snapshot_list = m.get('IncludeSnapshotList')
        if m.get('IncludeSummaryList') is not None:
            self.include_summary_list = m.get('IncludeSummaryList')
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaListResponseBodyMediaListMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the input file. Valid values:
        # 
        # *   **Normal**: normal
        # *   **Deleted**: deleted
        self.state = state
        # The OSS URL of the input file.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The total duration.
        self.duration = duration
        # The full name of the container format.
        self.format_long_name = format_long_name
        # The short name of the container format. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format_name = format_name
        # The total number of program streams.
        self.num_programs = num_programs
        # The total number of media streams.
        self.num_streams = num_streams
        # The size of the file.
        self.size = size
        # The start time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The output layout of the sound channels.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values: H264, mov, aac, avc, and mpeg.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration.
        self.duration = duration
        # The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
        self.index = index
        # The language. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata).
        self.lang = lang
        # The total number of frames.
        self.num_frames = num_frames
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate.
        self.samplerate = samplerate
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        # The sequence number of the subtitle stream. The value indicates the position of the subtitle stream in all subtitle streams.
        self.index = index
        # The language. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata).
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        # The average bitrate.
        self.avg_bitrate = avg_bitrate
        # The maximum bandwidth that was consumed.
        self.cost_bandwidth = cost_bandwidth
        # The amount of preload time.
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bitrate = bitrate
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The display aspect ratio (DAR).
        self.dar = dar
        # The duration.
        self.duration = duration
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). A value of **1** indicates that the video stream contains B-frames. A value of **2** indicates that the video stream does not contain B-frames.
        self.has_bframes = has_bframes
        # The latter number in the video resolution. The number indicates the video height.
        self.height = height
        # The sequence number of the video stream. The value indicates the position of the video stream in all video streams.
        self.index = index
        # The language. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata).
        self.lang = lang
        # The codec level.
        self.level = level
        # The network bandwidth consumption.
        self.network_cost = network_cost
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The codec profile.
        self.profile = profile
        # The video rotation angle.
        self.rotate = rotate
        # The sample aspect ratio (SAR).
        self.sar = sar
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase
        # The former number in the video resolution. The number indicates the video width.
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfoStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList = None,
        subtitle_stream_list: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList = None,
        video_stream_list: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList = None,
    ):
        # The list of audio streams.
        self.audio_stream_list = audio_stream_list
        # The list of subtitle streams.
        self.subtitle_stream_list = subtitle_stream_list
        # The list of video streams.
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryMediaListResponseBodyMediaListMediaMediaInfo(TeaModel):
    def __init__(
        self,
        format: QueryMediaListResponseBodyMediaListMediaMediaInfoFormat = None,
        streams: QueryMediaListResponseBodyMediaListMediaMediaInfoStreams = None,
    ):
        # The format information.
        self.format = format
        # The stream information.
        self.streams = streams

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Streams') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfoStreams()
            self.streams = temp_model.from_map(m['Streams'])
        return self


class QueryMediaListResponseBodyMediaListMediaPlayListPlayFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the file. Valid values:
        # 
        # *   **Normal**: normal
        # *   **Deleted**: deleted
        self.state = state
        # The Object Storage Service (OSS) URL of the output file.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListResponseBodyMediaListMediaPlayListPlay(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        bitrate: str = None,
        duration: str = None,
        encryption: str = None,
        file: QueryMediaListResponseBodyMediaListMediaPlayListPlayFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        size: str = None,
        width: str = None,
    ):
        # The name of the workflow activity.
        self.activity_name = activity_name
        # The bitrate of the media file.
        self.bitrate = bitrate
        # The duration of the media file.
        self.duration = duration
        # Indicates whether the media file is encrypted. Valid values:
        # 
        # *   **0**: The media file is not encrypted.
        # *   **1**: The media file is encrypted.
        self.encryption = encryption
        # The playback file.
        self.file = file
        # The encoding format of the media file. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format = format
        # The frame rate of the media file.
        self.fps = fps
        # The height.
        self.height = height
        # The ID of the workflow that generates the playback file.
        self.media_workflow_id = media_workflow_id
        # The name of the workflow that generates the playback file.
        self.media_workflow_name = media_workflow_name
        # The size of the media file.
        self.size = size
        # The width of the media file.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.encryption is not None:
            result['Encryption'] = self.encryption
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.size is not None:
            result['Size'] = self.size
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Encryption') is not None:
            self.encryption = m.get('Encryption')
        if m.get('File') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaPlayListPlayFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListResponseBodyMediaListMediaPlayList(TeaModel):
    def __init__(
        self,
        play: List[QueryMediaListResponseBodyMediaListMediaPlayListPlay] = None,
    ):
        self.play = play

    def validate(self):
        if self.play:
            for k in self.play:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Play'] = []
        if self.play is not None:
            for k in self.play:
                result['Play'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.play = []
        if m.get('Play') is not None:
            for k in m.get('Play'):
                temp_model = QueryMediaListResponseBodyMediaListMediaPlayListPlay()
                self.play.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the file. Valid values:
        # 
        # - **Normal**: normal
        # - **Deleted**: deleted
        self.state = state
        # The OSS URL of the snapshot.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        count: str = None,
        file: QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        type: str = None,
    ):
        # The name of the workflow activity that generates the snapshot.
        self.activity_name = activity_name
        # The number of snapshots. This parameter is valid only when the value of the **Type** parameter is **Sequence**.
        self.count = count
        # The snapshot.
        self.file = file
        # The ID of the workflow that generates the snapshot.
        self.media_workflow_id = media_workflow_id
        # The name of the workflow that generates the snapshot.
        self.media_workflow_name = media_workflow_name
        # The type of the snapshot. Valid values:
        # 
        # - **Single**\
        # - **Sequence**\
        self.type = type

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.count is not None:
            result['Count'] = self.count
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('File') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaListResponseBodyMediaListMediaSnapshotList(TeaModel):
    def __init__(
        self,
        snapshot: List[QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot] = None,
    ):
        self.snapshot = snapshot

    def validate(self):
        if self.snapshot:
            for k in self.snapshot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Snapshot'] = []
        if self.snapshot is not None:
            for k in self.snapshot:
                result['Snapshot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.snapshot = []
        if m.get('Snapshot') is not None:
            for k in m.get('Snapshot'):
                temp_model = QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot()
                self.snapshot.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the file. Valid values:
        # 
        # *   **Normal**: normal
        # *   **Deleted**: deleted
        self.state = state
        # The OSS URL of the input file.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListResponseBodyMediaListMediaSummaryListSummary(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        file: QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        type: str = None,
    ):
        # The name of the workflow activity.
        self.activity_name = activity_name
        # The information about the input file.
        self.file = file
        # The ID of the workflow that generates the summary.
        self.media_workflow_id = media_workflow_id
        # The name of the workflow that generates the summary.
        self.media_workflow_name = media_workflow_name
        # The type of the summary. Valid values:
        # 
        # *   **Video**: video
        # *   **Gif**: dynamic image
        self.type = type

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('File') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaListResponseBodyMediaListMediaSummaryList(TeaModel):
    def __init__(
        self,
        summary: List[QueryMediaListResponseBodyMediaListMediaSummaryListSummary] = None,
    ):
        self.summary = summary

    def validate(self):
        if self.summary:
            for k in self.summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Summary'] = []
        if self.summary is not None:
            for k in self.summary:
                result['Summary'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.summary = []
        if m.get('Summary') is not None:
            for k in m.get('Summary'):
                temp_model = QueryMediaListResponseBodyMediaListMediaSummaryListSummary()
                self.summary.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyMediaListMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class QueryMediaListResponseBodyMediaListMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: QueryMediaListResponseBodyMediaListMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        media_info: QueryMediaListResponseBodyMediaListMediaMediaInfo = None,
        play_list: QueryMediaListResponseBodyMediaListMediaPlayList = None,
        publish_state: str = None,
        run_id_list: QueryMediaListResponseBodyMediaListMediaRunIdList = None,
        size: str = None,
        snapshot_list: QueryMediaListResponseBodyMediaListMediaSnapshotList = None,
        summary_list: QueryMediaListResponseBodyMediaListMediaSummaryList = None,
        tags: QueryMediaListResponseBodyMediaListMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The ID of the category to which the media file belongs.
        self.cate_id = cate_id
        # The review status of the media file. Valid values:
        # 
        # *   **Initiated**: The media file is uploaded but not reviewed.
        # *   **Pass**: The media file is uploaded and passes the review.
        self.censor_state = censor_state
        # The OSS URL of the thumbnail.
        self.cover_url = cover_url
        # The time when the media file was created.
        self.creation_time = creation_time
        # The description.
        self.description = description
        # The duration.
        self.duration = duration
        # The details of the input file.
        self.file = file
        # The encoding format. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format = format
        # The frame rate.
        self.fps = fps
        # The height of the media file.
        self.height = height
        # The ID of the media file.
        self.media_id = media_id
        # The media information.
        self.media_info = media_info
        # The playlist.
        self.play_list = play_list
        # The publishing status of the media file. Valid values:
        # 
        # - **Initiated**: The media file is in the initial state.
        # - **UnPublish**: The media file has not been published, and the playback permission on the OSS object is Private.
        # - **Published**: The media file has been published, and the playback permission on the OSS object is Default.
        # - **Deleted**: The media file has been deleted.
        self.publish_state = publish_state
        # The ID of the instance.
        self.run_id_list = run_id_list
        # The size of the file.
        self.size = size
        # The list of snapshots.
        self.snapshot_list = snapshot_list
        # The list of video summaries.
        self.summary_list = summary_list
        # The tags of the media file.
        self.tags = tags
        # The title.
        self.title = title
        # The width.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.media_info:
            self.media_info.validate()
        if self.play_list:
            self.play_list.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.snapshot_list:
            self.snapshot_list.validate()
        if self.summary_list:
            self.summary_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.play_list is not None:
            result['PlayList'] = self.play_list.to_map()
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_list is not None:
            result['SnapshotList'] = self.snapshot_list.to_map()
        if self.summary_list is not None:
            result['SummaryList'] = self.summary_list.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaInfo') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('PlayList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaPlayList()
            self.play_list = temp_model.from_map(m['PlayList'])
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaSnapshotList()
            self.snapshot_list = temp_model.from_map(m['SnapshotList'])
        if m.get('SummaryList') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaSummaryList()
            self.summary_list = temp_model.from_map(m['SummaryList'])
        if m.get('Tags') is not None:
            temp_model = QueryMediaListResponseBodyMediaListMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        media: List[QueryMediaListResponseBodyMediaListMedia] = None,
    ):
        self.media = media

    def validate(self):
        if self.media:
            for k in self.media:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Media'] = []
        if self.media is not None:
            for k in self.media:
                result['Media'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media = []
        if m.get('Media') is not None:
            for k in m.get('Media'):
                temp_model = QueryMediaListResponseBodyMediaListMedia()
                self.media.append(temp_model.from_map(k))
        return self


class QueryMediaListResponseBodyNonExistMediaIds(TeaModel):
    def __init__(
        self,
        media_id: List[str] = None,
    ):
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class QueryMediaListResponseBody(TeaModel):
    def __init__(
        self,
        media_list: QueryMediaListResponseBodyMediaList = None,
        non_exist_media_ids: QueryMediaListResponseBodyNonExistMediaIds = None,
        request_id: str = None,
    ):
        # The list of media files.
        self.media_list = media_list
        # The IDs of the media files that do not exist. This parameter is not returned when all specified media files exist.
        self.non_exist_media_ids = non_exist_media_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_list:
            self.media_list.validate()
        if self.non_exist_media_ids:
            self.non_exist_media_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_list is not None:
            result['MediaList'] = self.media_list.to_map()
        if self.non_exist_media_ids is not None:
            result['NonExistMediaIds'] = self.non_exist_media_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaList') is not None:
            temp_model = QueryMediaListResponseBodyMediaList()
            self.media_list = temp_model.from_map(m['MediaList'])
        if m.get('NonExistMediaIds') is not None:
            temp_model = QueryMediaListResponseBodyNonExistMediaIds()
            self.non_exist_media_ids = temp_model.from_map(m['NonExistMediaIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaListByURLRequest(TeaModel):
    def __init__(
        self,
        file_urls: str = None,
        include_media_info: bool = None,
        include_play_list: bool = None,
        include_snapshot_list: bool = None,
        include_summary_list: bool = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The OSS URLs of the media files. To obtain the OSS URL of a media file, you can perform the following operations in the ApsaraVideo Media Processing (MPS) console: In the left-side navigation pane, choose **Media Management** > **Media List**. Find the media file whose OSS URL you want to view and click **Manage** in the **Actions** column. The OSS URL of the media file is displayed on the **Obtain Encoding URL** tab. Separate multiple URLs with commas (,). You can query up to 10 media files at a time.
        # 
        # *   The URL complies with RFC 3986 and is encoded in UTF-8, with reserved characters being percent-encoded. The value can be up to 3,200 bytes in size. For more information, see [URL encoding](https://help.aliyun.com/document_detail/423796.html).
        # *   Only OSS HTTP URLs are supported. Alibaba Cloud CDN URLs and HTTPS URLs are not supported.
        # 
        # This parameter is required.
        self.file_urls = file_urls
        # Specifies whether to include media information in the returned result.
        # 
        # *   Valid values: true and false.
        # 
        # *   Default value: **false**.
        # 
        # > To obtain detailed information about the media files, set this parameter to true.
        self.include_media_info = include_media_info
        # Specifies whether to include playback information in the returned result.
        # 
        # *   Valid values: true and false.
        # *   Default value: **false**.
        self.include_play_list = include_play_list
        # Specifies whether to include snapshot information in the returned result.
        # 
        # *   Valid values: true and false.
        # *   Default value: **false**.
        self.include_snapshot_list = include_snapshot_list
        # Specifies whether to include summaries in the returned result.
        # 
        # *   Valid values: true and false.
        # *   Default value: **false**.
        self.include_summary_list = include_summary_list
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_urls is not None:
            result['FileURLs'] = self.file_urls
        if self.include_media_info is not None:
            result['IncludeMediaInfo'] = self.include_media_info
        if self.include_play_list is not None:
            result['IncludePlayList'] = self.include_play_list
        if self.include_snapshot_list is not None:
            result['IncludeSnapshotList'] = self.include_snapshot_list
        if self.include_summary_list is not None:
            result['IncludeSummaryList'] = self.include_summary_list
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileURLs') is not None:
            self.file_urls = m.get('FileURLs')
        if m.get('IncludeMediaInfo') is not None:
            self.include_media_info = m.get('IncludeMediaInfo')
        if m.get('IncludePlayList') is not None:
            self.include_play_list = m.get('IncludePlayList')
        if m.get('IncludeSnapshotList') is not None:
            self.include_snapshot_list = m.get('IncludeSnapshotList')
        if m.get('IncludeSummaryList') is not None:
            self.include_summary_list = m.get('IncludeSummaryList')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the media file. Valid values:
        # 
        # *   **Normal**: The file is normal.
        # *   **Deleted**: The file is deleted.
        self.state = state
        # The OSS URL of the input file.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The duration.
        self.duration = duration
        # The full name of the encoding format.
        self.format_long_name = format_long_name
        # The short name of the container format. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format_name = format_name
        # The total number of program streams.
        self.num_programs = num_programs
        # The total number of media streams.
        self.num_streams = num_streams
        # The size.
        self.size = size
        # The start time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The output layout of the sound channels.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values: H264, mov, aac, avc, and mpeg.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration of the media file.
        self.duration = duration
        # The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
        self.index = index
        # The language. For more information, see [FFmpeg language definition](https://www.ffmpeg.org/ffmpeg-all.html#Metadata).
        self.lang = lang
        # The total number of frames.
        self.num_frames = num_frames
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate.
        self.samplerate = samplerate
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        # The sequence number of the subtitle stream. The value indicates the position of the subtitle stream in all subtitle streams.
        self.index = index
        # The language. For more information, see [FFmpeg language definition](https://www.ffmpeg.org/ffmpeg-all.html#Metadata).
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        # The average bitrate of the video stream.
        self.avg_bitrate = avg_bitrate
        # The maximum bandwidth that was consumed.
        self.cost_bandwidth = cost_bandwidth
        # The amount of preload time.
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate.
        self.bitrate = bitrate
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values: H264, mov, aac, avc, and mpeg.
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The display aspect ratio (DAR) of the video stream.
        self.dar = dar
        # The duration.
        self.duration = duration
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). A value of **1** indicates that the video stream contains B-frames. A value of **2** indicates that the video stream does not contain B-frames.
        self.has_bframes = has_bframes
        # The latter number in the video resolution. The number indicates the video height.
        self.height = height
        # The sequence number of the video stream. The value indicates the position of the video stream in all video streams.
        self.index = index
        # The language. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata).
        self.lang = lang
        # The codec level.
        self.level = level
        # The network bandwidth consumption.
        self.network_cost = network_cost
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format of the video stream.
        self.pix_fmt = pix_fmt
        # The codec profile.
        self.profile = profile
        # The rotation angle of the video.
        self.rotate = rotate
        # The sample aspect ratio (SAR).
        self.sar = sar
        # The start time.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase
        # The former number in the video resolution. The number indicates the video width and cannot be negative.
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList = None,
        subtitle_stream_list: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList = None,
        video_stream_list: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList = None,
    ):
        # The list of audio streams.
        self.audio_stream_list = audio_stream_list
        # The list of subtitle streams.
        self.subtitle_stream_list = subtitle_stream_list
        # The list of video streams.
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class QueryMediaListByURLResponseBodyMediaListMediaMediaInfo(TeaModel):
    def __init__(
        self,
        format: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat = None,
        streams: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams = None,
    ):
        # The format information.
        self.format = format
        # The stream information.
        self.streams = streams

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Streams') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams()
            self.streams = temp_model.from_map(m['Streams'])
        return self


class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the media file. Valid values:
        # 
        # *   **Normal**: The file is normal.
        # *   **Deleted**: The file is deleted.
        self.state = state
        # The OSS URL of the playback file.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        bitrate: str = None,
        duration: str = None,
        encryption: str = None,
        file: QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        size: str = None,
        width: str = None,
    ):
        # The name of the workflow activity.
        self.activity_name = activity_name
        # The bitrate of the media file.
        self.bitrate = bitrate
        # The duration.
        self.duration = duration
        # Indicates whether the media file is encrypted. Valid values:
        # 
        # *   **0**: The media file is not encrypted.
        # *   **1**: The media file is encrypted.
        self.encryption = encryption
        # The playback file.
        self.file = file
        # The encoding format of the media file. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format = format
        # The frame rate.
        self.fps = fps
        # The height of the media file.
        self.height = height
        # The ID of the workflow that generates the playback file.
        self.media_workflow_id = media_workflow_id
        # The name of the workflow that generates the playback file.
        self.media_workflow_name = media_workflow_name
        # The size.
        self.size = size
        # The width.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.encryption is not None:
            result['Encryption'] = self.encryption
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.size is not None:
            result['Size'] = self.size
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Encryption') is not None:
            self.encryption = m.get('Encryption')
        if m.get('File') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaPlayList(TeaModel):
    def __init__(
        self,
        play: List[QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay] = None,
    ):
        self.play = play

    def validate(self):
        if self.play:
            for k in self.play:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Play'] = []
        if self.play is not None:
            for k in self.play:
                result['Play'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.play = []
        if m.get('Play') is not None:
            for k in m.get('Play'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay()
                self.play.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the file. Valid values:
        # 
        # - **Normal**: The file is normal.
        # - **Deleted**: The file is deleted.
        self.state = state
        # The OSS URL of the snapshot.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        count: str = None,
        file: QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        type: str = None,
    ):
        # The name of the workflow activity that generates the snapshot.
        self.activity_name = activity_name
        # The number of snapshots. This parameter is valid only when the value of the **Type** parameter is **Sequence**.
        self.count = count
        # The snapshot.
        self.file = file
        # The ID of the workflow that generates the snapshot.
        self.media_workflow_id = media_workflow_id
        # The name of the workflow that generates the snapshot.
        self.media_workflow_name = media_workflow_name
        # The type of the snapshot. Valid values:
        # 
        # - **Single**: a single snapshot
        # - **Sequence**: snapshots in sequence
        self.type = type

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.count is not None:
            result['Count'] = self.count
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('File') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSnapshotList(TeaModel):
    def __init__(
        self,
        snapshot: List[QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot] = None,
    ):
        self.snapshot = snapshot

    def validate(self):
        if self.snapshot:
            for k in self.snapshot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Snapshot'] = []
        if self.snapshot is not None:
            for k in self.snapshot:
                result['Snapshot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.snapshot = []
        if m.get('Snapshot') is not None:
            for k in m.get('Snapshot'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot()
                self.snapshot.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The status of the media file. Valid values:
        # 
        # *   **Normal**: The file is normal.
        # *   **Deleted**: The file is deleted.
        self.state = state
        # The OSS URL of the input file.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary(TeaModel):
    def __init__(
        self,
        activity_name: str = None,
        file: QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile = None,
        media_workflow_id: str = None,
        media_workflow_name: str = None,
        type: str = None,
    ):
        # The name of the workflow activity.
        self.activity_name = activity_name
        # The information about the input file.
        self.file = file
        # The ID of the workflow that generates the summary.
        self.media_workflow_id = media_workflow_id
        # The name of the workflow that generates the summary.
        self.media_workflow_name = media_workflow_name
        # The type of the summary. Valid values:
        # 
        # *   **Video**: video
        # *   **Gif**: dynamic image
        self.type = type

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_name is not None:
            result['ActivityName'] = self.activity_name
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.media_workflow_name is not None:
            result['MediaWorkflowName'] = self.media_workflow_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityName') is not None:
            self.activity_name = m.get('ActivityName')
        if m.get('File') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('MediaWorkflowName') is not None:
            self.media_workflow_name = m.get('MediaWorkflowName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaListByURLResponseBodyMediaListMediaSummaryList(TeaModel):
    def __init__(
        self,
        summary: List[QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary] = None,
    ):
        self.summary = summary

    def validate(self):
        if self.summary:
            for k in self.summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Summary'] = []
        if self.summary is not None:
            for k in self.summary:
                result['Summary'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.summary = []
        if m.get('Summary') is not None:
            for k in m.get('Summary'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary()
                self.summary.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyMediaListMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class QueryMediaListByURLResponseBodyMediaListMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: QueryMediaListByURLResponseBodyMediaListMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        media_info: QueryMediaListByURLResponseBodyMediaListMediaMediaInfo = None,
        play_list: QueryMediaListByURLResponseBodyMediaListMediaPlayList = None,
        publish_state: str = None,
        run_id_list: QueryMediaListByURLResponseBodyMediaListMediaRunIdList = None,
        size: str = None,
        snapshot_list: QueryMediaListByURLResponseBodyMediaListMediaSnapshotList = None,
        summary_list: QueryMediaListByURLResponseBodyMediaListMediaSummaryList = None,
        tags: QueryMediaListByURLResponseBodyMediaListMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        # The bitrate.
        self.bitrate = bitrate
        # The ID of the category to which the media file belongs.
        self.cate_id = cate_id
        # The review status of the media file. Valid values:
        # 
        # *   **Initiated**: The media file is uploaded but not reviewed.
        # *   **Pass**: The media file is uploaded and passes the review.
        self.censor_state = censor_state
        # The OSS URL of the thumbnail.
        self.cover_url = cover_url
        # The time when the media file was created.
        self.creation_time = creation_time
        # The description.
        self.description = description
        # The duration.
        self.duration = duration
        # The details of the input file.
        self.file = file
        # The encoding format. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format = format
        # The frame rate.
        self.fps = fps
        # The height of the queried media file.
        self.height = height
        # The ID of the media file.
        self.media_id = media_id
        # The media information.
        self.media_info = media_info
        # The playlist.
        self.play_list = play_list
        # The publishing status of the media file. Valid values:
        # 
        # - **Initiated**: The media file is in the initial state.
        # - **UnPublish**: The media file has not been published, and the playback permission on the OSS object is Private.
        # - **Published**: The media file has been published, and the playback permission on the OSS object is Default.
        # - **Deleted**: The file is deleted.
        self.publish_state = publish_state
        # The IDs of the media workflow execution instances.
        self.run_id_list = run_id_list
        # The size of the file.
        self.size = size
        # The list of snapshots.
        self.snapshot_list = snapshot_list
        # The list of video summaries.
        self.summary_list = summary_list
        # The tags of the media file.
        self.tags = tags
        # The title.
        self.title = title
        # The width.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.media_info:
            self.media_info.validate()
        if self.play_list:
            self.play_list.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.snapshot_list:
            self.snapshot_list.validate()
        if self.summary_list:
            self.summary_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.play_list is not None:
            result['PlayList'] = self.play_list.to_map()
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_list is not None:
            result['SnapshotList'] = self.snapshot_list.to_map()
        if self.summary_list is not None:
            result['SummaryList'] = self.summary_list.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaInfo') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('PlayList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaPlayList()
            self.play_list = temp_model.from_map(m['PlayList'])
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaSnapshotList()
            self.snapshot_list = temp_model.from_map(m['SnapshotList'])
        if m.get('SummaryList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaSummaryList()
            self.summary_list = temp_model.from_map(m['SummaryList'])
        if m.get('Tags') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaListMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryMediaListByURLResponseBodyMediaList(TeaModel):
    def __init__(
        self,
        media: List[QueryMediaListByURLResponseBodyMediaListMedia] = None,
    ):
        self.media = media

    def validate(self):
        if self.media:
            for k in self.media:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Media'] = []
        if self.media is not None:
            for k in self.media:
                result['Media'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media = []
        if m.get('Media') is not None:
            for k in m.get('Media'):
                temp_model = QueryMediaListByURLResponseBodyMediaListMedia()
                self.media.append(temp_model.from_map(k))
        return self


class QueryMediaListByURLResponseBodyNonExistFileURLs(TeaModel):
    def __init__(
        self,
        file_url: List[str] = None,
    ):
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        return self


class QueryMediaListByURLResponseBody(TeaModel):
    def __init__(
        self,
        media_list: QueryMediaListByURLResponseBodyMediaList = None,
        non_exist_file_urls: QueryMediaListByURLResponseBodyNonExistFileURLs = None,
        request_id: str = None,
    ):
        # The list of media files.
        self.media_list = media_list
        # The IDs of the media files that do not exist. This parameter is not returned if all specified media files exist.
        self.non_exist_file_urls = non_exist_file_urls
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_list:
            self.media_list.validate()
        if self.non_exist_file_urls:
            self.non_exist_file_urls.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_list is not None:
            result['MediaList'] = self.media_list.to_map()
        if self.non_exist_file_urls is not None:
            result['NonExistFileURLs'] = self.non_exist_file_urls.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaList') is not None:
            temp_model = QueryMediaListByURLResponseBodyMediaList()
            self.media_list = temp_model.from_map(m['MediaList'])
        if m.get('NonExistFileURLs') is not None:
            temp_model = QueryMediaListByURLResponseBodyNonExistFileURLs()
            self.non_exist_file_urls = temp_model.from_map(m['NonExistFileURLs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaListByURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaListByURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaListByURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaWorkflowExecutionListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        run_ids: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The IDs of the media workflow execution instances. To obtain the instance ID, log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Execution Instances** in the left-side navigation pane. Separate multiple IDs with commas (,). You can query a maximum of 10 media workflow execution instances at a time.
        # 
        # This parameter is required.
        self.run_ids = run_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.run_ids is not None:
            result['RunIds'] = self.run_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RunIds') is not None:
            self.run_ids = m.get('RunIds')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the MNS message fails to be sent. This parameter is not returned if the MNS message is sent.
        self.error_code = error_code
        # The error message returned if the MNS message fails to be sent. This parameter is not returned if the MNS message is sent.
        self.error_message = error_message
        # The ID of the message that indicates the MNS message is sent. This parameter is not returned if the MNS message fails to be sent.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(TeaModel):
    def __init__(
        self,
        code: str = None,
        end_time: str = None,
        job_id: str = None,
        mnsmessage_result: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult = None,
        message: str = None,
        name: str = None,
        start_time: str = None,
        state: str = None,
        type: str = None,
    ):
        # The error code.
        # 
        # *   This parameter is returned only if **Fail** is returned for the State parameter.
        # *   This parameter is not returned if the method status is **Success**.
        self.code = code
        # The time when the method ends.
        self.end_time = end_time
        # The IDs of the jobs that are generated when the methods are called, such as the job IDs for the analysis, transcode, and snapshot methods.
        self.job_id = job_id
        # The message sent by Message Service (MNS) to notify the user of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message.
        # 
        # *   This parameter is returned only if **Fail** is returned for the State parameter.
        # *   This parameter is not returned if the method status is **Success**.
        self.message = message
        # The name of the method.
        # 
        # > The name of each method in a media workflow is unique.
        self.name = name
        # The time when the method is called.
        self.start_time = start_time
        # The status of the workflow method. Valid values:
        # 
        # *   Running: The method is being called.
        # *   Success: The method is called.
        # *   Fail: The method failed to be called.
        # *   Skipped: The method is skipped.
        # 
        # > For example, after the analysis is complete, the transcode method is called and high-definition and standard-definition transcoding jobs are created. The system determines whether to run the jobs based on the analysis result. If the resolution of the input video is low, the high-definition transcoding job may be skipped.
        self.state = state
        # The methods that are supported in the media workflow. Valid values: Start, Snapshot, Transcode, Analysis, and Report. For more information, see [Methods supported for media workflows](https://help.aliyun.com/document_detail/68494.html).
        self.type = type

    def validate(self):
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(TeaModel):
    def __init__(
        self,
        activity: List[QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity] = None,
    ):
        self.activity = activity

    def validate(self):
        if self.activity:
            for k in self.activity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Activity'] = []
        if self.activity is not None:
            for k in self.activity:
                result['Activity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.activity = []
        if m.get('Activity') is not None:
            for k in m.get('Activity'):
                temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity()
                self.activity.append(temp_model.from_map(k))
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the input file resides.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(TeaModel):
    def __init__(
        self,
        input_file: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile = None,
        user_data: str = None,
    ):
        # The input file of the media workflow.
        self.input_file = input_file
        # The user-defined data.
        self.user_data = user_data

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputFile') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(TeaModel):
    def __init__(
        self,
        activity_list: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList = None,
        creation_time: str = None,
        input: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput = None,
        media_id: str = None,
        media_workflow_id: str = None,
        name: str = None,
        run_id: str = None,
        state: str = None,
    ):
        # The methods that are called in the media workflow.
        self.activity_list = activity_list
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The input data of the media workflow.
        self.input = input
        # The ID of the media asset. A media file contains all the information about a media workflow.
        self.media_id = media_id
        # The ID of the media workflow.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow.
        self.name = name
        # The ID of the execution instance.
        self.run_id = run_id
        # The status of the media workflow. Valid values:
        # 
        # *   Running: The media workflow is running.
        # *   Completed: The media workflow is complete.
        # 
        # > Completed only indicates that the media workflow is complete. View the status of each method in the workflow, such as the transcode and snapshot methods, to check whether the method is called.
        # 
        # *   Fail: The media workflow fails.
        self.state = state

    def validate(self):
        if self.activity_list:
            self.activity_list.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_list is not None:
            result['ActivityList'] = self.activity_list.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.run_id is not None:
            result['RunId'] = self.run_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActivityList') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList()
            self.activity_list = temp_model.from_map(m['ActivityList'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList(TeaModel):
    def __init__(
        self,
        media_workflow_execution: List[QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution] = None,
    ):
        self.media_workflow_execution = media_workflow_execution

    def validate(self):
        if self.media_workflow_execution:
            for k in self.media_workflow_execution:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaWorkflowExecution'] = []
        if self.media_workflow_execution is not None:
            for k in self.media_workflow_execution:
                result['MediaWorkflowExecution'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_workflow_execution = []
        if m.get('MediaWorkflowExecution') is not None:
            for k in m.get('MediaWorkflowExecution'):
                temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution()
                self.media_workflow_execution.append(temp_model.from_map(k))
        return self


class QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class QueryMediaWorkflowExecutionListResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow_execution_list: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList = None,
        non_exist_run_ids: QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds = None,
        request_id: str = None,
    ):
        # The details of the media workflows.
        self.media_workflow_execution_list = media_workflow_execution_list
        # The IDs of the execution instances that do not exist.
        self.non_exist_run_ids = non_exist_run_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow_execution_list:
            self.media_workflow_execution_list.validate()
        if self.non_exist_run_ids:
            self.non_exist_run_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_execution_list is not None:
            result['MediaWorkflowExecutionList'] = self.media_workflow_execution_list.to_map()
        if self.non_exist_run_ids is not None:
            result['NonExistRunIds'] = self.non_exist_run_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowExecutionList') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList()
            self.media_workflow_execution_list = temp_model.from_map(m['MediaWorkflowExecutionList'])
        if m.get('NonExistRunIds') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds()
            self.non_exist_run_ids = temp_model.from_map(m['NonExistRunIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaWorkflowExecutionListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaWorkflowExecutionListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaWorkflowExecutionListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaWorkflowListRequest(TeaModel):
    def __init__(
        self,
        media_workflow_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The IDs of the media workflows that you want to query. To obtain the IDs of the media workflows, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Workflow Settings** in the left-side navigation pane. You can query up to 10 media workflows at a time. Separate multiple IDs of media workflows with commas (,).
        # 
        # This parameter is required.
        self.media_workflow_ids = media_workflow_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_ids is not None:
            result['MediaWorkflowIds'] = self.media_workflow_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowIds') is not None:
            self.media_workflow_ids = m.get('MediaWorkflowIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The ID of the media workflow.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow.
        self.name = name
        # The state of the media workflow. Valid values:
        # 
        # *   **Inactive**: The media workflow was deactivated.
        # *   **Active**: The media workflow was activated.
        # *   **Deleted**: The media workflow was deleted.
        self.state = state
        # The topology of the media workflow.
        self.topology = topology
        # The trigger mode of the media workflow. Valid values:
        # 
        # *   **OssAutoTrigger**: The media workflow is automatically triggered.
        # *   **NotInAuto**: The media workflow is not automatically triggered.
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class QueryMediaWorkflowListResponseBodyMediaWorkflowList(TeaModel):
    def __init__(
        self,
        media_workflow: List[QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow] = None,
    ):
        self.media_workflow = media_workflow

    def validate(self):
        if self.media_workflow:
            for k in self.media_workflow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaWorkflow'] = []
        if self.media_workflow is not None:
            for k in self.media_workflow:
                result['MediaWorkflow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_workflow = []
        if m.get('MediaWorkflow') is not None:
            for k in m.get('MediaWorkflow'):
                temp_model = QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow()
                self.media_workflow.append(temp_model.from_map(k))
        return self


class QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds(TeaModel):
    def __init__(
        self,
        media_workflow_id: List[str] = None,
    ):
        self.media_workflow_id = media_workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        return self


class QueryMediaWorkflowListResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow_list: QueryMediaWorkflowListResponseBodyMediaWorkflowList = None,
        non_exist_media_workflow_ids: QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds = None,
        request_id: str = None,
    ):
        # The media workflows.
        self.media_workflow_list = media_workflow_list
        # The workflows that do not exist.
        self.non_exist_media_workflow_ids = non_exist_media_workflow_ids
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow_list:
            self.media_workflow_list.validate()
        if self.non_exist_media_workflow_ids:
            self.non_exist_media_workflow_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_list is not None:
            result['MediaWorkflowList'] = self.media_workflow_list.to_map()
        if self.non_exist_media_workflow_ids is not None:
            result['NonExistMediaWorkflowIds'] = self.non_exist_media_workflow_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowList') is not None:
            temp_model = QueryMediaWorkflowListResponseBodyMediaWorkflowList()
            self.media_workflow_list = temp_model.from_map(m['MediaWorkflowList'])
        if m.get('NonExistMediaWorkflowIds') is not None:
            temp_model = QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds()
            self.non_exist_media_workflow_ids = temp_model.from_map(m['NonExistMediaWorkflowIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaWorkflowListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMediaWorkflowListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaWorkflowListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryPipelineListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_ids: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The IDs of the MPS queues that you want to query. To view the IDs, you can log on to the **MPS console** and choose **Global Settings** > **Pipelines** in the left-side navigation pane. You can query up to 10 MPS queues at a time. Separate multiple IDs of MPS queues with commas (,).
        # 
        # This parameter is required.
        self.pipeline_ids = pipeline_ids
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_ids is not None:
            result['PipelineIds'] = self.pipeline_ids
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineIds') is not None:
            self.pipeline_ids = m.get('PipelineIds')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryPipelineListResponseBodyNonExistPids(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryPipelineListResponseBodyPipelineListPipelineExtendConfig(TeaModel):
    def __init__(
        self,
        is_boost_new: bool = None,
        max_multi_speed: int = None,
        multi_speed_downgrade_policy: str = None,
    ):
        self.is_boost_new = is_boost_new
        self.max_multi_speed = max_multi_speed
        self.multi_speed_downgrade_policy = multi_speed_downgrade_policy

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_boost_new is not None:
            result['IsBoostNew'] = self.is_boost_new
        if self.max_multi_speed is not None:
            result['MaxMultiSpeed'] = self.max_multi_speed
        if self.multi_speed_downgrade_policy is not None:
            result['MultiSpeedDowngradePolicy'] = self.multi_speed_downgrade_policy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsBoostNew') is not None:
            self.is_boost_new = m.get('IsBoostNew')
        if m.get('MaxMultiSpeed') is not None:
            self.max_multi_speed = m.get('MaxMultiSpeed')
        if m.get('MultiSpeedDowngradePolicy') is not None:
            self.multi_speed_downgrade_policy = m.get('MultiSpeedDowngradePolicy')
        return self


class QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig(TeaModel):
    def __init__(
        self,
        mq_tag: str = None,
        mq_topic: str = None,
        queue_name: str = None,
        topic: str = None,
    ):
        # The tag string.
        self.mq_tag = mq_tag
        # The queue of messages that are received.
        self.mq_topic = mq_topic
        # The name of the queue that is created in MNS.
        self.queue_name = queue_name
        # The name of the topic that is created in MNS.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mq_tag is not None:
            result['MqTag'] = self.mq_tag
        if self.mq_topic is not None:
            result['MqTopic'] = self.mq_topic
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MqTag') is not None:
            self.mq_tag = m.get('MqTag')
        if m.get('MqTopic') is not None:
            self.mq_topic = m.get('MqTopic')
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class QueryPipelineListResponseBodyPipelineListPipeline(TeaModel):
    def __init__(
        self,
        extend_config: QueryPipelineListResponseBodyPipelineListPipelineExtendConfig = None,
        id: str = None,
        name: str = None,
        notify_config: QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig = None,
        quota_allocate: int = None,
        role: str = None,
        speed: str = None,
        speed_level: int = None,
        state: str = None,
    ):
        self.extend_config = extend_config
        # The ID of the MPS queue.
        self.id = id
        # The name of the MPS queue.
        self.name = name
        # The Message Service (MNS) configuration.
        self.notify_config = notify_config
        # The quota that is allocated to the MPS queue.
        self.quota_allocate = quota_allocate
        # The role that is assigned to the current RAM user.
        self.role = role
        # The type of the MPS queue. Default value: **Standard**. Valid values:
        # 
        # *   **Boost**: MPS queue with transcoding speed boosted
        # *   **Standard**: standard MPS queue
        # *   **NarrowBandHDV2**: MPS queue that supports Narrowband HD 2.0
        # *   **AIVideoCover**: MPS queue for intelligent snapshot capture
        # *   **AIVideoFPShot**: MPS queue for media fingerprinting
        # *   **AIVideoCensor**: MPS queue for automated review
        # *   **AIVideoMCU**: MPS queue for smart tagging
        # *   **AIVideoSummary**: MPS queue for video synopsis
        # *   **AIVideoPorn**: MPS queue for pornography detection in videos
        # *   **AIAudioKWS**: MPS queue for keyword recognition in audio
        # *   **AIAudioASR**: MPS queue for speech-to-text conversion
        self.speed = speed
        # The level of the MPS queue.
        self.speed_level = speed_level
        # The state of the MPS queue. Valid values:
        # 
        # *   **Active**: The MPS queue is active.
        # *   **Paused**: The MPS queue is paused.
        self.state = state

    def validate(self):
        if self.extend_config:
            self.extend_config.validate()
        if self.notify_config:
            self.notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extend_config is not None:
            result['ExtendConfig'] = self.extend_config.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config.to_map()
        if self.quota_allocate is not None:
            result['QuotaAllocate'] = self.quota_allocate
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.speed_level is not None:
            result['SpeedLevel'] = self.speed_level
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtendConfig') is not None:
            temp_model = QueryPipelineListResponseBodyPipelineListPipelineExtendConfig()
            self.extend_config = temp_model.from_map(m['ExtendConfig'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            temp_model = QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig()
            self.notify_config = temp_model.from_map(m['NotifyConfig'])
        if m.get('QuotaAllocate') is not None:
            self.quota_allocate = m.get('QuotaAllocate')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('SpeedLevel') is not None:
            self.speed_level = m.get('SpeedLevel')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QueryPipelineListResponseBodyPipelineList(TeaModel):
    def __init__(
        self,
        pipeline: List[QueryPipelineListResponseBodyPipelineListPipeline] = None,
    ):
        self.pipeline = pipeline

    def validate(self):
        if self.pipeline:
            for k in self.pipeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Pipeline'] = []
        if self.pipeline is not None:
            for k in self.pipeline:
                result['Pipeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pipeline = []
        if m.get('Pipeline') is not None:
            for k in m.get('Pipeline'):
                temp_model = QueryPipelineListResponseBodyPipelineListPipeline()
                self.pipeline.append(temp_model.from_map(k))
        return self


class QueryPipelineListResponseBody(TeaModel):
    def __init__(
        self,
        non_exist_pids: QueryPipelineListResponseBodyNonExistPids = None,
        pipeline_list: QueryPipelineListResponseBodyPipelineList = None,
        request_id: str = None,
    ):
        # The IDs of MPS queues that do not exist.
        self.non_exist_pids = non_exist_pids
        # The MPS queues.
        self.pipeline_list = pipeline_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.non_exist_pids:
            self.non_exist_pids.validate()
        if self.pipeline_list:
            self.pipeline_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.non_exist_pids is not None:
            result['NonExistPids'] = self.non_exist_pids.to_map()
        if self.pipeline_list is not None:
            result['PipelineList'] = self.pipeline_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NonExistPids') is not None:
            temp_model = QueryPipelineListResponseBodyNonExistPids()
            self.non_exist_pids = temp_model.from_map(m['NonExistPids'])
        if m.get('PipelineList') is not None:
            temp_model = QueryPipelineListResponseBodyPipelineList()
            self.pipeline_list = temp_model.from_map(m['PipelineList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryPipelineListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryPipelineListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryPipelineListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySmarttagJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        params: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.job_id = job_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.params = params
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.params is not None:
            result['Params'] = self.params
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QuerySmarttagJobResponseBodyResultsResult(TeaModel):
    def __init__(
        self,
        data: str = None,
        type: str = None,
    ):
        self.data = data
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QuerySmarttagJobResponseBodyResults(TeaModel):
    def __init__(
        self,
        result: List[QuerySmarttagJobResponseBodyResultsResult] = None,
    ):
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QuerySmarttagJobResponseBodyResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class QuerySmarttagJobResponseBody(TeaModel):
    def __init__(
        self,
        job_status: str = None,
        message: str = None,
        request_id: str = None,
        results: QuerySmarttagJobResponseBodyResults = None,
        user_data: str = None,
    ):
        self.job_status = job_status
        self.message = message
        self.request_id = request_id
        self.results = results
        self.user_data = user_data

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.results is not None:
            result['Results'] = self.results.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Results') is not None:
            temp_model = QuerySmarttagJobResponseBodyResults()
            self.results = temp_model.from_map(m['Results'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QuerySmarttagJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySmarttagJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySmarttagJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySmarttagTemplateListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The ID of the template. You can obtain the template ID from the response of the [AddSmarttagTemplate](https://help.aliyun.com/document_detail/187759.html) operation. If you set this parameter to a specific value, the information about the corresponding template is returned. If you do not specify this parameter, the operation returns the information about all the templates that are created by the current RAM user.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class QuerySmarttagTemplateListResponseBodyTemplatesTemplate(TeaModel):
    def __init__(
        self,
        analyse_types: str = None,
        face_category_ids: str = None,
        face_custom_params_config: str = None,
        industry: str = None,
        is_default: bool = None,
        keyword_config: str = None,
        knowledge_config: str = None,
        label_type: str = None,
        label_version: str = None,
        landmark_group_ids: str = None,
        object_group_ids: str = None,
        scene: str = None,
        template_id: str = None,
        template_name: str = None,
    ):
        # The analysis types that are used in the template. One or more values are returned. Valid values:
        # 
        # *   **ocr**: text recognition
        # *   **asr**: speech recognition
        # *   **classification**: video classification
        # *   **shows**: program recognition
        # *   **face**: facial recognition
        # *   **role**: figure recognition
        # *   **object**: object recognition
        # *   **tvstation**: logo recognition
        # *   **action**: action recognition
        # *   **emotion**: facial expression recognition
        # *   **landmark**: landmark recognition
        # *   **scene**: scene recognition
        # *   **movieip**: movie intellectual property recognition
        # *   **subtitle**: subtitle extraction
        self.analyse_types = analyse_types
        # The IDs of the system facial image libraries that are used in the template. One or more values are returned. Valid values:
        # 
        # *   celebrity: the facial image library of celebrities
        # *   politician: the facial image library of politicians
        # *   sensitive: the facial image library of sensitive figures
        self.face_category_ids = face_category_ids
        # The configurations of face-related algorithms. The value of this parameter is a JSON string and consists of the thresholds set for face detection and facial recognition. Valid values:
        # 
        # *   **faceDetThreshold**: The default threshold for face detection is 0.999. The threshold takes effect only for the faces that are strange to the system.
        # *   **faceRegThreshold**: The default threshold for facial recognition is 0.9.
        self.face_custom_params_config = face_custom_params_config
        # The industry to which the template applies. Default value: **common**. Valid values:
        # 
        # *   **microVideo**: short video industry
        # *   **common**: general industries
        self.industry = industry
        # Indicates whether the template is the default template. Valid values:
        # 
        # *   **true**: The template is the default template.
        # *   **false**: The template is not the default template.
        self.is_default = is_default
        # The configuration of keyword tags. The type field specifies the category of a keyword tag. You can specify one or more values and separate the values with commas (,). Valid values:
        # 
        # *   name
        # *   location
        # *   organization
        # *   other
        # 
        # > Keyword tags of all the categories are returned in one of the following scenarios: The KeywordConfig parameter is not specified or the Keyword field is invalid because it is not a JSON string, or the KeywordConfig parameter does not contain the type field or the type field is invalid.
        self.keyword_config = keyword_config
        # The fields to be identified as knowledge graph information when tags are returned in Smart tagging V2.0 and Smart tagging V2.0-custom modes. For more information, see [Knowledge graph fields in smart tagging jobs](https://help.aliyun.com/document_detail/356383.html). If this parameter is not specified or the specified value is NULL or invalid because it is not a JSON string, the following fields are returned:
        # 
        # *   movie-related fields:
        # 
        #     *   name: the name of the intellectual property that is featured in the movie
        #     *   alias: the alias of the intellectual property that is featured in the movie
        #     *   chnl: the category of the movie
        #     *   genre: the genre of the movie
        #     *   country: the country or region in which the movie was produced
        #     *   language: the language of the movie
        #     *   releaseYear: the year when the movie was released
        # 
        # *   music-related fields:
        # 
        #     *   songName: the name of the song
        #     *   artistName: the name of the singer
        #     *   artistArea: the region to which the singer belongs, such as China, Japan, Korea, Europe, and America, or others.
        #     *   albumName: the name of the album
        # 
        # *   person-related fields:
        # 
        #     *   name: the name of the person
        #     *   gender: the gender of the person
        #     *   citizenship: the nationality of the person
        #     *   occupation: the occupation of the person
        #     *   classification: the type into which the person is classified
        #     *   nationality: the ethnic group of the person
        #     *   birthPlace: the place where the person was born
        #     *   birthDate: the date when the person was born
        # 
        # *   landmark-related fields:
        # 
        #     *   name: the display name of the landmark
        #     *   nameEn: the English name of the landmark
        #     *   Description: the description of the parameter
        #     *   address: the address of the landmark
        # 
        # *   item-related fields:
        # 
        #     *   brandName: the brand of the item
        #     *   finegrainName: the fine-grained description of the item
        self.knowledge_config = knowledge_config
        # The type of the tagging. Default value: **auto**. Valid values:
        # 
        # *   **auto**: machine tagging
        # *   **hmi**: tagging by human and machine
        self.label_type = label_type
        # The version of the smart tagging feature. Default value: 1.0. Valid values:
        # 
        # *   1.0: Smart tagging V1.0
        # *   2.0: Smart tagging V2.0 (CPV tagging)
        # *   2.0-custom: Smart tagging V2.0-custom (CPV tagging by using custom models)
        self.label_version = label_version
        # The IDs of the landmark libraries that are used in the template.
        self.landmark_group_ids = landmark_group_ids
        # The IDs of the object libraries that are used in the template.
        self.object_group_ids = object_group_ids
        # The scenario in which the template is used. Valid values:
        # 
        # *   **search**: search scenarios
        # *   **recommend**: recommendation scenarios
        self.scene = scene
        # The ID of the template.
        self.template_id = template_id
        # The name of the template.
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analyse_types is not None:
            result['AnalyseTypes'] = self.analyse_types
        if self.face_category_ids is not None:
            result['FaceCategoryIds'] = self.face_category_ids
        if self.face_custom_params_config is not None:
            result['FaceCustomParamsConfig'] = self.face_custom_params_config
        if self.industry is not None:
            result['Industry'] = self.industry
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.keyword_config is not None:
            result['KeywordConfig'] = self.keyword_config
        if self.knowledge_config is not None:
            result['KnowledgeConfig'] = self.knowledge_config
        if self.label_type is not None:
            result['LabelType'] = self.label_type
        if self.label_version is not None:
            result['LabelVersion'] = self.label_version
        if self.landmark_group_ids is not None:
            result['LandmarkGroupIds'] = self.landmark_group_ids
        if self.object_group_ids is not None:
            result['ObjectGroupIds'] = self.object_group_ids
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalyseTypes') is not None:
            self.analyse_types = m.get('AnalyseTypes')
        if m.get('FaceCategoryIds') is not None:
            self.face_category_ids = m.get('FaceCategoryIds')
        if m.get('FaceCustomParamsConfig') is not None:
            self.face_custom_params_config = m.get('FaceCustomParamsConfig')
        if m.get('Industry') is not None:
            self.industry = m.get('Industry')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('KeywordConfig') is not None:
            self.keyword_config = m.get('KeywordConfig')
        if m.get('KnowledgeConfig') is not None:
            self.knowledge_config = m.get('KnowledgeConfig')
        if m.get('LabelType') is not None:
            self.label_type = m.get('LabelType')
        if m.get('LabelVersion') is not None:
            self.label_version = m.get('LabelVersion')
        if m.get('LandmarkGroupIds') is not None:
            self.landmark_group_ids = m.get('LandmarkGroupIds')
        if m.get('ObjectGroupIds') is not None:
            self.object_group_ids = m.get('ObjectGroupIds')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class QuerySmarttagTemplateListResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        template: List[QuerySmarttagTemplateListResponseBodyTemplatesTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = QuerySmarttagTemplateListResponseBodyTemplatesTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class QuerySmarttagTemplateListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        templates: QuerySmarttagTemplateListResponseBodyTemplates = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The templates.
        self.templates = templates

    def validate(self):
        if self.templates:
            self.templates.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.templates is not None:
            result['Templates'] = self.templates.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Templates') is not None:
            temp_model = QuerySmarttagTemplateListResponseBodyTemplates()
            self.templates = temp_model.from_map(m['Templates'])
        return self


class QuerySmarttagTemplateListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySmarttagTemplateListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySmarttagTemplateListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySnapshotJobListRequest(TeaModel):
    def __init__(
        self,
        end_of_job_created_time_range: str = None,
        maximum_page_size: int = None,
        next_page_token: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        snapshot_job_ids: str = None,
        start_of_job_created_time_range: str = None,
        state: str = None,
    ):
        # The snapshot configuration.
        self.end_of_job_created_time_range = end_of_job_created_time_range
        # The ID of the MPS queue to which the snapshot jobs that you want to query are submitted. To obtain the ID, you can log on to the **MPS console** and choose **Global Settings** > **Pipelines** in the left-side navigation pane.
        self.maximum_page_size = maximum_page_size
        # The end of the time range within which the creation time of snapshot jobs to be queried is.
        # 
        # *   Specify the time in the ISO 8601 standard in the
        # *   YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        self.next_page_token = next_page_token
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The start time for taking snapshots. Unit: milliseconds.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The beginning of the time range within which the creation time of snapshot jobs to be queried is.
        # 
        # *   Specify the time in the ISO 8601 standard in the
        # *   YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        self.snapshot_job_ids = snapshot_job_ids
        # The time when the job was created.
        self.start_of_job_created_time_range = start_of_job_created_time_range
        # The information about the snapshot jobs.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_job_created_time_range is not None:
            result['EndOfJobCreatedTimeRange'] = self.end_of_job_created_time_range
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_job_ids is not None:
            result['SnapshotJobIds'] = self.snapshot_job_ids
        if self.start_of_job_created_time_range is not None:
            result['StartOfJobCreatedTimeRange'] = self.start_of_job_created_time_range
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndOfJobCreatedTimeRange') is not None:
            self.end_of_job_created_time_range = m.get('EndOfJobCreatedTimeRange')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotJobIds') is not None:
            self.snapshot_job_ids = m.get('SnapshotJobIds')
        if m.get('StartOfJobCreatedTimeRange') is not None:
            self.start_of_job_created_time_range = m.get('StartOfJobCreatedTimeRange')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The ID of the snapshot job.
        self.bucket = bucket
        # The ID of the MPS queue to which the snapshot job was submitted.
        self.location = location
        # The error code returned when the job fails. This parameter is not returned if the job is successfully processed.
        self.object = object
        # The custom data.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The number of snapshots that were taken.
        self.error_code = error_code
        # The OSS bucket that stores the input file.
        self.error_message = error_message
        # The ID of the region in which the input OSS bucket is located.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The OSS bucket that stores the output file.
        self.bucket = bucket
        # The ID of the region in which the output OSS bucket is located.
        self.location = location
        # The OSS object that is generated as the output file of the tiling job.
        self.object = object
        # The ARN of the specified RAM role. Format: acs:ram::$accountID:role/$roleName.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut(TeaModel):
    def __init__(
        self,
        cell_height: str = None,
        cell_sel_step: str = None,
        cell_width: str = None,
        color: str = None,
        columns: str = None,
        is_keep_cell_pic: str = None,
        lines: str = None,
        margin: str = None,
        padding: str = None,
    ):
        # The interval for taking snapshots.
        # 
        # *   If this Interval parameter is specified in the request, snapshots are taken at intervals. The value must be greater than 0.
        # *   Unit: seconds.
        # *   Default value: **10**.
        self.cell_height = cell_height
        # The number of rows that the tiled image can contain. Default value: **10**.
        self.cell_sel_step = cell_sel_step
        # The type of the snapshot. Valid values:
        # 
        # *   **normal**: normal frames.
        # *   **intra**: I-frames.
        # *   Default value: **intra**.
        self.cell_width = cell_width
        # Indicates whether the single images are retained. Default value: **true**.
        self.color = color
        # The height of the output snapshot.
        self.columns = columns
        # The Object Storage Service (OSS) output file of the snapshot job.
        self.is_keep_cell_pic = is_keep_cell_pic
        # The Alibaba Cloud Resource Name (ARN) of the specified RAM role. Format: acs:ram::$accountID:role/$roleName.
        self.lines = lines
        # The width of the output snapshot.
        self.margin = margin
        # The number of columns that the tiled image can contain. Default value: **10**.
        self.padding = padding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_height is not None:
            result['CellHeight'] = self.cell_height
        if self.cell_sel_step is not None:
            result['CellSelStep'] = self.cell_sel_step
        if self.cell_width is not None:
            result['CellWidth'] = self.cell_width
        if self.color is not None:
            result['Color'] = self.color
        if self.columns is not None:
            result['Columns'] = self.columns
        if self.is_keep_cell_pic is not None:
            result['IsKeepCellPic'] = self.is_keep_cell_pic
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.margin is not None:
            result['Margin'] = self.margin
        if self.padding is not None:
            result['Padding'] = self.padding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CellHeight') is not None:
            self.cell_height = m.get('CellHeight')
        if m.get('CellSelStep') is not None:
            self.cell_sel_step = m.get('CellSelStep')
        if m.get('CellWidth') is not None:
            self.cell_width = m.get('CellWidth')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('Columns') is not None:
            self.columns = m.get('Columns')
        if m.get('IsKeepCellPic') is not None:
            self.is_keep_cell_pic = m.get('IsKeepCellPic')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('Margin') is not None:
            self.margin = m.get('Margin')
        if m.get('Padding') is not None:
            self.padding = m.get('Padding')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The error code returned when the job fails. This parameter is not returned if the job is successfully processed.
        self.bucket = bucket
        # The error message returned when the job fails. This parameter is not returned if the job is successfully processed.
        self.location = location
        # The ID of the message. This parameter is not returned if the job fails.
        self.object = object
        # The message sent by MNS to notify the user of the job result.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray(TeaModel):
    def __init__(
        self,
        time_point_list: List[int] = None,
    ):
        self.time_point_list = time_point_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_point_list is not None:
            result['TimePointList'] = self.time_point_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimePointList') is not None:
            self.time_point_list = m.get('TimePointList')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig(TeaModel):
    def __init__(
        self,
        frame_type: str = None,
        height: str = None,
        interval: str = None,
        num: str = None,
        output_file: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile = None,
        tile_out: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut = None,
        tile_output_file: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile = None,
        time: str = None,
        time_array: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray = None,
        width: str = None,
    ):
        # The ID of the region in which the output OSS bucket is located.
        self.frame_type = frame_type
        # The number of snapshots to take. If the Num parameter is set in the request, snapshots are taken at intervals.
        self.height = height
        # The OSS object that is generated as the output file of the snapshot job.
        self.interval = interval
        # The status of the snapshot job. 
        # 
        # - **Submitted**: The job was submitted.
        # - **Snapshoting**: The job is being processed.
        # - **Success**: The job was successfully processed.
        # - **Fail**: The job failed.
        self.num = num
        # The OSS output file of the tiling job.
        self.output_file = output_file
        # The margin width of the tiled image.
        # 
        # *   Default value: **0**.
        # *   Unit: pixel.
        self.tile_out = tile_out
        # The error message returned when the job fails. This parameter is not returned if the job is successfully processed.
        self.tile_output_file = tile_output_file
        # The width of a single image. The default value is the width of the output snapshot.
        self.time = time
        self.time_array = time_array
        # The OSS bucket that stores the output file.
        self.width = width

    def validate(self):
        if self.output_file:
            self.output_file.validate()
        if self.tile_out:
            self.tile_out.validate()
        if self.tile_output_file:
            self.tile_output_file.validate()
        if self.time_array:
            self.time_array.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.frame_type is not None:
            result['FrameType'] = self.frame_type
        if self.height is not None:
            result['Height'] = self.height
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.num is not None:
            result['Num'] = self.num
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.tile_out is not None:
            result['TileOut'] = self.tile_out.to_map()
        if self.tile_output_file is not None:
            result['TileOutputFile'] = self.tile_output_file.to_map()
        if self.time is not None:
            result['Time'] = self.time
        if self.time_array is not None:
            result['TimeArray'] = self.time_array.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FrameType') is not None:
            self.frame_type = m.get('FrameType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Num') is not None:
            self.num = m.get('Num')
        if m.get('OutputFile') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('TileOut') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut()
            self.tile_out = temp_model.from_map(m['TileOut'])
        if m.get('TileOutputFile') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile()
            self.tile_output_file = temp_model.from_map(m['TileOutputFile'])
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('TimeArray') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTimeArray()
            self.time_array = temp_model.from_map(m['TimeArray'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        count: str = None,
        creation_time: str = None,
        id: str = None,
        input: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput = None,
        mnsmessage_result: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult = None,
        message: str = None,
        pipeline_id: str = None,
        snapshot_config: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig = None,
        state: str = None,
        tile_count: str = None,
        user_data: str = None,
    ):
        # You can call this operation to query up to 10 snapshot jobs at a time.
        # 
        # 
        # ## Limits on QPS
        # 
        # You can call this operation up to 100 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation. For more information, see [QPS limit](https://www.alibabacloud.com/help/en/apsaravideo-for-media-processing/latest/qps-limit).
        self.code = code
        # The ID of the request.
        self.count = count
        # The stride of a single image.
        self.creation_time = creation_time
        # The OSS output file of the tiling job.
        self.id = id
        # The number of snapshots that are contained in the tiled image.
        self.input = input
        # The OSS object that is used as the input file.
        self.mnsmessage_result = mnsmessage_result
        # The ARN of the specified RAM role. Format: acs:ram::$accountID:role/$roleName.
        self.message = message
        # The start time for taking snapshots. Unit: milliseconds.
        self.pipeline_id = pipeline_id
        # The height of a single image. The default value is the height of the output snapshot.
        self.snapshot_config = snapshot_config
        # The information about the job input.
        self.state = state
        # The snapshot job IDs that do not exist. This parameter is not returned if all specified snapshot jobs are found.
        self.tile_count = tile_count
        # The token that is used to retrieve the next page of the query results. The value is a 32-bit UUID. If the returned query results cannot be displayed within one page, this parameter is returned. The value of this parameter is updated for each query.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.snapshot_config:
            self.snapshot_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.snapshot_config is not None:
            result['SnapshotConfig'] = self.snapshot_config.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.tile_count is not None:
            result['TileCount'] = self.tile_count
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Input') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('MNSMessageResult') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('SnapshotConfig') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig()
            self.snapshot_config = temp_model.from_map(m['SnapshotConfig'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TileCount') is not None:
            self.tile_count = m.get('TileCount')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QuerySnapshotJobListResponseBodySnapshotJobList(TeaModel):
    def __init__(
        self,
        snapshot_job: List[QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob] = None,
    ):
        self.snapshot_job = snapshot_job

    def validate(self):
        if self.snapshot_job:
            for k in self.snapshot_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SnapshotJob'] = []
        if self.snapshot_job is not None:
            for k in self.snapshot_job:
                result['SnapshotJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.snapshot_job = []
        if m.get('SnapshotJob') is not None:
            for k in m.get('SnapshotJob'):
                temp_model = QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob()
                self.snapshot_job.append(temp_model.from_map(k))
        return self


class QuerySnapshotJobListResponseBody(TeaModel):
    def __init__(
        self,
        next_page_token: str = None,
        non_exist_snapshot_job_ids: QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds = None,
        request_id: str = None,
        snapshot_job_list: QuerySnapshotJobListResponseBodySnapshotJobList = None,
    ):
        # The OSS object that is used as the input file.
        self.next_page_token = next_page_token
        # The OSS object that is generated as the output file of the tiling job.
        self.non_exist_snapshot_job_ids = non_exist_snapshot_job_ids
        # The ID of the snapshot job.
        self.request_id = request_id
        # The distance between images.
        # 
        # *   Default value: **0**.
        # *   Unit: pixel.
        self.snapshot_job_list = snapshot_job_list

    def validate(self):
        if self.non_exist_snapshot_job_ids:
            self.non_exist_snapshot_job_ids.validate()
        if self.snapshot_job_list:
            self.snapshot_job_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.non_exist_snapshot_job_ids is not None:
            result['NonExistSnapshotJobIds'] = self.non_exist_snapshot_job_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_job_list is not None:
            result['SnapshotJobList'] = self.snapshot_job_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NonExistSnapshotJobIds') is not None:
            temp_model = QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds()
            self.non_exist_snapshot_job_ids = temp_model.from_map(m['NonExistSnapshotJobIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotJobList') is not None:
            temp_model = QuerySnapshotJobListResponseBodySnapshotJobList()
            self.snapshot_job_list = temp_model.from_map(m['SnapshotJobList'])
        return self


class QuerySnapshotJobListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySnapshotJobListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySnapshotJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTemplateListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_ids: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The response parameters.
        # 
        # This parameter is required.
        self.template_ids = template_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        return self


class QueryTemplateListResponseBodyNonExistTids(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        level: str = None,
        loudness_range_target: str = None,
        method: str = None,
        peak_level: str = None,
        true_peak: str = None,
    ):
        # The output volume.
        # 
        # *   This parameter takes effect only if the value of Method is dynamic.
        # *   Unit: dB.
        # *   Valid values: [-70,-5].
        # *   Default value: -6.
        self.integrated_loudness_target = integrated_loudness_target
        # The increased volume relative to the volume of the input audio.
        # 
        # *   This parameter takes effect only if the value of Method is linear.
        # *   Unit: dB.
        # *   Valid values: less than or equal to 20.
        # *   Default value: -20.
        self.level = level
        # The range of the volume relative to the output volume.
        # 
        # *   This parameter takes effect only if the value of Method is dynamic.
        # *   Unit: dB.
        # *   Valid values: [1,20].
        # *   Default value: 8.
        self.loudness_range_target = loudness_range_target
        # The method that is used to adjust the volume. Valid values:
        # 
        # *   **auto**\
        # *   **dynamic**\
        # *   **linear**\
        # *   Default value: dynamic.
        self.method = method
        # The volume adjustment coefficient.
        # 
        # This parameter takes effect only if the value of Method is adaptive.
        # 
        # Valid values: [0,1].
        # 
        # Default value: 0.9.
        self.peak_level = peak_level
        # The peak volume.
        # 
        # *   This parameter takes effect only if the value of Method is dynamic.
        # *   Unit: dB.
        # *   Valid values: [-9,0].
        # *   Default value: -1.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.level is not None:
            result['Level'] = self.level
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.peak_level is not None:
            result['PeakLevel'] = self.peak_level
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('PeakLevel') is not None:
            self.peak_level = m.get('PeakLevel')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: QueryTemplateListResponseBodyTemplateListTemplateAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Valid values: **[8,1000]**.
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.bitrate = bitrate
        # The number of sound channels. Default value: **2**.
        self.channels = channels
        # The audio codec format. Default value: **aac**. Valid values:
        # 
        # *   **aac**\
        # *   **mp3**\
        # *   **vorbis**\
        # *   **flac**\
        self.codec = codec
        # The codec profile of the audio. Valid values when the value of Codec is aac:
        # 
        # *   **aac_low**\
        # *   **aac_he**\
        # *   **aac_he_v2**\
        # *   **aac_ld**\
        # *   **aac_eld**\
        self.profile = profile
        # The strength of the independent denoising algorithm.
        self.qscale = qscale
        # Indicates whether the audio stream is deleted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.remove = remove
        # The sampling rate.
        # 
        # *   Unit: Hz
        # *   Default value: **44100**.
        self.samplerate = samplerate
        # The volume control configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class QueryTemplateListResponseBodyTemplateListTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The format of the container. Valid values: flv, mp4, ts, m3u8, gif, mp3, ogg, and flac.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        # The color dithering algorithm of the palette. Valid values: sierra and bayer.
        self.dither_mode = dither_mode
        # The duration for which the final frame is paused.
        self.final_delay = final_delay
        # Indicates whether a custom palette is used.
        self.is_custom_palette = is_custom_palette
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The length of the segment. Unit: seconds.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif = None,
        segment: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment = None,
        webp: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp = None,
    ):
        # The transmuxing configurations for GIF.
        self.gif = gif
        # The segment configurations.
        self.segment = segment
        # The transmuxing configurations for WebP.
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class QueryTemplateListResponseBodyTemplateListTemplateTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method of resolution adjustment. Default value: **none**. Valid values:
        # 
        # *   rescale
        # *   crop
        # *   none
        self.adj_dar_method = adj_dar_method
        # Indicates whether the audio bitrate is checked. If the bitrate of the output audio is higher than that of the input audio, the input bitrate is retained and the specified audio bitrate does not take effect. This parameter has a lower priority than IsCheckAudioBitrateFail. Valid values:
        # 
        # *   **true**\
        # 
        # *   **false**\
        # 
        # *   Default value:
        # 
        #     *   If this parameter is not specified and the codec of the output audio is different from that of the input audio, the default value is false.
        #     *   If this parameter is not specified and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Indicates whether audio bitrate check errors are allowed. This parameter has a greater priority than IsCheckAudioBitrate. Valid values:
        # 
        # *   **true**: If the audio bitrate check fails, the input file is not transcoded.
        # *   **false**: The audio bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, the input resolution is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso = is_check_reso
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, a transcoding failure is returned. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the video bitrate is checked. If the bitrate of the output video is higher than that of the input video, the input bitrate is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Indicates whether video bitrate check errors are allowed. This parameter has a higher priority than IsCheckVideoBitrate. Valid values:
        # 
        # *   **true**: If the video bitrate check fails, the input file is not transcoded.
        # *   **false**: The video bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The transcoding mode. Default value: **onepass**. Valid values:
        # 
        # *   **onepass**\
        # *   **twopass**\
        # *   **CBR**\
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The upper limit of the total bitrate. Unit: Kbit/s.
        self.max = max
        # The lower limit of the total bitrate. Unit: Kbit/s.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand(TeaModel):
    def __init__(
        self,
        abrmax: float = None,
        max_abr_ratio: float = None,
        version: str = None,
    ):
        # The upper limit of the dynamic bitrate. If this parameter is set, the average bitrate is in the range of (0, 1000000].
        self.abrmax = abrmax
        # The maximum ratio of the upper limit of dynamic bitrate. If this parameter is set, the value of Abrmax does not exceed x times of the source video bitrate. Valid values: (0,1.0].
        self.max_abr_ratio = max_abr_ratio
        # The Narrowband HD version. Only 1.0 may be returned.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abrmax is not None:
            result['Abrmax'] = self.abrmax
        if self.max_abr_ratio is not None:
            result['MaxAbrRatio'] = self.max_abr_ratio
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Abrmax') is not None:
            self.abrmax = m.get('Abrmax')
        if m.get('MaxAbrRatio') is not None:
            self.max_abr_ratio = m.get('MaxAbrRatio')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class QueryTemplateListResponseBodyTemplateListTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        hdr_2sdr: str = None,
        height: str = None,
        long_short_mode: str = None,
        max_fps: str = None,
        maxrate: str = None,
        narrow_band: QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The average bitrate of the video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The average bitrate range of the video.
        self.bitrate_bnd = bitrate_bnd
        # The buffer size.
        # 
        # *   Unit: KB.
        # *   Default value: **6000**.
        self.bufsize = bufsize
        # The codec. Default value: **H.264**.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Default value when the encoding format is H.264: **23**. Default value when the encoding format is H.265: **26**.
        # *   If this parameter is set, the value of Bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   **border**: automatically detects and removes black bars.
        # *   **Value in the width:height:left:top format**: crops the video based on custom settings. Format: width:height:left:top. Example: 1280:800:0:140.
        self.crop = crop
        # The level of video quality control.
        self.degrain = degrain
        # The frame rate.
        # 
        # *   The value is 60 if the frame rate of the input file exceeds 60.
        # *   Default value: **the frame rate of the input file**.
        self.fps = fps
        # The maximum number of frames between two keyframes. Default value: **250**.
        self.gop = gop
        # Indicates whether the HDR2SDR conversion feature is enabled. If this feature is enabled, high dynamic range (HDR) videos are transcoded to standard dynamic range (SDR) videos.
        self.hdr_2sdr = hdr_2sdr
        # The height of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: **the height of the input video**.
        self.height = height
        # Indicates whether the auto-rotate screen feature is enabled.
        # 
        # *   If this feature is enabled, the width of the output video corresponds to the long side of the input video, which is the height of the input video in portrait mode. The height of the output video corresponds to the short side of the input video, which is the width of the input video in portrait mode. Valid values:
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.long_short_mode = long_short_mode
        # The maximum frame rate.
        self.max_fps = max_fps
        # The maximum bitrate of the video. Unit: Kbit/s.
        self.maxrate = maxrate
        # The Narrowband HD settings.
        self.narrow_band = narrow_band
        # The black bars that are added to the video. Format: width:height:left:top. Example: 1280:800:0:140.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. Valid values: veryfast, fast, medium, slow, and slower. Default value: **medium**.
        self.preset = preset
        # The encoding profile. Valid values:
        # 
        # *   **baseline**: applicable to mobile devices.
        # *   **main**: applicable to standard-definition devices.
        # *   **high**: applicable to high-definition devices.
        # *   Default value: **high**.
        self.profile = profile
        # The strength of the independent denoising algorithm.
        self.qscale = qscale
        # Indicates whether the video stream is deleted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.remove = remove
        # The policy of resolution adjustment. Valid values: cropFirst, widthFirst, and heightFirst.
        self.reso_priority = reso_priority
        # The scan mode. Valid values:
        # 
        # *   **interlaced**\
        # *   **progressive**\
        self.scan_mode = scan_mode
        # The width of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: **the width of the input video**.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()
        if self.narrow_band:
            self.narrow_band.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.hdr_2sdr is not None:
            result['Hdr2sdr'] = self.hdr_2sdr
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.narrow_band is not None:
            result['NarrowBand'] = self.narrow_band.to_map()
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Hdr2sdr') is not None:
            self.hdr_2sdr = m.get('Hdr2sdr')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('NarrowBand') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateVideoNarrowBand()
            self.narrow_band = temp_model.from_map(m['NarrowBand'])
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryTemplateListResponseBodyTemplateListTemplate(TeaModel):
    def __init__(
        self,
        audio: QueryTemplateListResponseBodyTemplateListTemplateAudio = None,
        container: QueryTemplateListResponseBodyTemplateListTemplateContainer = None,
        creation_time: str = None,
        id: str = None,
        mux_config: QueryTemplateListResponseBodyTemplateListTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: QueryTemplateListResponseBodyTemplateListTemplateTransConfig = None,
        video: QueryTemplateListResponseBodyTemplateListTemplateVideo = None,
    ):
        # The audio codec configurations.
        self.audio = audio
        # The container format configurations.
        self.container = container
        # The time when the template was created.
        self.creation_time = creation_time
        # The transcoding template ID.
        self.id = id
        # The transmuxing configurations.
        self.mux_config = mux_config
        # The name of the template.
        self.name = name
        # The status of the template. Valid values:
        # 
        # *   **Normal**\
        # *   **Deleted**\
        self.state = state
        # The general transcoding configurations.
        self.trans_config = trans_config
        # The video codec configurations.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateListTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class QueryTemplateListResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        template: List[QueryTemplateListResponseBodyTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = QueryTemplateListResponseBodyTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class QueryTemplateListResponseBody(TeaModel):
    def __init__(
        self,
        non_exist_tids: QueryTemplateListResponseBodyNonExistTids = None,
        request_id: str = None,
        template_list: QueryTemplateListResponseBodyTemplateList = None,
    ):
        # The IDs of the templates that do not exist. This parameter is not returned if all specified transcoding templates are found.
        self.non_exist_tids = non_exist_tids
        # The ID of the request.
        self.request_id = request_id
        # The transcoding templates.
        self.template_list = template_list

    def validate(self):
        if self.non_exist_tids:
            self.non_exist_tids.validate()
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.non_exist_tids is not None:
            result['NonExistTids'] = self.non_exist_tids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NonExistTids') is not None:
            temp_model = QueryTemplateListResponseBodyNonExistTids()
            self.non_exist_tids = temp_model.from_map(m['NonExistTids'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateList') is not None:
            temp_model = QueryTemplateListResponseBodyTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        return self


class QueryTemplateListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTemplateListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTemplateListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTraceAbJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        media_id: str = None,
    ):
        self.job_id = job_id
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class QueryTraceAbJobResponseBodyData(TeaModel):
    def __init__(
        self,
        callback: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        input: str = None,
        job_id: str = None,
        level: int = None,
        media_id: str = None,
        output: str = None,
        result: str = None,
        status: str = None,
        user_data: str = None,
        user_id: int = None,
    ):
        self.callback = callback
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.input = input
        self.job_id = job_id
        self.level = level
        self.media_id = media_id
        self.output = output
        self.result = result
        self.status = status
        self.user_data = user_data
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback is not None:
            result['Callback'] = self.callback
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.input is not None:
            result['Input'] = self.input
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.level is not None:
            result['Level'] = self.level
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.output is not None:
            result['Output'] = self.output
        if self.result is not None:
            result['Result'] = self.result
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callback') is not None:
            self.callback = m.get('Callback')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryTraceAbJobResponseBody(TeaModel):
    def __init__(
        self,
        data: List[QueryTraceAbJobResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = QueryTraceAbJobResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryTraceAbJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTraceAbJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTraceAbJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTraceExtractJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryTraceExtractJobResponseBodyData(TeaModel):
    def __init__(
        self,
        trace: str = None,
    ):
        self.trace = trace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.trace is not None:
            result['Trace'] = self.trace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Trace') is not None:
            self.trace = m.get('Trace')
        return self


class QueryTraceExtractJobResponseBody(TeaModel):
    def __init__(
        self,
        data: QueryTraceExtractJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = QueryTraceExtractJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryTraceExtractJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTraceExtractJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTraceExtractJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTraceM3u8JobRequest(TeaModel):
    def __init__(
        self,
        create_time_end: int = None,
        create_time_start: int = None,
        job_id: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.job_id = job_id
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryTraceM3u8JobResponseBodyData(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        job_id: str = None,
        media_id: str = None,
        output: str = None,
        status: str = None,
        trace: str = None,
        user_data: str = None,
        user_id: int = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.job_id = job_id
        self.media_id = media_id
        self.output = output
        self.status = status
        self.trace = trace
        self.user_data = user_data
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.output is not None:
            result['Output'] = self.output
        if self.status is not None:
            result['Status'] = self.status
        if self.trace is not None:
            result['Trace'] = self.trace
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Trace') is not None:
            self.trace = m.get('Trace')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class QueryTraceM3u8JobResponseBody(TeaModel):
    def __init__(
        self,
        data: List[QueryTraceM3u8JobResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = QueryTraceM3u8JobResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class QueryTraceM3u8JobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTraceM3u8JobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTraceM3u8JobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryWaterMarkTemplateListRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        water_mark_template_ids: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The IDs of the watermark templates that you want to query. To obtain the IDs of the watermark templates, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Global Settings** > **Watermark Templates** in the left-side navigation pane. You can query up to 10 watermark templates at a time. Separate multiple IDs of watermark templates with commas (,).
        # 
        # This parameter is required.
        self.water_mark_template_ids = water_mark_template_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.water_mark_template_ids is not None:
            result['WaterMarkTemplateIds'] = self.water_mark_template_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('WaterMarkTemplateIds') is not None:
            self.water_mark_template_ids = m.get('WaterMarkTemplateIds')
        return self


class QueryWaterMarkTemplateListResponseBodyNonExistWids(TeaModel):
    def __init__(
        self,
        string: List[str] = None,
    ):
        self.string = string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark relative to the output video image. Default value: **0**. The default value indicates no offset. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the vertical offset. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the horizontal offset to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.dx = dx
        # The vertical offset of the watermark relative to the output video image. Default value: **0**. The default value indicates no offset. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the vertical offset. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the vertical offset to the height of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.dy = dy
        # The height of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the height of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the height of the watermark image to the height of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.height = height
        # The width of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the width of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the width of the watermark image to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The display duration of the watermark. Default value: **ToEND**. The default value indicates that the watermark is displayed until the video ends.
        self.duration = duration
        # The beginning of the time range during which the watermark is displayed.
        # 
        # *   Unit: seconds.
        # *   Default value: **0**.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        id: str = None,
        name: str = None,
        ratio_refer: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer = None,
        refer_pos: str = None,
        state: str = None,
        timeline: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline = None,
        type: str = None,
        width: str = None,
    ):
        # The horizontal offset. Unit: pixel.
        self.dx = dx
        # The vertical offset. Unit: pixel.
        self.dy = dy
        # The height of the watermark image. Unit: pixel.
        self.height = height
        # The ID of the watermark template.
        self.id = id
        # The name of the watermark template.
        self.name = name
        # The values of the Height, Width, Dx, and Dy parameters relative to the reference edges. If the values of the Height, Width, Dx, and Dy parameters are decimals between 0 and 1, the values are calculated by referring to the following edges in sequence:
        # 
        # *   **Width**: the width edge.
        # *   **Height**: the height edge.
        # *   **Long**: the long edge.
        # *   **Short**: the short edge.
        self.ratio_refer = ratio_refer
        # The position of the watermark. Valid values:
        # 
        # *   **TopRight**: the upper-right corner.
        # *   **TopLeft**: the upper-left corner.
        # *   **BottomRight**: the lower-right corner.
        # *   **BottomLeft**: the lower-left corner.
        self.refer_pos = refer_pos
        # The status of the watermark template. Valid values: Valid values:
        # 
        # *   **Normal**: The watermark template is normal.
        # *   **Deleted**: The watermark template is deleted.
        self.state = state
        # The timeline of the watermark.
        self.timeline = timeline
        # The type of the watermark. Valid values:
        # 
        # *   Image: an image watermark.
        # *   Text: a text watermark.
        # 
        # > Only watermarks of the **Image** type are supported.
        self.type = type
        # The width of the watermark image. Unit: pixel.
        self.width = width

    def validate(self):
        if self.ratio_refer:
            self.ratio_refer.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.ratio_refer is not None:
            result['RatioRefer'] = self.ratio_refer.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.state is not None:
            result['State'] = self.state
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RatioRefer') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer()
            self.ratio_refer = temp_model.from_map(m['RatioRefer'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Timeline') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList(TeaModel):
    def __init__(
        self,
        water_mark_template: List[QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate] = None,
    ):
        self.water_mark_template = water_mark_template

    def validate(self):
        if self.water_mark_template:
            for k in self.water_mark_template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMarkTemplate'] = []
        if self.water_mark_template is not None:
            for k in self.water_mark_template:
                result['WaterMarkTemplate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark_template = []
        if m.get('WaterMarkTemplate') is not None:
            for k in m.get('WaterMarkTemplate'):
                temp_model = QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate()
                self.water_mark_template.append(temp_model.from_map(k))
        return self


class QueryWaterMarkTemplateListResponseBody(TeaModel):
    def __init__(
        self,
        non_exist_wids: QueryWaterMarkTemplateListResponseBodyNonExistWids = None,
        request_id: str = None,
        water_mark_template_list: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList = None,
    ):
        # The IDs of the templates that do not exist.
        self.non_exist_wids = non_exist_wids
        # The ID of the request.
        self.request_id = request_id
        # The details of the watermark templates.
        self.water_mark_template_list = water_mark_template_list

    def validate(self):
        if self.non_exist_wids:
            self.non_exist_wids.validate()
        if self.water_mark_template_list:
            self.water_mark_template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.non_exist_wids is not None:
            result['NonExistWids'] = self.non_exist_wids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.water_mark_template_list is not None:
            result['WaterMarkTemplateList'] = self.water_mark_template_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NonExistWids') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBodyNonExistWids()
            self.non_exist_wids = temp_model.from_map(m['NonExistWids'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WaterMarkTemplateList') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList()
            self.water_mark_template_list = temp_model.from_map(m['WaterMarkTemplateList'])
        return self


class QueryWaterMarkTemplateListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryWaterMarkTemplateListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryWaterMarkTemplateListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterCustomFaceRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        image_url: str = None,
        owner_account: str = None,
        owner_id: int = None,
        person_id: str = None,
        person_name: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the figure library in which you want to register a custom face. The ID is used to uniquely identify a figure library. You can specify the ID of a custom figure library. Make sure that the ID is unique and keep the ID for future API operation calls. If you set this parameter to the ID of a system figure library, the custom face is registered in the system figure library. The ID can be up to 120 characters in length and is not case-sensitive.
        # 
        # This parameter is required.
        self.category_id = category_id
        # The URL of the facial image that you want to register for the specified figure. The image must contain only one face.
        # 
        # This parameter is required.
        self.image_url = image_url
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the figure for which you want to register a custom face. The ID is used to uniquely identify a figure. You can specify a figure ID. Make sure that the ID is unique and keep the ID for future API operation calls. The ID can be up to 120 characters in length and is not case-sensitive. The value returned is of the String type.
        # 
        # This parameter is required.
        self.person_id = person_id
        self.person_name = person_name
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.person_id is not None:
            result['PersonId'] = self.person_id
        if self.person_name is not None:
            result['PersonName'] = self.person_name
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PersonId') is not None:
            self.person_id = m.get('PersonId')
        if m.get('PersonName') is not None:
            self.person_name = m.get('PersonName')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RegisterCustomFaceResponseBody(TeaModel):
    def __init__(
        self,
        face_id: str = None,
        request_id: str = None,
    ):
        # The ID of the face.
        self.face_id = face_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.face_id is not None:
            result['FaceId'] = self.face_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FaceId') is not None:
            self.face_id = m.get('FaceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RegisterCustomFaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterCustomFaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterCustomFaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterCustomViewRequest(TeaModel):
    def __init__(
        self,
        algorithm: str = None,
        custom_entity_id: str = None,
        custom_group_id: str = None,
        image_url: str = None,
        label_prompt: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # This parameter is required.
        self.algorithm = algorithm
        # This parameter is required.
        self.custom_entity_id = custom_entity_id
        # This parameter is required.
        self.custom_group_id = custom_group_id
        self.image_url = image_url
        self.label_prompt = label_prompt
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm is not None:
            result['Algorithm'] = self.algorithm
        if self.custom_entity_id is not None:
            result['CustomEntityId'] = self.custom_entity_id
        if self.custom_group_id is not None:
            result['CustomGroupId'] = self.custom_group_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.label_prompt is not None:
            result['LabelPrompt'] = self.label_prompt
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Algorithm') is not None:
            self.algorithm = m.get('Algorithm')
        if m.get('CustomEntityId') is not None:
            self.custom_entity_id = m.get('CustomEntityId')
        if m.get('CustomGroupId') is not None:
            self.custom_group_id = m.get('CustomGroupId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('LabelPrompt') is not None:
            self.label_prompt = m.get('LabelPrompt')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RegisterCustomViewResponseBody(TeaModel):
    def __init__(
        self,
        custom_view_id: str = None,
        request_id: str = None,
    ):
        self.custom_view_id = custom_view_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_view_id is not None:
            result['CustomViewId'] = self.custom_view_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomViewId') is not None:
            self.custom_view_id = m.get('CustomViewId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RegisterCustomViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterCustomViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterCustomViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        state_list: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The number of the page to return. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page.
        # 
        # *   A maximum of **100** entries can be returned on each page.
        # *   Default value: **10**.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The status of the media workflows that you want to query. You can specify multiple states. Separate multiple states with commas (,). Default value: **Inactive,Active,Deleted**. Valid values:
        # 
        # *   **Inactive**: Deactivated media workflows are queried.
        # *   **Active**: Activated media workflows are queried.
        # *   **Deleted**: Deleted media workflows are queried.
        self.state_list = state_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.state_list is not None:
            result['StateList'] = self.state_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StateList') is not None:
            self.state_list = m.get('StateList')
        return self


class SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The ID of the media workflow.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow.
        self.name = name
        # The status of the media workflow. Valid values:
        # 
        # *   **Inactive**: The media workflow is deactivated.
        # *   **Active**: The media workflow is activated.
        # *   **Deleted**: The media workflow is deleted.
        self.state = state
        # The topology of the media workflow.
        self.topology = topology
        # The trigger mode of the media workflow. Valid values:
        # 
        # *   **OssAutoTrigger**: The media workflow is automatically triggered.
        # *   **NotInAuto**: The media workflow is not automatically triggered.
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class SearchMediaWorkflowResponseBodyMediaWorkflowList(TeaModel):
    def __init__(
        self,
        media_workflow: List[SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow] = None,
    ):
        self.media_workflow = media_workflow

    def validate(self):
        if self.media_workflow:
            for k in self.media_workflow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaWorkflow'] = []
        if self.media_workflow is not None:
            for k in self.media_workflow:
                result['MediaWorkflow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.media_workflow = []
        if m.get('MediaWorkflow') is not None:
            for k in m.get('MediaWorkflow'):
                temp_model = SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow()
                self.media_workflow.append(temp_model.from_map(k))
        return self


class SearchMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow_list: SearchMediaWorkflowResponseBodyMediaWorkflowList = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The details of the media workflows.
        self.media_workflow_list = media_workflow_list
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned on each page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.media_workflow_list:
            self.media_workflow_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_list is not None:
            result['MediaWorkflowList'] = self.media_workflow_list.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowList') is not None:
            temp_model = SearchMediaWorkflowResponseBodyMediaWorkflowList()
            self.media_workflow_list = temp_model.from_map(m['MediaWorkflowList'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchPipelineRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        state: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The number of the page to return. Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page.
        # 
        # *   A maximum of **100** entries can be returned on each page.
        # *   Default value: **10**.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The status of the MPS queues that you want to query. If you leave this parameter empty, all MPS queues are queried.
        # 
        # *   **All**: queries all MPS queues.
        # *   **Active**: queries the MPS queues that are active.
        # *   **Paused**: queues the MPS queues that are paused.
        # *   Default value: **All**.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SearchPipelineResponseBodyPipelineListPipelineNotifyConfig(TeaModel):
    def __init__(
        self,
        mq_tag: str = None,
        mq_topic: str = None,
        queue_name: str = None,
        topic: str = None,
    ):
        # The tags.
        self.mq_tag = mq_tag
        # The queue of messages that are received.
        self.mq_topic = mq_topic
        # The name of the queue that is created in MNS.
        self.queue_name = queue_name
        # The name of the topic that is created in MNS.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mq_tag is not None:
            result['MqTag'] = self.mq_tag
        if self.mq_topic is not None:
            result['MqTopic'] = self.mq_topic
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MqTag') is not None:
            self.mq_tag = m.get('MqTag')
        if m.get('MqTopic') is not None:
            self.mq_topic = m.get('MqTopic')
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class SearchPipelineResponseBodyPipelineListPipeline(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        id: str = None,
        name: str = None,
        notify_config: SearchPipelineResponseBodyPipelineListPipelineNotifyConfig = None,
        quota_allocate: int = None,
        role: str = None,
        speed: str = None,
        speed_level: int = None,
        state: str = None,
    ):
        self.creation_time = creation_time
        # The ID of the MPS queue.
        self.id = id
        # The name of the MPS queue.
        self.name = name
        # The Message Service (MNS) configuration.
        self.notify_config = notify_config
        # The quota that is allocated to the MPS queue.
        self.quota_allocate = quota_allocate
        # The role that is assigned to the current RAM user.
        self.role = role
        # The type of the MPS queue. Default value: **Standard**. Valid values:
        # 
        # *   **Boost**: MPS queue with transcoding speed boosted
        # *   **Standard**: standard MPS queue
        # *   **NarrowBandHDV2**: MPS queue that supports Narrowband HD 2.0
        # *   **AIVideoCover**: MPS queue for intelligent snapshot capture
        # *   **AIVideoFPShot**: MPS queue for media fingerprinting
        # *   **AIVideoCensor**: MPS queue for automated review
        # *   **AIVideoMCU**: MPS queue for smart tagging
        # *   **AIVideoSummary**: MPS queue for video synopsis
        # *   **AIVideoPorn**: MPS queue for pornography detection in videos
        # *   **AIAudioKWS**: MPS queue for keyword recognition in audio
        # *   **AIAudioASR**: MPS queue for speech-to-text conversion
        self.speed = speed
        # The level of the MPS queue.
        self.speed_level = speed_level
        # The state of the MPS queue. Valid values:
        # 
        # *   **Active**: The MPS queue is active.
        # *   **Paused**: The MPS queue is paused.
        self.state = state

    def validate(self):
        if self.notify_config:
            self.notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config.to_map()
        if self.quota_allocate is not None:
            result['QuotaAllocate'] = self.quota_allocate
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.speed_level is not None:
            result['SpeedLevel'] = self.speed_level
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            temp_model = SearchPipelineResponseBodyPipelineListPipelineNotifyConfig()
            self.notify_config = temp_model.from_map(m['NotifyConfig'])
        if m.get('QuotaAllocate') is not None:
            self.quota_allocate = m.get('QuotaAllocate')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('SpeedLevel') is not None:
            self.speed_level = m.get('SpeedLevel')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SearchPipelineResponseBodyPipelineList(TeaModel):
    def __init__(
        self,
        pipeline: List[SearchPipelineResponseBodyPipelineListPipeline] = None,
    ):
        self.pipeline = pipeline

    def validate(self):
        if self.pipeline:
            for k in self.pipeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Pipeline'] = []
        if self.pipeline is not None:
            for k in self.pipeline:
                result['Pipeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pipeline = []
        if m.get('Pipeline') is not None:
            for k in m.get('Pipeline'):
                temp_model = SearchPipelineResponseBodyPipelineListPipeline()
                self.pipeline.append(temp_model.from_map(k))
        return self


class SearchPipelineResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        pipeline_list: SearchPipelineResponseBodyPipelineList = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The MPS queues.
        self.pipeline_list = pipeline_list
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.pipeline_list:
            self.pipeline_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pipeline_list is not None:
            result['PipelineList'] = self.pipeline_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PipelineList') is not None:
            temp_model = SearchPipelineResponseBodyPipelineList()
            self.pipeline_list = temp_model.from_map(m['PipelineList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchPipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchPipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchPipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTemplateRequest(TeaModel):
    def __init__(
        self,
        name_prefix: str = None,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        state: str = None,
    ):
        # The name prefix based on which you want to search for templates.
        self.name_prefix = name_prefix
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The number of the page to return. Default value: **1**.
        self.page_number = page_number
        # The size of each page set during the result paging query.
        # 
        # - Upper limit: 100.
        # - Default value: 10.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The status of the custom transcoding templates that you want to query.
        # 
        # *   **All**: All custom transcoding templates are queried.
        # *   **Normal**: Normal custom transcoding templates are queried.
        # *   **Deleted**: Deleted custom transcoding templates are queried.
        # *   Default value: **All**.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_prefix is not None:
            result['NamePrefix'] = self.name_prefix
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamePrefix') is not None:
            self.name_prefix = m.get('NamePrefix')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SearchTemplateResponseBodyTemplateListTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        samplerate: str = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.bitrate = bitrate
        # The number of sound channels. Default value: **2**.
        self.channels = channels
        # The audio codec format. Default value: **aac**. Valid values:
        # 
        # *   **aac**\
        # *   **mp3**\
        # *   **vorbis**\
        # *   **flac**\
        self.codec = codec
        # The codec profile of the audio. Valid values when the value of Codec is aac:
        # 
        # *   **aac_low**\
        # *   **aac_he**\
        # *   **aac_he_v2**\
        # *   **aac_ld**\
        # *   **aac_eld**\
        self.profile = profile
        # The strength of the independent denoising algorithm. Valid values: **[1,9]**.
        self.qscale = qscale
        # Indicates whether the audio stream is deleted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.remove = remove
        # The sampling rate.
        # 
        # *   Unit: Hz
        # *   Default value: **44100**.
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class SearchTemplateResponseBodyTemplateListTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The format of the container. Valid values:
        # 
        # *   **flv**\
        # *   **mp4**\
        # *   **ts**\
        # *   **m3u8**\
        # *   **gif**\
        # *   **mp3**\
        # *   **ogg**\
        # *   **flac**\
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        # The color dithering algorithm of the palette. Valid values: sierra and bayer.
        self.dither_mode = dither_mode
        # The duration for which the final frame is paused. Unit: centisecond.
        self.final_delay = final_delay
        # Indicates whether a custom palette is used.
        self.is_custom_palette = is_custom_palette
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The length of the segment. Unit: seconds.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class SearchTemplateResponseBodyTemplateListTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif = None,
        segment: SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment = None,
    ):
        # The transmuxing configurations for GIF.
        self.gif = gif
        # The segment configurations.
        self.segment = segment

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SearchTemplateResponseBodyTemplateListTemplateTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method of resolution adjustment. Default value: **none**. Valid values:
        # 
        # *   rescale
        # *   crop
        # *   none
        self.adj_dar_method = adj_dar_method
        # Indicates whether the audio bitrate is checked. If the bitrate of the output audio is higher than that of the input audio, the input bitrate is retained and the specified audio bitrate does not take effect. This parameter has a lower priority than IsCheckAudioBitrateFail. Valid values:
        # 
        # *   **true**\
        # 
        # *   **false**\
        # 
        # *   Default value:
        # 
        #     *   If this parameter is empty and the codec of the output audio is different from that of the input audio, the default value is false.
        #     *   If this parameter is empty and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Indicates whether audio bitrate check errors are allowed. This parameter has a greater priority than IsCheckAudioBitrate. Valid values:
        # 
        # *   **true**: If the audio bitrate check fails, the input file is not transcoded.
        # *   **false**: The audio bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, the input resolution is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso = is_check_reso
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, a transcoding failure is returned. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the video bitrate is checked. If the bitrate of the output video is higher than that of the input video, the input bitrate is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Indicates whether video bitrate check errors are allowed. This parameter has a higher priority than IsCheckVideoBitrate. Valid values:
        # 
        # *   **true**: If the video bitrate check fails, the input file is not transcoded.
        # *   **false**: The video bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The transcoding mode. Default value: **onepass**. Valid values:
        # 
        # *   **onepass**\
        # *   **twopass**\
        # *   **CBR**\
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The upper limit of the total bitrate. Unit: Kbit/s.
        self.max = max
        # The lower limit of the total bitrate. Unit: Kbit/s.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand(TeaModel):
    def __init__(
        self,
        abrmax: float = None,
        max_abr_ratio: float = None,
        version: str = None,
    ):
        # The upper limit of the dynamic bitrate. If this parameter is set, the average bitrate is in the range of (0, 1000000].
        self.abrmax = abrmax
        # The maximum ratio of the upper limit of dynamic bitrate. If this parameter is set, the value of Abrmax does not exceed x times of the source video bitrate. Valid values: (0,1.0].
        self.max_abr_ratio = max_abr_ratio
        # The Narrowband HD version. Only 1.0 may be returned.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abrmax is not None:
            result['Abrmax'] = self.abrmax
        if self.max_abr_ratio is not None:
            result['MaxAbrRatio'] = self.max_abr_ratio
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Abrmax') is not None:
            self.abrmax = m.get('Abrmax')
        if m.get('MaxAbrRatio') is not None:
            self.max_abr_ratio = m.get('MaxAbrRatio')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class SearchTemplateResponseBodyTemplateListTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        hdr_2sdr: str = None,
        height: str = None,
        long_short_mode: str = None,
        max_fps: str = None,
        maxrate: str = None,
        narrow_band: SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The average bitrate of the video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The average bitrate range of the video.
        self.bitrate_bnd = bitrate_bnd
        # The buffer size.
        # 
        # *   Unit: KB.
        # *   Default value: **6000**.
        self.bufsize = bufsize
        # The codec.
        # 
        # *   Valid values: H.264 and H.265.
        # *   Default value: **H.264**.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Default value when the value of Codec is H.264: **23**, default value when the value of Codec is H.265: **26**.
        # *   If this parameter is set, the value of Bitrate becomes invalid.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   **border**: automatically detects and removes black bars.
        # *   **Value in the width:height:left:top format**: crops the video image based on the custom settings. Format: width:height:left:top. Example: 1280:800:0:140.
        self.crop = crop
        # The level of video quality control.
        self.degrain = degrain
        # The frame rate of the video.
        # 
        # *   The value is 60 if the frame rate of the input video exceeds 60.
        # *   Default value: **the frame rate of the input video**.
        self.fps = fps
        # The maximum number of frames between two keyframes. Default value: **250**.
        self.gop = gop
        # Indicates whether the HDR2SDR conversion feature is enabled. If this feature is enabled, high dynamic range (HDR) videos are transcoded to standard dynamic range (SDR) videos.
        self.hdr_2sdr = hdr_2sdr
        # The height of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: **the height of the input video**.
        self.height = height
        # Indicates whether the auto-rotate screen feature is enabled.
        # 
        # *   If this feature is enabled, the width of the output video corresponds to the long side of the input video, which is the height of the input video in portrait mode. The height of the output video corresponds to the short side of the input video, which is the width of the input video in portrait mode. Valid values:
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.long_short_mode = long_short_mode
        # The maximum frame rate.
        self.max_fps = max_fps
        # The maximum bitrate of the video. Unit: Kbit/s.
        self.maxrate = maxrate
        # The Narrowband HD settings.
        self.narrow_band = narrow_band
        # The black bars that are added to the video.
        # 
        # *   Format: width:height:left:top.
        # *   Example: 1280:800:0:140.
        self.pad = pad
        # The pixel format of the video. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. Default value: **medium**. Valid values:
        # 
        # *   **veryfast**\
        # *   **fast**\
        # *   **medium**\
        # *   **slow**\
        # *   **slower**\
        self.preset = preset
        # The codec profile. Valid values:
        # 
        # *   **baseline**: applicable to mobile devices.
        # *   **main**: applicable to standard-definition devices.
        # *   **high**: applicable to high-definition devices.
        # *   Default value: **high**.
        self.profile = profile
        # The strength of the independent denoising algorithm.
        self.qscale = qscale
        # Indicates whether the video stream is deleted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.remove = remove
        # The policy of resolution adjustment.
        self.reso_priority = reso_priority
        # The scan mode. Valid values:
        # 
        # *   **interlaced**\
        # *   **progressive**\
        self.scan_mode = scan_mode
        # The width of the video.
        # 
        # *   Valid values: **[128,4096]**.
        # *   Unit: pixel.
        # *   Default value: **the width of the input video**.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()
        if self.narrow_band:
            self.narrow_band.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.hdr_2sdr is not None:
            result['Hdr2sdr'] = self.hdr_2sdr
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.narrow_band is not None:
            result['NarrowBand'] = self.narrow_band.to_map()
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Hdr2sdr') is not None:
            self.hdr_2sdr = m.get('Hdr2sdr')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('NarrowBand') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateVideoNarrowBand()
            self.narrow_band = temp_model.from_map(m['NarrowBand'])
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SearchTemplateResponseBodyTemplateListTemplate(TeaModel):
    def __init__(
        self,
        audio: SearchTemplateResponseBodyTemplateListTemplateAudio = None,
        container: SearchTemplateResponseBodyTemplateListTemplateContainer = None,
        creation_time: str = None,
        id: str = None,
        mux_config: SearchTemplateResponseBodyTemplateListTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: SearchTemplateResponseBodyTemplateListTemplateTransConfig = None,
        video: SearchTemplateResponseBodyTemplateListTemplateVideo = None,
    ):
        # The audio codec configurations.
        self.audio = audio
        # The container format configurations.
        self.container = container
        # The time when the template was created.
        self.creation_time = creation_time
        # The transcoding template ID.
        self.id = id
        # The transmuxing configurations.
        self.mux_config = mux_config
        # The name of the template.
        self.name = name
        # The status of the template. Valid values:
        # 
        # *   **Normal**\
        # *   **Deleted**\
        self.state = state
        # The general transcoding configurations.
        self.trans_config = trans_config
        # The video codec configurations.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = SearchTemplateResponseBodyTemplateListTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SearchTemplateResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        template: List[SearchTemplateResponseBodyTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = SearchTemplateResponseBodyTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class SearchTemplateResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        template_list: SearchTemplateResponseBodyTemplateList = None,
        total_count: int = None,
    ):
        # The number of the page to return.
        self.page_number = page_number
        # The page number of the returned page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The transcoding templates.
        self.template_list = template_list
        # The total number of search results.
        self.total_count = total_count

    def validate(self):
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateList') is not None:
            temp_model = SearchTemplateResponseBodyTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchWaterMarkTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_account: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        state: str = None,
    ):
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page.
        # 
        # *   A maximum of **100** entries can be returned on each page.
        # *   Default value: **10**.
        self.page_size = page_size
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The state of the watermark templates that you want to query. Valid values:
        # 
        # *   **All (default)**\
        # *   **Normal**\
        # *   **Deleted**\
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        width: str = None,
    ):
        # The horizontal offset. Unit: pixel.
        self.dx = dx
        # The timeline of the watermark.
        self.dy = dy
        # The height of the watermark image. Unit: pixel.
        self.height = height
        # The width of the watermark image. Unit: pixel.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The horizontal offset of the watermark relative to the output video image. Default value: **0**. The default value indicates no offset.
        # 
        # The value can be an integer or a decimal.
        # 
        # *   **Integer**: the vertical offset. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the horizontal offset to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.duration = duration
        # The total number of returned entries.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        id: str = None,
        name: str = None,
        ratio_refer: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer = None,
        refer_pos: str = None,
        state: str = None,
        timeline: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline = None,
        type: str = None,
        width: str = None,
    ):
        # The name of the watermark template.
        self.dx = dx
        # The values of the Height, Width, Dx, and Dy parameters relative to the reference edges. If the values of the Height, Width, Dx, and Dy parameters are decimals between 0 and 1, the values are calculated by referring to the following edges in sequence:
        # 
        # *   **Width**: the width edge.
        # *   **Height**: the height edge.
        # *   **Long**: the long edge.
        # *   **Short**: the short edge.
        self.dy = dy
        # The ID of the watermark template.
        self.height = height
        # The vertical offset. Unit: pixel.
        self.id = id
        # The width of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the width of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the width of the watermark image to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.name = name
        # The status of the watermark template. Valid values: Valid values:
        # 
        # *   **Normal**: The watermark template is normal.
        # *   **Deleted**: The watermark template is deleted.
        self.ratio_refer = ratio_refer
        # The beginning of the time range during which the watermark is displayed.
        # 
        # *   Unit: seconds.
        # *   Default value: **0**.
        self.refer_pos = refer_pos
        # The display duration of the watermark. Default value: **ToEND**. The default value indicates that the watermark is displayed until the video ends.
        self.state = state
        # The timeline of the watermark.
        self.timeline = timeline
        # The position of the watermark. Valid values:
        # 
        # *   TopRight: the upper-right corner.
        # *   TopLeft: the upper-left corner.
        # *   BottomRight: the lower-right corner.
        # *   BottomLeft: the lower-left corner.
        self.type = type
        # The vertical offset. Unit: pixel.
        self.width = width

    def validate(self):
        if self.ratio_refer:
            self.ratio_refer.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.ratio_refer is not None:
            result['RatioRefer'] = self.ratio_refer.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.state is not None:
            result['State'] = self.state
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RatioRefer') is not None:
            temp_model = SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer()
            self.ratio_refer = temp_model.from_map(m['RatioRefer'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Timeline') is not None:
            temp_model = SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList(TeaModel):
    def __init__(
        self,
        water_mark_template: List[SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate] = None,
    ):
        self.water_mark_template = water_mark_template

    def validate(self):
        if self.water_mark_template:
            for k in self.water_mark_template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMarkTemplate'] = []
        if self.water_mark_template is not None:
            for k in self.water_mark_template:
                result['WaterMarkTemplate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark_template = []
        if m.get('WaterMarkTemplate') is not None:
            for k in m.get('WaterMarkTemplate'):
                temp_model = SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate()
                self.water_mark_template.append(temp_model.from_map(k))
        return self


class SearchWaterMarkTemplateResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        water_mark_template_list: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList = None,
    ):
        # The width of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the width of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the width of the watermark image to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.page_number = page_number
        # The values of the Height, Width, Dx, and Dy parameters relative to the reference edges. If the values of the Height, Width, Dx, and Dy parameters are decimals between 0 and 1, the values are calculated by referring to the following edges in sequence:
        # 
        # *   **Width**: the width edge.
        # *   **Height**: the height edge.
        # *   **Long**: the long edge.
        # *   **Short**: the short edge.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The type of the watermark. Valid values:
        # 
        # *   Image: an image watermark.
        # *   Text: a text watermark.
        # 
        # >  Only watermarks of the **Image** types are supported.
        self.total_count = total_count
        # The height of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the height of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the height of the watermark image to the height of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.water_mark_template_list = water_mark_template_list

    def validate(self):
        if self.water_mark_template_list:
            self.water_mark_template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.water_mark_template_list is not None:
            result['WaterMarkTemplateList'] = self.water_mark_template_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('WaterMarkTemplateList') is not None:
            temp_model = SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList()
            self.water_mark_template_list = temp_model.from_map(m['WaterMarkTemplateList'])
        return self


class SearchWaterMarkTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchWaterMarkTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchWaterMarkTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAnalysisJobRequest(TeaModel):
    def __init__(
        self,
        analysis_config: str = None,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        priority: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        user_data: str = None,
    ):
        # The job configurations. Set this parameter as required. For more information, see the "AnalysisConfig" section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        self.analysis_config = analysis_config
        # The input information about the preset template analysis job to be submitted. The value must be a JSON object. You must log on to the Object Storage Service (OSS) console to grant the read permissions on the specified OSS bucket to MPS. For more information, see the "Input" section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        # 
        # > The OSS bucket must reside in the same region as your MPS service.
        # 
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue to which the job is submitted. To view the ID of the MPS queue, log on to the **MPS console** and choose **Global Settings** > **Pipelines** in the left-side navigation pane. If you want to enable asynchronous notifications, make sure that the MPS queue is bound to a Message Service (MNS) topic.
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id
        # The priority of the job in the MPS queue to which the job is submitted.
        # 
        # *   Valid values: **1 to 10**. A value of 10 indicates the highest priority.
        # *   Default value: **6**.
        self.priority = priority
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The custom data. The custom data can contain letters, digits, and hyphens (-), and can be up to 1,024 bytes in length. The custom data cannot start with a special character.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_config is not None:
            result['AnalysisConfig'] = self.analysis_config
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisConfig') is not None:
            self.analysis_config = m.get('AnalysisConfig')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop(TeaModel):
    def __init__(
        self,
        height: str = None,
        left: str = None,
        mode: str = None,
        top: str = None,
        width: str = None,
    ):
        # The height of the video after the margins were cropped out.
        # 
        # > This parameter is invalid if the **Mode** parameter is set to Auto or None.
        self.height = height
        # The left margin that was cropped out.
        # 
        # > This parameter is invalid if the **Mode** parameter is set to Auto or None.
        self.left = left
        # The cropping mode. Valid values:
        # 
        # *   **Auto**: Cropping was automatically run. This is the default value.
        # *   **Force**: Cropping was forced to run.
        # *   **None**: Cropping was forced not to run.
        self.mode = mode
        # The top margin that was cropped out.
        # 
        # > This parameter is invalid if the **Mode** parameter is set to Auto or None.
        self.top = top
        # The width of the video after the margins were cropped out.
        # 
        # > This parameter is invalid if the **Mode** parameter is set to Auto or None.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.left is not None:
            result['Left'] = self.left
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.top is not None:
            result['Top'] = self.top
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl(TeaModel):
    def __init__(
        self,
        crop: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop = None,
        deinterlace: str = None,
    ):
        # The cropping configurations of video images.
        self.crop = crop
        # Indicates whether deinterlacing was forced to run. Valid values:
        # 
        # *   **Auto**: Deinterlacing was automatically run.
        # *   **Force**: Deinterlacing was forced to run.
        # *   **None**: Deinterlacing was forced not to run.
        self.deinterlace = deinterlace

    def validate(self):
        if self.crop:
            self.crop.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.crop is not None:
            result['Crop'] = self.crop.to_map()
        if self.deinterlace is not None:
            result['Deinterlace'] = self.deinterlace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Crop') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop()
            self.crop = temp_model.from_map(m['Crop'])
        if m.get('Deinterlace') is not None:
            self.deinterlace = m.get('Deinterlace')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl(TeaModel):
    def __init__(
        self,
        method_streaming: str = None,
        rate_quality: str = None,
    ):
        # The playback mode. Valid values:
        # 
        # *   **network**: online playback
        # *   **local**: playback on local devices
        # *   Default value: **network**.
        self.method_streaming = method_streaming
        # The quality level of the output file.
        self.rate_quality = rate_quality

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method_streaming is not None:
            result['MethodStreaming'] = self.method_streaming
        if self.rate_quality is not None:
            result['RateQuality'] = self.rate_quality
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MethodStreaming') is not None:
            self.method_streaming = m.get('MethodStreaming')
        if m.get('RateQuality') is not None:
            self.rate_quality = m.get('RateQuality')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig(TeaModel):
    def __init__(
        self,
        properties_control: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl = None,
        quality_control: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl = None,
    ):
        # The control on the attributes of the job output.
        self.properties_control = properties_control
        # The quality control on the job output.
        self.quality_control = quality_control

    def validate(self):
        if self.properties_control:
            self.properties_control.validate()
        if self.quality_control:
            self.quality_control.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.properties_control is not None:
            result['PropertiesControl'] = self.properties_control.to_map()
        if self.quality_control is not None:
            result['QualityControl'] = self.quality_control.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PropertiesControl') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl()
            self.properties_control = temp_model.from_map(m['PropertiesControl'])
        if m.get('QualityControl') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl()
            self.quality_control = temp_model.from_map(m['QualityControl'])
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket.
        self.bucket = bucket
        # The ID of the OSS region.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the job failed. This parameter is not returned if the job was successful.
        self.error_code = error_code
        # The error message returned if the job failed. This parameter is not returned if the job was successful.
        self.error_message = error_message
        # The ID of the message returned if the job was successful. This parameter is not returned if the job failed.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.bitrate = bitrate
        # The number of sound channels. Default value: **2**.
        self.channels = channels
        # The audio codec format. Default value: **acc**.
        self.codec = codec
        # The codec profile of the audio. Valid values if the **Codec** parameter is set to **aac**: aac_low, aac_he, aac_he_v2, aac_ld, and aac_eld.
        self.profile = profile
        # The level of quality control on the audio.
        self.qscale = qscale
        # The sampling rate.
        # 
        # *   Unit: Hz.
        # *   Default value: **44100**.
        self.samplerate = samplerate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        final_delay: str = None,
        loop: str = None,
    ):
        # The interval between two consecutive loops for the GIF format. Unit: 0.01s. For example, a value of 500 indicates 5 seconds.
        self.final_delay = final_delay
        # The number of loops for the GIF or WebP format. Default value: 0.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The length of the segment. Unit: seconds.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif = None,
        segment: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment = None,
    ):
        # The transmuxing configurations for the GIF format.
        self.gif = gif
        # The segment configurations.
        self.segment = segment

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig(TeaModel):
    def __init__(
        self,
        trans_mode: str = None,
    ):
        # The transcoding mode. Valid values: onepass, twopass, and CBR. Default value: **onepass**.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The upper limit of the total bitrate. Unit: Kbit/s.
        self.max = max
        # The lower limit of the total bitrate. Unit: Kbit/s.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        maxrate: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The average bitrate of the video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The average bitrate range of the video.
        self.bitrate_bnd = bitrate_bnd
        # The size of the buffer.
        # 
        # *   Unit: KB.
        # *   Default value: **6000**.
        self.bufsize = bufsize
        # The video codec. Default value: **H.264**.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   Default value if the Codec parameter is set to H.264: **23**. Default value if the Codec parameter is set to H.265: **26**.
        # *   If this parameter is returned, the setting of the Bitrate parameter is invalid.
        self.crf = crf
        # The strength of the independent noise reduction algorithm.
        self.degrain = degrain
        # The frame rate.
        # 
        # *   The value is 60 if the frame rate of the input video exceeds 60.
        # *   Default value: the frame rate of the input video.
        self.fps = fps
        # The maximum number of frames between two keyframes. Default value: **250**.
        self.gop = gop
        # The height of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: the height of the input video.
        self.height = height
        # The maximum bitrate of the video. Unit: Kbit/s.
        self.maxrate = maxrate
        # The pixel format for video color encoding. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. Valid values: veryfast, fast, medium, slow, and slower. Default value: **medium**.
        self.preset = preset
        # The codec profile. Valid values:
        # 
        # *   **baseline**: applicable to mobile devices.
        # *   **main**: applicable to standard-definition devices.
        # *   **high**: applicable to high-definition devices.
        # *   Default value: **high**.
        self.profile = profile
        # The level of quality control on the video.
        self.qscale = qscale
        # The scan mode. Valid values:
        # 
        # *   **interlaced**\
        # *   **progressive**\
        self.scan_mode = scan_mode
        # The width of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: the width of the input video.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate(TeaModel):
    def __init__(
        self,
        audio: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio = None,
        container: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer = None,
        id: str = None,
        mux_config: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig = None,
        video: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo = None,
    ):
        # The audio codec configurations.
        self.audio = audio
        # The container format configurations.
        self.container = container
        # The ID of the transcoding template.
        self.id = id
        # The transmuxing configurations.
        self.mux_config = mux_config
        # The name of the template.
        self.name = name
        # The status of the template.
        # 
        # *   **Normal**: The template is normal.
        # *   **Deleted**: The template is deleted.
        self.state = state
        # The general transcoding configurations.
        self.trans_config = trans_config
        # The video codec configurations.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SubmitAnalysisJobResponseBodyAnalysisJobTemplateList(TeaModel):
    def __init__(
        self,
        template: List[SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class SubmitAnalysisJobResponseBodyAnalysisJob(TeaModel):
    def __init__(
        self,
        analysis_config: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig = None,
        code: str = None,
        creation_time: str = None,
        id: str = None,
        input_file: SubmitAnalysisJobResponseBodyAnalysisJobInputFile = None,
        mnsmessage_result: SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult = None,
        message: str = None,
        percent: int = None,
        pipeline_id: str = None,
        priority: str = None,
        state: str = None,
        template_list: SubmitAnalysisJobResponseBodyAnalysisJobTemplateList = None,
        user_data: str = None,
    ):
        # The job configurations.
        self.analysis_config = analysis_config
        # The error code returned if the job failed. This parameter is not returned if the job was successful.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The ID of the template analysis job.
        self.id = id
        # The information about the job input.
        self.input_file = input_file
        # The message sent by MNS to notify users of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the job failed.
        self.message = message
        # The transcoding progress.
        self.percent = percent
        # The ID of the MPS queue to which the analysis job was submitted.
        self.pipeline_id = pipeline_id
        # The priority of the job in the MPS queue to which the job was submitted.
        # 
        # *   Valid values: **1 to 10**. A value of 10 indicates the highest priority.
        # *   Default value: **10**.
        self.priority = priority
        # The status of the job. Valid values:
        # 
        # *   **Submitted**: The job is submitted.
        # *   **Analyzing**: The job is being run.
        # *   **Success**: The job is successful.
        # *   **Fail**: The job fails.
        self.state = state
        # The matched preset templates.
        self.template_list = template_list
        # The custom data.
        self.user_data = user_data

    def validate(self):
        if self.analysis_config:
            self.analysis_config.validate()
        if self.input_file:
            self.input_file.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_config is not None:
            result['AnalysisConfig'] = self.analysis_config.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.state is not None:
            result['State'] = self.state
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisConfig') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig()
            self.analysis_config = temp_model.from_map(m['AnalysisConfig'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InputFile') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TemplateList') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJobTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAnalysisJobResponseBody(TeaModel):
    def __init__(
        self,
        analysis_job: SubmitAnalysisJobResponseBodyAnalysisJob = None,
        request_id: str = None,
    ):
        # The information about the preset template analysis job that was submitted.
        self.analysis_job = analysis_job
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.analysis_job:
            self.analysis_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_job is not None:
            result['AnalysisJob'] = self.analysis_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisJob') is not None:
            temp_model = SubmitAnalysisJobResponseBodyAnalysisJob()
            self.analysis_job = temp_model.from_map(m['AnalysisJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitAnalysisJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAnalysisJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAnalysisJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCopyrightExtractJobRequest(TeaModel):
    def __init__(
        self,
        call_back: str = None,
        input: str = None,
        params: str = None,
        url: str = None,
        user_data: str = None,
    ):
        self.call_back = call_back
        self.input = input
        self.params = params
        self.url = url
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_back is not None:
            result['CallBack'] = self.call_back
        if self.input is not None:
            result['Input'] = self.input
        if self.params is not None:
            result['Params'] = self.params
        if self.url is not None:
            result['Url'] = self.url
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallBack') is not None:
            self.call_back = m.get('CallBack')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitCopyrightExtractJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitCopyrightExtractJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitCopyrightExtractJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitCopyrightExtractJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitCopyrightExtractJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCopyrightExtractJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCopyrightExtractJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCopyrightJobRequest(TeaModel):
    def __init__(
        self,
        call_back: str = None,
        description: str = None,
        input: str = None,
        level: int = None,
        message: str = None,
        output: str = None,
        params: str = None,
        start_time: int = None,
        total_time: int = None,
        url: str = None,
        user_data: str = None,
    ):
        self.call_back = call_back
        self.description = description
        self.input = input
        self.level = level
        # This parameter is required.
        self.message = message
        # This parameter is required.
        self.output = output
        self.params = params
        self.start_time = start_time
        self.total_time = total_time
        self.url = url
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_back is not None:
            result['CallBack'] = self.call_back
        if self.description is not None:
            result['Description'] = self.description
        if self.input is not None:
            result['Input'] = self.input
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output
        if self.params is not None:
            result['Params'] = self.params
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.total_time is not None:
            result['TotalTime'] = self.total_time
        if self.url is not None:
            result['Url'] = self.url
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallBack') is not None:
            self.call_back = m.get('CallBack')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TotalTime') is not None:
            self.total_time = m.get('TotalTime')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitCopyrightJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitCopyrightJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitCopyrightJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitCopyrightJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitCopyrightJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCopyrightJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCopyrightJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitFpDBDeleteJobRequest(TeaModel):
    def __init__(
        self,
        del_type: str = None,
        fp_dbid: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        user_data: str = None,
    ):
        # The operation type. Valid values:
        # 
        # *   **Purge**: clears the media fingerprint library. The content in the library is deleted, but the library is not deleted.
        # *   **Delete**: deletes the media fingerprint library. Both the library and its content are deleted.
        # *   Default value: **Purge**.
        self.del_type = del_type
        # The ID of the media fingerprint library. You can obtain the library ID from the response parameters of the [CreateFpShotDB](https://help.aliyun.com/document_detail/170149.html) operation.
        # 
        # This parameter is required.
        self.fp_dbid = fp_dbid
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the ApsaraVideo Media Processing (MPS) queue. This ID can be used to associate the job with a notification method. To view the MPS queue ID, log on to the **MPS console** and choose **Global Settings** > **Pipelines** in the left-side navigation pane.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The custom data. The value can contain letters and digits and can be up to 128 bytes in length.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.del_type is not None:
            result['DelType'] = self.del_type
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DelType') is not None:
            self.del_type = m.get('DelType')
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitFpDBDeleteJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the job. We recommend that you keep this ID for subsequent operation calls.
        self.job_id = job_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitFpDBDeleteJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitFpDBDeleteJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitFpDBDeleteJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitFpFileDeleteJobRequest(TeaModel):
    def __init__(
        self,
        file_ids: str = None,
        fp_dbid: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        primary_keys: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        user_data: str = None,
    ):
        # The IDs of the media files that you want to delete. Separate multiple file IDs with commas (,). You can delete up to 200 media files at a time. You can obtain media file IDs from the response parameters of the [ListFpShotFiles](https://help.aliyun.com/document_detail/209266.html) operation.
        self.file_ids = file_ids
        # The ID of the media fingerprint library. You can obtain the library ID from the response parameters of the [CreateFpShotDB](https://help.aliyun.com/document_detail/170149.html) operation.
        # 
        # This parameter is required.
        self.fp_dbid = fp_dbid
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the ApsaraVideo Media Processing (MPS) queue to which the job is submitted. The MPS queue is bound with a notification method. To view the MPS queue ID, log on to the **MPS console** and choose **Global Settings** > **MPS queue and Callback** in the left-side navigation pane.
        self.pipeline_id = pipeline_id
        # The primary keys of the files to be deleted. Separate multiple primary keys with commas (,). You can delete up to 200 primary keys at a time. You can obtain the primary keys of media files from the response parameters of the [ListFpShotFiles](https://help.aliyun.com/document_detail/209266.html) operation.
        # 
        # >  This parameter is available only in the China (Beijing), China (Hangzhou), and China (Shanghai) regions.
        self.primary_keys = primary_keys
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The custom data. The value can contain letters and digits and can be up to 128 bytes in length.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_ids is not None:
            result['FileIds'] = self.file_ids
        if self.fp_dbid is not None:
            result['FpDBId'] = self.fp_dbid
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.primary_keys is not None:
            result['PrimaryKeys'] = self.primary_keys
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileIds') is not None:
            self.file_ids = m.get('FileIds')
        if m.get('FpDBId') is not None:
            self.fp_dbid = m.get('FpDBId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PrimaryKeys') is not None:
            self.primary_keys = m.get('PrimaryKeys')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitFpFileDeleteJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The job ID.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitFpFileDeleteJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitFpFileDeleteJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitFpFileDeleteJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitFpShotJobRequest(TeaModel):
    def __init__(
        self,
        fp_shot_config: str = None,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        user_data: str = None,
    ):
        # The configurations of the media fingerprint analysis job. The value is a JSON object. For more information, see the "FpShotConfig" section of the [Parameter details](https://help.aliyun.com/document_detail/93568.html) topic.
        # 
        # This parameter is required.
        self.fp_shot_config = fp_shot_config
        # The OSS URL of the job input. The value is a JSON object. You can query the OSS URL in the OSS or MPS console.
        # 
        # > The OSS bucket must reside in the same region as your MPS service.
        # 
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue. This ID can be used to associate the job with a notification method. To view the ID of the MPS queue, perform the following steps: Log on to the **MPS console**. In the left-side navigation pane, choose **Global Settings** > **Pipelines**.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The custom data. The value can be up to 128 bytes in length and cannot start with a special character.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fp_shot_config is not None:
            result['FpShotConfig'] = self.fp_shot_config
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FpShotConfig') is not None:
            self.fp_shot_config = m.get('FpShotConfig')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitFpShotJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the media fingerprint analysis job. We recommend that you keep this ID for subsequent operation calls.
        self.job_id = job_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitFpShotJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitFpShotJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitFpShotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitIProductionJobRequest(TeaModel):
    def __init__(
        self,
        function_name: str = None,
        input: str = None,
        job_params: str = None,
        model_id: str = None,
        notify_url: str = None,
        output: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        schedule_params: str = None,
        user_data: str = None,
    ):
        # This parameter is required.
        self.function_name = function_name
        self.input = input
        self.job_params = job_params
        self.model_id = model_id
        self.notify_url = notify_url
        self.output = output
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.schedule_params = schedule_params
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.input is not None:
            result['Input'] = self.input
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.output is not None:
            result['Output'] = self.output
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.schedule_params is not None:
            result['ScheduleParams'] = self.schedule_params
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ScheduleParams') is not None:
            self.schedule_params = m.get('ScheduleParams')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitIProductionJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
        result: str = None,
    ):
        self.job_id = job_id
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class SubmitIProductionJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitIProductionJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitIProductionJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitImageCopyrightRequest(TeaModel):
    def __init__(
        self,
        message: str = None,
        output: str = None,
        params: str = None,
    ):
        # This parameter is required.
        self.message = message
        self.output = output
        self.params = params

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output
        if self.params is not None:
            result['Params'] = self.params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        return self


class SubmitImageCopyrightResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitImageCopyrightResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitImageCopyrightResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitImageCopyrightResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitImageCopyrightResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitImageCopyrightResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitImageCopyrightResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitJobsRequest(TeaModel):
    def __init__(
        self,
        input: str = None,
        output_bucket: str = None,
        output_location: str = None,
        outputs: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The information about the input file. For more information, see the "Input" section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        # 
        # > 
        # 
        # *   The path of an Object Storage Service (OSS) object must be URL-encoded in UTF-8 before you use the path in MPS.
        # 
        # *   The OSS bucket must reside in the same region as your MPS service.
        # 
        # This parameter is required.
        self.input = input
        # The name of the OSS bucket that stores the output file.
        # 
        # *   For more information about the term bucket, see [Terms](https://help.aliyun.com/document_detail/31827.html).
        # 
        # This parameter is required.
        self.output_bucket = output_bucket
        # The region in which the OSS bucket that stores the output file resides.
        # 
        # *   The OSS bucket must reside in the same region as MPS.
        # *   For more information about the term bucket, see [Terms](https://help.aliyun.com/document_detail/31827.html).
        self.output_location = output_location
        # The job output configurations. For more information, see the "Output" section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        # 
        # *   Specify the value in a JSON array of Output objects. You can specify up to 30 Output objects.
        # 
        # This parameter is required.
        self.outputs = outputs
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue. For more information, see [Terms](https://help.aliyun.com/document_detail/31827.html).
        # 
        # *   To obtain the ID of an MPS queue, you can log on to the [MPS console](https://mps.console.aliyun.com/overview) and choose **Global Settings** > **MPS Queue and Callback** in the left-side navigation pane.
        # *   If you want to receive asynchronous message notifications, associate an MNS queue or topic with the MPS queue. For more information, see [Receive notifications](https://help.aliyun.com/document_detail/42618.html).
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input
        if self.output_bucket is not None:
            result['OutputBucket'] = self.output_bucket
        if self.output_location is not None:
            result['OutputLocation'] = self.output_location
        if self.outputs is not None:
            result['Outputs'] = self.outputs
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OutputBucket') is not None:
            self.output_bucket = m.get('OutputBucket')
        if m.get('OutputLocation') is not None:
            self.output_location = m.get('OutputLocation')
        if m.get('Outputs') is not None:
            self.outputs = m.get('Outputs')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the job input is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the job input is stored.
        self.location = location
        # The name of the OSS object that is used as the job input.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the job failed. This parameter is not returned if the job was successful.
        self.error_code = error_code
        # The error message returned if the job failed. This parameter is not returned if the job was successful.
        self.error_message = error_message
        # The ID of the error message returned if the job failed. This parameter is not returned if the job was successful.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix(TeaModel):
    def __init__(
        self,
        amix_url: str = None,
        duration: str = None,
        map: str = None,
        mix_dur_mode: str = None,
        start: str = None,
    ):
        # The URL of the audio track that is mixed as the background music.
        # 
        # *   The URL can be an OSS URL or the string `input`.
        # *   A value of input indicates that two audio tracks are mixed in a video.
        self.amix_url = amix_url
        # The duration of the mixed audio track. The value is in the number or time format.
        self.duration = duration
        # The audio track that is mixed. Format: 0:a:{audio_index}. Example: 0:a:0.
        self.map = map
        # The mode to specify the mixing duration. Valid values: **first** and **long**.
        # 
        # *   **first**: The length of the output media equals the length of the input media.
        # *   **long**: The length of the output media equals the length of the output media or the length of the input media, whichever is longer.
        # *   Default value: **long**.
        self.mix_dur_mode = mix_dur_mode
        # The start time. The value is in the number or time format. Examples: 1:25:36.240 and 32000.23.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amix_url is not None:
            result['AmixURL'] = self.amix_url
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.map is not None:
            result['Map'] = self.map
        if self.mix_dur_mode is not None:
            result['MixDurMode'] = self.mix_dur_mode
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AmixURL') is not None:
            self.amix_url = m.get('AmixURL')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('MixDurMode') is not None:
            self.mix_dur_mode = m.get('MixDurMode')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList(TeaModel):
    def __init__(
        self,
        amix: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix] = None,
    ):
        self.amix = amix

    def validate(self):
        if self.amix:
            for k in self.amix:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Amix'] = []
        if self.amix is not None:
            for k in self.amix:
                result['Amix'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.amix = []
        if m.get('Amix') is not None:
            for k in m.get('Amix'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix()
                self.amix.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume(TeaModel):
    def __init__(
        self,
        level: str = None,
        method: str = None,
    ):
        # The volume adjustment range.
        # 
        # *   Unit: decibel.
        # *   Default value: **-20**.
        self.level = level
        # The method that is used to adjust the volume. Valid values:
        # 
        # *   **auto**\
        # *   **dynamic**\
        # *   **linear**\
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        samplerate: str = None,
        volume: SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume = None,
    ):
        # The audio bitrate of the output file.
        # 
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.bitrate = bitrate
        # The number of sound channels.
        # 
        # *   If the value of Codec is mp3, the value of this parameter can only be **1** or **2**.
        # *   If the value of Codec is aac, the value of this parameter can only be **1**, **2**, **4**, **5**, **6**, or **8**.
        # *   Default value: **2**.
        self.channels = channels
        # The audio codec.
        # 
        # *   Valid values: **aac**, **mp3**, **vorbis**, and **flac**.
        # *   Default value: **aac**.
        self.codec = codec
        # The codec profile of the audio.
        # 
        # >  Valid values if the value of **Codec** is **aac**: **aac_low**, **aac_he**, **aac_he_v2**, **aac_ld**, and **aac_eld**.
        self.profile = profile
        # The level of quality control on the audio.
        self.qscale = qscale
        # The sampling rate.
        # 
        # *   Valid values: **22050**, **32000**, **44100**, **48000**, and **96000**.
        # *   Unit: Hz.
        # *   Default value: **44100**.
        # 
        # >  If the video container format is FLV and the audio codec is MP3, the value of this parameter cannot be 32000, 48000, or 96000. If the audio codec is MP3, the value of this parameter cannot be 96000.
        self.samplerate = samplerate
        # The volume configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan(TeaModel):
    def __init__(
        self,
        duration: str = None,
        seek: str = None,
    ):
        # The duration of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Valid values: `[00:00:00.000,23:59:59.999]` or `[0.000,86399.999]`.
        self.duration = duration
        # The start time.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Valid values: `[00:00:00.000,23:59:59.999]` or `[0.000,86399.999]`.
        self.seek = seek

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputClip(TeaModel):
    def __init__(
        self,
        time_span: SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan = None,
    ):
        # The time span of the clip.
        self.time_span = time_span

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeSpan') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        # 
        # *   Default value: **mp4**.
        # *   Video formats include FLV, MP4, HLS (M3U8 + TS), and MPEG-DASH (MPD + fMP4).
        # *   Audio formats include MP3, MP4, Ogg, FLAC, and M4A.
        # *   Image formats include GIF and WebP.
        # *   If the container format is GIF, the video codec must be GIF.
        # *   If the container format is WebP, the video codec must be WebP.
        # *   If the container format is FLV, the video codec cannot be H.265.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the input file is stored.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark(TeaModel):
    def __init__(
        self,
        alpha: str = None,
        input_file: SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile = None,
        type: str = None,
    ):
        # The transparency of the text or image.
        # 
        # *   Value values: **(0,1]**.
        # *   Default value: **1.0**.
        self.alpha = alpha
        # The details of the input file.
        self.input_file = input_file
        # The type of the watermark. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. Valid values:
        # 
        # *   **Image** (default)
        # *   **Text**\
        self.type = type

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('InputFile') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        key_type: str = None,
        key_uri: str = None,
        skip_cnt: str = None,
        type: str = None,
    ):
        # The encryption ID.
        self.id = id
        # The key that is used to encrypt the video.
        self.key = key
        # The key encryption method. Keys cannot be transmitted to MPS in plaintext. Keys must be encrypted by using Base64 or Key Management Service (KMS). For example, if the key is encryptionkey128, you can encrypt the key by using the following method: Base64("encryptionkey128") or KMS(Base64("encryptionkey128").
        self.key_type = key_type
        # The URL that is used to request the key. The URL is Base64-encoded.
        self.key_uri = key_uri
        # The number of unencrypted frames at the beginning of the video. Leaving these frames unencrypted enables video playback to quickly start.
        self.skip_cnt = skip_cnt
        # The encryption type. Only **hls-aes-128** may be returned.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.key is not None:
            result['Key'] = self.key
        if self.key_type is not None:
            result['KeyType'] = self.key_type
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.skip_cnt is not None:
            result['SkipCnt'] = self.skip_cnt
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('KeyType') is not None:
            self.key_type = m.get('KeyType')
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('SkipCnt') is not None:
            self.skip_cnt = m.get('SkipCnt')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS(TeaModel):
    def __init__(
        self,
        md_5support: bool = None,
        size_support: bool = None,
    ):
        # Indicates whether the output of the MD5 value of the TS file is supported in the M3U8 video. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.md_5support = md_5support
        # Indicates whether the size of the TS file is generated in the output M3U8 video. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.size_support = size_support

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.md_5support is not None:
            result['Md5Support'] = self.md_5support
        if self.size_support is not None:
            result['SizeSupport'] = self.size_support
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Md5Support') is not None:
            self.md_5support = m.get('Md5Support')
        if m.get('SizeSupport') is not None:
            self.size_support = m.get('SizeSupport')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport(TeaModel):
    def __init__(
        self,
        ts: SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS = None,
    ):
        # The non-standard support configurations for TS files. The value is a JSON object. For more information, see the **TS** section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        self.ts = ts

    def validate(self):
        if self.ts:
            self.ts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['TS'] = self.ts.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TS') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS()
            self.ts = temp_model.from_map(m['TS'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge(TeaModel):
    def __init__(
        self,
        duration: str = None,
        merge_url: str = None,
        role_arn: str = None,
        start: str = None,
    ):
        # The duration of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Examples: 01:59:59.999 and 32000.23.
        self.duration = duration
        # The OSS URL of the clip.
        # 
        # *   Example: `http://example-bucket-****.oss-cn-hangzhou.aliyuncs.com/example-object-****.flv`.
        # *   The OSS URL of the object must be URL-encoded by using the UTF-8 standard.
        self.merge_url = merge_url
        # The Alibaba Cloud Resource Name (ARN) of the Resource Access Management (RAM) role used for delegated authorization.
        self.role_arn = role_arn
        # The start point in time of the clip.
        # 
        # *   Format: `hh:mm:ss[.SSS]` or `sssss[.SSS]`.
        # *   Examples: 01:59:59.999 and 32000.23.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.merge_url is not None:
            result['MergeURL'] = self.merge_url
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MergeURL') is not None:
            self.merge_url = m.get('MergeURL')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList(TeaModel):
    def __init__(
        self,
        merge: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge] = None,
    ):
        self.merge = merge

    def validate(self):
        if self.merge:
            for k in self.merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Merge'] = []
        if self.merge is not None:
            for k in self.merge:
                result['Merge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.merge = []
        if m.get('Merge') is not None:
            for k in m.get('Merge'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge()
                self.merge.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        # The color dithering algorithm of the palette. Valid values: **sierra** and **bayer**.
        self.dither_mode = dither_mode
        # The duration for which the final frame is paused. Unit: centisecond.
        self.final_delay = final_delay
        # Indicates whether a custom palette is used. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_custom_palette = is_custom_palette
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The length of the segment. The value is an integer. Unit: seconds.
        # 
        # *   Valid values: **[1,10]**.
        # *   Default value: **10**.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        # The loop count.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig(TeaModel):
    def __init__(
        self,
        gif: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif = None,
        segment: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment = None,
        webp: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp = None,
    ):
        # The transmuxing configurations for GIF.
        self.gif = gif
        # The segment configuration. The value is a JSON object.
        self.segment = segment
        # The transmuxing configurations for WebP.
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening(TeaModel):
    def __init__(
        self,
        height: str = None,
        start: str = None,
        width: str = None,
        open_url: str = None,
    ):
        # The height of the opening part.
        # 
        # *   Valid values: values in the range of **(0,4096)**, **-1**, and **full**.
        # *   Default value: **-1**.
        # *   A value of **-1** indicates that the height of the source of the opening part is retained.
        # *   A value of **full** indicates that the height of the main part is used for the opening part.
        self.height = height
        # The amount of time after which the opening part is played. The value starts from 0.
        # 
        # *   Unit: seconds.
        # *   Default value: **0**.
        self.start = start
        # The width of the opening part.
        # 
        # *   Valid values: values in the range of **(0,4096)**, **-1**, and **full**.
        # *   Default value: **-1**.
        # *   A value of **-1** indicates that the width of the source of the opening part is retained.
        # *   A value of **full** indicates that the width of the main part is used for the opening part.
        self.width = width
        # The OSS URL of the opening part.
        self.open_url = open_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.start is not None:
            result['Start'] = self.start
        if self.width is not None:
            result['Width'] = self.width
        if self.open_url is not None:
            result['openUrl'] = self.open_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('openUrl') is not None:
            self.open_url = m.get('openUrl')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList(TeaModel):
    def __init__(
        self,
        opening: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening] = None,
    ):
        self.opening = opening

    def validate(self):
        if self.opening:
            for k in self.opening:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Opening'] = []
        if self.opening is not None:
            for k in self.opening:
                result['Opening'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.opening = []
        if m.get('Opening') is not None:
            for k in m.get('Opening'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening()
                self.opening.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the output file is stored.
        self.location = location
        # The name of the OSS object that is used as the output file.
        self.object = object
        # The ARN of the RAM role used for delegated authorization.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
        message: str = None,
        out_subtitle_file: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile = None,
        success: bool = None,
    ):
        # The video track. Format: `0:{Stream}:{Stream sequence number}`, which is `0:v:{video_index}`. The value of Stream is v, which indicates a video stream. The sequence number is the index of the video stream in the list and starts from 0.
        self.map = map
        # The error message returned if the job failed to be created. This parameter is not returned if the job was created.
        self.message = message
        # The details of the output file.
        self.out_subtitle_file = out_subtitle_file
        # Indicates whether the job was created. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.out_subtitle_file:
            self.out_subtitle_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        if self.message is not None:
            result['Message'] = self.message
        if self.out_subtitle_file is not None:
            result['OutSubtitleFile'] = self.out_subtitle_file.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OutSubtitleFile') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile()
            self.out_subtitle_file = temp_model.from_map(m['OutSubtitleFile'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList(TeaModel):
    def __init__(
        self,
        out_subtitle: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle] = None,
    ):
        self.out_subtitle = out_subtitle

    def validate(self):
        if self.out_subtitle:
            for k in self.out_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OutSubtitle'] = []
        if self.out_subtitle is not None:
            for k in self.out_subtitle:
                result['OutSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.out_subtitle = []
        if m.get('OutSubtitle') is not None:
            for k in m.get('OutSubtitle'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle()
                self.out_subtitle.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the output file is stored.
        self.location = location
        # The name of the OSS object that is used as the output file.
        self.object = object
        # The ARN of the RAM role used for delegated authorization.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        # The total bitrate.
        self.bitrate = bitrate
        # The total duration.
        self.duration = duration
        # The full name of the container format.
        self.format_long_name = format_long_name
        # The short name of the container format. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format_name = format_name
        # The total number of program streams.
        self.num_programs = num_programs
        # The total number of media streams.
        self.num_streams = num_streams
        # The size of the file.
        self.size = size
        # The start time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate of the audio stream.
        self.bitrate = bitrate
        # The output layout of the sound channels.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration of the audio stream.
        self.duration = duration
        # The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
        self.index = index
        # The language of the audio stream. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata) and [ISO 639](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
        self.lang = lang
        # The total number of frames.
        self.num_frames = num_frames
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate of the audio stream.
        self.samplerate = samplerate
        # The start time of the audio stream.
        self.start_time = start_time
        # The time base of the audio stream.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        index: str = None,
        lang: str = None,
    ):
        # The sequence number of the subtitle stream. The value indicates the position of the subtitle stream in all subtitle streams.
        self.index = index
        # The language of the subtitle stream. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata) and [ISO 639](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        # The average bitrate of the video stream.
        self.avg_bitrate = avg_bitrate
        # The maximum bandwidth that was consumed.
        self.cost_bandwidth = cost_bandwidth
        # The amount of time consumed to preload the video stream.
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        dar: str = None,
        duration: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        # The average frame rate of the video stream.
        self.avg_fps = avg_fps
        # The bitrate of the video stream.
        self.bitrate = bitrate
        # The full name of the codec.
        self.codec_long_name = codec_long_name
        # The short name of the codec.
        self.codec_name = codec_name
        # The tag of the codec.
        self.codec_tag = codec_tag
        # The tag string of the codec.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The display aspect ratio (DAR) of the video stream.
        self.dar = dar
        # The duration of the video stream.
        self.duration = duration
        # The frame rate of the video stream.
        self.fps = fps
        # Indicates whether the video stream contains B-frames.
        self.has_bframes = has_bframes
        # The height of the video stream in pixels.
        self.height = height
        # The sequence number of the video stream. The value indicates the position of the video stream in all video streams.
        self.index = index
        # The language of the video stream. For more information, see [FFmpeg documentation](https://www.ffmpeg.org/ffmpeg-all.html#Metadata) and [ISO 639](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
        self.lang = lang
        # The codec level.
        self.level = level
        # The network bandwidth that was consumed.
        self.network_cost = network_cost
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format of the video stream.
        self.pix_fmt = pix_fmt
        # The codec profile.
        self.profile = profile
        # The sample aspect ratio (SAR) of the video stream.
        self.sar = sar
        # The start time of the video stream.
        self.start_time = start_time
        # The time base of the video stream.
        self.timebase = timebase
        # The width of the video stream in pixels.
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList = None,
    ):
        # The audio streams.
        self.audio_stream_list = audio_stream_list
        # The subtitle streams.
        self.subtitle_stream_list = subtitle_stream_list
        # The video streams.
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        streams: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams = None,
        width: str = None,
    ):
        # The bitrate of the video.
        self.bitrate = bitrate
        # The duration of the video.
        self.duration = duration
        # The format of the video.
        self.file_format = file_format
        # The size of the file.
        self.file_size = file_size
        # The format information.
        self.format = format
        # The frame rate of the video. The value is a number.
        self.fps = fps
        # The height of the video.
        self.height = height
        # The stream information.
        self.streams = streams
        # The width of the video.
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Streams') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the input file is stored.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle(TeaModel):
    def __init__(
        self,
        char_enc: str = None,
        font_name: str = None,
        input: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput = None,
    ):
        # The character set used by the external subtitle.
        # 
        # *   Valid values: **UTF-8**, **GBK**, **BIG5**, and **auto**.
        # *   Default value: **auto**.
        # 
        # >  If this parameter is set to **auto**, the detected character set may not be the actual character set. We recommend that you set this parameter to another value.
        self.char_enc = char_enc
        # The font of the hardcoded subtitles converted from external subtitles. Default value: **SimSun**. For more information, see [Fonts](https://help.aliyun.com/document_detail/59950.html).
        self.font_name = font_name
        # The OSS object that is used as the external subtitle. The value is a JSON object. Files in the **SRT** or **ASS** format are supported.
        self.input = input

    def validate(self):
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('Input') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput()
            self.input = temp_model.from_map(m['Input'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList(TeaModel):
    def __init__(
        self,
        ext_subtitle: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle] = None,
    ):
        self.ext_subtitle = ext_subtitle

    def validate(self):
        if self.ext_subtitle:
            for k in self.ext_subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExtSubtitle'] = []
        if self.ext_subtitle is not None:
            for k in self.ext_subtitle:
                result['ExtSubtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ext_subtitle = []
        if m.get('ExtSubtitle') is not None:
            for k in m.get('ExtSubtitle'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle()
                self.ext_subtitle.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle(TeaModel):
    def __init__(
        self,
        map: str = None,
    ):
        # The audio track. Format: `0:{Stream}:{Stream sequence number}`, which is `0:a:{audio_index}`. The value of Stream is a, which indicates an audio stream. The sequence number is the index of the audio stream in the list and starts from 0.
        self.map = map

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.map is not None:
            result['Map'] = self.map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Map') is not None:
            self.map = m.get('Map')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList(TeaModel):
    def __init__(
        self,
        subtitle: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle] = None,
    ):
        self.subtitle = subtitle

    def validate(self):
        if self.subtitle:
            for k in self.subtitle:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Subtitle'] = []
        if self.subtitle is not None:
            for k in self.subtitle:
                result['Subtitle'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle = []
        if m.get('Subtitle') is not None:
            for k in m.get('Subtitle'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle()
                self.subtitle.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig(TeaModel):
    def __init__(
        self,
        ext_subtitle_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList = None,
        subtitle_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList = None,
    ):
        # The external subtitles. The value is a JSON array that contains up to **four** objects.
        self.ext_subtitle_list = ext_subtitle_list
        # The subtitles.
        self.subtitle_list = subtitle_list

    def validate(self):
        if self.ext_subtitle_list:
            self.ext_subtitle_list.validate()
        if self.subtitle_list:
            self.subtitle_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext_subtitle_list is not None:
            result['ExtSubtitleList'] = self.ext_subtitle_list.to_map()
        if self.subtitle_list is not None:
            result['SubtitleList'] = self.subtitle_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtSubtitleList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList()
            self.ext_subtitle_list = temp_model.from_map(m['ExtSubtitleList'])
        if m.get('SubtitleList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList()
            self.subtitle_list = temp_model.from_map(m['SubtitleList'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso(TeaModel):
    def __init__(
        self,
        is_half_sample: str = None,
    ):
        # Indicates whether parameters related to the sampling rate are obtained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_half_sample = is_half_sample

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_half_sample is not None:
            result['IsHalfSample'] = self.is_half_sample
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsHalfSample') is not None:
            self.is_half_sample = m.get('IsHalfSample')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        blend_duration: str = None,
        height: str = None,
        is_merge_audio: bool = None,
        start: str = None,
        tail_url: str = None,
        width: str = None,
    ):
        # The color of the bars that are added to the ending part if the size of the ending part is smaller than that of the main part. Default value: **White**. For more information, see [Background colors](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/29253/cn_zh/1502784952344/color.txt?spm=a2c4g.11186623.2.63.241240f77qp3Yy\\&file=color.txt).
        self.bg_color = bg_color
        # The duration of the transition between the main part and the ending part. A fade transition is used: The last frame of the main part fades out, and the first frame of the ending part fades in. Unit: seconds. Default value: **0**.
        self.blend_duration = blend_duration
        # The height of the ending part.
        # 
        # *   Valid values: values in the range of **(0,4096)**, **-1**, and **full**.
        # *   A value of **-1** indicates that the height of the source of the ending part is retained. A value of **full** indicates that the height of the main part is used for the ending part.
        # *   Default value: -1.
        self.height = height
        # Indicates whether the audio content of the ending part is merged. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_merge_audio = is_merge_audio
        # The start time.
        self.start = start
        # The OSS URL of the ending part.
        self.tail_url = tail_url
        # The width of the ending part.
        # 
        # *   Valid values: values in the range of **(0,4096)**, **-1**, and **full**.
        # *   A value of **-1** indicates that the width of the source of the ending part is retained. A value of **full** indicates that the width of the main part is used for the ending part.
        # *   Default value: -1.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.blend_duration is not None:
            result['BlendDuration'] = self.blend_duration
        if self.height is not None:
            result['Height'] = self.height
        if self.is_merge_audio is not None:
            result['IsMergeAudio'] = self.is_merge_audio
        if self.start is not None:
            result['Start'] = self.start
        if self.tail_url is not None:
            result['TailUrl'] = self.tail_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BlendDuration') is not None:
            self.blend_duration = m.get('BlendDuration')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('IsMergeAudio') is not None:
            self.is_merge_audio = m.get('IsMergeAudio')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('TailUrl') is not None:
            self.tail_url = m.get('TailUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList(TeaModel):
    def __init__(
        self,
        tail_slate: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate] = None,
    ):
        self.tail_slate = tail_slate

    def validate(self):
        if self.tail_slate:
            for k in self.tail_slate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TailSlate'] = []
        if self.tail_slate is not None:
            for k in self.tail_slate:
                result['TailSlate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tail_slate = []
        if m.get('TailSlate') is not None:
            for k in m.get('TailSlate'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate()
                self.tail_slate.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # The method of resolution adjustment. Default value: **none**. Valid values:
        # 
        # *   rescale: The video image is resized.
        # *   crop: The video image is cropped.
        # *   pad: The video image is scaled out to fill the view.
        # *   none: The resolution is not adjusted.
        self.adj_dar_method = adj_dar_method
        # Indicates whether the audio bitrate is checked. If the bitrate of the output audio is higher than that of the input audio, the input bitrate is retained and the specified audio bitrate does not take effect. This parameter has a lower priority than IsCheckAudioBitrateFail. Valid values:
        # 
        # *   **true**\
        # 
        # *   **false**\
        # 
        # *   Default value:
        # 
        #     *   If this parameter is empty and the codec of the output audio is different from the codec of the input audio, the default value is false.
        #     *   If this parameter is empty and the codec of the output audio is the same as the codec of the input audio, the default value is true.
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # Indicates whether the audio bitrate is checked. This parameter has a higher priority than **IsCheckAudioBitrate**. If the bitrate of the output audio is higher than that of the input audio, a transcoding failure is returned without transcoding the audio. Valid values:
        # 
        # *   **false**\
        # *   **true**\
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, the input resolution is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso = is_check_reso
        # Indicates whether the resolution is checked. This parameter has a higher priority than IsCheckReso. If the output resolution is higher than the input resolution based on the width or height, a transcoding failure is returned without transcoding the video. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the video bitrate is checked. If the bitrate of the output video is higher than that of the input video, the input bitrate is retained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_video_bitrate = is_check_video_bitrate
        # Indicates whether the video bitrate is checked. If the bitrate of the output video is higher than that of the input video, a transcoding failure is returned without transcoding the video. This parameter has a higher priority than**IsCheckVideoBitrate**. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # *   Default value: **false**.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # The transcoding mode. Valid values:
        # 
        # *   **onepass**: transcoding based on one-pass algorithms, which has higher accuracy.
        # *   **twopass**: transcoding based on two-pass algorithms, which has lower accuracy.
        # *   **CBR**: transcoding based on a fixed bitrate.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The upper limit of the total bitrate. Unit: Kbit/s.
        self.max = max
        # The lower limit of the total bitrate. Unit: Kbit/s.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        height: str = None,
        max_fps: str = None,
        maxrate: str = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The bitrate of the output video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The average bitrate range of the video.
        self.bitrate_bnd = bitrate_bnd
        # The size of the buffer.
        # 
        # *   Unit: KB.
        # *   Default value: **6000**.
        self.bufsize = bufsize
        # The video codec.
        # 
        # *   Valid values: **H.264**, **H.265**, **GIF**, and **WEBP**.
        # *   Default value: **H.264**.
        self.codec = codec
        # The constant rate factor.
        # 
        # *   If **Crf** is returned, the value of **Bitrate** is invalid.
        # *   Default value if the value of Codec is H.264: **23**. Default value if the value of Codec is H.265: **26**.
        self.crf = crf
        # The method of video cropping. Valid values:
        # 
        # *   **border**: Black borders are automatically detected and removed.
        # *   A value in the format of width:height:left:top: The video is cropped based on the custom settings.
        self.crop = crop
        # The strength of the independent noise reduction algorithm.
        self.degrain = degrain
        # The frame rate.
        # 
        # *   Unit: frames per second.
        # *   Valid values: 0 to 60. The value is 60 if the frame rate of the input file exceeds 60.
        # *   Default value: the frame rate of the input file.
        self.fps = fps
        # The maximum interval between keyframes or the maximum number of frames in a frame group. Unit: seconds.
        # 
        # *   Default value: 10.
        # *   If the maximum number of frames is returned, the value does not have a unit.
        self.gop = gop
        # The height of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: the height of the input video.
        self.height = height
        # The maximum frame rate.
        self.max_fps = max_fps
        # The maximum bitrate of the video. Unit: Kbit/s.
        self.maxrate = maxrate
        # The black borders that are added to the video.
        # 
        # *   The value is in the width:height:left:top format.
        # *   Unit: pixel.
        self.pad = pad
        # The pixel format of the video.
        # 
        # *   The default pixel format can be **yuv420p** or the pixel format of the input file.
        # 
        # *   Valid values: standard pixel formats such as **yuv420p** and **yuvj420p**.
        # 
        #     **\
        # 
        #     **Note** If a non-standard pixel format such as yuvj420p(pc, bt470bg/bt470bg/smpte170m) is used, compatibility with the pixel format must be configured. Otherwise, the transcoding job fails.
        self.pix_fmt = pix_fmt
        # The preset video algorithm. Default value: **medium**. Valid values:
        # 
        # *   **veryfast**\
        # *   **fast**\
        # *   **medium**\
        # *   **slow**\
        # *   **slower**\
        self.preset = preset
        # The encoding profile. This parameter is returned only for the H.264 codec. Default value: **high**. Valid values:
        # 
        # >  If multiple definitions are involved, we recommend that you use baseline for the lowest definition to ensure normal playback on low-definition devices, and use main or high for other definitions.
        # 
        # *   **baseline**: applicable to mobile devices.
        # *   **main**: applicable to standard-definition devices.
        # *   **high**: applicable to high-definition devices.
        self.profile = profile
        # The level of quality control on the video.
        self.qscale = qscale
        # The priority of the resource.
        self.reso_priority = reso_priority
        # The scan mode. Valid values:
        # 
        # *   If this parameter is **empty**, the scan mode of the input file is used.
        # *   **auto**: automatic deinterlacing.
        # *   **progressive**: progressive scan.
        # *   **interlaced**: interlaced scan.
        # *   **By default**, this parameter is empty.
        # 
        # **Best practice**: Interlaced scan consumes less bandwidth than progressive scan, but the image quality is poor. Therefore, mainstream video production uses progressive scan.
        # 
        # *   If **progressive scan** or **interlaced scan** is used when the scan mode of the input file is neither of them, the transcoding job fails.
        # *   We recommend that you use **the scan mode of the input file** or **automatic deinterlacing** to improve compatibility.
        self.scan_mode = scan_mode
        # The width of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: **the width of the input video**.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input file is stored.
        self.bucket = bucket
        # The ID of the OSS region in which the input file is stored.
        self.location = location
        # The name of the OSS object that is used as the input file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        input_file: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile = None,
        refer_pos: str = None,
        type: str = None,
        water_mark_template_id: str = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark image relative to the output video. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. Default value: 0. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the horizontal offset.
        # 
        #     *   Valid values: **[8,4096]**.
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the horizontal offset to the width in the output video resolution.
        # 
        #     *   Valid values: (0,1).
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excess digits are automatically deleted.
        self.dx = dx
        # The vertical offset of the watermark image relative to the output video. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the vertical offset.
        # 
        #     *   Valid values: **[8,4096]**.
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the vertical offset to the height in the output video resolution.
        # 
        #     *   Valid values: **(0,1)**.
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excess digits are automatically deleted.
        self.dy = dy
        # The height of the watermark. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the watermark height.
        # 
        #     *   Valid values: **[8,4096]**.
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the watermark height to the height in the output video resolution.
        # 
        #     *   Valid values: **(0,1)**.
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excess digits are automatically deleted.
        self.height = height
        # The watermark input file. PNG images and MOV files are supported.
        self.input_file = input_file
        # The position of the watermark. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. Valid values:
        # 
        # *   **TopRight**\
        # *   **TopLeft**\
        # *   **BottomRight**\
        # *   **BottomLeft**\
        self.refer_pos = refer_pos
        # The type of the watermark. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html). Valid values:
        # 
        # *   **Image**\
        # *   **Text**\
        self.type = type
        # The ID of the watermark template.
        self.water_mark_template_id = water_mark_template_id
        # The width of the watermark image. If this parameter is specified in the request, the corresponding parameter in the watermark template is overwritten. The value can be an integer or a decimal number.
        # 
        # *   An integer indicates the pixel value of the watermark width.
        # 
        #     *   Valid values: **[8,4096]**.
        #     *   Unit: pixel.
        # 
        # *   A decimal number indicates the ratio of the watermark width to the width in the output video resolution.
        # 
        #     *   Valid values: **(0,1)**.
        #     *   The decimal number can be accurate to four decimal places, such as 0.9999. Excess digits are automatically deleted.
        self.width = width

    def validate(self):
        if self.input_file:
            self.input_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.input_file is not None:
            result['InputFile'] = self.input_file.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.type is not None:
            result['Type'] = self.type
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('InputFile') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile()
            self.input_file = temp_model.from_map(m['InputFile'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList(TeaModel):
    def __init__(
        self,
        water_mark: List[SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark] = None,
    ):
        self.water_mark = water_mark

    def validate(self):
        if self.water_mark:
            for k in self.water_mark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WaterMark'] = []
        if self.water_mark is not None:
            for k in self.water_mark:
                result['WaterMark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.water_mark = []
        if m.get('WaterMark') is not None:
            for k in m.get('WaterMark'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark()
                self.water_mark.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBodyJobResultListJobResultJobOutput(TeaModel):
    def __init__(
        self,
        amix_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList = None,
        audio: SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio = None,
        audio_stream_map: str = None,
        clip: SubmitJobsResponseBodyJobResultListJobResultJobOutputClip = None,
        container: SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer = None,
        de_watermark: str = None,
        digi_water_mark: SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark = None,
        encryption: SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption = None,
        m_3u8non_standard_support: SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport = None,
        merge_config_url: str = None,
        merge_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList = None,
        mux_config: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig = None,
        opening_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList = None,
        out_subtitle_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList = None,
        output_file: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile = None,
        priority: str = None,
        properties: SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties = None,
        rotate: str = None,
        subtitle_config: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig = None,
        super_reso: SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso = None,
        tail_slate_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList = None,
        template_id: str = None,
        trans_config: SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig = None,
        user_data: str = None,
        video: SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo = None,
        video_stream_map: str = None,
        water_mark_config_url: str = None,
        water_mark_list: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList = None,
    ):
        # The audio tracks that are mixed.
        self.amix_list = amix_list
        # The audio configurations.
        # 
        # >  If this parameter is specified in the request, the corresponding configurations in the specified transcoding template are overwritten.
        self.audio = audio
        # The sequence number of the audio stream.
        # 
        # *   Format: 0:a:{Sequence number}. Example: 0:a:0.
        # *   The sequence number is the index of the audio stream in the list and starts from 0.
        # *   If no sequence number is specified, the default audio stream is used.
        self.audio_stream_map = audio_stream_map
        # The information about the clip.
        self.clip = clip
        # The container format configurations.
        self.container = container
        # The configurations of watermark blurring. The value is a JSON object. For more information, see the **DeWatermark** section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        self.de_watermark = de_watermark
        # The digital watermarks.
        self.digi_water_mark = digi_water_mark
        # The encryption configurations. Only outputs in the M3U8 format are supported.
        self.encryption = encryption
        # The non-standard support configuration for M3U8. The value is a JSON object. For more information, see the **M3U8NonStandardSupport** section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        self.m_3u8non_standard_support = m_3u8non_standard_support
        # The URL of the merging configuration file. Only one of **MergeList** and **MergeConfigUrl** takes effect.
        # 
        # *   The configuration file specified by MergeConfigUrl can contain up to 50 clips.
        # *   MergeConfigUrl indicates the URL of the configuration file for merging clips.
        # *   Make sure that the configuration file is stored as an object in OSS and that MPS can access the OSS object. For information about the file content, see the details about merging parameters.
        # *   Example of the content of the merging configuration file: `{"MergeList":[{"MergeURL":"http://exampleBucket****.oss-cn-hangzhou.aliyuncs.com/video_01.mp4"}]}`.
        self.merge_config_url = merge_config_url
        # The configurations for merging clips.
        self.merge_list = merge_list
        # The transmuxing configurations. If this parameter is specified in the request, the corresponding configurations in the specified transcoding template are overwritten.
        self.mux_config = mux_config
        # The opening parts. The value is a JSON object.
        self.opening_list = opening_list
        # The output subtitles.
        self.out_subtitle_list = out_subtitle_list
        # The details of the output file.
        self.output_file = output_file
        # The priority of the job in the MPS queue to which the job is added.
        # 
        # *   A value of **10** indicates the highest priority.
        # *   Default value: **6**.
        self.priority = priority
        # The media properties.
        self.properties = properties
        # The rotation angle of the video, in the clockwise direction.
        self.rotate = rotate
        # The subtitle configurations.
        self.subtitle_config = subtitle_config
        # The configurations for using the resolution of the source video.
        self.super_reso = super_reso
        # The ending parts. The value is a JSON object.
        self.tail_slate_list = tail_slate_list
        # The ID of the transcoding template.
        self.template_id = template_id
        # The general transcoding configurations.
        # 
        # >  If this parameter is specified in the request, the corresponding parameter in the specified transcoding template are overwritten.
        self.trans_config = trans_config
        # The custom data.
        self.user_data = user_data
        # The video configurations.
        # 
        # >  If this parameter is specified, **AliyunVideoCodec** in the template specified by **TemplateId** is overwritten.
        self.video = video
        # The sequence number of the video stream.
        # 
        # *   Format: 0:a:{Sequence number}. Example: 0:a:0.
        # *   The sequence number is the index of the video stream in the list and starts from 0.
        # *   If no sequence number is specified, the default video stream is used.
        self.video_stream_map = video_stream_map
        # The URL of the watermark configuration file.
        self.water_mark_config_url = water_mark_config_url
        # The watermarks.
        # 
        # >  If watermarks are truncated or fail to be generated, check whether the text watermarks that you add contain special characters. If the text watermarks contain special characters, you must escape the special characters before you add the watermarks. Alternatively, you can [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12246746.top-nav.dticket.68797bbcm8H408#/ticket/add/?productId=1232) to contact Alibaba Cloud customer service for compatibility processing.
        self.water_mark_list = water_mark_list

    def validate(self):
        if self.amix_list:
            self.amix_list.validate()
        if self.audio:
            self.audio.validate()
        if self.clip:
            self.clip.validate()
        if self.container:
            self.container.validate()
        if self.digi_water_mark:
            self.digi_water_mark.validate()
        if self.encryption:
            self.encryption.validate()
        if self.m_3u8non_standard_support:
            self.m_3u8non_standard_support.validate()
        if self.merge_list:
            self.merge_list.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.opening_list:
            self.opening_list.validate()
        if self.out_subtitle_list:
            self.out_subtitle_list.validate()
        if self.output_file:
            self.output_file.validate()
        if self.properties:
            self.properties.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()
        if self.super_reso:
            self.super_reso.validate()
        if self.tail_slate_list:
            self.tail_slate_list.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()
        if self.water_mark_list:
            self.water_mark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amix_list is not None:
            result['AmixList'] = self.amix_list.to_map()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.audio_stream_map is not None:
            result['AudioStreamMap'] = self.audio_stream_map
        if self.clip is not None:
            result['Clip'] = self.clip.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.de_watermark is not None:
            result['DeWatermark'] = self.de_watermark
        if self.digi_water_mark is not None:
            result['DigiWaterMark'] = self.digi_water_mark.to_map()
        if self.encryption is not None:
            result['Encryption'] = self.encryption.to_map()
        if self.m_3u8non_standard_support is not None:
            result['M3U8NonStandardSupport'] = self.m_3u8non_standard_support.to_map()
        if self.merge_config_url is not None:
            result['MergeConfigUrl'] = self.merge_config_url
        if self.merge_list is not None:
            result['MergeList'] = self.merge_list.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.opening_list is not None:
            result['OpeningList'] = self.opening_list.to_map()
        if self.out_subtitle_list is not None:
            result['OutSubtitleList'] = self.out_subtitle_list.to_map()
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.subtitle_config is not None:
            result['SubtitleConfig'] = self.subtitle_config.to_map()
        if self.super_reso is not None:
            result['SuperReso'] = self.super_reso.to_map()
        if self.tail_slate_list is not None:
            result['TailSlateList'] = self.tail_slate_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video is not None:
            result['Video'] = self.video.to_map()
        if self.video_stream_map is not None:
            result['VideoStreamMap'] = self.video_stream_map
        if self.water_mark_config_url is not None:
            result['WaterMarkConfigUrl'] = self.water_mark_config_url
        if self.water_mark_list is not None:
            result['WaterMarkList'] = self.water_mark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AmixList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList()
            self.amix_list = temp_model.from_map(m['AmixList'])
        if m.get('Audio') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('AudioStreamMap') is not None:
            self.audio_stream_map = m.get('AudioStreamMap')
        if m.get('Clip') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputClip()
            self.clip = temp_model.from_map(m['Clip'])
        if m.get('Container') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('DeWatermark') is not None:
            self.de_watermark = m.get('DeWatermark')
        if m.get('DigiWaterMark') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark()
            self.digi_water_mark = temp_model.from_map(m['DigiWaterMark'])
        if m.get('Encryption') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption()
            self.encryption = temp_model.from_map(m['Encryption'])
        if m.get('M3U8NonStandardSupport') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport()
            self.m_3u8non_standard_support = temp_model.from_map(m['M3U8NonStandardSupport'])
        if m.get('MergeConfigUrl') is not None:
            self.merge_config_url = m.get('MergeConfigUrl')
        if m.get('MergeList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList()
            self.merge_list = temp_model.from_map(m['MergeList'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('OpeningList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList()
            self.opening_list = temp_model.from_map(m['OpeningList'])
        if m.get('OutSubtitleList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList()
            self.out_subtitle_list = temp_model.from_map(m['OutSubtitleList'])
        if m.get('OutputFile') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Properties') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('SubtitleConfig') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['SubtitleConfig'])
        if m.get('SuperReso') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso()
            self.super_reso = temp_model.from_map(m['SuperReso'])
        if m.get('TailSlateList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList()
            self.tail_slate_list = temp_model.from_map(m['TailSlateList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('Video') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo()
            self.video = temp_model.from_map(m['Video'])
        if m.get('VideoStreamMap') is not None:
            self.video_stream_map = m.get('VideoStreamMap')
        if m.get('WaterMarkConfigUrl') is not None:
            self.water_mark_config_url = m.get('WaterMarkConfigUrl')
        if m.get('WaterMarkList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList()
            self.water_mark_list = temp_model.from_map(m['WaterMarkList'])
        return self


class SubmitJobsResponseBodyJobResultListJobResultJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        creation_time: str = None,
        finish_time: str = None,
        input: SubmitJobsResponseBodyJobResultListJobResultJobInput = None,
        job_id: str = None,
        mnsmessage_result: SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult = None,
        message: str = None,
        output: SubmitJobsResponseBodyJobResultListJobResultJobOutput = None,
        percent: int = None,
        pipeline_id: str = None,
        state: str = None,
    ):
        # The error code returned if the job failed. This parameter is not returned if the job was successful.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The time when the job was complete.
        self.finish_time = finish_time
        # The information about the job input.
        self.input = input
        # The job ID.
        self.job_id = job_id
        # The message sent by MNS to notify users of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the job failed. This parameter is not returned if the job was successful.
        self.message = message
        # The output of the job.
        self.output = output
        # The transcoding progress.
        self.percent = percent
        # The ID of the MPS queue.
        self.pipeline_id = pipeline_id
        # The state of the job. Valid values:
        # 
        # *   **Submitted**\
        # *   **TranscodeFail**\
        self.state = state

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Output') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SubmitJobsResponseBodyJobResultListJobResult(TeaModel):
    def __init__(
        self,
        code: str = None,
        job: SubmitJobsResponseBodyJobResultListJobResultJob = None,
        message: str = None,
        success: bool = None,
    ):
        # The error code returned if the job failed to be created. This parameter is not returned if the job was created.
        self.code = code
        # The details of the job. If the job fails to be submitted, no job ID is generated.
        self.job = job
        # The error message returned if the job failed to be created. This parameter is not returned if the job was created.
        self.message = message
        # Indicates whether the job was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.job:
            self.job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.job is not None:
            result['Job'] = self.job.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Job') is not None:
            temp_model = SubmitJobsResponseBodyJobResultListJobResultJob()
            self.job = temp_model.from_map(m['Job'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitJobsResponseBodyJobResultList(TeaModel):
    def __init__(
        self,
        job_result: List[SubmitJobsResponseBodyJobResultListJobResult] = None,
    ):
        self.job_result = job_result

    def validate(self):
        if self.job_result:
            for k in self.job_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobResult'] = []
        if self.job_result is not None:
            for k in self.job_result:
                result['JobResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_result = []
        if m.get('JobResult') is not None:
            for k in m.get('JobResult'):
                temp_model = SubmitJobsResponseBodyJobResultListJobResult()
                self.job_result.append(temp_model.from_map(k))
        return self


class SubmitJobsResponseBody(TeaModel):
    def __init__(
        self,
        job_result_list: SubmitJobsResponseBodyJobResultList = None,
        request_id: str = None,
    ):
        # The transcoding jobs that are generated.
        self.job_result_list = job_result_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.job_result_list:
            self.job_result_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_result_list is not None:
            result['JobResultList'] = self.job_result_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobResultList') is not None:
            temp_model = SubmitJobsResponseBodyJobResultList()
            self.job_result_list = temp_model.from_map(m['JobResultList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaCensorJobRequest(TeaModel):
    def __init__(
        self,
        barrages: str = None,
        cover_images: str = None,
        description: str = None,
        external_url: str = None,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        title: str = None,
        user_data: str = None,
        video_censor_config: str = None,
    ):
        # The live comments.
        self.barrages = barrages
        # The OSS URL of the image file that is used as the thumbnail. To view the OSS URL of the image file, you can log on to the **MPS console** and choose **Media Management** > **Media List** in the left-side navigation pane. You can specify up to five thumbnails in a JSON array.
        # 
        # *   Bucket: the name of the OSS bucket that stores the input file.
        # 
        # *   Location: the OSS region. The OSS region must be the same as the region in which your MPS service is activated.
        # 
        # *   Object: the OSS object to be moderated.
        # 
        #     **\
        # 
        #     **Note**The name of the object cannot start with a forward slash (/). Otherwise, the operation fails to be called.
        self.cover_images = cover_images
        # The description of the video. The value can be up to 128 bytes in size.
        self.description = description
        # The URL of the video.
        self.external_url = external_url
        # The Object Storage Service (OSS) URL of the media file to be moderated. To view the OSS URL of the media file, you can log on to the **MPS console** and choose **Media Management** > **Media List** in the left-side navigation pane. To moderate an image file, use the `CoverImage` parameter to specify the OSS URL of the image file. The value is a JSON object. For more information, see the "Input" section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        # 
        # *   Bucket: the name of the OSS bucket that stores the input file.
        # 
        # *   Location: the OSS region. The OSS region must be the same as the region in which your MPS service is activated.
        # 
        # *   Object: the OSS object to be moderated.
        # 
        #     **\
        # 
        #     **Note**The name of the object cannot start with a forward slash (/). Otherwise, the operation fails to be called.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue. This ID can be used to associate the job with a notification method. To view the ID of the MPS queue, you can log on to the **MPS console** and choose **Global Settings** > **Pipelines** in the left-side navigation pane. An empty string ("") indicates that the default MPS queue is used to run the job. By default, an MPS queue can process a maximum of 10 concurrent content moderation jobs. To increase the limit, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12246746.top-nav.ditem-sub.35da7bbcitpQnr#/ticket/createIndex).
        # 
        # > MPS queues are automatically created by the system. For more information about how to query and update MPS queues, see the [UpdatePipeline](https://help.aliyun.com/document_detail/188374.html) topic.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The title of the video. The value can be up to 64 bytes in size.
        self.title = title
        # The custom data. The value can be up to 128 bytes in size.
        self.user_data = user_data
        # The video moderation configurations and the OSS URLs of the output snapshots. To view the OSS URL of the media file, you can log on to the **MPS console** and choose **Media Management** > **Media List** in the left-side navigation pane.
        # 
        # The value is a JSON object.
        # 
        # *   OutputFile:
        # 
        #     *   Bucket: the name of the OSS bucket that stores the output file.
        #     *   Location: the OSS region. The OSS region must be the same as the region in which your MPS service is activated.
        #     *   Object: the OSS object to be generated. In the value, {Count} indicates the sequence number of the frame snapshot.
        # 
        # *   StoreVideoTimeline: specifies whether to generate the `{jobId}.video_timeline` file. The file is stored in OSS. A value of true indicates that the file is generated. A value of false indicates that the file is not generated. If you do not specify this parameter, the file is not generated by default. For more information about the format of the file, see the "VideoTimelines" parameter in the [QueryMediaCensorJobDetail](https://help.aliyun.com/document_detail/91779.html) topic.
        # 
        # *   SaveType: the output mode. A value of abnormal indicates that snapshots are generated only for illegal frames. A value of all indicates that snapshots are generated for all frames.
        # 
        # *   Biztype: the moderation template. If you do not specify this parameter or set the value to common, the default template is used. You can submit a ticket to create a custom moderation template. Then, set this parameter to your user ID to use the custom moderation template.
        # 
        # *   Scenes: the moderation scenarios. You can specify the moderation scenarios that you want to use. If you do not specify this parameter, the terrorism and porn moderation scenarios are used by default. Valid values:
        # 
        #     *   porn: pornographic content detection
        #     *   terrorism: terrorist content detection
        #     *   ad: ad violation detection
        #     *   live: undesirable scene detection
        #     *   logo: special logo detection
        #     *   audio: audio anti-spam
        # 
        # > If the input file contains audio tracks and the audio moderation scenario is specified, the audio tracks are moderated. If the input file does not contain audio tracks, you do not need to specify the audio moderation scenario.
        # 
        # This parameter is required.
        self.video_censor_config = video_censor_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrages is not None:
            result['Barrages'] = self.barrages
        if self.cover_images is not None:
            result['CoverImages'] = self.cover_images
        if self.description is not None:
            result['Description'] = self.description
        if self.external_url is not None:
            result['ExternalUrl'] = self.external_url
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.video_censor_config is not None:
            result['VideoCensorConfig'] = self.video_censor_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Barrages') is not None:
            self.barrages = m.get('Barrages')
        if m.get('CoverImages') is not None:
            self.cover_images = m.get('CoverImages')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExternalUrl') is not None:
            self.external_url = m.get('ExternalUrl')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VideoCensorConfig') is not None:
            self.video_censor_config = m.get('VideoCensorConfig')
        return self


class SubmitMediaCensorJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the content moderation job. We recommend that you keep this ID for subsequent operation calls.
        self.job_id = job_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaCensorJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitMediaCensorJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaCensorJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaInfoJobRequest(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        config: str = None,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        user_data: str = None,
    ):
        # Specifies whether to enable the asynchronous mode for the job. We recommend that you set this parameter to true. Valid values:
        # 
        # *   **true**: enables the asynchronous mode.
        # *   **false**: does not enable the asynchronous mode.
        self.async_ = async_
        self.config = config
        # The information about the input media file. The value is a JSON string. You must perform the following operations to add the OSS bucket in which the input media file is stored as a media bucket: Log on to the **MPS console**, choose **Workflows** > **Media Buckets** in the left-side navigation pane, and then click **Add Bucket**. After you add the OSS bucket as a media bucket, you must perform URL encoding for the OSS object. For example, `{"Bucket":"example-bucket","Location":"example-location","Object":"example%2Fexample.flv"}` indicates the `example-bucket.example-location.aliyuncs.com/example/example.flv` file.
        # 
        # > The OSS bucket must reside in the same region as your MPS service.
        # 
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue to which the job was submitted. For more information, see [Terms](https://help.aliyun.com/document_detail/29197.html).
        # 
        # *   To view the ID of the MPS queue, log on to the [MPS console](https://mps.console.aliyun.com/overview) and choose **Global Settings** > **MPS queue and Callback** in the left-side navigation pane. On the MPS queue and Callback page, you can view the ID of an MPS queue or create an MPS queue.
        # *   If you want to receive asynchronous message notifications, associate an MNS queue or topic with the MPS queue. For more information, see [Receive message notifications](https://www.alibabacloud.com/help/en/mps/receive-message-notifications/?spm=a2c63.p38356.0.0.b48576d2jxNSca).
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The custom data. The custom data can contain letters, digits, and hyphens (-), and can be up to 1,024 bytes in length. The custom data cannot start with a special character.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.config is not None:
            result['Config'] = self.config
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
    ):
        # The name of the OSS bucket in which the input media file is stored.
        self.bucket = bucket
        # The region in which the OSS bucket that stores the input media file resides.
        self.location = location
        # The name of the OSS object that is used as the input media file.
        self.object = object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code that is returned if the job fails. This parameter is not returned if the job is successful.
        self.error_code = error_code
        # The error message that is returned if the job fails. This parameter is not returned if the job is successful.
        self.error_message = error_message
        # The ID of the message that is returned if the job is successful. This parameter is not returned if the job fails.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        format_long_name: str = None,
        format_name: str = None,
        num_programs: str = None,
        num_streams: str = None,
        size: str = None,
        start_time: str = None,
    ):
        # The total bitrate. Unit: Kbit/s.
        self.bitrate = bitrate
        # The duration of the input media file. Unit: seconds.
        self.duration = duration
        # The full name of the container format.
        self.format_long_name = format_long_name
        # The short name of the container format. For more information about the parameters, see [Parameter details](https://help.aliyun.com/document_detail/29253.html).
        self.format_name = format_name
        # The total number of program streams.
        self.num_programs = num_programs
        # The total number of media streams.
        self.num_streams = num_streams
        # The size of the file. Unit: bytes.
        self.size = size
        # The start time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.format_long_name is not None:
            result['FormatLongName'] = self.format_long_name
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.num_programs is not None:
            result['NumPrograms'] = self.num_programs
        if self.num_streams is not None:
            result['NumStreams'] = self.num_streams
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FormatLongName') is not None:
            self.format_long_name = m.get('FormatLongName')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('NumPrograms') is not None:
            self.num_programs = m.get('NumPrograms')
        if m.get('NumStreams') is not None:
            self.num_streams = m.get('NumStreams')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channel_layout: str = None,
        channels: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        duration_inaccurate: str = None,
        index: str = None,
        lang: str = None,
        num_frames: str = None,
        sample_fmt: str = None,
        samplerate: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The bitrate. Unit: Kbit/s.
        self.bitrate = bitrate
        # The output layout of the sound channels.
        self.channel_layout = channel_layout
        # The number of sound channels.
        self.channels = channels
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Default value: acc. Valid values:
        # 
        # *   **acc**\
        # *   **mp3**\
        # *   **mp4**\
        # *   **ogg**\
        # *   **flac**\
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration of the audio stream. Unit: seconds.
        self.duration = duration
        self.duration_inaccurate = duration_inaccurate
        # The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
        self.index = index
        # The language.
        self.lang = lang
        # The total number of frames.
        self.num_frames = num_frames
        # The sampling format.
        self.sample_fmt = sample_fmt
        # The sampling rate. Unit: Hz.
        self.samplerate = samplerate
        # The start time of the audio stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.duration_inaccurate is not None:
            result['DurationInaccurate'] = self.duration_inaccurate
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('DurationInaccurate') is not None:
            self.duration_inaccurate = m.get('DurationInaccurate')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList(TeaModel):
    def __init__(
        self,
        audio_stream: List[SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream] = None,
    ):
        self.audio_stream = audio_stream

    def validate(self):
        if self.audio_stream:
            for k in self.audio_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStream'] = []
        if self.audio_stream is not None:
            for k in self.audio_stream:
                result['AudioStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stream = []
        if m.get('AudioStream') is not None:
            for k in m.get('AudioStream'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream()
                self.audio_stream.append(temp_model.from_map(k))
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(TeaModel):
    def __init__(
        self,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        duration: str = None,
        index: str = None,
        lang: str = None,
        start_time: str = None,
        timebase: str = None,
    ):
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values:
        # 
        # *   **srt**\
        # *   **ass**\
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The duration of the audio stream. Unit: seconds.
        self.duration = duration
        # The sequence number of the subtitle stream. The value indicates the position of the subtitle stream in all subtitle streams.
        self.index = index
        # The language.
        self.lang = lang
        # The start time of the subtitle stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList(TeaModel):
    def __init__(
        self,
        subtitle_stream: List[SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream] = None,
    ):
        self.subtitle_stream = subtitle_stream

    def validate(self):
        if self.subtitle_stream:
            for k in self.subtitle_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleStream'] = []
        if self.subtitle_stream is not None:
            for k in self.subtitle_stream:
                result['SubtitleStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_stream = []
        if m.get('SubtitleStream') is not None:
            for k in m.get('SubtitleStream'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream()
                self.subtitle_stream.append(temp_model.from_map(k))
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(TeaModel):
    def __init__(
        self,
        avg_bitrate: str = None,
        cost_bandwidth: str = None,
        preload_time: str = None,
    ):
        # The average bitrate. Unit: Kbit/s.
        self.avg_bitrate = avg_bitrate
        # The maximum bandwidth that is consumed.
        self.cost_bandwidth = cost_bandwidth
        # The time consumed to preload the video.
        self.preload_time = preload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_bitrate is not None:
            result['AvgBitrate'] = self.avg_bitrate
        if self.cost_bandwidth is not None:
            result['CostBandwidth'] = self.cost_bandwidth
        if self.preload_time is not None:
            result['PreloadTime'] = self.preload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgBitrate') is not None:
            self.avg_bitrate = m.get('AvgBitrate')
        if m.get('CostBandwidth') is not None:
            self.cost_bandwidth = m.get('CostBandwidth')
        if m.get('PreloadTime') is not None:
            self.preload_time = m.get('PreloadTime')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(TeaModel):
    def __init__(
        self,
        avg_fps: str = None,
        bitrate: str = None,
        codec_long_name: str = None,
        codec_name: str = None,
        codec_tag: str = None,
        codec_tag_string: str = None,
        codec_time_base: str = None,
        color_primaries: str = None,
        color_range: str = None,
        color_transfer: str = None,
        dar: str = None,
        duration: str = None,
        duration_inaccurate: str = None,
        fps: str = None,
        has_bframes: str = None,
        height: str = None,
        index: str = None,
        lang: str = None,
        level: str = None,
        network_cost: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost = None,
        num_frames: str = None,
        pix_fmt: str = None,
        profile: str = None,
        rotate: str = None,
        sar: str = None,
        start_time: str = None,
        timebase: str = None,
        width: str = None,
    ):
        # The average frame rate.
        self.avg_fps = avg_fps
        # The bitrate. Unit: Kbit/s.
        self.bitrate = bitrate
        # The full name of the encoding format.
        self.codec_long_name = codec_long_name
        # The short name of the encoding format. Valid values:
        # 
        # *   **h264**\
        # *   **h265**\
        # *   **gif**\
        # *   **webp**\
        self.codec_name = codec_name
        # The tag of the encoding format.
        self.codec_tag = codec_tag
        # The tag string of the encoding format.
        self.codec_tag_string = codec_tag_string
        # The codec time base.
        self.codec_time_base = codec_time_base
        # The level of color reconstruction.
        self.color_primaries = color_primaries
        # The color range.
        self.color_range = color_range
        # The color channel.
        self.color_transfer = color_transfer
        # The display aspect ratio (DAR). DAR is the proportional relationship between the width and the height of a video. The value is used to determine whether the video is in portrait mode or landscape mode.
        self.dar = dar
        # The duration of the video stream. Unit: seconds.
        self.duration = duration
        self.duration_inaccurate = duration_inaccurate
        # The frame rate.
        self.fps = fps
        # Indicates whether the video stream contains bidirectional frames (B-frames). A value of 1 indicates that the video stream contains B-frames. A value of 0 indicates that the video stream does not contain B-frames.
        self.has_bframes = has_bframes
        # The height of the video. Unit: pixel.
        self.height = height
        # The sequence number of the video stream. The value indicates the position of the video stream in all video streams. The sequence number of the first video stream to be played can be specified in some players. Default value: 1.
        self.index = index
        # The language.
        self.lang = lang
        # The codec level.
        self.level = level
        # The network bandwidth that is consumed.
        self.network_cost = network_cost
        # The total number of frames.
        self.num_frames = num_frames
        # The pixel format.
        self.pix_fmt = pix_fmt
        # The codec profile.
        self.profile = profile
        # The rotation angle of the video.
        self.rotate = rotate
        # The sample aspect ratio (SAR).
        self.sar = sar
        # The start time of the video stream.
        self.start_time = start_time
        # The time base.
        self.timebase = timebase
        # The width of the video. Unit: pixel.
        self.width = width

    def validate(self):
        if self.network_cost:
            self.network_cost.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.color_primaries is not None:
            result['ColorPrimaries'] = self.color_primaries
        if self.color_range is not None:
            result['ColorRange'] = self.color_range
        if self.color_transfer is not None:
            result['ColorTransfer'] = self.color_transfer
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.duration_inaccurate is not None:
            result['DurationInaccurate'] = self.duration_inaccurate
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.network_cost is not None:
            result['NetworkCost'] = self.network_cost.to_map()
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('ColorPrimaries') is not None:
            self.color_primaries = m.get('ColorPrimaries')
        if m.get('ColorRange') is not None:
            self.color_range = m.get('ColorRange')
        if m.get('ColorTransfer') is not None:
            self.color_transfer = m.get('ColorTransfer')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('DurationInaccurate') is not None:
            self.duration_inaccurate = m.get('DurationInaccurate')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NetworkCost') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost()
            self.network_cost = temp_model.from_map(m['NetworkCost'])
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList(TeaModel):
    def __init__(
        self,
        video_stream: List[SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream] = None,
    ):
        self.video_stream = video_stream

    def validate(self):
        if self.video_stream:
            for k in self.video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStream'] = []
        if self.video_stream is not None:
            for k in self.video_stream:
                result['VideoStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stream = []
        if m.get('VideoStream') is not None:
            for k in m.get('VideoStream'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream()
                self.video_stream.append(temp_model.from_map(k))
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams(TeaModel):
    def __init__(
        self,
        audio_stream_list: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList = None,
        subtitle_stream_list: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList = None,
        video_stream_list: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList = None,
    ):
        # The audio streams. A media file can contain up to four audio streams.
        self.audio_stream_list = audio_stream_list
        # The subtitle streams. A media file can contain up to four subtitle streams.
        self.subtitle_stream_list = subtitle_stream_list
        # The video streams. A media file can contain up to four video streams.
        self.video_stream_list = video_stream_list

    def validate(self):
        if self.audio_stream_list:
            self.audio_stream_list.validate()
        if self.subtitle_stream_list:
            self.subtitle_stream_list.validate()
        if self.video_stream_list:
            self.video_stream_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_stream_list is not None:
            result['AudioStreamList'] = self.audio_stream_list.to_map()
        if self.subtitle_stream_list is not None:
            result['SubtitleStreamList'] = self.subtitle_stream_list.to_map()
        if self.video_stream_list is not None:
            result['VideoStreamList'] = self.video_stream_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioStreamList') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList()
            self.audio_stream_list = temp_model.from_map(m['AudioStreamList'])
        if m.get('SubtitleStreamList') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList()
            self.subtitle_stream_list = temp_model.from_map(m['SubtitleStreamList'])
        if m.get('VideoStreamList') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList()
            self.video_stream_list = temp_model.from_map(m['VideoStreamList'])
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobProperties(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        duration: str = None,
        file_format: str = None,
        file_size: str = None,
        format: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat = None,
        fps: str = None,
        height: str = None,
        md5: str = None,
        streams: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams = None,
        width: str = None,
    ):
        # The bitrate. Unit: Kbit/s.
        self.bitrate = bitrate
        # The duration of the input media file. Unit: seconds.
        self.duration = duration
        # The format of the input media file.
        self.file_format = file_format
        # The size of the file. Unit: bytes.
        self.file_size = file_size
        # The format information.
        self.format = format
        # The frame rate.
        self.fps = fps
        # The height of the video. Unit: pixel.
        self.height = height
        self.md5 = md5
        # The media streams that are contained in the input media file.
        self.streams = streams
        # The width of the video. Unit: pixel.
        self.width = width

    def validate(self):
        if self.format:
            self.format.validate()
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_format is not None:
            result['FileFormat'] = self.file_format
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.format is not None:
            result['Format'] = self.format.to_map()
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.md5 is not None:
            result['MD5'] = self.md5
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileFormat') is not None:
            self.file_format = m.get('FileFormat')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Format') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat()
            self.format = temp_model.from_map(m['Format'])
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MD5') is not None:
            self.md5 = m.get('MD5')
        if m.get('Streams') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams()
            self.streams = temp_model.from_map(m['Streams'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJob(TeaModel):
    def __init__(
        self,
        async_: bool = None,
        code: str = None,
        creation_time: str = None,
        input: SubmitMediaInfoJobResponseBodyMediaInfoJobInput = None,
        job_id: str = None,
        mnsmessage_result: SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult = None,
        message: str = None,
        pipeline_id: str = None,
        properties: SubmitMediaInfoJobResponseBodyMediaInfoJobProperties = None,
        state: str = None,
        user_data: str = None,
    ):
        # Indicates whether the job is run in asynchronous mode.
        self.async_ = async_
        # The error code returned if the job fails.
        self.code = code
        # The time when the job was created.
        self.creation_time = creation_time
        # The information about the input media file.
        self.input = input
        # The ID of the job.
        self.job_id = job_id
        # The message sent by Message Service (MNS) to notify users of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the job fails.
        self.message = message
        # The ID of the MPS queue to which the analysis job is submitted.
        self.pipeline_id = pipeline_id
        # The properties of the input media file.
        self.properties = properties
        # The status of the job. Valid values:
        # 
        # *   **Success**: The job is successful.
        # *   **Fail**: The job fails.
        # *   **Analyzing**: The job is being run.
        self.state = state
        # The custom data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.properties:
            self.properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_ is not None:
            result['Async'] = self.async_
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.properties is not None:
            result['Properties'] = self.properties.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async_ = m.get('Async')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Input') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Properties') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobProperties()
            self.properties = temp_model.from_map(m['Properties'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobResponseBody(TeaModel):
    def __init__(
        self,
        media_info_job: SubmitMediaInfoJobResponseBodyMediaInfoJob = None,
        request_id: str = None,
    ):
        # The details of the media information analysis job.
        self.media_info_job = media_info_job
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_info_job:
            self.media_info_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job is not None:
            result['MediaInfoJob'] = self.media_info_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaInfoJob') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJob()
            self.media_info_job = temp_model.from_map(m['MediaInfoJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaInfoJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitMediaInfoJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaInfoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSmarttagJobRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_addr: str = None,
        content_type: str = None,
        input: str = None,
        notify_url: str = None,
        owner_account: str = None,
        owner_id: int = None,
        params: str = None,
        pipeline_id: str = None,
        priority: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
        title: str = None,
        user_data: str = None,
    ):
        self.content = content
        self.content_addr = content_addr
        self.content_type = content_type
        self.input = input
        self.notify_url = notify_url
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.params = params
        # This parameter is required.
        self.pipeline_id = pipeline_id
        # The priority of the job in the ApsaraVideo Media Processing (MPS) queue to which the job is added. Valid values: 0 to 9. Default value: 5.
        self.priority = priority
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The template ID, which is used to specify the analysis algorithm of the smart tagging job. For more information about how to manage templates, see [AddSmarttagTemplate](https://help.aliyun.com/document_detail/602910.html), [QuerySmarttagTemplateList](https://help.aliyun.com/document_detail/187770.html), [UpdateSmarttagTemplate](https://help.aliyun.com/document_detail/187776.html), and [DeleteSmarttagTemplate](https://help.aliyun.com/document_detail/187775.html).
        self.template_id = template_id
        # This parameter is required.
        self.title = title
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_addr is not None:
            result['ContentAddr'] = self.content_addr
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.input is not None:
            result['Input'] = self.input
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.params is not None:
            result['Params'] = self.params
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentAddr') is not None:
            self.content_addr = m.get('ContentAddr')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSmarttagJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        self.job_id = job_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSmarttagJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSmarttagJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSmarttagJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSnapshotJobRequest(TeaModel):
    def __init__(
        self,
        input: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        snapshot_config: str = None,
        user_data: str = None,
    ):
        # The information about the job input. The value must be a JSON object. You must add the Object Storage Service (OSS) bucket that stores the OSS object to be used as the job input as a media bucket in the MPS console. To add an OSS bucket as a media bucket, you can log on to the MPS console, choose Workflows > Media Buckets in the left-side navigation pane, and then click Add Bucket. After the OSS bucket is added as a media bucket, you must perform URL encoding for the OSS object. Example: `{"Bucket":"example-bucket","Location":"example-location","Object":"example%2Ftest.flv"}`. This example indicates the `"example-bucket.example-location.aliyuncs.com/example/test.flv"` object.
        # 
        # > The OSS bucket must reside in the same region as your MPS service.
        # 
        # This parameter is required.
        self.input = input
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue to which you want to submit the snapshot job. To obtain the ID, you can log on to the **MPS console** and choose **Global Settings** > **Pipelines** in the left-side navigation pane.
        # 
        # > Make sure that an available Message Service (MNS) topic is bound to the specified MPS queue. Otherwise, the relevant messages may fail to be sent as expected.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The snapshot configurations. For more information, see the "AliyunSnapshotConfig" section of the [Data types](https://help.aliyun.com/document_detail/29253.html) topic.
        # 
        # > If you set the Interval parameter that is nested under SnapshotConfig, snapshots are captured at the specified intervals. The default value of the Interval parameter is 10, in seconds. If an input video is short but you specify large values for both the Num and Interval parameters, the actual number of snapshots captured may be smaller than the specified number. For example, if you set the Num parameter to 5 and the Interval parameter to 3 for a video of 10 seconds, the number of snapshots captured cannot reach 5.
        # 
        # This parameter is required.
        self.snapshot_config = snapshot_config
        # The custom data. The custom data can contain letters, digits, and hyphens (-) and be up to 1,024 bytes in size. The custom data cannot start with a special character.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_config is not None:
            result['SnapshotConfig'] = self.snapshot_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotConfig') is not None:
            self.snapshot_config = m.get('SnapshotConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobInput(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The OSS bucket that stores the object.
        self.bucket = bucket
        # The region in which the OSS bucket resides.
        self.location = location
        # The OSS object that is used as the input file.
        self.object = object
        # The ARN of the specified RAM role. Format: acs:ram::$accountID:role/$roleName.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        message_id: str = None,
    ):
        # The error code returned if the job fails. This parameter is not returned if the job is successful.
        self.error_code = error_code
        # The error message returned if the job fails. This parameter is not returned if the job is successful.
        self.error_message = error_message
        # The ID of the message. This parameter is not returned if the job fails.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The OSS bucket that stores the output snapshot.
        self.bucket = bucket
        # The OSS region in which the OSS bucket for storing the output snapshot resides.
        self.location = location
        # The OSS object that is generated as the output file of the snapshot job.
        self.object = object
        # The Alibaba Cloud Resource Name (ARN) of the specified RAM role. Format: acs:ram::$accountID:role/$roleName.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut(TeaModel):
    def __init__(
        self,
        cell_height: str = None,
        cell_sel_step: str = None,
        cell_width: str = None,
        color: str = None,
        columns: str = None,
        is_keep_cell_pic: str = None,
        lines: str = None,
        margin: str = None,
        padding: str = None,
    ):
        # The height of a single image. The default value is the height of the output snapshot.
        self.cell_height = cell_height
        # The step for selecting a single image.
        self.cell_sel_step = cell_sel_step
        # The width of a single image. The default value is the width of the output snapshot.
        self.cell_width = cell_width
        # The background color.
        # 
        # *   Default value: **black**.
        # *   You can set the Color parameter to a **color keyword** or **random** in the request.
        # 
        # > If you want to set the background color to black, you can specify the color keyword in one of the following three formats: Black, black, and #000000.
        self.color = color
        # The number of columns that the tiled image contains. Default value: **10**.
        self.columns = columns
        # Indicates whether the single images are retained. Valid values:
        # 
        # *   **true**: The single images are retained.
        # *   **false**: The single images are not retained.
        # *   Default value: **true**.
        self.is_keep_cell_pic = is_keep_cell_pic
        # The number of rows that the tiled image contains. Default value: **10**.
        self.lines = lines
        # The margin width of the tiled image.
        # 
        # *   Default value: **0**.
        # *   Unit: pixel.
        self.margin = margin
        # The distance between two consecutive single images in the tiled image.
        # 
        # *   Default value: **0**.
        # *   Unit: pixel.
        self.padding = padding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_height is not None:
            result['CellHeight'] = self.cell_height
        if self.cell_sel_step is not None:
            result['CellSelStep'] = self.cell_sel_step
        if self.cell_width is not None:
            result['CellWidth'] = self.cell_width
        if self.color is not None:
            result['Color'] = self.color
        if self.columns is not None:
            result['Columns'] = self.columns
        if self.is_keep_cell_pic is not None:
            result['IsKeepCellPic'] = self.is_keep_cell_pic
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.margin is not None:
            result['Margin'] = self.margin
        if self.padding is not None:
            result['Padding'] = self.padding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CellHeight') is not None:
            self.cell_height = m.get('CellHeight')
        if m.get('CellSelStep') is not None:
            self.cell_sel_step = m.get('CellSelStep')
        if m.get('CellWidth') is not None:
            self.cell_width = m.get('CellWidth')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('Columns') is not None:
            self.columns = m.get('Columns')
        if m.get('IsKeepCellPic') is not None:
            self.is_keep_cell_pic = m.get('IsKeepCellPic')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('Margin') is not None:
            self.margin = m.get('Margin')
        if m.get('Padding') is not None:
            self.padding = m.get('Padding')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        location: str = None,
        object: str = None,
        role_arn: str = None,
    ):
        # The OSS bucket that stores the object.
        self.bucket = bucket
        # The ID of the region in which the OSS bucket that stores the object is located.
        self.location = location
        # The OSS object that is generated as the output file of the tiling job.
        self.object = object
        # The ARN of the specified RAM role. Format: acs:ram::$accountID:role/$roleName.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray(TeaModel):
    def __init__(
        self,
        time_point_list: List[int] = None,
    ):
        self.time_point_list = time_point_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_point_list is not None:
            result['TimePointList'] = self.time_point_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimePointList') is not None:
            self.time_point_list = m.get('TimePointList')
        return self


class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig(TeaModel):
    def __init__(
        self,
        frame_type: str = None,
        height: str = None,
        interval: str = None,
        num: str = None,
        output_file: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile = None,
        tile_out: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut = None,
        tile_output_file: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile = None,
        time: str = None,
        time_array: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray = None,
        width: str = None,
    ):
        # The type of the snapshot. Default value: **Normal**. Valid values:
        # 
        # *   **normal**: normal frames.
        # *   **intra**: I-frames (keyframes).
        # 
        # > If the FrameType parameter is set to intra in the request, only keyframes are captured. If no keyframe is found at the specified point in time, the keyframe closest to the specified point in time is captured. Keyframes are captured faster than normal frames if the same snapshot rules are applied.
        self.frame_type = frame_type
        # The height of the output snapshot.
        self.height = height
        # The interval for capturing snapshots.
        # 
        # *   If this parameter is specified in the request, snapshots are captured at intervals. The value must be greater than 0 in the request.
        # *   Unit: seconds.
        # *   Default value: **10**.
        self.interval = interval
        # The number of snapshots. If the Num parameter is set in the request, snapshots are captured at intervals.
        self.num = num
        # The information about the output file of the snapshot job.
        self.output_file = output_file
        # The tiling configurations.
        self.tile_out = tile_out
        # The information about the output file of the tiling job.
        self.tile_output_file = tile_output_file
        # The start time for capturing snapshots. Unit: milliseconds.
        self.time = time
        self.time_array = time_array
        # The width of the output snapshot.
        self.width = width

    def validate(self):
        if self.output_file:
            self.output_file.validate()
        if self.tile_out:
            self.tile_out.validate()
        if self.tile_output_file:
            self.tile_output_file.validate()
        if self.time_array:
            self.time_array.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.frame_type is not None:
            result['FrameType'] = self.frame_type
        if self.height is not None:
            result['Height'] = self.height
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.num is not None:
            result['Num'] = self.num
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.tile_out is not None:
            result['TileOut'] = self.tile_out.to_map()
        if self.tile_output_file is not None:
            result['TileOutputFile'] = self.tile_output_file.to_map()
        if self.time is not None:
            result['Time'] = self.time
        if self.time_array is not None:
            result['TimeArray'] = self.time_array.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FrameType') is not None:
            self.frame_type = m.get('FrameType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Num') is not None:
            self.num = m.get('Num')
        if m.get('OutputFile') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('TileOut') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut()
            self.tile_out = temp_model.from_map(m['TileOut'])
        if m.get('TileOutputFile') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile()
            self.tile_output_file = temp_model.from_map(m['TileOutputFile'])
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('TimeArray') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTimeArray()
            self.time_array = temp_model.from_map(m['TimeArray'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSnapshotJobResponseBodySnapshotJob(TeaModel):
    def __init__(
        self,
        code: str = None,
        count: str = None,
        creation_time: str = None,
        id: str = None,
        input: SubmitSnapshotJobResponseBodySnapshotJobInput = None,
        mnsmessage_result: SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult = None,
        message: str = None,
        pipeline_id: str = None,
        snapshot_config: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig = None,
        state: str = None,
        tile_count: str = None,
        user_data: str = None,
    ):
        # The error code returned if the job fails. This parameter is not returned if the job is successful.
        self.code = code
        # The number of snapshots that are captured.
        self.count = count
        # The time when the job was created.
        self.creation_time = creation_time
        # The ID of the snapshot job.
        self.id = id
        # The information about the job input.
        self.input = input
        # The message sent by MNS to notify the user of the job result.
        self.mnsmessage_result = mnsmessage_result
        # The error message returned if the job fails. This parameter is not returned if the job is successful.
        self.message = message
        # The ID of the MPS queue to which the snapshot job is submitted.
        self.pipeline_id = pipeline_id
        # The snapshot configurations.
        self.snapshot_config = snapshot_config
        # The status of the snapshot job. Valid values:
        # 
        # *   **Submitted**: The job is submitted.
        # *   **Snapshoting**: The job is being processed.
        # *   **Success**: The job is successful.
        # *   **Fail**: The job fails.
        self.state = state
        # The number of single images that are contained in the tiled image.
        self.tile_count = tile_count
        # The custom data.
        self.user_data = user_data

    def validate(self):
        if self.input:
            self.input.validate()
        if self.mnsmessage_result:
            self.mnsmessage_result.validate()
        if self.snapshot_config:
            self.snapshot_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.id is not None:
            result['Id'] = self.id
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.mnsmessage_result is not None:
            result['MNSMessageResult'] = self.mnsmessage_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.snapshot_config is not None:
            result['SnapshotConfig'] = self.snapshot_config.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.tile_count is not None:
            result['TileCount'] = self.tile_count
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Input') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('MNSMessageResult') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult()
            self.mnsmessage_result = temp_model.from_map(m['MNSMessageResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('SnapshotConfig') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig()
            self.snapshot_config = temp_model.from_map(m['SnapshotConfig'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TileCount') is not None:
            self.tile_count = m.get('TileCount')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSnapshotJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        snapshot_job: SubmitSnapshotJobResponseBodySnapshotJob = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The information about the snapshot job.
        self.snapshot_job = snapshot_job

    def validate(self):
        if self.snapshot_job:
            self.snapshot_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_job is not None:
            result['SnapshotJob'] = self.snapshot_job.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotJob') is not None:
            temp_model = SubmitSnapshotJobResponseBodySnapshotJob()
            self.snapshot_job = temp_model.from_map(m['SnapshotJob'])
        return self


class SubmitSnapshotJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSnapshotJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSnapshotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTraceAbJobRequest(TeaModel):
    def __init__(
        self,
        call_back: str = None,
        cipher_base_64ed: str = None,
        input: str = None,
        level: int = None,
        output: str = None,
        start_time: int = None,
        total_time: int = None,
        url: str = None,
        user_data: str = None,
    ):
        self.call_back = call_back
        self.cipher_base_64ed = cipher_base_64ed
        self.input = input
        self.level = level
        # This parameter is required.
        self.output = output
        self.start_time = start_time
        self.total_time = total_time
        self.url = url
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_back is not None:
            result['CallBack'] = self.call_back
        if self.cipher_base_64ed is not None:
            result['CipherBase64ed'] = self.cipher_base_64ed
        if self.input is not None:
            result['Input'] = self.input
        if self.level is not None:
            result['Level'] = self.level
        if self.output is not None:
            result['Output'] = self.output
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.total_time is not None:
            result['TotalTime'] = self.total_time
        if self.url is not None:
            result['Url'] = self.url
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallBack') is not None:
            self.call_back = m.get('CallBack')
        if m.get('CipherBase64ed') is not None:
            self.cipher_base_64ed = m.get('CipherBase64ed')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TotalTime') is not None:
            self.total_time = m.get('TotalTime')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTraceAbJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        media_id: str = None,
    ):
        self.job_id = job_id
        self.media_id = media_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class SubmitTraceAbJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitTraceAbJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitTraceAbJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitTraceAbJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTraceAbJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTraceAbJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTraceExtractJobRequest(TeaModel):
    def __init__(
        self,
        call_back: str = None,
        input: str = None,
        params: str = None,
        url: str = None,
        user_data: str = None,
    ):
        self.call_back = call_back
        self.input = input
        self.params = params
        self.url = url
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_back is not None:
            result['CallBack'] = self.call_back
        if self.input is not None:
            result['Input'] = self.input
        if self.params is not None:
            result['Params'] = self.params
        if self.url is not None:
            result['Url'] = self.url
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallBack') is not None:
            self.call_back = m.get('CallBack')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTraceExtractJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitTraceExtractJobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitTraceExtractJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        status_code: int = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.status_code = status_code

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitTraceExtractJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class SubmitTraceExtractJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTraceExtractJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTraceExtractJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTraceM3u8JobRequest(TeaModel):
    def __init__(
        self,
        key_uri: str = None,
        media_id: str = None,
        output: str = None,
        params: str = None,
        trace: str = None,
    ):
        self.key_uri = key_uri
        self.media_id = media_id
        self.output = output
        self.params = params
        self.trace = trace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_uri is not None:
            result['KeyUri'] = self.key_uri
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.output is not None:
            result['Output'] = self.output
        if self.params is not None:
            result['Params'] = self.params
        if self.trace is not None:
            result['Trace'] = self.trace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyUri') is not None:
            self.key_uri = m.get('KeyUri')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('Trace') is not None:
            self.trace = m.get('Trace')
        return self


class SubmitTraceM3u8JobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SubmitTraceM3u8JobResponseBody(TeaModel):
    def __init__(
        self,
        data: SubmitTraceM3u8JobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = SubmitTraceM3u8JobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitTraceM3u8JobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTraceM3u8JobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTraceM3u8JobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagCustomPersonRequest(TeaModel):
    def __init__(
        self,
        category_description: str = None,
        category_id: str = None,
        category_name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        person_description: str = None,
        person_id: str = None,
        person_name: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        self.category_description = category_description
        self.category_id = category_id
        self.category_name = category_name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.person_description = person_description
        self.person_id = person_id
        self.person_name = person_name
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_description is not None:
            result['CategoryDescription'] = self.category_description
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.category_name is not None:
            result['CategoryName'] = self.category_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.person_description is not None:
            result['PersonDescription'] = self.person_description
        if self.person_id is not None:
            result['PersonId'] = self.person_id
        if self.person_name is not None:
            result['PersonName'] = self.person_name
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryDescription') is not None:
            self.category_description = m.get('CategoryDescription')
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('CategoryName') is not None:
            self.category_name = m.get('CategoryName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PersonDescription') is not None:
            self.person_description = m.get('PersonDescription')
        if m.get('PersonId') is not None:
            self.person_id = m.get('PersonId')
        if m.get('PersonName') is not None:
            self.person_name = m.get('PersonName')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class TagCustomPersonResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagCustomPersonResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagCustomPersonResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagCustomPersonResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindInputBucketRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        role_arn: str = None,
    ):
        # The name of the input media bucket to be unbound. To obtain the media bucket name, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Media Buckets** in the left-side navigation pane. Alternatively, you can log on to the **Object Storage Service (OSS) console** and click **Historical Paths**.
        # 
        # This parameter is required.
        self.bucket = bucket
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The Alibaba Cloud Resource Name (ARN) of the role used for delegated authorization.
        self.role_arn = role_arn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        return self


class UnbindInputBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbindInputBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindInputBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindInputBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindOutputBucketRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the request.
        # 
        # This parameter is required.
        self.bucket = bucket
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UnbindOutputBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The operation that you want to perform. Set the value to **UnbindOutputBucket**.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbindOutputBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindOutputBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindOutputBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnregisterCustomFaceRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        face_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        person_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the figure library. The ID is used to uniquely identify a figure library. You can specify the ID of a custom figure library. Make sure that the ID is unique. If you set this parameter to the ID of a system figure library, the system figure library is used. The ID can be up to 120 characters in length and is not case-sensitive. You can call the [ListCustomPersons](https://help.aliyun.com/document_detail/187787.html) operation to query the figure library ID.
        # 
        # This parameter is required.
        self.category_id = category_id
        # The ID of the face. The ID is used to uniquely identify a face. Make sure that the ID is unique. The ID can be up to 120 characters in length and is not case-sensitive. You can call the [ListCustomPersons](https://help.aliyun.com/document_detail/187787.html) operation to query the face ID. If you set this parameter to ALL, all the faces associated with the specified figure are deleted.
        # 
        # This parameter is required.
        self.face_id = face_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the figure. The ID is used to uniquely identify a custom figure. Make sure that the ID is unique. The ID can be up to 120 characters in length and is not case-sensitive. You can call the [ListCustomPersons](https://help.aliyun.com/document_detail/187787.html) operation to query the figure ID. If you set this parameter to ALL, all the faces in the specified figure library are deleted, and the custom figure library is deleted.
        # 
        # This parameter is required.
        self.person_id = person_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.face_id is not None:
            result['FaceId'] = self.face_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.person_id is not None:
            result['PersonId'] = self.person_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('FaceId') is not None:
            self.face_id = m.get('FaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PersonId') is not None:
            self.person_id = m.get('PersonId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UnregisterCustomFaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnregisterCustomFaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnregisterCustomFaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnregisterCustomFaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        cover_url: str = None,
        description: str = None,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        tags: str = None,
        title: str = None,
    ):
        # The ID of the category to which the media file belongs. The value must be an integer.
        # 
        # *   If you do not specify this parameter, the value is NULL.
        # *   The value cannot be negative.
        self.cate_id = cate_id
        # The URL of the thumbnail. This parameter is used to specify the storage location of the thumbnail. To obtain the URL, you can log on to the **MPS console** and choose **Workflows** > **Media Buckets** in the left-side navigation pane. Alternatively, you can log on to the **OSS console** and click **Buckets** in the left-side navigation pane.
        # 
        # *   The value can be up to 3,200 bytes in length.
        # *   The URL complies with RFC 2396 and is encoded in UTF-8, with reserved characters being percent-encoded. For more information, see [URL encoding](https://help.aliyun.com/document_detail/423796.html).
        self.cover_url = cover_url
        # The description of the media file. Multiple character types, such as letters and digits, are supported.
        # 
        # *   If you do not specify this parameter, the value is NULL.
        # *   The value is encoded in UTF-8 and can be up to 1,024 bytes in length.
        self.description = description
        # The ID of the media file whose basic information you want to update. To obtain the ID of the media file, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Media Management** > **Media List** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The tags that you want to add to the media file.
        # 
        # *   You can specify up to 16 tags for a media file. Separate multiple tags with commas (,).
        # *   Each tag can be up to 32 bytes in length.
        # *   The value is encoded in UTF-8.
        self.tags = tags
        # The title of the media file. Multiple character types, such as letters and digits, are supported.
        # 
        # *   If you do not specify this parameter, the value is NULL.
        # *   The value is encoded in UTF-8 and can be up to 128 bytes in length.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateMediaResponseBodyMediaFile(TeaModel):
    def __init__(
        self,
        state: str = None,
        url: str = None,
    ):
        # The state of the input file. Valid values:
        # 
        # *   **Normal**: The input file is normal.
        # *   **Deleted**: The input file is deleted.
        self.state = state
        # The name of the OSS bucket in which the input media file is stored.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['State'] = self.state
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class UpdateMediaResponseBodyMediaRunIdList(TeaModel):
    def __init__(
        self,
        run_id: List[str] = None,
    ):
        self.run_id = run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.run_id is not None:
            result['RunId'] = self.run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RunId') is not None:
            self.run_id = m.get('RunId')
        return self


class UpdateMediaResponseBodyMediaTags(TeaModel):
    def __init__(
        self,
        tag: List[str] = None,
    ):
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class UpdateMediaResponseBodyMedia(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        cate_id: int = None,
        censor_state: str = None,
        cover_url: str = None,
        creation_time: str = None,
        description: str = None,
        duration: str = None,
        file: UpdateMediaResponseBodyMediaFile = None,
        format: str = None,
        fps: str = None,
        height: str = None,
        media_id: str = None,
        publish_state: str = None,
        run_id_list: UpdateMediaResponseBodyMediaRunIdList = None,
        size: str = None,
        tags: UpdateMediaResponseBodyMediaTags = None,
        title: str = None,
        width: str = None,
    ):
        # The bitrate of the media file.
        self.bitrate = bitrate
        # The ID of the category to which the media file belongs.
        self.cate_id = cate_id
        # The review state of the media file. Valid values:
        # 
        # *   **Initiated**: The media file is uploaded but not reviewed.
        # *   **Pass**: The media file is uploaded and passes the review.
        self.censor_state = censor_state
        # The URL of the thumbnail.
        self.cover_url = cover_url
        # The time when the media file was created.
        self.creation_time = creation_time
        # The description of the media file.
        self.description = description
        # The duration of the media file.
        self.duration = duration
        # The information about the input file.
        self.file = file
        # The format of the media file. Valid values: mov, mp4, m4a, 3gp, 3g2, and mj2.
        self.format = format
        # The frame rate of the media file.
        self.fps = fps
        # The height of the media file.
        self.height = height
        # The ID of the media file.
        self.media_id = media_id
        # The publishing state of the media file. Valid values:
        # 
        # *   **Initiated**: The media file is in the initial state.
        # *   **UnPublish**: The media file has not been published, and the playback permission on the OSS object is Private.
        # *   **Published**: The media file has been published, and the playback permission on the OSS object is Default.
        # *   **Deleted**: The media file is deleted.
        self.publish_state = publish_state
        # The IDs of the media workflow execution instances.
        self.run_id_list = run_id_list
        # The size of the media file.
        self.size = size
        # The information about the tags.
        self.tags = tags
        # The title of the media file.
        self.title = title
        # The width of the media file.
        self.width = width

    def validate(self):
        if self.file:
            self.file.validate()
        if self.run_id_list:
            self.run_id_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.censor_state is not None:
            result['CensorState'] = self.censor_state
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.publish_state is not None:
            result['PublishState'] = self.publish_state
        if self.run_id_list is not None:
            result['RunIdList'] = self.run_id_list.to_map()
        if self.size is not None:
            result['Size'] = self.size
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CensorState') is not None:
            self.censor_state = m.get('CensorState')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('File') is not None:
            temp_model = UpdateMediaResponseBodyMediaFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('PublishState') is not None:
            self.publish_state = m.get('PublishState')
        if m.get('RunIdList') is not None:
            temp_model = UpdateMediaResponseBodyMediaRunIdList()
            self.run_id_list = temp_model.from_map(m['RunIdList'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Tags') is not None:
            temp_model = UpdateMediaResponseBodyMediaTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateMediaResponseBody(TeaModel):
    def __init__(
        self,
        media: UpdateMediaResponseBodyMedia = None,
        request_id: str = None,
    ):
        # The information about the media file.
        self.media = media
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media:
            self.media.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Media') is not None:
            temp_model = UpdateMediaResponseBodyMedia()
            self.media = temp_model.from_map(m['Media'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaCategoryRequest(TeaModel):
    def __init__(
        self,
        cate_id: int = None,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the category. The value cannot be negative.
        self.cate_id = cate_id
        # The ID of the media file whose category you want to update.
        # 
        # > To obtain the ID of a media file, you can call the [AddMedia](https://help.aliyun.com/document_detail/44458.html) operation. Alternatively, perform the following operations in the ApsaraVideo Media Processing (MPS) console: In the left-side navigation pane, choose **Media Management > Media List**. Find the required video and click **Manage** in the Actions column. The ID of the video is displayed on the Basics tab.
        # 
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UpdateMediaCategoryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaCoverRequest(TeaModel):
    def __init__(
        self,
        cover_url: str = None,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The URL of the thumbnail that you want to specify for the media file. The URL complies with RFC 2396 and is encoded in UTF-8. The URL can be up to 3,200 bytes in length.
        # 
        # >  To obtain the thumbnail URL, you can find the image in the Object Storage Service (OSS) bucket and click the image to view details. In the View Details panel, copy the part before the question mark (?) from the URL field. You can enter only an HTTP URL.
        self.cover_url = cover_url
        # The ID of the media file whose thumbnail you want to update. To obtain the ID of a media file, you can call the [AddMedia](https://help.aliyun.com/document_detail/44458.html) operation. Alternatively, perform the following operations in the ApsaraVideo Media Processing (MPS) console: In the left-side navigation pane, choose **Media Management** > **Media List**. Find the required video and click **Manage**. The ID of the video is displayed on the Basics tab.
        # 
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UpdateMediaCoverResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaCoverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaCoverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaCoverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaPublishStateRequest(TeaModel):
    def __init__(
        self,
        media_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        publish: bool = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
    ):
        # The ID of the media file whose publishing status you want to update. You can obtain the ID of a media file from the response of the [AddMedia](https://help.aliyun.com/document_detail/44458.html) operation. Alternatively, perform the following operations in the ApsaraVideo Media Processing (MPS) console: In the left-side navigation pane, choose **Media Management** > **Media List**. Find the required video and click **Manage**. The ID of the video is displayed on the Basics tab.
        # 
        # This parameter is required.
        self.media_id = media_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The publishing status. Default value: **Initialed**. Valid values:
        # 
        # *   **true**: published.
        # *   **false**: unpublished.
        self.publish = publish
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.publish is not None:
            result['Publish'] = self.publish
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Publish') is not None:
            self.publish = m.get('Publish')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UpdateMediaPublishStateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaPublishStateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaPublishStateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaPublishStateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaWorkflowRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        # The ID of the media workflow that you want to update. To obtain the ID of the media workflow, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Workflow Settings** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The new topology of the media workflow. The value is a JSON object that contains the activity list and activity dependencies.
        # 
        # > The Object Storage Service (OSS) bucket must reside in the same region as your MPS service.
        # 
        # This parameter is required.
        self.topology = topology
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class UpdateMediaWorkflowResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The ID of the media workflow that is updated.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow.
        self.name = name
        # The state of the media workflow. Valid values:
        # 
        # *   **Inactive**: The media workflow is disabled.
        # *   **Active**: The media workflow is enabled.
        self.state = state
        # The topology of the media workflow.
        self.topology = topology
        # The trigger mode of the media workflow. Valid values:
        # 
        # *   **OssAutoTrigger**: The media workflow is automatically triggered.
        # *   **NotInAuto**: The media workflow is not automatically triggered.
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class UpdateMediaWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: UpdateMediaWorkflowResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        # The detailed information about the media workflow.
        self.media_workflow = media_workflow
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = UpdateMediaWorkflowResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaWorkflowTriggerModeRequest(TeaModel):
    def __init__(
        self,
        media_workflow_id: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        trigger_mode: str = None,
    ):
        # The ID of the media workflow that you want to update. To obtain the ID of the media workflow, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Workflows** > **Workflow Settings** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.media_workflow_id = media_workflow_id
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The trigger mode of the media workflow. Valid values:
        # 
        # *   **OssAutoTrigger**: automatically triggers the media workflow.
        # *   **NotInAuto**: does not automatically trigger the media workflow.
        # 
        # This parameter is required.
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        media_workflow_id: str = None,
        name: str = None,
        state: str = None,
        topology: str = None,
        trigger_mode: str = None,
    ):
        # The time when the media workflow was created.
        self.creation_time = creation_time
        # The ID of the media workflow.
        self.media_workflow_id = media_workflow_id
        # The name of the media workflow.
        self.name = name
        # The status of the media workflow. Valid values:
        # 
        # *   **Inactive**: The media workflow is disabled.
        # *   **Active**: The media workflow is enabled.
        self.state = state
        # The topology of the media workflow.
        self.topology = topology
        # The trigger mode of the media workflow. Valid values:
        # 
        # *   **OssAutoTrigger**: The media workflow is automatically triggered.
        # *   **NotInAuto**: The media workflow is not automatically triggered.
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_workflow_id is not None:
            result['MediaWorkflowId'] = self.media_workflow_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.topology is not None:
            result['Topology'] = self.topology
        if self.trigger_mode is not None:
            result['TriggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaWorkflowId') is not None:
            self.media_workflow_id = m.get('MediaWorkflowId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Topology') is not None:
            self.topology = m.get('Topology')
        if m.get('TriggerMode') is not None:
            self.trigger_mode = m.get('TriggerMode')
        return self


class UpdateMediaWorkflowTriggerModeResponseBody(TeaModel):
    def __init__(
        self,
        media_workflow: UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow = None,
        request_id: str = None,
    ):
        # The information about the media workflow.
        self.media_workflow = media_workflow
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.media_workflow:
            self.media_workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_workflow is not None:
            result['MediaWorkflow'] = self.media_workflow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaWorkflow') is not None:
            temp_model = UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow()
            self.media_workflow = temp_model.from_map(m['MediaWorkflow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaWorkflowTriggerModeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMediaWorkflowTriggerModeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaWorkflowTriggerModeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePipelineRequest(TeaModel):
    def __init__(
        self,
        extend_config: str = None,
        name: str = None,
        notify_config: str = None,
        owner_account: str = None,
        owner_id: int = None,
        pipeline_id: str = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        role: str = None,
        state: str = None,
    ):
        self.extend_config = extend_config
        # The new name of the MPS queue. The value can contain letters, digits, and special characters such as hyphens (-) and can be up to 128 bytes in size. The value cannot start with a special character.
        # 
        # This parameter is required.
        self.name = name
        # The Message Service (MNS) configuration, such as the information about the MNS queue or topic. For more information, see the "NotifyConfig" section of the [Parameter details](https://help.aliyun.com/document_detail/29253.html) topic.
        self.notify_config = notify_config
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The ID of the MPS queue that you want to update. To view the MPS queue ID, log on to the **MPS console** and choose **Global Settings** > **Pipelines** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The role that is assigned to the current RAM user. To obtain the role, you can log on to the **Resource Access Management (RAM) console** and choose **Identities** > **Roles** in the left-side navigation pane.
        self.role = role
        # The new state of the MPS queue.
        # 
        # *   **Active**: The MPS queue is active. Jobs in the MPS queue can be scheduled and run by MPS.
        # *   **Paused**: The MPS queue is paused. Jobs in the MPS queue cannot be scheduled or run by MPS, and all jobs remain in the Submitted state. Jobs that are running will not be affected.
        # 
        # This parameter is required.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extend_config is not None:
            result['ExtendConfig'] = self.extend_config
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role is not None:
            result['Role'] = self.role
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtendConfig') is not None:
            self.extend_config = m.get('ExtendConfig')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            self.notify_config = m.get('NotifyConfig')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdatePipelineResponseBodyPipelineNotifyConfig(TeaModel):
    def __init__(
        self,
        mq_tag: str = None,
        mq_topic: str = None,
        queue_name: str = None,
        topic: str = None,
    ):
        # The tags of the messages.
        self.mq_tag = mq_tag
        # The queue of messages that are received.
        self.mq_topic = mq_topic
        # The queue that is created in MNS.
        self.queue_name = queue_name
        # The topic that is created in MNS.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mq_tag is not None:
            result['MqTag'] = self.mq_tag
        if self.mq_topic is not None:
            result['MqTopic'] = self.mq_topic
        if self.queue_name is not None:
            result['QueueName'] = self.queue_name
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MqTag') is not None:
            self.mq_tag = m.get('MqTag')
        if m.get('MqTopic') is not None:
            self.mq_topic = m.get('MqTopic')
        if m.get('QueueName') is not None:
            self.queue_name = m.get('QueueName')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class UpdatePipelineResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        notify_config: UpdatePipelineResponseBodyPipelineNotifyConfig = None,
        quota_allocate: int = None,
        role: str = None,
        speed: str = None,
        state: str = None,
    ):
        # The ID of the MPS queue.
        self.id = id
        # The new name of the MPS queue.
        self.name = name
        # The MNS configuration.
        self.notify_config = notify_config
        # The quota that is allocated to the MPS queue.
        self.quota_allocate = quota_allocate
        # The role that is assigned to the current RAM user.
        self.role = role
        # The type of the MPS queue. Default value: **Standard**. Valid values:
        # 
        # *   **Boost**: MPS queue with transcoding speed boosted
        # *   **Standard**: standard MPS queue
        # *   **NarrowBandHDV2**: MPS queue that supports Narrowband HD 2.0
        # *   **AIVideoCover**: MPS queue for intelligent snapshot capture
        # *   **AIVideoFPShot**: MPS queue for media fingerprinting
        # *   **AIVideoCensor**: MPS queue for automated review
        # *   **AIVideoMCU**: MPS queue for smart tagging
        # *   **AIVideoSummary**: MPS queue for video synopsis
        # *   **AIVideoPorn**: MPS queue for pornography detection in videos
        # *   **AIAudioKWS**: MPS queue for keyword recognition in audio
        # *   **AIAudioASR**: MPS queue for speech-to-text conversion
        self.speed = speed
        # The state of the MPS queue. Valid values:
        # 
        # *   **Active**: The MPS queue is active.
        # *   **Paused**: The MPS queue is paused.
        self.state = state

    def validate(self):
        if self.notify_config:
            self.notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_config is not None:
            result['NotifyConfig'] = self.notify_config.to_map()
        if self.quota_allocate is not None:
            result['QuotaAllocate'] = self.quota_allocate
        if self.role is not None:
            result['Role'] = self.role
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyConfig') is not None:
            temp_model = UpdatePipelineResponseBodyPipelineNotifyConfig()
            self.notify_config = temp_model.from_map(m['NotifyConfig'])
        if m.get('QuotaAllocate') is not None:
            self.quota_allocate = m.get('QuotaAllocate')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdatePipelineResponseBody(TeaModel):
    def __init__(
        self,
        pipeline: UpdatePipelineResponseBodyPipeline = None,
        request_id: str = None,
    ):
        # The details of the MPS queue.
        self.pipeline = pipeline
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = UpdatePipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdatePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSmarttagTemplateRequest(TeaModel):
    def __init__(
        self,
        analyse_types: str = None,
        face_category_ids: str = None,
        face_custom_params_config: str = None,
        industry: str = None,
        is_default: bool = None,
        keyword_config: str = None,
        knowledge_config: str = None,
        label_type: str = None,
        label_version: str = None,
        landmark_group_ids: str = None,
        object_group_ids: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        scene: str = None,
        template_config: str = None,
        template_id: str = None,
        template_name: str = None,
    ):
        self.analyse_types = analyse_types
        self.face_category_ids = face_category_ids
        self.face_custom_params_config = face_custom_params_config
        self.industry = industry
        self.is_default = is_default
        self.keyword_config = keyword_config
        self.knowledge_config = knowledge_config
        self.label_type = label_type
        self.label_version = label_version
        self.landmark_group_ids = landmark_group_ids
        self.object_group_ids = object_group_ids
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        self.scene = scene
        self.template_config = template_config
        # This parameter is required.
        self.template_id = template_id
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analyse_types is not None:
            result['AnalyseTypes'] = self.analyse_types
        if self.face_category_ids is not None:
            result['FaceCategoryIds'] = self.face_category_ids
        if self.face_custom_params_config is not None:
            result['FaceCustomParamsConfig'] = self.face_custom_params_config
        if self.industry is not None:
            result['Industry'] = self.industry
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.keyword_config is not None:
            result['KeywordConfig'] = self.keyword_config
        if self.knowledge_config is not None:
            result['KnowledgeConfig'] = self.knowledge_config
        if self.label_type is not None:
            result['LabelType'] = self.label_type
        if self.label_version is not None:
            result['LabelVersion'] = self.label_version
        if self.landmark_group_ids is not None:
            result['LandmarkGroupIds'] = self.landmark_group_ids
        if self.object_group_ids is not None:
            result['ObjectGroupIds'] = self.object_group_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalyseTypes') is not None:
            self.analyse_types = m.get('AnalyseTypes')
        if m.get('FaceCategoryIds') is not None:
            self.face_category_ids = m.get('FaceCategoryIds')
        if m.get('FaceCustomParamsConfig') is not None:
            self.face_custom_params_config = m.get('FaceCustomParamsConfig')
        if m.get('Industry') is not None:
            self.industry = m.get('Industry')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('KeywordConfig') is not None:
            self.keyword_config = m.get('KeywordConfig')
        if m.get('KnowledgeConfig') is not None:
            self.knowledge_config = m.get('KnowledgeConfig')
        if m.get('LabelType') is not None:
            self.label_type = m.get('LabelType')
        if m.get('LabelVersion') is not None:
            self.label_version = m.get('LabelVersion')
        if m.get('LandmarkGroupIds') is not None:
            self.landmark_group_ids = m.get('LandmarkGroupIds')
        if m.get('ObjectGroupIds') is not None:
            self.object_group_ids = m.get('ObjectGroupIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        return self


class UpdateSmarttagTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateSmarttagTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSmarttagTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSmarttagTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTemplateRequest(TeaModel):
    def __init__(
        self,
        audio: str = None,
        container: str = None,
        mux_config: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        template_id: str = None,
        trans_config: str = None,
        video: str = None,
    ):
        # The transmuxing configurations. The value is a JSON object. For more information, see the [MuxConfig](https://help.aliyun.com/document_detail/29253.html) parameter of the "Parameter details" topic.
        self.audio = audio
        # The configurations of the video stream. The value is a JSON object. For more information, see the [Video](https://help.aliyun.com/document_detail/29253.html) parameter of the "Parameter details" topic.
        self.container = container
        # The general transcoding configurations. The value is a JSON object. For more information, see the [TransConfig](https://help.aliyun.com/document_detail/29253.html) parameter of the "Parameter details" topic.
        self.mux_config = mux_config
        # The container format. The value is a JSON object. Default format: **MP4**.
        # 
        # *   Video formats: FLV, MP4, HLS (M3U8 + TS), and MPEG-DASH (MPD + fMP4)
        # *   Audio formats: MP3, MP4, OGG, FLAC, and M4A
        # *   Images formats: GIF and WebP
        # 
        # For more information, see the [Container](https://help.aliyun.com/document_detail/29253.html) parameter of the "Parameter details" topic.
        # 
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The name of the template. The name can be up to 128 bytes in length.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The ID of the request.
        self.trans_config = trans_config
        # The configurations of the audio stream. The value is a JSON object. For more information, see the [Audio](https://help.aliyun.com/document_detail/29253.html) parameter of the "Parameter details" topic.
        self.video = video

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio
        if self.container is not None:
            result['Container'] = self.container
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config
        if self.video is not None:
            result['Video'] = self.video
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            self.audio = m.get('Audio')
        if m.get('Container') is not None:
            self.container = m.get('Container')
        if m.get('MuxConfig') is not None:
            self.mux_config = m.get('MuxConfig')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TransConfig') is not None:
            self.trans_config = m.get('TransConfig')
        if m.get('Video') is not None:
            self.video = m.get('Video')
        return self


class UpdateTemplateResponseBodyTemplateAudioVolume(TeaModel):
    def __init__(
        self,
        integrated_loudness_target: str = None,
        level: str = None,
        loudness_range_target: str = None,
        method: str = None,
        peak_level: str = None,
        true_peak: str = None,
    ):
        # The expected volume.
        # 
        # *   This parameter takes effect only if the value of Method is dynamic.
        # *   Unit: decibel.
        # *   Valid values: [-70,-5].
        # *   Default value: -6.
        self.integrated_loudness_target = integrated_loudness_target
        # The increased volume relative to the volume of the input audio.
        # 
        # *   This parameter takes effect only if the value of Method is linear.
        # *   Unit: decibel.
        # *   Valid values: less than or equal to 20.
        # *   Default value: -20.
        self.level = level
        # The range of the volume relative to the expected volume.
        # 
        # *   This parameter takes effect only if the value of Method is dynamic.
        # *   Unit: decibel.
        # *   Valid values: [1,20].
        # *   Default value: 8.
        self.loudness_range_target = loudness_range_target
        # The volume adjustment method. Valid values:
        # 
        # *   **auto**\
        # *   **dynamic**\
        # *   **linear**\
        self.method = method
        # The volume adjustment coefficient.
        # 
        # This parameter takes effect only if the value of Method is adaptive.
        # 
        # Valid values: [0,1].
        # 
        # Default value: 0.9.
        self.peak_level = peak_level
        # The peak volume.
        # 
        # *   This parameter takes effect only if the value of Method is dynamic.
        # *   Unit: decibel.
        # *   Valid values: [-9,0].
        # *   Default value: -1.
        self.true_peak = true_peak

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.level is not None:
            result['Level'] = self.level
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.peak_level is not None:
            result['PeakLevel'] = self.peak_level
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('PeakLevel') is not None:
            self.peak_level = m.get('PeakLevel')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class UpdateTemplateResponseBodyTemplateAudio(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        channels: str = None,
        codec: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        samplerate: str = None,
        volume: UpdateTemplateResponseBodyTemplateAudioVolume = None,
    ):
        # The ID of the transcoding template.
        self.bitrate = bitrate
        # The audio bitrate of the output file.
        # 
        # *   Valid values: 8 to 1000.****\
        # *   Unit: Kbit/s.
        # *   Default value: **128**.
        self.channels = channels
        # The sampling rate.
        # 
        # *   Unit: Hz.
        # *   Default value: **44100**.
        self.codec = codec
        # Indicates whether the audio stream is deleted.
        # 
        # *   **true**: The audio stream is deleted.
        # *   **false**: The audio stream is retained.
        # *   Default value: **false**.
        self.profile = profile
        # The number of sound channels. Default value: **2**.
        self.qscale = qscale
        # The audio codec format. Default value: **aac**. Valid values:
        # 
        # *   **aac**\
        # *   **mp3**\
        # *   **vorbis**\
        # *   **flac**\
        self.remove = remove
        # The level of the independent denoising algorithm.
        self.samplerate = samplerate
        # The volume control configurations.
        self.volume = volume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class UpdateTemplateResponseBodyTemplateContainer(TeaModel):
    def __init__(
        self,
        format: str = None,
    ):
        # The container format.
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class UpdateTemplateResponseBodyTemplateMuxConfigGif(TeaModel):
    def __init__(
        self,
        dither_mode: str = None,
        final_delay: str = None,
        is_custom_palette: str = None,
        loop: str = None,
    ):
        # The loop count.
        self.dither_mode = dither_mode
        # The color dithering algorithm of the palette. Valid values: sierra and bayer.
        self.final_delay = final_delay
        # The segment configurations.
        self.is_custom_palette = is_custom_palette
        # Indicates whether the custom palette is used.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dither_mode is not None:
            result['DitherMode'] = self.dither_mode
        if self.final_delay is not None:
            result['FinalDelay'] = self.final_delay
        if self.is_custom_palette is not None:
            result['IsCustomPalette'] = self.is_custom_palette
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DitherMode') is not None:
            self.dither_mode = m.get('DitherMode')
        if m.get('FinalDelay') is not None:
            self.final_delay = m.get('FinalDelay')
        if m.get('IsCustomPalette') is not None:
            self.is_custom_palette = m.get('IsCustomPalette')
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class UpdateTemplateResponseBodyTemplateMuxConfigSegment(TeaModel):
    def __init__(
        self,
        duration: str = None,
    ):
        # The name of the template.
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class UpdateTemplateResponseBodyTemplateMuxConfigWebp(TeaModel):
    def __init__(
        self,
        loop: str = None,
    ):
        # The transmuxing configurations for GIF.
        self.loop = loop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.loop is not None:
            result['Loop'] = self.loop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Loop') is not None:
            self.loop = m.get('Loop')
        return self


class UpdateTemplateResponseBodyTemplateMuxConfig(TeaModel):
    def __init__(
        self,
        gif: UpdateTemplateResponseBodyTemplateMuxConfigGif = None,
        segment: UpdateTemplateResponseBodyTemplateMuxConfigSegment = None,
        webp: UpdateTemplateResponseBodyTemplateMuxConfigWebp = None,
    ):
        # The duration for which the final frame is paused. Unit: milliseconds.
        self.gif = gif
        # The length of the segment. Unit: seconds.
        self.segment = segment
        # The loop count.
        self.webp = webp

    def validate(self):
        if self.gif:
            self.gif.validate()
        if self.segment:
            self.segment.validate()
        if self.webp:
            self.webp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gif is not None:
            result['Gif'] = self.gif.to_map()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        if self.webp is not None:
            result['Webp'] = self.webp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gif') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateMuxConfigGif()
            self.gif = temp_model.from_map(m['Gif'])
        if m.get('Segment') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        if m.get('Webp') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateMuxConfigWebp()
            self.webp = temp_model.from_map(m['Webp'])
        return self


class UpdateTemplateResponseBodyTemplateTransConfig(TeaModel):
    def __init__(
        self,
        adj_dar_method: str = None,
        is_check_audio_bitrate: str = None,
        is_check_audio_bitrate_fail: str = None,
        is_check_reso: str = None,
        is_check_reso_fail: str = None,
        is_check_video_bitrate: str = None,
        is_check_video_bitrate_fail: str = None,
        trans_mode: str = None,
    ):
        # Indicates whether the video bitrate is checked. If this parameter is set to true and the system detects that the video bitrate of the output file is greater than that of the input file, the video bitrate of the input file is retained after transcoding. Valid values:
        # 
        # *   **true**: The video bitrate is checked.
        # *   **false**: The video bitrate is not checked.
        # *   Default value: **false**.
        self.adj_dar_method = adj_dar_method
        # The transcoding mode. Default value: **onepass**. Valid values:
        # 
        # *   **onepass**\
        # *   **twopass**\
        # *   **CBR**\
        self.is_check_audio_bitrate = is_check_audio_bitrate
        # The status of the template. Valid values:
        # 
        # *   **Normal**: The template is normal.
        # *   **Deleted**: The template is deleted.
        self.is_check_audio_bitrate_fail = is_check_audio_bitrate_fail
        # Indicates whether the video bitrate is checked. This parameter has a higher priority than the IsCheckVideoBitrate parameter. Valid values:
        # 
        # *   **true**: The video bitrate is checked
        # *   **false**: The video bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_reso = is_check_reso
        # Indicates whether the audio bitrate is checked. This parameter has a higher priority than the IsCheckAudioBitrate parameter. Valid values:
        # 
        # *   **true**: The audio bitrate is checked.
        # *   **false**: The audio bitrate is not checked.
        # *   Default value: **false**.
        self.is_check_reso_fail = is_check_reso_fail
        # Indicates whether the resolution is checked. If this parameter is set to true and the system detects that the resolution of the output file is higher than that of the input file based on the width or height, an error that indicates a transcoding failure is returned. Valid values:
        # 
        # *   **true**: The resolution is checked.
        # *   **false**: The resolution is not checked.
        # *   Default value: **false**.
        self.is_check_video_bitrate = is_check_video_bitrate
        # The method of resolution adjustment. Default value: **none**. Valid values:
        # 
        # *   rescale: The input video is rescaled.
        # *   crop: The input video is cropped.
        # *   none: No change is made.
        self.is_check_video_bitrate_fail = is_check_video_bitrate_fail
        # Indicates whether the resolution is checked. If the output resolution is higher than the input resolution based on the width or height, the input resolution is retained after transcoding. Valid values:
        # 
        # *   **true**: The resolution is checked.
        # *   **false**: The resolution is not checked.
        # *   Default value: **false**.
        self.trans_mode = trans_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adj_dar_method is not None:
            result['AdjDarMethod'] = self.adj_dar_method
        if self.is_check_audio_bitrate is not None:
            result['IsCheckAudioBitrate'] = self.is_check_audio_bitrate
        if self.is_check_audio_bitrate_fail is not None:
            result['IsCheckAudioBitrateFail'] = self.is_check_audio_bitrate_fail
        if self.is_check_reso is not None:
            result['IsCheckReso'] = self.is_check_reso
        if self.is_check_reso_fail is not None:
            result['IsCheckResoFail'] = self.is_check_reso_fail
        if self.is_check_video_bitrate is not None:
            result['IsCheckVideoBitrate'] = self.is_check_video_bitrate
        if self.is_check_video_bitrate_fail is not None:
            result['IsCheckVideoBitrateFail'] = self.is_check_video_bitrate_fail
        if self.trans_mode is not None:
            result['TransMode'] = self.trans_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdjDarMethod') is not None:
            self.adj_dar_method = m.get('AdjDarMethod')
        if m.get('IsCheckAudioBitrate') is not None:
            self.is_check_audio_bitrate = m.get('IsCheckAudioBitrate')
        if m.get('IsCheckAudioBitrateFail') is not None:
            self.is_check_audio_bitrate_fail = m.get('IsCheckAudioBitrateFail')
        if m.get('IsCheckReso') is not None:
            self.is_check_reso = m.get('IsCheckReso')
        if m.get('IsCheckResoFail') is not None:
            self.is_check_reso_fail = m.get('IsCheckResoFail')
        if m.get('IsCheckVideoBitrate') is not None:
            self.is_check_video_bitrate = m.get('IsCheckVideoBitrate')
        if m.get('IsCheckVideoBitrateFail') is not None:
            self.is_check_video_bitrate_fail = m.get('IsCheckVideoBitrateFail')
        if m.get('TransMode') is not None:
            self.trans_mode = m.get('TransMode')
        return self


class UpdateTemplateResponseBodyTemplateVideoBitrateBnd(TeaModel):
    def __init__(
        self,
        max: str = None,
        min: str = None,
    ):
        # The lower limit of the total bitrate. Unit: Kbit/s.
        self.max = max
        # The pixel format. Valid values: standard pixel formats such as yuv420p and yuvj420p.
        self.min = min

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class UpdateTemplateResponseBodyTemplateVideoNarrowBand(TeaModel):
    def __init__(
        self,
        abrmax: float = None,
        max_abr_ratio: float = None,
        version: str = None,
    ):
        # The upper limit of the dynamic bitrate. If this parameter is set, the average bitrate is in the range of (0, 1000000].
        self.abrmax = abrmax
        # The maximum ratio of the upper limit of dynamic bitrate. If this parameter is set, the value of Abrmax does not exceed x times of the source video bitrate. Valid values: (0,1.0].
        self.max_abr_ratio = max_abr_ratio
        # The Narrowband HD version. Only 1.0 may be returned.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abrmax is not None:
            result['Abrmax'] = self.abrmax
        if self.max_abr_ratio is not None:
            result['MaxAbrRatio'] = self.max_abr_ratio
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Abrmax') is not None:
            self.abrmax = m.get('Abrmax')
        if m.get('MaxAbrRatio') is not None:
            self.max_abr_ratio = m.get('MaxAbrRatio')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class UpdateTemplateResponseBodyTemplateVideo(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        bitrate_bnd: UpdateTemplateResponseBodyTemplateVideoBitrateBnd = None,
        bufsize: str = None,
        codec: str = None,
        crf: str = None,
        crop: str = None,
        degrain: str = None,
        fps: str = None,
        gop: str = None,
        hdr_2sdr: str = None,
        height: str = None,
        long_short_mode: str = None,
        max_fps: str = None,
        maxrate: str = None,
        narrow_band: UpdateTemplateResponseBodyTemplateVideoNarrowBand = None,
        pad: str = None,
        pix_fmt: str = None,
        preset: str = None,
        profile: str = None,
        qscale: str = None,
        remove: str = None,
        reso_priority: str = None,
        scan_mode: str = None,
        width: str = None,
    ):
        # The maximum bitrate of the video. Unit: Kbit/s.
        self.bitrate = bitrate
        # The upper limit of the total bitrate. Unit: Kbit/s.
        self.bitrate_bnd = bitrate_bnd
        # The level of quality control on the video.
        self.bufsize = bufsize
        # The height of the output video.
        # 
        # *   Unit: pixel.
        # *   Default value: the height of the input video.
        self.codec = codec
        # Indicates whether the video stream is deleted. Valid values:
        # 
        # *   **true**: The video stream is deleted.
        # *   **false**: The video stream is retained.
        # *   Default value: **false**.
        self.crf = crf
        # The average bitrate of the video. Unit: Kbit/s.
        self.crop = crop
        # The average bitrate range of the video.
        self.degrain = degrain
        # The preset video algorithm. Default value: **medium**. Valid values:
        # 
        # *   **veryfast**\
        # *   **fast**\
        # *   **medium**\
        # *   **slow**\
        # *   **slower**\
        self.fps = fps
        # The width of the video.
        # 
        # *   Unit: pixel.
        # *   Default value: **the width of the input video**.
        self.gop = gop
        # Indicates whether the HDR2SDR conversion feature is enabled. If this feature is enabled, high dynamic range (HDR) videos are transcoded to standard dynamic range (SDR) videos.
        self.hdr_2sdr = hdr_2sdr
        # The level of the independent denoising algorithm.
        self.height = height
        # The size of the buffer.
        # 
        # *   Unit: KB.
        # *   Default value: **6000**.
        self.long_short_mode = long_short_mode
        # The encoding profile. Valid values:
        # 
        # *   **baseline**: applicable to mobile devices.
        # *   **main**: applicable to standard-definition devices.
        # *   **high**: applicable to high-definition devices.
        # *   Default value: **high**.
        self.max_fps = max_fps
        # The maximum frame rate.
        self.maxrate = maxrate
        # The Narrowband HD settings.
        self.narrow_band = narrow_band
        # The video codec. Default value: **H.264**.
        self.pad = pad
        # The black borders added to the video.
        # 
        # *   Format: width:height:left:top.
        # *   Example: 1280:800:0:140.
        self.pix_fmt = pix_fmt
        # The scan mode. Valid values:
        # 
        # *   **interlaced**: An interlaced scan is performed.
        # *   **progressive**: A progressive scan is performed.
        self.preset = preset
        # The bitrate quality control factor.
        # 
        # *   Default value if the Codec parameter is set to H.264: **23**. Default value if the Codec parameter is set to H.265: **26**.
        # *   If this parameter is returned, the setting of the Bitrate parameter is invalid.
        self.profile = profile
        # The method used to crop the video.
        # 
        # *   **border**: automatically detects and removes borders.
        # *   Value in the width:height:left:top format: crops the video based on custom settings.**** Example: 1280:800:0:140.
        self.qscale = qscale
        # The maximum number of frames between two keyframes. Default value: **250**.
        self.remove = remove
        # The general transcoding configurations.
        self.reso_priority = reso_priority
        # The policy of resolution adjustment.
        self.scan_mode = scan_mode
        # The frame rate.
        # 
        # *   A value of 60 is returned if the frame rate of the input video exceeds 60.
        # *   Default value: the frame rate of the input video.
        self.width = width

    def validate(self):
        if self.bitrate_bnd:
            self.bitrate_bnd.validate()
        if self.narrow_band:
            self.narrow_band.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bitrate_bnd is not None:
            result['BitrateBnd'] = self.bitrate_bnd.to_map()
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.degrain is not None:
            result['Degrain'] = self.degrain
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.hdr_2sdr is not None:
            result['Hdr2sdr'] = self.hdr_2sdr
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.max_fps is not None:
            result['MaxFps'] = self.max_fps
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.narrow_band is not None:
            result['NarrowBand'] = self.narrow_band.to_map()
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.qscale is not None:
            result['Qscale'] = self.qscale
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.reso_priority is not None:
            result['ResoPriority'] = self.reso_priority
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BitrateBnd') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateVideoBitrateBnd()
            self.bitrate_bnd = temp_model.from_map(m['BitrateBnd'])
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Degrain') is not None:
            self.degrain = m.get('Degrain')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Hdr2sdr') is not None:
            self.hdr_2sdr = m.get('Hdr2sdr')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('MaxFps') is not None:
            self.max_fps = m.get('MaxFps')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('NarrowBand') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateVideoNarrowBand()
            self.narrow_band = temp_model.from_map(m['NarrowBand'])
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Qscale') is not None:
            self.qscale = m.get('Qscale')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ResoPriority') is not None:
            self.reso_priority = m.get('ResoPriority')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateTemplateResponseBodyTemplate(TeaModel):
    def __init__(
        self,
        audio: UpdateTemplateResponseBodyTemplateAudio = None,
        container: UpdateTemplateResponseBodyTemplateContainer = None,
        id: str = None,
        mux_config: UpdateTemplateResponseBodyTemplateMuxConfig = None,
        name: str = None,
        state: str = None,
        trans_config: UpdateTemplateResponseBodyTemplateTransConfig = None,
        video: UpdateTemplateResponseBodyTemplateVideo = None,
    ):
        # The audio codec settings.
        self.audio = audio
        # The container format.
        self.container = container
        # The container configurations.
        self.id = id
        # The transmuxing configurations for WebP.
        self.mux_config = mux_config
        # The audio codec configurations.
        self.name = name
        # The transmuxing configurations.
        self.state = state
        # Indicates whether the audio bitrate is checked. If the bitrate of the output audio is greater than the bitrate of the input audio, the bitrate of the input audio is retained after transcoding. In this case, the specified audio bitrate does not take effect. This parameter has a lower priority than the IsCheckAudioBitrateFail parameter. Valid values:
        # 
        # *   **true**: The audio bitrate is checked.
        # 
        # *   **false**: The audio bitrate is not checked.
        # 
        # *   Default value:
        # 
        #     *   If the parameter is left empty and the codec of the output audio is different from that of the input audio, the default value is false.
        #     *   If the parameter is left empty and the codec of the output audio is the same as that of the input audio, the default value is true.
        self.trans_config = trans_config
        # The video codec configurations.
        self.video = video

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.trans_config:
            self.trans_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.trans_config is not None:
            result['TransConfig'] = self.trans_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MuxConfig') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TransConfig') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateTransConfig()
            self.trans_config = temp_model.from_map(m['TransConfig'])
        if m.get('Video') is not None:
            temp_model = UpdateTemplateResponseBodyTemplateVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class UpdateTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template: UpdateTemplateResponseBodyTemplate = None,
    ):
        # The type of the transcoding template.
        self.request_id = request_id
        # The type of the transcoding template.
        self.template = template

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = UpdateTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class UpdateTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWaterMarkTemplateRequest(TeaModel):
    def __init__(
        self,
        config: str = None,
        name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        resource_owner_account: str = None,
        resource_owner_id: int = None,
        water_mark_template_id: str = None,
    ):
        # The updated configuration of the watermark template. The value is a JSON object. For more information, see [Parameter details](https://help.aliyun.com/document_detail/29253.html).
        # 
        # This parameter is required.
        self.config = config
        # The new name of the watermark template. The value can contain letters and digits and can be up to 128 bytes in size.
        # 
        # This parameter is required.
        self.name = name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.resource_owner_account = resource_owner_account
        self.resource_owner_id = resource_owner_id
        # The ID of the watermark template that you want to update. To obtain the ID of the watermark template, you can log on to the **ApsaraVideo Media Processing (MPS) console** and choose **Global Settings** > **Watermark Templates** in the left-side navigation pane.
        # 
        # This parameter is required.
        self.water_mark_template_id = water_mark_template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.water_mark_template_id is not None:
            result['WaterMarkTemplateId'] = self.water_mark_template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('WaterMarkTemplateId') is not None:
            self.water_mark_template_id = m.get('WaterMarkTemplateId')
        return self


class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        width: str = None,
    ):
        # The horizontal offset of the watermark relative to the output video image. Default value: **0**. The default value indicates no offset. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the vertical offset. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the horizontal offset to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.dx = dx
        # The vertical offset of the watermark relative to the output video image. Default value: **0**. The default value indicates no offset. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the vertical offset. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the vertical offset to the height of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.dy = dy
        # The height of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the height of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the height of the watermark image to the height of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.height = height
        # The width of the watermark image in the output video. The value can be an integer or a decimal.
        # 
        # *   **Integer**: the width of the watermark image. This indicates the absolute position. Unit: pixel.
        # *   **Decimal**: the ratio of the width of the watermark image to the width of the output video. The ratio varies based on the size of the video. Four decimal places are supported, such as 0.9999. More decimal places are discarded.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(TeaModel):
    def __init__(
        self,
        duration: str = None,
        start: str = None,
    ):
        # The display duration of the watermark. Default value: **ToEND**. The default value indicates that the watermark is displayed until the video ends.
        self.duration = duration
        # The beginning of the time range during which the watermark is displayed.
        # 
        # *   Unit: seconds.
        # *   Default value: **0**.
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate(TeaModel):
    def __init__(
        self,
        dx: str = None,
        dy: str = None,
        height: str = None,
        id: str = None,
        name: str = None,
        ratio_refer: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer = None,
        refer_pos: str = None,
        state: str = None,
        timeline: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline = None,
        type: str = None,
        width: str = None,
    ):
        # The horizontal offset. Unit: pixel.
        self.dx = dx
        # The vertical offset. Unit: pixel.
        self.dy = dy
        # The height of the watermark image. Unit: pixel.
        self.height = height
        # The ID of the watermark template. We recommend that you keep this ID for subsequent operation calls.
        self.id = id
        # The name of the watermark template.
        self.name = name
        # The values of the Height, Width, Dx, and Dy parameters relative to the reference edges. If the values of the Height, Width, Dx, and Dy parameters are decimals between 0 and 1, the values are calculated by referring to the following edges in sequence:
        # 
        # *   **Width**: the width edge.
        # *   **Height**: the height edge.
        # *   **Long**: the long edge.
        # *   **Short**: the short edge.
        self.ratio_refer = ratio_refer
        # The position of the watermark. Valid values:
        # 
        # *   **TopRight**: the upper-right corner.
        # *   **TopLeft**: the upper-left corner.
        # *   **BottomRight**: the lower-right corner.
        # *   **BottomLeft**: the lower-left corner.
        self.refer_pos = refer_pos
        # The status of the watermark template. Default value: **Normal**.
        self.state = state
        # The timeline of the watermark.
        self.timeline = timeline
        # The type of the watermark. Valid values:
        # 
        # *   Image: an image watermark.
        # *   Text: a text watermark.
        # 
        # > Only watermarks of the Image type are supported.
        self.type = type
        # The width of the watermark image. Unit: pixel.
        self.width = width

    def validate(self):
        if self.ratio_refer:
            self.ratio_refer.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.height is not None:
            result['Height'] = self.height
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.ratio_refer is not None:
            result['RatioRefer'] = self.ratio_refer.to_map()
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.state is not None:
            result['State'] = self.state
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RatioRefer') is not None:
            temp_model = UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer()
            self.ratio_refer = temp_model.from_map(m['RatioRefer'])
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Timeline') is not None:
            temp_model = UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateWaterMarkTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        water_mark_template: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The details of the watermark template.
        self.water_mark_template = water_mark_template

    def validate(self):
        if self.water_mark_template:
            self.water_mark_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.water_mark_template is not None:
            result['WaterMarkTemplate'] = self.water_mark_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WaterMarkTemplate') is not None:
            temp_model = UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate()
            self.water_mark_template = temp_model.from_map(m['WaterMarkTemplate'])
        return self


class UpdateWaterMarkTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWaterMarkTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWaterMarkTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


