# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class DataQualityEvaluationTaskHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        self.condition = condition
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.extension = extension
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class DataQualityEvaluationTaskNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers] = None,
    ):
        self.notification_channels = notification_channels
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class DataQualityEvaluationTaskNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[DataQualityEvaluationTaskNotificationsNotifications] = None,
    ):
        self.condition = condition
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = DataQualityEvaluationTaskNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class DataQualityEvaluationTaskTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        self.task_ids = task_ids
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTask(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        description: str = None,
        hooks: List[DataQualityEvaluationTaskHooks] = None,
        id: int = None,
        name: str = None,
        notifications: List[DataQualityEvaluationTaskNotifications] = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: DataQualityEvaluationTaskTarget = None,
        tenant_id: int = None,
        trigger: DataQualityEvaluationTaskTrigger = None,
    ):
        self.data_source_id = data_source_id
        self.description = description
        self.hooks = hooks
        self.id = id
        self.name = name
        self.notifications = notifications
        self.project_id = project_id
        self.runtime_conf = runtime_conf
        self.target = target
        self.tenant_id = tenant_id
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = DataQualityEvaluationTaskHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = DataQualityEvaluationTaskNotifications()
                self.notifications.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = DataQualityEvaluationTaskTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Trigger') is not None:
            temp_model = DataQualityEvaluationTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class DataQualityEvaluationTaskInstanceTaskHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        self.condition = condition
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.extension = extension
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class DataQualityEvaluationTaskInstanceTaskNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers] = None,
    ):
        self.notification_channels = notification_channels
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class DataQualityEvaluationTaskInstanceTaskNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[DataQualityEvaluationTaskInstanceTaskNotificationsNotifications] = None,
    ):
        self.condition = condition
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = DataQualityEvaluationTaskInstanceTaskNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class DataQualityEvaluationTaskInstanceTaskTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskInstanceTaskTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        self.task_ids = task_ids
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskInstanceTask(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        hooks: List[DataQualityEvaluationTaskInstanceTaskHooks] = None,
        id: int = None,
        name: str = None,
        notifications: List[DataQualityEvaluationTaskInstanceTaskNotifications] = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: DataQualityEvaluationTaskInstanceTaskTarget = None,
        tenant_id: int = None,
        trigger: DataQualityEvaluationTaskInstanceTaskTrigger = None,
    ):
        self.data_source_id = data_source_id
        self.hooks = hooks
        self.id = id
        self.name = name
        self.notifications = notifications
        self.project_id = project_id
        self.runtime_conf = runtime_conf
        self.target = target
        self.tenant_id = tenant_id
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = DataQualityEvaluationTaskInstanceTaskHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = DataQualityEvaluationTaskInstanceTaskNotifications()
                self.notifications.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = DataQualityEvaluationTaskInstanceTaskTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Trigger') is not None:
            temp_model = DataQualityEvaluationTaskInstanceTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class DataQualityEvaluationTaskInstance(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        finish_time: int = None,
        id: int = None,
        status: str = None,
        task: DataQualityEvaluationTaskInstanceTask = None,
    ):
        self.create_time = create_time
        self.finish_time = finish_time
        self.id = id
        self.status = status
        self.task = task

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Task') is not None:
            temp_model = DataQualityEvaluationTaskInstanceTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class DataQualityResultDetails(TeaModel):
    def __init__(
        self,
        checked_value: str = None,
        referenced_value: str = None,
        status: str = None,
    ):
        self.checked_value = checked_value
        self.referenced_value = referenced_value
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checked_value is not None:
            result['CheckedValue'] = self.checked_value
        if self.referenced_value is not None:
            result['ReferencedValue'] = self.referenced_value
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckedValue') is not None:
            self.checked_value = m.get('CheckedValue')
        if m.get('ReferencedValue') is not None:
            self.referenced_value = m.get('ReferencedValue')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DataQualityResultRuleCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityResultRuleCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityResultRuleCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityResultRuleCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: DataQualityResultRuleCheckingConfigThresholdsCritical = None,
        expected: DataQualityResultRuleCheckingConfigThresholdsExpected = None,
        warned: DataQualityResultRuleCheckingConfigThresholdsWarned = None,
    ):
        self.critical = critical
        self.expected = expected
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = DataQualityResultRuleCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = DataQualityResultRuleCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = DataQualityResultRuleCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class DataQualityResultRuleCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: DataQualityResultRuleCheckingConfigThresholds = None,
        type: str = None,
    ):
        self.referenced_samples_filter = referenced_samples_filter
        self.thresholds = thresholds
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = DataQualityResultRuleCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityResultRuleErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        self.error_data_filter = error_data_filter
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityResultRuleSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        self.metric = metric
        self.metric_parameters = metric_parameters
        self.sampling_filter = sampling_filter
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class DataQualityResultRuleTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityResultRule(TeaModel):
    def __init__(
        self,
        checking_config: DataQualityResultRuleCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[DataQualityResultRuleErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: DataQualityResultRuleSamplingConfig = None,
        severity: str = None,
        target: DataQualityResultRuleTarget = None,
        template_code: str = None,
        tenant_id: int = None,
    ):
        self.checking_config = checking_config
        self.description = description
        self.enabled = enabled
        self.error_handlers = error_handlers
        self.id = id
        self.name = name
        self.project_id = project_id
        self.sampling_config = sampling_config
        self.severity = severity
        self.target = target
        self.template_code = template_code
        self.tenant_id = tenant_id

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = DataQualityResultRuleCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = DataQualityResultRuleErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = DataQualityResultRuleSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = DataQualityResultRuleTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DataQualityResult(TeaModel):
    def __init__(
        self,
        details: List[DataQualityResultDetails] = None,
        id: int = None,
        rule: DataQualityResultRule = None,
        sample: str = None,
        status: str = None,
        task_instance_id: int = None,
    ):
        self.details = details
        self.id = id
        self.rule = rule
        self.sample = sample
        self.status = status
        self.task_instance_id = task_instance_id

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()
        if self.rule:
            self.rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.rule is not None:
            result['Rule'] = self.rule.to_map()
        if self.sample is not None:
            result['Sample'] = self.sample
        if self.status is not None:
            result['Status'] = self.status
        if self.task_instance_id is not None:
            result['TaskInstanceId'] = self.task_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = DataQualityResultDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Rule') is not None:
            temp_model = DataQualityResultRule()
            self.rule = temp_model.from_map(m['Rule'])
        if m.get('Sample') is not None:
            self.sample = m.get('Sample')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskInstanceId') is not None:
            self.task_instance_id = m.get('TaskInstanceId')
        return self


class DataQualityRuleCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityRuleCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityRuleCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityRuleCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: DataQualityRuleCheckingConfigThresholdsCritical = None,
        expected: DataQualityRuleCheckingConfigThresholdsExpected = None,
        warned: DataQualityRuleCheckingConfigThresholdsWarned = None,
    ):
        self.critical = critical
        self.expected = expected
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = DataQualityRuleCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = DataQualityRuleCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = DataQualityRuleCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class DataQualityRuleCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: DataQualityRuleCheckingConfigThresholds = None,
        type: str = None,
    ):
        self.referenced_samples_filter = referenced_samples_filter
        self.thresholds = thresholds
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = DataQualityRuleCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityRuleErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        self.error_data_filter = error_data_filter
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityRuleSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        self.metric = metric
        self.metric_parameters = metric_parameters
        self.sampling_filter = sampling_filter
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class DataQualityRuleTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityRule(TeaModel):
    def __init__(
        self,
        checking_config: DataQualityRuleCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[DataQualityRuleErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: DataQualityRuleSamplingConfig = None,
        severity: str = None,
        target: DataQualityRuleTarget = None,
        template_code: str = None,
        tenant_id: int = None,
    ):
        self.checking_config = checking_config
        self.description = description
        self.enabled = enabled
        self.error_handlers = error_handlers
        self.id = id
        self.name = name
        self.project_id = project_id
        self.sampling_config = sampling_config
        self.severity = severity
        self.target = target
        self.template_code = template_code
        self.tenant_id = tenant_id

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = DataQualityRuleCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = DataQualityRuleErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = DataQualityRuleSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = DataQualityRuleTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class SuccessInfoValue(TeaModel):
    def __init__(
        self,
        success: bool = None,
        message: str = None,
    ):
        self.success = success
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class AbolishDeploymentRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the process.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class AbolishDeploymentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AbolishDeploymentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbolishDeploymentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbolishDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssociateProjectToResourceGroupRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        resource_group_id: str = None,
    ):
        # The ID of the DataWorks workspace with which you want to associate the resource group.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class AssociateProjectToResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AssociateProjectToResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AssociateProjectToResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssociateProjectToResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloneDataSourceRequest(TeaModel):
    def __init__(
        self,
        clone_data_source_name: str = None,
        id: int = None,
    ):
        self.clone_data_source_name = clone_data_source_name
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clone_data_source_name is not None:
            result['CloneDataSourceName'] = self.clone_data_source_name
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CloneDataSourceName') is not None:
            self.clone_data_source_name = m.get('CloneDataSourceName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class CloneDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        self.id = id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CloneDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloneDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloneDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertRuleRequestNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.extension = extension
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class CreateAlertRuleRequestNotification(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        interval_in_minutes: int = None,
        maximum: int = None,
        receivers: List[CreateAlertRuleRequestNotificationReceivers] = None,
        silence_end_time: str = None,
        silence_start_time: str = None,
    ):
        # This parameter is required.
        self.channels = channels
        self.interval_in_minutes = interval_in_minutes
        self.maximum = maximum
        # This parameter is required.
        self.receivers = receivers
        self.silence_end_time = silence_end_time
        self.silence_start_time = silence_start_time

    def validate(self):
        if self.receivers:
            for k in self.receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.interval_in_minutes is not None:
            result['IntervalInMinutes'] = self.interval_in_minutes
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        result['Receivers'] = []
        if self.receivers is not None:
            for k in self.receivers:
                result['Receivers'].append(k.to_map() if k else None)
        if self.silence_end_time is not None:
            result['SilenceEndTime'] = self.silence_end_time
        if self.silence_start_time is not None:
            result['SilenceStartTime'] = self.silence_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('IntervalInMinutes') is not None:
            self.interval_in_minutes = m.get('IntervalInMinutes')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        self.receivers = []
        if m.get('Receivers') is not None:
            for k in m.get('Receivers'):
                temp_model = CreateAlertRuleRequestNotificationReceivers()
                self.receivers.append(temp_model.from_map(k))
        if m.get('SilenceEndTime') is not None:
            self.silence_end_time = m.get('SilenceEndTime')
        if m.get('SilenceStartTime') is not None:
            self.silence_start_time = m.get('SilenceStartTime')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime(TeaModel):
    def __init__(
        self,
        cycle_id: int = None,
        time: str = None,
    ):
        self.cycle_id = cycle_id
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_id is not None:
            result['CycleId'] = self.cycle_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleId') is not None:
            self.cycle_id = m.get('CycleId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished(TeaModel):
    def __init__(
        self,
        cycle_and_time: List[CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime] = None,
    ):
        self.cycle_and_time = cycle_and_time

    def validate(self):
        if self.cycle_and_time:
            for k in self.cycle_and_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleAndTime'] = []
        if self.cycle_and_time is not None:
            for k in self.cycle_and_time:
                result['CycleAndTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_and_time = []
        if m.get('CycleAndTime') is not None:
            for k in m.get('CycleAndTime'):
                temp_model = CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime()
                self.cycle_and_time.append(temp_model.from_map(k))
        return self


class CreateAlertRuleRequestTriggerConditionExtensionError(TeaModel):
    def __init__(
        self,
        auto_rerun_alert: bool = None,
        stream_task_ids: List[int] = None,
    ):
        self.auto_rerun_alert = auto_rerun_alert
        self.stream_task_ids = stream_task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_alert is not None:
            result['AutoRerunAlert'] = self.auto_rerun_alert
        if self.stream_task_ids is not None:
            result['StreamTaskIds'] = self.stream_task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunAlert') is not None:
            self.auto_rerun_alert = m.get('AutoRerunAlert')
        if m.get('StreamTaskIds') is not None:
            self.stream_task_ids = m.get('StreamTaskIds')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount(TeaModel):
    def __init__(
        self,
        count: int = None,
    ):
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage(TeaModel):
    def __init__(
        self,
        percentage: int = None,
    ):
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate(TeaModel):
    def __init__(
        self,
        percentage: int = None,
        trend: str = None,
    ):
        self.percentage = percentage
        self.trend = trend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.trend is not None:
            result['Trend'] = self.trend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Trend') is not None:
            self.trend = m.get('Trend')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionTimeout(TeaModel):
    def __init__(
        self,
        timeout_in_minutes: int = None,
    ):
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionUnFinished(TeaModel):
    def __init__(
        self,
        un_finished_time: str = None,
    ):
        self.un_finished_time = un_finished_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.un_finished_time is not None:
            result['UnFinishedTime'] = self.un_finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UnFinishedTime') is not None:
            self.un_finished_time = m.get('UnFinishedTime')
        return self


class CreateAlertRuleRequestTriggerConditionExtension(TeaModel):
    def __init__(
        self,
        cycle_unfinished: CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished = None,
        error: CreateAlertRuleRequestTriggerConditionExtensionError = None,
        instance_error_count: CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount = None,
        instance_error_percentage: CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage = None,
        instance_transfer_fluctuate: CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate = None,
        timeout: CreateAlertRuleRequestTriggerConditionExtensionTimeout = None,
        un_finished: CreateAlertRuleRequestTriggerConditionExtensionUnFinished = None,
    ):
        self.cycle_unfinished = cycle_unfinished
        self.error = error
        self.instance_error_count = instance_error_count
        self.instance_error_percentage = instance_error_percentage
        self.instance_transfer_fluctuate = instance_transfer_fluctuate
        self.timeout = timeout
        self.un_finished = un_finished

    def validate(self):
        if self.cycle_unfinished:
            self.cycle_unfinished.validate()
        if self.error:
            self.error.validate()
        if self.instance_error_count:
            self.instance_error_count.validate()
        if self.instance_error_percentage:
            self.instance_error_percentage.validate()
        if self.instance_transfer_fluctuate:
            self.instance_transfer_fluctuate.validate()
        if self.timeout:
            self.timeout.validate()
        if self.un_finished:
            self.un_finished.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_unfinished is not None:
            result['CycleUnfinished'] = self.cycle_unfinished.to_map()
        if self.error is not None:
            result['Error'] = self.error.to_map()
        if self.instance_error_count is not None:
            result['InstanceErrorCount'] = self.instance_error_count.to_map()
        if self.instance_error_percentage is not None:
            result['InstanceErrorPercentage'] = self.instance_error_percentage.to_map()
        if self.instance_transfer_fluctuate is not None:
            result['InstanceTransferFluctuate'] = self.instance_transfer_fluctuate.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        if self.un_finished is not None:
            result['UnFinished'] = self.un_finished.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleUnfinished') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished()
            self.cycle_unfinished = temp_model.from_map(m['CycleUnfinished'])
        if m.get('Error') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionError()
            self.error = temp_model.from_map(m['Error'])
        if m.get('InstanceErrorCount') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount()
            self.instance_error_count = temp_model.from_map(m['InstanceErrorCount'])
        if m.get('InstanceErrorPercentage') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage()
            self.instance_error_percentage = temp_model.from_map(m['InstanceErrorPercentage'])
        if m.get('InstanceTransferFluctuate') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate()
            self.instance_transfer_fluctuate = temp_model.from_map(m['InstanceTransferFluctuate'])
        if m.get('Timeout') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        if m.get('UnFinished') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionUnFinished()
            self.un_finished = temp_model.from_map(m['UnFinished'])
        return self


class CreateAlertRuleRequestTriggerConditionTarget(TeaModel):
    def __init__(
        self,
        allow_tasks: List[int] = None,
        ids: List[int] = None,
        type: str = None,
    ):
        self.allow_tasks = allow_tasks
        self.ids = ids
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_tasks is not None:
            result['AllowTasks'] = self.allow_tasks
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowTasks') is not None:
            self.allow_tasks = m.get('AllowTasks')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateAlertRuleRequestTriggerCondition(TeaModel):
    def __init__(
        self,
        extension: CreateAlertRuleRequestTriggerConditionExtension = None,
        target: CreateAlertRuleRequestTriggerConditionTarget = None,
        type: str = None,
    ):
        self.extension = extension
        self.target = target
        self.type = type

    def validate(self):
        if self.extension:
            self.extension.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Target') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateAlertRuleRequest(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        name: str = None,
        notification: CreateAlertRuleRequestNotification = None,
        owner: str = None,
        trigger_condition: CreateAlertRuleRequestTriggerCondition = None,
    ):
        # This parameter is required.
        self.enabled = enabled
        # This parameter is required.
        self.name = name
        self.notification = notification
        # This parameter is required.
        self.owner = owner
        # This parameter is required.
        self.trigger_condition = trigger_condition

    def validate(self):
        if self.notification:
            self.notification.validate()
        if self.trigger_condition:
            self.trigger_condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.name is not None:
            result['Name'] = self.name
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition is not None:
            result['TriggerCondition'] = self.trigger_condition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            temp_model = CreateAlertRuleRequestNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            temp_model = CreateAlertRuleRequestTriggerCondition()
            self.trigger_condition = temp_model.from_map(m['TriggerCondition'])
        return self


class CreateAlertRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        name: str = None,
        notification_shrink: str = None,
        owner: str = None,
        trigger_condition_shrink: str = None,
    ):
        # This parameter is required.
        self.enabled = enabled
        # This parameter is required.
        self.name = name
        self.notification_shrink = notification_shrink
        # This parameter is required.
        self.owner = owner
        # This parameter is required.
        self.trigger_condition_shrink = trigger_condition_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_shrink is not None:
            result['Notification'] = self.notification_shrink
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition_shrink is not None:
            result['TriggerCondition'] = self.trigger_condition_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            self.notification_shrink = m.get('Notification')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            self.trigger_condition_shrink = m.get('TriggerCondition')
        return self


class CreateAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        self.id = id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        severity: str = None,
    ):
        self.channels = channels
        self.severity = severity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers(TeaModel):
    def __init__(
        self,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class CreateDIAlarmRuleRequestNotificationSettings(TeaModel):
    def __init__(
        self,
        inhibition_interval: int = None,
        notification_channels: List[CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels] = None,
        notification_receivers: List[CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers] = None,
    ):
        self.inhibition_interval = inhibition_interval
        self.notification_channels = notification_channels
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inhibition_interval is not None:
            result['InhibitionInterval'] = self.inhibition_interval
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InhibitionInterval') is not None:
            self.inhibition_interval = m.get('InhibitionInterval')
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class CreateDIAlarmRuleRequestTriggerConditions(TeaModel):
    def __init__(
        self,
        ddl_report_tags: List[str] = None,
        duration: int = None,
        severity: str = None,
        threshold: int = None,
    ):
        self.ddl_report_tags = ddl_report_tags
        self.duration = duration
        self.severity = severity
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ddl_report_tags is not None:
            result['DdlReportTags'] = self.ddl_report_tags
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DdlReportTags') is not None:
            self.ddl_report_tags = m.get('DdlReportTags')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class CreateDIAlarmRuleRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        metric_type: str = None,
        name: str = None,
        notification_settings: CreateDIAlarmRuleRequestNotificationSettings = None,
        trigger_conditions: List[CreateDIAlarmRuleRequestTriggerConditions] = None,
    ):
        self.client_token = client_token
        # IDID
        # 
        # This parameter is required.
        self.dijob_id = dijob_id
        # 
        self.description = description
        # 
        self.enabled = enabled
        # 
        # - Heartbeat
        # - FailoverCountfailover
        # - Delay
        # 
        # This parameter is required.
        self.metric_type = metric_type
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.notification_settings = notification_settings
        # This parameter is required.
        self.trigger_conditions = trigger_conditions

    def validate(self):
        if self.notification_settings:
            self.notification_settings.validate()
        if self.trigger_conditions:
            for k in self.trigger_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings is not None:
            result['NotificationSettings'] = self.notification_settings.to_map()
        result['TriggerConditions'] = []
        if self.trigger_conditions is not None:
            for k in self.trigger_conditions:
                result['TriggerConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            temp_model = CreateDIAlarmRuleRequestNotificationSettings()
            self.notification_settings = temp_model.from_map(m['NotificationSettings'])
        self.trigger_conditions = []
        if m.get('TriggerConditions') is not None:
            for k in m.get('TriggerConditions'):
                temp_model = CreateDIAlarmRuleRequestTriggerConditions()
                self.trigger_conditions.append(temp_model.from_map(k))
        return self


class CreateDIAlarmRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        metric_type: str = None,
        name: str = None,
        notification_settings_shrink: str = None,
        trigger_conditions_shrink: str = None,
    ):
        self.client_token = client_token
        # IDID
        # 
        # This parameter is required.
        self.dijob_id = dijob_id
        # 
        self.description = description
        # 
        self.enabled = enabled
        # 
        # - Heartbeat
        # - FailoverCountfailover
        # - Delay
        # 
        # This parameter is required.
        self.metric_type = metric_type
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.notification_settings_shrink = notification_settings_shrink
        # This parameter is required.
        self.trigger_conditions_shrink = trigger_conditions_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings_shrink is not None:
            result['NotificationSettings'] = self.notification_settings_shrink
        if self.trigger_conditions_shrink is not None:
            result['TriggerConditions'] = self.trigger_conditions_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            self.notification_settings_shrink = m.get('NotificationSettings')
        if m.get('TriggerConditions') is not None:
            self.trigger_conditions_shrink = m.get('TriggerConditions')
        return self


class CreateDIAlarmRuleResponseBody(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: str = None,
        request_id: str = None,
    ):
        # ID
        self.dialarm_rule_id = dialarm_rule_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDIAlarmRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDIAlarmRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDIAlarmRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDIJobRequestDestinationDataSourceSettings(TeaModel):
    def __init__(
        self,
        data_source_name: str = None,
    ):
        self.data_source_name = data_source_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        return self


class CreateDIJobRequestJobSettingsColumnDataTypeSettings(TeaModel):
    def __init__(
        self,
        destination_data_type: str = None,
        source_data_type: str = None,
    ):
        self.destination_data_type = destination_data_type
        self.source_data_type = source_data_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_data_type is not None:
            result['DestinationDataType'] = self.destination_data_type
        if self.source_data_type is not None:
            result['SourceDataType'] = self.source_data_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDataType') is not None:
            self.destination_data_type = m.get('DestinationDataType')
        if m.get('SourceDataType') is not None:
            self.source_data_type = m.get('SourceDataType')
        return self


class CreateDIJobRequestJobSettingsCycleScheduleSettings(TeaModel):
    def __init__(
        self,
        cycle_migration_type: str = None,
        schedule_parameters: str = None,
    ):
        self.cycle_migration_type = cycle_migration_type
        self.schedule_parameters = schedule_parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_migration_type is not None:
            result['CycleMigrationType'] = self.cycle_migration_type
        if self.schedule_parameters is not None:
            result['ScheduleParameters'] = self.schedule_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleMigrationType') is not None:
            self.cycle_migration_type = m.get('CycleMigrationType')
        if m.get('ScheduleParameters') is not None:
            self.schedule_parameters = m.get('ScheduleParameters')
        return self


class CreateDIJobRequestJobSettingsDdlHandlingSettings(TeaModel):
    def __init__(
        self,
        action: str = None,
        type: str = None,
    ):
        self.action = action
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDIJobRequestJobSettingsRuntimeSettings(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDIJobRequestJobSettings(TeaModel):
    def __init__(
        self,
        channel_settings: str = None,
        column_data_type_settings: List[CreateDIJobRequestJobSettingsColumnDataTypeSettings] = None,
        cycle_schedule_settings: CreateDIJobRequestJobSettingsCycleScheduleSettings = None,
        ddl_handling_settings: List[CreateDIJobRequestJobSettingsDdlHandlingSettings] = None,
        runtime_settings: List[CreateDIJobRequestJobSettingsRuntimeSettings] = None,
    ):
        self.channel_settings = channel_settings
        self.column_data_type_settings = column_data_type_settings
        self.cycle_schedule_settings = cycle_schedule_settings
        self.ddl_handling_settings = ddl_handling_settings
        self.runtime_settings = runtime_settings

    def validate(self):
        if self.column_data_type_settings:
            for k in self.column_data_type_settings:
                if k:
                    k.validate()
        if self.cycle_schedule_settings:
            self.cycle_schedule_settings.validate()
        if self.ddl_handling_settings:
            for k in self.ddl_handling_settings:
                if k:
                    k.validate()
        if self.runtime_settings:
            for k in self.runtime_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_settings is not None:
            result['ChannelSettings'] = self.channel_settings
        result['ColumnDataTypeSettings'] = []
        if self.column_data_type_settings is not None:
            for k in self.column_data_type_settings:
                result['ColumnDataTypeSettings'].append(k.to_map() if k else None)
        if self.cycle_schedule_settings is not None:
            result['CycleScheduleSettings'] = self.cycle_schedule_settings.to_map()
        result['DdlHandlingSettings'] = []
        if self.ddl_handling_settings is not None:
            for k in self.ddl_handling_settings:
                result['DdlHandlingSettings'].append(k.to_map() if k else None)
        result['RuntimeSettings'] = []
        if self.runtime_settings is not None:
            for k in self.runtime_settings:
                result['RuntimeSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelSettings') is not None:
            self.channel_settings = m.get('ChannelSettings')
        self.column_data_type_settings = []
        if m.get('ColumnDataTypeSettings') is not None:
            for k in m.get('ColumnDataTypeSettings'):
                temp_model = CreateDIJobRequestJobSettingsColumnDataTypeSettings()
                self.column_data_type_settings.append(temp_model.from_map(k))
        if m.get('CycleScheduleSettings') is not None:
            temp_model = CreateDIJobRequestJobSettingsCycleScheduleSettings()
            self.cycle_schedule_settings = temp_model.from_map(m['CycleScheduleSettings'])
        self.ddl_handling_settings = []
        if m.get('DdlHandlingSettings') is not None:
            for k in m.get('DdlHandlingSettings'):
                temp_model = CreateDIJobRequestJobSettingsDdlHandlingSettings()
                self.ddl_handling_settings.append(temp_model.from_map(k))
        self.runtime_settings = []
        if m.get('RuntimeSettings') is not None:
            for k in m.get('RuntimeSettings'):
                temp_model = CreateDIJobRequestJobSettingsRuntimeSettings()
                self.runtime_settings.append(temp_model.from_map(k))
        return self


class CreateDIJobRequestResourceSettingsOfflineResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class CreateDIJobRequestResourceSettingsRealtimeResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class CreateDIJobRequestResourceSettingsScheduleResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class CreateDIJobRequestResourceSettings(TeaModel):
    def __init__(
        self,
        offline_resource_settings: CreateDIJobRequestResourceSettingsOfflineResourceSettings = None,
        realtime_resource_settings: CreateDIJobRequestResourceSettingsRealtimeResourceSettings = None,
        schedule_resource_settings: CreateDIJobRequestResourceSettingsScheduleResourceSettings = None,
    ):
        self.offline_resource_settings = offline_resource_settings
        self.realtime_resource_settings = realtime_resource_settings
        self.schedule_resource_settings = schedule_resource_settings

    def validate(self):
        if self.offline_resource_settings:
            self.offline_resource_settings.validate()
        if self.realtime_resource_settings:
            self.realtime_resource_settings.validate()
        if self.schedule_resource_settings:
            self.schedule_resource_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offline_resource_settings is not None:
            result['OfflineResourceSettings'] = self.offline_resource_settings.to_map()
        if self.realtime_resource_settings is not None:
            result['RealtimeResourceSettings'] = self.realtime_resource_settings.to_map()
        if self.schedule_resource_settings is not None:
            result['ScheduleResourceSettings'] = self.schedule_resource_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OfflineResourceSettings') is not None:
            temp_model = CreateDIJobRequestResourceSettingsOfflineResourceSettings()
            self.offline_resource_settings = temp_model.from_map(m['OfflineResourceSettings'])
        if m.get('RealtimeResourceSettings') is not None:
            temp_model = CreateDIJobRequestResourceSettingsRealtimeResourceSettings()
            self.realtime_resource_settings = temp_model.from_map(m['RealtimeResourceSettings'])
        if m.get('ScheduleResourceSettings') is not None:
            temp_model = CreateDIJobRequestResourceSettingsScheduleResourceSettings()
            self.schedule_resource_settings = temp_model.from_map(m['ScheduleResourceSettings'])
        return self


class CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties(TeaModel):
    def __init__(
        self,
        encoding: str = None,
        timezone: str = None,
    ):
        self.encoding = encoding
        self.timezone = timezone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        return self


class CreateDIJobRequestSourceDataSourceSettings(TeaModel):
    def __init__(
        self,
        data_source_name: str = None,
        data_source_properties: CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties = None,
    ):
        self.data_source_name = data_source_name
        self.data_source_properties = data_source_properties

    def validate(self):
        if self.data_source_properties:
            self.data_source_properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        if self.data_source_properties is not None:
            result['DataSourceProperties'] = self.data_source_properties.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        if m.get('DataSourceProperties') is not None:
            temp_model = CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties()
            self.data_source_properties = temp_model.from_map(m['DataSourceProperties'])
        return self


class CreateDIJobRequestTableMappingsSourceObjectSelectionRules(TeaModel):
    def __init__(
        self,
        action: str = None,
        expression: str = None,
        expression_type: str = None,
        object_type: str = None,
    ):
        self.action = action
        self.expression = expression
        self.expression_type = expression_type
        self.object_type = object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.expression_type is not None:
            result['ExpressionType'] = self.expression_type
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('ExpressionType') is not None:
            self.expression_type = m.get('ExpressionType')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        return self


class CreateDIJobRequestTableMappingsTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        self.rule_action_type = rule_action_type
        self.rule_name = rule_name
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class CreateDIJobRequestTableMappings(TeaModel):
    def __init__(
        self,
        source_object_selection_rules: List[CreateDIJobRequestTableMappingsSourceObjectSelectionRules] = None,
        transformation_rules: List[CreateDIJobRequestTableMappingsTransformationRules] = None,
    ):
        self.source_object_selection_rules = source_object_selection_rules
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.source_object_selection_rules:
            for k in self.source_object_selection_rules:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SourceObjectSelectionRules'] = []
        if self.source_object_selection_rules is not None:
            for k in self.source_object_selection_rules:
                result['SourceObjectSelectionRules'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.source_object_selection_rules = []
        if m.get('SourceObjectSelectionRules') is not None:
            for k in m.get('SourceObjectSelectionRules'):
                temp_model = CreateDIJobRequestTableMappingsSourceObjectSelectionRules()
                self.source_object_selection_rules.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = CreateDIJobRequestTableMappingsTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class CreateDIJobRequestTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_expression: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        self.rule_action_type = rule_action_type
        self.rule_expression = rule_expression
        self.rule_name = rule_name
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_expression is not None:
            result['RuleExpression'] = self.rule_expression
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleExpression') is not None:
            self.rule_expression = m.get('RuleExpression')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class CreateDIJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        destination_data_source_settings: List[CreateDIJobRequestDestinationDataSourceSettings] = None,
        destination_data_source_type: str = None,
        job_name: str = None,
        job_settings: CreateDIJobRequestJobSettings = None,
        migration_type: str = None,
        project_id: int = None,
        resource_settings: CreateDIJobRequestResourceSettings = None,
        source_data_source_settings: List[CreateDIJobRequestSourceDataSourceSettings] = None,
        source_data_source_type: str = None,
        table_mappings: List[CreateDIJobRequestTableMappings] = None,
        transformation_rules: List[CreateDIJobRequestTransformationRules] = None,
    ):
        self.description = description
        # This parameter is required.
        self.destination_data_source_settings = destination_data_source_settings
        # This parameter is required.
        self.destination_data_source_type = destination_data_source_type
        # This parameter is required.
        self.job_name = job_name
        self.job_settings = job_settings
        # This parameter is required.
        self.migration_type = migration_type
        self.project_id = project_id
        # This parameter is required.
        self.resource_settings = resource_settings
        # This parameter is required.
        self.source_data_source_settings = source_data_source_settings
        # This parameter is required.
        self.source_data_source_type = source_data_source_type
        # This parameter is required.
        self.table_mappings = table_mappings
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.destination_data_source_settings:
            for k in self.destination_data_source_settings:
                if k:
                    k.validate()
        if self.job_settings:
            self.job_settings.validate()
        if self.resource_settings:
            self.resource_settings.validate()
        if self.source_data_source_settings:
            for k in self.source_data_source_settings:
                if k:
                    k.validate()
        if self.table_mappings:
            for k in self.table_mappings:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['DestinationDataSourceSettings'] = []
        if self.destination_data_source_settings is not None:
            for k in self.destination_data_source_settings:
                result['DestinationDataSourceSettings'].append(k.to_map() if k else None)
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.job_settings is not None:
            result['JobSettings'] = self.job_settings.to_map()
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings is not None:
            result['ResourceSettings'] = self.resource_settings.to_map()
        result['SourceDataSourceSettings'] = []
        if self.source_data_source_settings is not None:
            for k in self.source_data_source_settings:
                result['SourceDataSourceSettings'].append(k.to_map() if k else None)
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        result['TableMappings'] = []
        if self.table_mappings is not None:
            for k in self.table_mappings:
                result['TableMappings'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.destination_data_source_settings = []
        if m.get('DestinationDataSourceSettings') is not None:
            for k in m.get('DestinationDataSourceSettings'):
                temp_model = CreateDIJobRequestDestinationDataSourceSettings()
                self.destination_data_source_settings.append(temp_model.from_map(k))
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('JobSettings') is not None:
            temp_model = CreateDIJobRequestJobSettings()
            self.job_settings = temp_model.from_map(m['JobSettings'])
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            temp_model = CreateDIJobRequestResourceSettings()
            self.resource_settings = temp_model.from_map(m['ResourceSettings'])
        self.source_data_source_settings = []
        if m.get('SourceDataSourceSettings') is not None:
            for k in m.get('SourceDataSourceSettings'):
                temp_model = CreateDIJobRequestSourceDataSourceSettings()
                self.source_data_source_settings.append(temp_model.from_map(k))
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        self.table_mappings = []
        if m.get('TableMappings') is not None:
            for k in m.get('TableMappings'):
                temp_model = CreateDIJobRequestTableMappings()
                self.table_mappings.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = CreateDIJobRequestTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class CreateDIJobShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        destination_data_source_settings_shrink: str = None,
        destination_data_source_type: str = None,
        job_name: str = None,
        job_settings_shrink: str = None,
        migration_type: str = None,
        project_id: int = None,
        resource_settings_shrink: str = None,
        source_data_source_settings_shrink: str = None,
        source_data_source_type: str = None,
        table_mappings_shrink: str = None,
        transformation_rules_shrink: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.destination_data_source_settings_shrink = destination_data_source_settings_shrink
        # This parameter is required.
        self.destination_data_source_type = destination_data_source_type
        # This parameter is required.
        self.job_name = job_name
        self.job_settings_shrink = job_settings_shrink
        # This parameter is required.
        self.migration_type = migration_type
        self.project_id = project_id
        # This parameter is required.
        self.resource_settings_shrink = resource_settings_shrink
        # This parameter is required.
        self.source_data_source_settings_shrink = source_data_source_settings_shrink
        # This parameter is required.
        self.source_data_source_type = source_data_source_type
        # This parameter is required.
        self.table_mappings_shrink = table_mappings_shrink
        self.transformation_rules_shrink = transformation_rules_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.destination_data_source_settings_shrink is not None:
            result['DestinationDataSourceSettings'] = self.destination_data_source_settings_shrink
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.job_settings_shrink is not None:
            result['JobSettings'] = self.job_settings_shrink
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings_shrink is not None:
            result['ResourceSettings'] = self.resource_settings_shrink
        if self.source_data_source_settings_shrink is not None:
            result['SourceDataSourceSettings'] = self.source_data_source_settings_shrink
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        if self.table_mappings_shrink is not None:
            result['TableMappings'] = self.table_mappings_shrink
        if self.transformation_rules_shrink is not None:
            result['TransformationRules'] = self.transformation_rules_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestinationDataSourceSettings') is not None:
            self.destination_data_source_settings_shrink = m.get('DestinationDataSourceSettings')
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('JobSettings') is not None:
            self.job_settings_shrink = m.get('JobSettings')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            self.resource_settings_shrink = m.get('ResourceSettings')
        if m.get('SourceDataSourceSettings') is not None:
            self.source_data_source_settings_shrink = m.get('SourceDataSourceSettings')
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        if m.get('TableMappings') is not None:
            self.table_mappings_shrink = m.get('TableMappings')
        if m.get('TransformationRules') is not None:
            self.transformation_rules_shrink = m.get('TransformationRules')
        return self


class CreateDIJobResponseBody(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        request_id: str = None,
    ):
        self.dijob_id = dijob_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataSourceRequest(TeaModel):
    def __init__(
        self,
        connection_properties: str = None,
        connection_properties_mode: str = None,
        description: str = None,
        name: str = None,
        project_id: int = None,
        type: str = None,
    ):
        # This parameter is required.
        self.connection_properties = connection_properties
        # This parameter is required.
        self.connection_properties_mode = connection_properties_mode
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.project_id = project_id
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_properties is not None:
            result['ConnectionProperties'] = self.connection_properties
        if self.connection_properties_mode is not None:
            result['ConnectionPropertiesMode'] = self.connection_properties_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionProperties') is not None:
            self.connection_properties = m.get('ConnectionProperties')
        if m.get('ConnectionPropertiesMode') is not None:
            self.connection_properties_mode = m.get('ConnectionPropertiesMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        self.id = id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataSourceSharedRuleRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        env_type: str = None,
        shared_user: str = None,
        target_project_id: int = None,
    ):
        # This parameter is required.
        self.data_source_id = data_source_id
        # This parameter is required.
        self.env_type = env_type
        self.shared_user = shared_user
        # This parameter is required.
        self.target_project_id = target_project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.shared_user is not None:
            result['SharedUser'] = self.shared_user
        if self.target_project_id is not None:
            result['TargetProjectId'] = self.target_project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('SharedUser') is not None:
            self.shared_user = m.get('SharedUser')
        if m.get('TargetProjectId') is not None:
            self.target_project_id = m.get('TargetProjectId')
        return self


class CreateDataSourceSharedRuleResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        self.id = id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDataSourceSharedRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataSourceSharedRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataSourceSharedRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDeploymentRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        object_ids: List[str] = None,
        project_id: str = None,
        type: str = None,
    ):
        # The description of the process.
        self.description = description
        # The IDs of entities to which you want to apply the process.
        # 
        # >  A process can be applied to only a single entity and its child entities. If you specify multiple entities in the array, the process is applied only to the first entity in the array and its child entities. Make sure that the array in your request contains only one element. Extra elements will be ignored.
        # 
        # This parameter is required.
        self.object_ids = object_ids
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # Specifies whether to deploy or undeploy the entity. Valid values:
        # 
        # *   Online: deploys the entity.
        # *   Offline: undeploys the entity.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.object_ids is not None:
            result['ObjectIds'] = self.object_ids
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ObjectIds') is not None:
            self.object_ids = m.get('ObjectIds')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDeploymentShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        object_ids_shrink: str = None,
        project_id: str = None,
        type: str = None,
    ):
        # The description of the process.
        self.description = description
        # The IDs of entities to which you want to apply the process.
        # 
        # >  A process can be applied to only a single entity and its child entities. If you specify multiple entities in the array, the process is applied only to the first entity in the array and its child entities. Make sure that the array in your request contains only one element. Extra elements will be ignored.
        # 
        # This parameter is required.
        self.object_ids_shrink = object_ids_shrink
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # Specifies whether to deploy or undeploy the entity. Valid values:
        # 
        # *   Online: deploys the entity.
        # *   Offline: undeploys the entity.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.object_ids_shrink is not None:
            result['ObjectIds'] = self.object_ids_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ObjectIds') is not None:
            self.object_ids_shrink = m.get('ObjectIds')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDeploymentResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        # The ID of the process.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDeploymentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDeploymentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFunctionRequest(TeaModel):
    def __init__(
        self,
        project_id: str = None,
        spec: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the UDF. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateFunctionResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        # The ID of the UDF.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        resource_group_id: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # This parameter is required.
        self.client_token = client_token
        # This parameter is required.
        self.resource_group_id = resource_group_id
        # This parameter is required.
        self.vpc_id = vpc_id
        # This parameter is required.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class CreateNetworkResponseBody(TeaModel):
    def __init__(
        self,
        network_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.network_id = network_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNodeRequest(TeaModel):
    def __init__(
        self,
        container_id: str = None,
        project_id: str = None,
        scene: str = None,
        spec: str = None,
    ):
        # The container ID. If you want to create a node in a container, you must configure this parameter to specify the container. The container can be a workflow or a node in a container.
        # 
        # >  If you configure this parameter, the path field defined in FlowSpec becomes invalid.
        self.container_id = container_id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The scene of the node. This parameter determines the location (the DataStudio pane or the Manual pane) of the node. You can set this parameter to DATAWORKS_MANUAL_WORKFLOW only if the ContainerId parameter is configured and the container specified by ContainerId is a manually triggered workflow.
        # 
        # Valid values:
        # 
        # *   DATAWORKS_PROJECT
        # *   DATAWORKS_MANUAL_WORKFLOW
        # *   DATAWORKS_MANUAL_TASK
        # 
        # This parameter is required.
        self.scene = scene
        # The FlowSpec field information about the node. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateNodeResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        # The ID of the node.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProjectRequestAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateProjectRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[CreateProjectRequestAliyunResourceTags] = None,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        name: str = None,
        pai_task_enabled: bool = None,
    ):
        self.aliyun_resource_group_id = aliyun_resource_group_id
        self.aliyun_resource_tags = aliyun_resource_tags
        self.description = description
        self.dev_environment_enabled = dev_environment_enabled
        self.dev_role_disabled = dev_role_disabled
        # This parameter is required.
        self.display_name = display_name
        # This parameter is required.
        self.name = name
        self.pai_task_enabled = pai_task_enabled

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.name is not None:
            result['Name'] = self.name
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = CreateProjectRequestAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        return self


class CreateProjectShrinkRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags_shrink: str = None,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        name: str = None,
        pai_task_enabled: bool = None,
    ):
        self.aliyun_resource_group_id = aliyun_resource_group_id
        self.aliyun_resource_tags_shrink = aliyun_resource_tags_shrink
        self.description = description
        self.dev_environment_enabled = dev_environment_enabled
        self.dev_role_disabled = dev_role_disabled
        # This parameter is required.
        self.display_name = display_name
        # This parameter is required.
        self.name = name
        self.pai_task_enabled = pai_task_enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        if self.aliyun_resource_tags_shrink is not None:
            result['AliyunResourceTags'] = self.aliyun_resource_tags_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.name is not None:
            result['Name'] = self.name
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        if m.get('AliyunResourceTags') is not None:
            self.aliyun_resource_tags_shrink = m.get('AliyunResourceTags')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        return self


class CreateProjectResponseBody(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        request_id: str = None,
    ):
        self.project_id = project_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProjectMemberRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes: List[str] = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.project_id = project_id
        # This parameter is required.
        self.role_codes = role_codes
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes is not None:
            result['RoleCodes'] = self.role_codes
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateProjectMemberShrinkRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes_shrink: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.project_id = project_id
        # This parameter is required.
        self.role_codes_shrink = role_codes_shrink
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes_shrink is not None:
            result['RoleCodes'] = self.role_codes_shrink
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes_shrink = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateProjectMemberResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateProjectMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProjectMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProjectMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateResourceRequest(TeaModel):
    def __init__(
        self,
        project_id: str = None,
        spec: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the file resource. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateResourceResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        # The ID of the file resource.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateResourceGroupRequest(TeaModel):
    def __init__(
        self,
        auto_renew: bool = None,
        client_token: str = None,
        name: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        payment_type: str = None,
        remark: str = None,
        spec: int = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        self.auto_renew = auto_renew
        # This parameter is required.
        self.client_token = client_token
        # This parameter is required.
        self.name = name
        self.payment_duration = payment_duration
        self.payment_duration_unit = payment_duration_unit
        # This parameter is required.
        self.payment_type = payment_type
        self.remark = remark
        self.spec = spec
        # This parameter is required.
        self.vpc_id = vpc_id
        # This parameter is required.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.name is not None:
            result['Name'] = self.name
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class CreateResourceGroupResponseBodyResourceGroupOrder(TeaModel):
    def __init__(
        self,
        id: str = None,
        order_id: int = None,
        order_instance_id: str = None,
    ):
        self.id = id
        self.order_id = order_id
        self.order_instance_id = order_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.order_instance_id is not None:
            result['OrderInstanceId'] = self.order_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('OrderInstanceId') is not None:
            self.order_instance_id = m.get('OrderInstanceId')
        return self


class CreateResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource_group_order: CreateResourceGroupResponseBodyResourceGroupOrder = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.resource_group_order = resource_group_order
        self.success = success

    def validate(self):
        if self.resource_group_order:
            self.resource_group_order.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_order is not None:
            result['ResourceGroupOrder'] = self.resource_group_order.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupOrder') is not None:
            temp_model = CreateResourceGroupResponseBodyResourceGroupOrder()
            self.resource_group_order = temp_model.from_map(m['ResourceGroupOrder'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRouteRequest(TeaModel):
    def __init__(
        self,
        destination_cidr: str = None,
        network_id: int = None,
    ):
        # This parameter is required.
        self.destination_cidr = destination_cidr
        # This parameter is required.
        self.network_id = network_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_cidr is not None:
            result['DestinationCidr'] = self.destination_cidr
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationCidr') is not None:
            self.destination_cidr = m.get('DestinationCidr')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        return self


class CreateRouteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        route_id: int = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.route_id = route_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        project_id: str = None,
        spec: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the workflow. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow/).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        # The ID of the workflow.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertRuleRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDIAlarmRuleRequest(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        dijob_id: int = None,
    ):
        # The ID of the alert rule.
        self.dialarm_rule_id = dialarm_rule_id
        # The ID of the synchronization task.
        self.dijob_id = dijob_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        return self


class DeleteDIAlarmRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDIAlarmRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDIAlarmRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDIAlarmRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        project_id: int = None,
    ):
        # This parameter is required.
        self.dijob_id = dijob_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteDIJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataSourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataSourceSharedRuleRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteDataSourceSharedRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataSourceSharedRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataSourceSharedRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataSourceSharedRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFunctionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteFunctionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteNetworkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNodeRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteNodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # true\\
        # false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProjectRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteProjectResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProjectMemberRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the account used by the member in the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=openapi-amp.newDocPublishment.0.0.51d7281fjgBRmo), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the ID of the account used by the member in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DeleteProjectMemberResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteProjectMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProjectMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProjectMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteResourceRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteResourceGroupRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRouteRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteRouteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_env: str = None,
    ):
        # This parameter is required.
        self.id = id
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class DeleteTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DissociateProjectFromResourceGroupRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        resource_group_id: str = None,
    ):
        # The ID of the workspace from which you want to disassociate the resource group.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class DissociateProjectFromResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DissociateProjectFromResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DissociateProjectFromResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DissociateProjectFromResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecDeploymentStageRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
        id: str = None,
        project_id: str = None,
    ):
        # The code of the stage in the process. You can call the GetDeployment operation to query the code.
        # 
        # This parameter is required.
        self.code = code
        # The ID of the process.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ExecDeploymentStageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # 
        # *   false
        # 
        #     **\
        # 
        #     **Note:** The value of this parameter indicates only whether the stage is triggered but does not indicate whether the execution of the stage is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecDeploymentStageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecDeploymentStageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecDeploymentStageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAlertRuleRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetAlertRuleResponseBodyAlertRuleNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.extension = extension
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class GetAlertRuleResponseBodyAlertRuleNotification(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        interval_in_minutes: int = None,
        maximum: int = None,
        receivers: List[GetAlertRuleResponseBodyAlertRuleNotificationReceivers] = None,
        silence_end_time: str = None,
        silence_start_time: str = None,
    ):
        self.channels = channels
        self.interval_in_minutes = interval_in_minutes
        self.maximum = maximum
        self.receivers = receivers
        self.silence_end_time = silence_end_time
        self.silence_start_time = silence_start_time

    def validate(self):
        if self.receivers:
            for k in self.receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.interval_in_minutes is not None:
            result['IntervalInMinutes'] = self.interval_in_minutes
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        result['Receivers'] = []
        if self.receivers is not None:
            for k in self.receivers:
                result['Receivers'].append(k.to_map() if k else None)
        if self.silence_end_time is not None:
            result['SilenceEndTime'] = self.silence_end_time
        if self.silence_start_time is not None:
            result['SilenceStartTime'] = self.silence_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('IntervalInMinutes') is not None:
            self.interval_in_minutes = m.get('IntervalInMinutes')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        self.receivers = []
        if m.get('Receivers') is not None:
            for k in m.get('Receivers'):
                temp_model = GetAlertRuleResponseBodyAlertRuleNotificationReceivers()
                self.receivers.append(temp_model.from_map(k))
        if m.get('SilenceEndTime') is not None:
            self.silence_end_time = m.get('SilenceEndTime')
        if m.get('SilenceStartTime') is not None:
            self.silence_start_time = m.get('SilenceStartTime')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime(TeaModel):
    def __init__(
        self,
        cycle_id: int = None,
        time: str = None,
    ):
        self.cycle_id = cycle_id
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_id is not None:
            result['CycleId'] = self.cycle_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleId') is not None:
            self.cycle_id = m.get('CycleId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished(TeaModel):
    def __init__(
        self,
        cycle_and_time: List[GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime] = None,
    ):
        self.cycle_and_time = cycle_and_time

    def validate(self):
        if self.cycle_and_time:
            for k in self.cycle_and_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleAndTime'] = []
        if self.cycle_and_time is not None:
            for k in self.cycle_and_time:
                result['CycleAndTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_and_time = []
        if m.get('CycleAndTime') is not None:
            for k in m.get('CycleAndTime'):
                temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime()
                self.cycle_and_time.append(temp_model.from_map(k))
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError(TeaModel):
    def __init__(
        self,
        auto_rerun_alert: bool = None,
        stream_task_ids: List[int] = None,
    ):
        self.auto_rerun_alert = auto_rerun_alert
        self.stream_task_ids = stream_task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_alert is not None:
            result['AutoRerunAlert'] = self.auto_rerun_alert
        if self.stream_task_ids is not None:
            result['StreamTaskIds'] = self.stream_task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunAlert') is not None:
            self.auto_rerun_alert = m.get('AutoRerunAlert')
        if m.get('StreamTaskIds') is not None:
            self.stream_task_ids = m.get('StreamTaskIds')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount(TeaModel):
    def __init__(
        self,
        count: int = None,
    ):
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage(TeaModel):
    def __init__(
        self,
        percentage: int = None,
    ):
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate(TeaModel):
    def __init__(
        self,
        percentage: int = None,
        trend: str = None,
    ):
        self.percentage = percentage
        self.trend = trend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.trend is not None:
            result['Trend'] = self.trend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Trend') is not None:
            self.trend = m.get('Trend')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout(TeaModel):
    def __init__(
        self,
        timeout_in_minutes: int = None,
    ):
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished(TeaModel):
    def __init__(
        self,
        un_finished_time: str = None,
    ):
        self.un_finished_time = un_finished_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.un_finished_time is not None:
            result['UnFinishedTime'] = self.un_finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UnFinishedTime') is not None:
            self.un_finished_time = m.get('UnFinishedTime')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension(TeaModel):
    def __init__(
        self,
        cycle_unfinished: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished = None,
        error: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError = None,
        instance_error_count: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount = None,
        instance_error_percentage: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage = None,
        instance_transfer_fluctuate: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate = None,
        timeout: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout = None,
        un_finished: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished = None,
    ):
        self.cycle_unfinished = cycle_unfinished
        self.error = error
        self.instance_error_count = instance_error_count
        self.instance_error_percentage = instance_error_percentage
        self.instance_transfer_fluctuate = instance_transfer_fluctuate
        self.timeout = timeout
        self.un_finished = un_finished

    def validate(self):
        if self.cycle_unfinished:
            self.cycle_unfinished.validate()
        if self.error:
            self.error.validate()
        if self.instance_error_count:
            self.instance_error_count.validate()
        if self.instance_error_percentage:
            self.instance_error_percentage.validate()
        if self.instance_transfer_fluctuate:
            self.instance_transfer_fluctuate.validate()
        if self.timeout:
            self.timeout.validate()
        if self.un_finished:
            self.un_finished.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_unfinished is not None:
            result['CycleUnfinished'] = self.cycle_unfinished.to_map()
        if self.error is not None:
            result['Error'] = self.error.to_map()
        if self.instance_error_count is not None:
            result['InstanceErrorCount'] = self.instance_error_count.to_map()
        if self.instance_error_percentage is not None:
            result['InstanceErrorPercentage'] = self.instance_error_percentage.to_map()
        if self.instance_transfer_fluctuate is not None:
            result['InstanceTransferFluctuate'] = self.instance_transfer_fluctuate.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        if self.un_finished is not None:
            result['UnFinished'] = self.un_finished.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleUnfinished') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished()
            self.cycle_unfinished = temp_model.from_map(m['CycleUnfinished'])
        if m.get('Error') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError()
            self.error = temp_model.from_map(m['Error'])
        if m.get('InstanceErrorCount') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount()
            self.instance_error_count = temp_model.from_map(m['InstanceErrorCount'])
        if m.get('InstanceErrorPercentage') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage()
            self.instance_error_percentage = temp_model.from_map(m['InstanceErrorPercentage'])
        if m.get('InstanceTransferFluctuate') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate()
            self.instance_transfer_fluctuate = temp_model.from_map(m['InstanceTransferFluctuate'])
        if m.get('Timeout') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        if m.get('UnFinished') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished()
            self.un_finished = temp_model.from_map(m['UnFinished'])
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget(TeaModel):
    def __init__(
        self,
        allow_tasks: List[int] = None,
        ids: List[int] = None,
        type: str = None,
    ):
        self.allow_tasks = allow_tasks
        self.ids = ids
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_tasks is not None:
            result['AllowTasks'] = self.allow_tasks
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowTasks') is not None:
            self.allow_tasks = m.get('AllowTasks')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerCondition(TeaModel):
    def __init__(
        self,
        extension: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension = None,
        target: GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget = None,
        type: str = None,
    ):
        self.extension = extension
        self.target = target
        self.type = type

    def validate(self):
        if self.extension:
            self.extension.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Target') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetAlertRuleResponseBodyAlertRule(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        id: int = None,
        name: str = None,
        notification: GetAlertRuleResponseBodyAlertRuleNotification = None,
        owner: str = None,
        trigger_condition: GetAlertRuleResponseBodyAlertRuleTriggerCondition = None,
    ):
        self.enabled = enabled
        self.id = id
        self.name = name
        self.notification = notification
        self.owner = owner
        self.trigger_condition = trigger_condition

    def validate(self):
        if self.notification:
            self.notification.validate()
        if self.trigger_condition:
            self.trigger_condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition is not None:
            result['TriggerCondition'] = self.trigger_condition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerCondition()
            self.trigger_condition = temp_model.from_map(m['TriggerCondition'])
        return self


class GetAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        alert_rule: GetAlertRuleResponseBodyAlertRule = None,
        request_id: str = None,
    ):
        self.alert_rule = alert_rule
        self.request_id = request_id

    def validate(self):
        if self.alert_rule:
            self.alert_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule is not None:
            result['AlertRule'] = self.alert_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertRule') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRule()
            self.alert_rule = temp_model.from_map(m['AlertRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        project_id: int = None,
        with_details: bool = None,
    ):
        self.dijob_id = dijob_id
        self.project_id = project_id
        self.with_details = with_details

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.with_details is not None:
            result['WithDetails'] = self.with_details
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WithDetails') is not None:
            self.with_details = m.get('WithDetails')
        return self


class GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings(TeaModel):
    def __init__(
        self,
        data_source_name: str = None,
    ):
        self.data_source_name = data_source_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        return self


class GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings(TeaModel):
    def __init__(
        self,
        destination_data_type: str = None,
        source_data_type: str = None,
    ):
        self.destination_data_type = destination_data_type
        self.source_data_type = source_data_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_data_type is not None:
            result['DestinationDataType'] = self.destination_data_type
        if self.source_data_type is not None:
            result['SourceDataType'] = self.source_data_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDataType') is not None:
            self.destination_data_type = m.get('DestinationDataType')
        if m.get('SourceDataType') is not None:
            self.source_data_type = m.get('SourceDataType')
        return self


class GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings(TeaModel):
    def __init__(
        self,
        cycle_migration_type: str = None,
        schedule_parameters: str = None,
    ):
        self.cycle_migration_type = cycle_migration_type
        self.schedule_parameters = schedule_parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_migration_type is not None:
            result['CycleMigrationType'] = self.cycle_migration_type
        if self.schedule_parameters is not None:
            result['ScheduleParameters'] = self.schedule_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleMigrationType') is not None:
            self.cycle_migration_type = m.get('CycleMigrationType')
        if m.get('ScheduleParameters') is not None:
            self.schedule_parameters = m.get('ScheduleParameters')
        return self


class GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings(TeaModel):
    def __init__(
        self,
        action: str = None,
        type: str = None,
    ):
        self.action = action
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDIJobResponseBodyPagingInfoJobSettings(TeaModel):
    def __init__(
        self,
        channel_settings: str = None,
        column_data_type_settings: List[GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings] = None,
        cycle_schedule_settings: GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings = None,
        ddl_handling_settings: List[GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings] = None,
        runtime_settings: List[GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings] = None,
    ):
        self.channel_settings = channel_settings
        self.column_data_type_settings = column_data_type_settings
        self.cycle_schedule_settings = cycle_schedule_settings
        self.ddl_handling_settings = ddl_handling_settings
        self.runtime_settings = runtime_settings

    def validate(self):
        if self.column_data_type_settings:
            for k in self.column_data_type_settings:
                if k:
                    k.validate()
        if self.cycle_schedule_settings:
            self.cycle_schedule_settings.validate()
        if self.ddl_handling_settings:
            for k in self.ddl_handling_settings:
                if k:
                    k.validate()
        if self.runtime_settings:
            for k in self.runtime_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_settings is not None:
            result['ChannelSettings'] = self.channel_settings
        result['ColumnDataTypeSettings'] = []
        if self.column_data_type_settings is not None:
            for k in self.column_data_type_settings:
                result['ColumnDataTypeSettings'].append(k.to_map() if k else None)
        if self.cycle_schedule_settings is not None:
            result['CycleScheduleSettings'] = self.cycle_schedule_settings.to_map()
        result['DdlHandlingSettings'] = []
        if self.ddl_handling_settings is not None:
            for k in self.ddl_handling_settings:
                result['DdlHandlingSettings'].append(k.to_map() if k else None)
        result['RuntimeSettings'] = []
        if self.runtime_settings is not None:
            for k in self.runtime_settings:
                result['RuntimeSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelSettings') is not None:
            self.channel_settings = m.get('ChannelSettings')
        self.column_data_type_settings = []
        if m.get('ColumnDataTypeSettings') is not None:
            for k in m.get('ColumnDataTypeSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings()
                self.column_data_type_settings.append(temp_model.from_map(k))
        if m.get('CycleScheduleSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings()
            self.cycle_schedule_settings = temp_model.from_map(m['CycleScheduleSettings'])
        self.ddl_handling_settings = []
        if m.get('DdlHandlingSettings') is not None:
            for k in m.get('DdlHandlingSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings()
                self.ddl_handling_settings.append(temp_model.from_map(k))
        self.runtime_settings = []
        if m.get('RuntimeSettings') is not None:
            for k in m.get('RuntimeSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings()
                self.runtime_settings.append(temp_model.from_map(k))
        return self


class GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class GetDIJobResponseBodyPagingInfoResourceSettings(TeaModel):
    def __init__(
        self,
        offline_resource_settings: GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings = None,
        realtime_resource_settings: GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings = None,
        schedule_resource_settings: GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings = None,
    ):
        self.offline_resource_settings = offline_resource_settings
        self.realtime_resource_settings = realtime_resource_settings
        self.schedule_resource_settings = schedule_resource_settings

    def validate(self):
        if self.offline_resource_settings:
            self.offline_resource_settings.validate()
        if self.realtime_resource_settings:
            self.realtime_resource_settings.validate()
        if self.schedule_resource_settings:
            self.schedule_resource_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offline_resource_settings is not None:
            result['OfflineResourceSettings'] = self.offline_resource_settings.to_map()
        if self.realtime_resource_settings is not None:
            result['RealtimeResourceSettings'] = self.realtime_resource_settings.to_map()
        if self.schedule_resource_settings is not None:
            result['ScheduleResourceSettings'] = self.schedule_resource_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OfflineResourceSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings()
            self.offline_resource_settings = temp_model.from_map(m['OfflineResourceSettings'])
        if m.get('RealtimeResourceSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings()
            self.realtime_resource_settings = temp_model.from_map(m['RealtimeResourceSettings'])
        if m.get('ScheduleResourceSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings()
            self.schedule_resource_settings = temp_model.from_map(m['ScheduleResourceSettings'])
        return self


class GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties(TeaModel):
    def __init__(
        self,
        encoding: str = None,
        timezone: str = None,
    ):
        self.encoding = encoding
        self.timezone = timezone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        return self


class GetDIJobResponseBodyPagingInfoSourceDataSourceSettings(TeaModel):
    def __init__(
        self,
        data_source_name: str = None,
        data_source_properties: GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties = None,
    ):
        self.data_source_name = data_source_name
        self.data_source_properties = data_source_properties

    def validate(self):
        if self.data_source_properties:
            self.data_source_properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        if self.data_source_properties is not None:
            result['DataSourceProperties'] = self.data_source_properties.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        if m.get('DataSourceProperties') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties()
            self.data_source_properties = temp_model.from_map(m['DataSourceProperties'])
        return self


class GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules(TeaModel):
    def __init__(
        self,
        action: str = None,
        expression: str = None,
        expression_type: str = None,
        object_type: str = None,
    ):
        self.action = action
        self.expression = expression
        self.expression_type = expression_type
        self.object_type = object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.expression_type is not None:
            result['ExpressionType'] = self.expression_type
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('ExpressionType') is not None:
            self.expression_type = m.get('ExpressionType')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        return self


class GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        self.rule_action_type = rule_action_type
        self.rule_name = rule_name
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class GetDIJobResponseBodyPagingInfoTableMappings(TeaModel):
    def __init__(
        self,
        source_object_selection_rules: List[GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules] = None,
        transformation_rules: List[GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules] = None,
    ):
        self.source_object_selection_rules = source_object_selection_rules
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.source_object_selection_rules:
            for k in self.source_object_selection_rules:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SourceObjectSelectionRules'] = []
        if self.source_object_selection_rules is not None:
            for k in self.source_object_selection_rules:
                result['SourceObjectSelectionRules'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.source_object_selection_rules = []
        if m.get('SourceObjectSelectionRules') is not None:
            for k in m.get('SourceObjectSelectionRules'):
                temp_model = GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules()
                self.source_object_selection_rules.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class GetDIJobResponseBodyPagingInfoTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_expression: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        self.rule_action_type = rule_action_type
        self.rule_expression = rule_expression
        self.rule_name = rule_name
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_expression is not None:
            result['RuleExpression'] = self.rule_expression
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleExpression') is not None:
            self.rule_expression = m.get('RuleExpression')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class GetDIJobResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        dijob_id: str = None,
        description: str = None,
        destination_data_source_settings: List[GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings] = None,
        destination_data_source_type: str = None,
        job_name: str = None,
        job_settings: GetDIJobResponseBodyPagingInfoJobSettings = None,
        job_status: str = None,
        migration_type: str = None,
        project_id: int = None,
        resource_settings: GetDIJobResponseBodyPagingInfoResourceSettings = None,
        source_data_source_settings: List[GetDIJobResponseBodyPagingInfoSourceDataSourceSettings] = None,
        source_data_source_type: str = None,
        table_mappings: List[GetDIJobResponseBodyPagingInfoTableMappings] = None,
        transformation_rules: List[GetDIJobResponseBodyPagingInfoTransformationRules] = None,
    ):
        self.dijob_id = dijob_id
        self.description = description
        self.destination_data_source_settings = destination_data_source_settings
        self.destination_data_source_type = destination_data_source_type
        self.job_name = job_name
        self.job_settings = job_settings
        self.job_status = job_status
        self.migration_type = migration_type
        self.project_id = project_id
        self.resource_settings = resource_settings
        self.source_data_source_settings = source_data_source_settings
        self.source_data_source_type = source_data_source_type
        self.table_mappings = table_mappings
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.destination_data_source_settings:
            for k in self.destination_data_source_settings:
                if k:
                    k.validate()
        if self.job_settings:
            self.job_settings.validate()
        if self.resource_settings:
            self.resource_settings.validate()
        if self.source_data_source_settings:
            for k in self.source_data_source_settings:
                if k:
                    k.validate()
        if self.table_mappings:
            for k in self.table_mappings:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        result['DestinationDataSourceSettings'] = []
        if self.destination_data_source_settings is not None:
            for k in self.destination_data_source_settings:
                result['DestinationDataSourceSettings'].append(k.to_map() if k else None)
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.job_settings is not None:
            result['JobSettings'] = self.job_settings.to_map()
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings is not None:
            result['ResourceSettings'] = self.resource_settings.to_map()
        result['SourceDataSourceSettings'] = []
        if self.source_data_source_settings is not None:
            for k in self.source_data_source_settings:
                result['SourceDataSourceSettings'].append(k.to_map() if k else None)
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        result['TableMappings'] = []
        if self.table_mappings is not None:
            for k in self.table_mappings:
                result['TableMappings'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.destination_data_source_settings = []
        if m.get('DestinationDataSourceSettings') is not None:
            for k in m.get('DestinationDataSourceSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings()
                self.destination_data_source_settings.append(temp_model.from_map(k))
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('JobSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoJobSettings()
            self.job_settings = temp_model.from_map(m['JobSettings'])
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoResourceSettings()
            self.resource_settings = temp_model.from_map(m['ResourceSettings'])
        self.source_data_source_settings = []
        if m.get('SourceDataSourceSettings') is not None:
            for k in m.get('SourceDataSourceSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoSourceDataSourceSettings()
                self.source_data_source_settings.append(temp_model.from_map(k))
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        self.table_mappings = []
        if m.get('TableMappings') is not None:
            for k in m.get('TableMappings'):
                temp_model = GetDIJobResponseBodyPagingInfoTableMappings()
                self.table_mappings.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = GetDIJobResponseBodyPagingInfoTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class GetDIJobResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: GetDIJobResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        # 
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = GetDIJobResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDIJobLogRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        failover_id: int = None,
        instance_id: int = None,
    ):
        # The ID of the synchronization task.
        # 
        # This parameter is required.
        self.dijob_id = dijob_id
        # The failover ID.
        self.failover_id = failover_id
        # The instance ID.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.failover_id is not None:
            result['FailoverId'] = self.failover_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('FailoverId') is not None:
            self.failover_id = m.get('FailoverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class GetDIJobLogResponseBody(TeaModel):
    def __init__(
        self,
        log: str = None,
        request_id: str = None,
    ):
        # The log.
        self.log = log
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log is not None:
            result['Log'] = self.log
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDIJobLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDIJobLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDIJobLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataSourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The data source ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetDataSourceResponseBodyDataSource(TeaModel):
    def __init__(
        self,
        connection_properties: Any = None,
        connection_properties_mode: str = None,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        project_id: int = None,
        qualified_name: str = None,
        type: str = None,
    ):
        # The connection properties of the data source.
        self.connection_properties = connection_properties
        # The mode in which the data source is added. The mode varies based on the data source type. Valid values:
        # 
        # *   InstanceMode: instance mode
        # *   UrlMode: connection string mode
        # *   CdhMode: CDH cluster mode
        self.connection_properties_mode = connection_properties_mode
        # The time when the data source was added. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the user who adds the data source.
        self.create_user = create_user
        # The description of the data source.
        self.description = description
        # The data source ID.
        self.id = id
        # The time when the data source was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The ID of the user who modifies the data source.
        self.modify_user = modify_user
        # The name of the data source.
        self.name = name
        # The ID of the workspace with which the data source is associated.
        self.project_id = project_id
        # The unique business key of the data source. For example, the unique business key of a Hologres data source is in the ${tenantOwnerId}:${regionId}:${type}:${instanceId}:${database} format.
        self.qualified_name = qualified_name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_properties is not None:
            result['ConnectionProperties'] = self.connection_properties
        if self.connection_properties_mode is not None:
            result['ConnectionPropertiesMode'] = self.connection_properties_mode
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.qualified_name is not None:
            result['QualifiedName'] = self.qualified_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionProperties') is not None:
            self.connection_properties = m.get('ConnectionProperties')
        if m.get('ConnectionPropertiesMode') is not None:
            self.connection_properties_mode = m.get('ConnectionPropertiesMode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('QualifiedName') is not None:
            self.qualified_name = m.get('QualifiedName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        data_source: GetDataSourceResponseBodyDataSource = None,
        request_id: str = None,
    ):
        self.data_source = data_source
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSource') is not None:
            temp_model = GetDataSourceResponseBodyDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDeploymentRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the process.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetDeploymentResponseBodyPipelineStages(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        detail: Dict[str, Any] = None,
        message: str = None,
        name: str = None,
        status: str = None,
        step: int = None,
        type: str = None,
    ):
        # The code of the stage.
        self.code = code
        # The description of the stage.
        self.description = description
        # The details of the stage.
        self.detail = detail
        # The error message returned for the stage.
        self.message = message
        # The name of the stage.
        self.name = name
        # The status of the stage.
        # 
        # Valid values:
        # 
        # *   INIT
        # *   RUNNING
        # *   SUCCESS
        # *   FAIL
        # *   TERMINATION
        # *   CANCEL
        self.status = status
        # The step number of the stage.
        self.step = step
        # The type of the stage.
        # 
        # Valid values:
        # 
        # *   DELETE
        # *   BUILD
        # *   CHECK
        # *   DEPLOY
        # *   OFFLINE
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.description is not None:
            result['Description'] = self.description
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.step is not None:
            result['Step'] = self.step
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDeploymentResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator: str = None,
        id: str = None,
        message: str = None,
        modify_time: int = None,
        project_id: str = None,
        stages: List[GetDeploymentResponseBodyPipelineStages] = None,
        status: str = None,
    ):
        # The time when the process was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The creator of the process.
        self.creator = creator
        # The ID of the process.
        self.id = id
        # The error message returned when the process fails.
        self.message = message
        # The time when the process was modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The information about stages in the process.
        self.stages = stages
        # The status of the process.
        # 
        # Valid values:
        # 
        # *   INIT
        # *   RUNNING
        # *   SUCCESS
        # *   FAIL
        # *   TERMINATION
        # *   CANCEL
        self.status = status

    def validate(self):
        if self.stages:
            for k in self.stages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Stages'] = []
        if self.stages is not None:
            for k in self.stages:
                result['Stages'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.stages = []
        if m.get('Stages') is not None:
            for k in m.get('Stages'):
                temp_model = GetDeploymentResponseBodyPipelineStages()
                self.stages.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetDeploymentResponseBody(TeaModel):
    def __init__(
        self,
        pipeline: GetDeploymentResponseBodyPipeline = None,
        request_id: str = None,
    ):
        # The information about the process.
        self.pipeline = pipeline
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = GetDeploymentResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDeploymentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDeploymentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFunctionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetFunctionResponseBodyFunction(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: str = None,
        spec: str = None,
    ):
        # The time when the UDF was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the UDF.
        self.id = id
        # The time when the UDF was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the UDF.
        self.name = name
        # The owner of the UDF.
        self.owner = owner
        # The ID of the DataWorks workspace to which the UDF belongs.
        self.project_id = project_id
        # The FlowSpec field information about the UDF. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class GetFunctionResponseBody(TeaModel):
    def __init__(
        self,
        function: GetFunctionResponseBodyFunction = None,
        request_id: str = None,
    ):
        # The information about the UDF.
        self.function = function
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.function:
            self.function.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['Function'] = self.function.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Function') is not None:
            temp_model = GetFunctionResponseBodyFunction()
            self.function = temp_model.from_map(m['Function'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetJobStatusRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetJobStatusResponseBodyJobStatus(TeaModel):
    def __init__(
        self,
        completed: str = None,
        create_time: str = None,
        error: str = None,
        job_id: str = None,
        job_type: str = None,
        status: str = None,
    ):
        self.completed = completed
        self.create_time = create_time
        self.error = error
        self.job_id = job_id
        self.job_type = job_type
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completed is not None:
            result['Completed'] = self.completed
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.error is not None:
            result['Error'] = self.error
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Completed') is not None:
            self.completed = m.get('Completed')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetJobStatusResponseBody(TeaModel):
    def __init__(
        self,
        job_status: GetJobStatusResponseBodyJobStatus = None,
        request_id: str = None,
    ):
        self.job_status = job_status
        self.request_id = request_id

    def validate(self):
        if self.job_status:
            self.job_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_status is not None:
            result['JobStatus'] = self.job_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobStatus') is not None:
            temp_model = GetJobStatusResponseBodyJobStatus()
            self.job_status = temp_model.from_map(m['JobStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetJobStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetJobStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetJobStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNetworkRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetNetworkResponseBodyNetwork(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        id: int = None,
        resource_group_id: str = None,
        security_group_id: str = None,
        status: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.id = id
        self.resource_group_id = resource_group_id
        self.security_group_id = security_group_id
        self.status = status
        self.vpc_id = vpc_id
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class GetNetworkResponseBody(TeaModel):
    def __init__(
        self,
        network: GetNetworkResponseBodyNetwork = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.network = network
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.network:
            self.network.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network is not None:
            result['Network'] = self.network.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Network') is not None:
            temp_model = GetNetworkResponseBodyNetwork()
            self.network = temp_model.from_map(m['Network'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNodeRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetNodeResponseBodyNode(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: str = None,
        spec: str = None,
    ):
        # The time when the node was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the node.
        self.id = id
        # The time when the node was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the node.
        self.name = name
        # The owner of the node.
        self.owner = owner
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The FlowSpec field information about this node. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow).
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class GetNodeResponseBody(TeaModel):
    def __init__(
        self,
        node: GetNodeResponseBodyNode = None,
        request_id: str = None,
    ):
        # The information about the node.
        self.node = node
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Node') is not None:
            temp_model = GetNodeResponseBodyNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetProjectResponseBodyProjectAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetProjectResponseBodyProject(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[GetProjectResponseBodyProjectAliyunResourceTags] = None,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        id: int = None,
        name: str = None,
        owner: str = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        # The ID of the Alibaba Cloud resource group to which the workspace belongs.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags = aliyun_resource_tags
        # The description of the workspace.
        self.description = description
        # Indicates whether the development environment is enabled. Valid values:
        # 
        # *   true: The development environment is enabled. In this case, the development environment is isolated from the production environment in the workspace.
        # *   false: The development environment is disabled. In this case, only the production environment is used in the workspace.
        self.dev_environment_enabled = dev_environment_enabled
        # Indicates whether the Develop role is disabled. Valid values:
        # 
        # *   false
        # *   true
        self.dev_role_disabled = dev_role_disabled
        # The display name of the workspace.
        self.display_name = display_name
        # The workspace ID.
        self.id = id
        # The name of the workspace.
        self.name = name
        # The ID of the Alibaba Cloud account to which the workspace belongs.
        self.owner = owner
        # Indicates whether scheduling of Platform for AI (PAI) tasks is enabled. Valid values:
        # 
        # *   true: Scheduling of PAI tasks is enabled. In this case, you can create a PAI node in a DataWorks workspace and configure scheduling properties for the node to implement periodic scheduling of PAI tasks.
        # *   false: Scheduling of PAI tasks is disabled.
        self.pai_task_enabled = pai_task_enabled
        # The status of the workspace. Valid values:
        # 
        # *   Available
        # *   Initializing
        # *   InitFailed
        # *   Forbidden
        # *   Deleting
        # *   DeleteFailed
        # *   Frozen
        # *   Updating
        # *   UpdateFailed
        # 
        # <!---->
        # 
        # *\
        # *\
        # *\
        # *\
        # *\
        # *\
        # *\
        # *\
        # *\
        self.status = status

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = GetProjectResponseBodyProjectAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetProjectResponseBody(TeaModel):
    def __init__(
        self,
        project: GetProjectResponseBodyProject = None,
        request_id: str = None,
    ):
        # The information about the workspace.
        self.project = project
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['Project'] = self.project.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Project') is not None:
            temp_model = GetProjectResponseBodyProject()
            self.project = temp_model.from_map(m['Project'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectMemberRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the account used by the member in the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=openapi-amp.newDocPublishment.0.0.39e9281f3mhq4J), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the ID of the account used by the member in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetProjectMemberResponseBodyProjectMemberRoles(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
        type: str = None,
    ):
        # The code of the role. Valid values:
        # 
        # *   role_project_admin: Workspace Administrator
        # *   role_project_dev: Develop
        # *   role_project_dg_admin: Data Governance Administrator
        # *   role_project_guest: Visitor
        # *   role_project_security: Security Administrator
        # *   role_project_deploy: Deploy
        # *   role_project_owner: Workspace Owner
        # *   role_project_data_analyst: Data Analyst
        # *   role_project_pe: O\\&M
        # *   role_project_erd: Model Designer
        self.code = code
        # The name of the role.
        self.name = name
        # The type of the role. Valid values:
        # 
        # *   UserCustom: custom role
        # *   System: built-in role
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetProjectMemberResponseBodyProjectMember(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        roles: List[GetProjectMemberResponseBodyProjectMemberRoles] = None,
        status: str = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The roles that are assigned to the member in the workspace.
        self.roles = roles
        # The status of the member.
        # 
        # *   Normal
        # *   Forbidden
        self.status = status
        # The ID of the account used by the member in the workspace.
        self.user_id = user_id

    def validate(self):
        if self.roles:
            for k in self.roles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Roles'] = []
        if self.roles is not None:
            for k in self.roles:
                result['Roles'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.roles = []
        if m.get('Roles') is not None:
            for k in m.get('Roles'):
                temp_model = GetProjectMemberResponseBodyProjectMemberRoles()
                self.roles.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetProjectMemberResponseBody(TeaModel):
    def __init__(
        self,
        project_member: GetProjectMemberResponseBodyProjectMember = None,
        request_id: str = None,
    ):
        # The details about the member in the workspace.
        self.project_member = project_member
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.project_member:
            self.project_member.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_member is not None:
            result['ProjectMember'] = self.project_member.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectMember') is not None:
            temp_model = GetProjectMemberResponseBodyProjectMember()
            self.project_member = temp_model.from_map(m['ProjectMember'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetProjectMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectRoleRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
        project_id: int = None,
    ):
        # This parameter is required.
        self.code = code
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetProjectRoleResponseBodyProjectRole(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
        project_id: int = None,
        type: str = None,
    ):
        self.code = code
        self.name = name
        self.project_id = project_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetProjectRoleResponseBody(TeaModel):
    def __init__(
        self,
        project_role: GetProjectRoleResponseBodyProjectRole = None,
        request_id: str = None,
    ):
        self.project_role = project_role
        self.request_id = request_id

    def validate(self):
        if self.project_role:
            self.project_role.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_role is not None:
            result['ProjectRole'] = self.project_role.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectRole') is not None:
            temp_model = GetProjectRoleResponseBodyProjectRole()
            self.project_role = temp_model.from_map(m['ProjectRole'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetProjectRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetResourceRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetResourceResponseBodyResource(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: str = None,
        spec: str = None,
    ):
        # The time when the file resource was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the file resource.
        self.id = id
        # The time when the file resource was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the file resource.
        self.name = name
        # The owner of the file resource.
        self.owner = owner
        # The ID of the workspace to which the file resource belongs.
        self.project_id = project_id
        # The FlowSpec field information about the file resource. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow).
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class GetResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource: GetResourceResponseBodyResource = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the file resource.
        self.resource = resource

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resource') is not None:
            temp_model = GetResourceResponseBodyResource()
            self.resource = temp_model.from_map(m['Resource'])
        return self


class GetResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetResourceGroupRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetResourceGroupResponseBodyResourceGroupSpec(TeaModel):
    def __init__(
        self,
        amount: int = None,
        standard: str = None,
    ):
        self.amount = amount
        self.standard = standard

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.standard is not None:
            result['Standard'] = self.standard
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Standard') is not None:
            self.standard = m.get('Standard')
        return self


class GetResourceGroupResponseBodyResourceGroup(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        default_vpc_id: str = None,
        default_vswitch_id: str = None,
        id: str = None,
        name: str = None,
        order_instance_id: str = None,
        payment_type: str = None,
        remark: str = None,
        resource_group_type: str = None,
        spec: GetResourceGroupResponseBodyResourceGroupSpec = None,
        status: str = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.default_vpc_id = default_vpc_id
        self.default_vswitch_id = default_vswitch_id
        self.id = id
        self.name = name
        self.order_instance_id = order_instance_id
        self.payment_type = payment_type
        self.remark = remark
        self.resource_group_type = resource_group_type
        self.spec = spec
        self.status = status

    def validate(self):
        if self.spec:
            self.spec.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.default_vpc_id is not None:
            result['DefaultVpcId'] = self.default_vpc_id
        if self.default_vswitch_id is not None:
            result['DefaultVswitchId'] = self.default_vswitch_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.order_instance_id is not None:
            result['OrderInstanceId'] = self.order_instance_id
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.resource_group_type is not None:
            result['ResourceGroupType'] = self.resource_group_type
        if self.spec is not None:
            result['Spec'] = self.spec.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DefaultVpcId') is not None:
            self.default_vpc_id = m.get('DefaultVpcId')
        if m.get('DefaultVswitchId') is not None:
            self.default_vswitch_id = m.get('DefaultVswitchId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OrderInstanceId') is not None:
            self.order_instance_id = m.get('OrderInstanceId')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ResourceGroupType') is not None:
            self.resource_group_type = m.get('ResourceGroupType')
        if m.get('Spec') is not None:
            temp_model = GetResourceGroupResponseBodyResourceGroupSpec()
            self.spec = temp_model.from_map(m['Spec'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource_group: GetResourceGroupResponseBodyResourceGroup = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.resource_group = resource_group
        self.success = success

    def validate(self):
        if self.resource_group:
            self.resource_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group is not None:
            result['ResourceGroup'] = self.resource_group.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroup') is not None:
            temp_model = GetResourceGroupResponseBodyResourceGroup()
            self.resource_group = temp_model.from_map(m['ResourceGroup'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRouteRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetRouteResponseBodyRoute(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        destination_cidr: str = None,
        id: int = None,
        network_id: int = None,
        resource_group_id: str = None,
        resource_id: str = None,
    ):
        self.create_time = create_time
        self.destination_cidr = destination_cidr
        self.id = id
        self.network_id = network_id
        self.resource_group_id = resource_group_id
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.destination_cidr is not None:
            result['DestinationCidr'] = self.destination_cidr
        if self.id is not None:
            result['Id'] = self.id
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DestinationCidr') is not None:
            self.destination_cidr = m.get('DestinationCidr')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class GetRouteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        route: GetRouteResponseBodyRoute = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.route = route
        self.success = success

    def validate(self):
        if self.route:
            self.route.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.route is not None:
            result['Route'] = self.route.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Route') is not None:
            temp_model = GetRouteResponseBodyRoute()
            self.route = temp_model.from_map(m['Route'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_env: str = None,
    ):
        # This parameter is required.
        self.id = id
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class GetTaskResponseBodyTaskDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetTaskResponseBodyTaskDependencies(TeaModel):
    def __init__(
        self,
        type: str = None,
        upstream_output: str = None,
        upstream_task_id: str = None,
    ):
        self.type = type
        self.upstream_output = upstream_output
        self.upstream_task_id = upstream_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.upstream_output is not None:
            result['UpstreamOutput'] = self.upstream_output
        if self.upstream_task_id is not None:
            result['UpstreamTaskId'] = self.upstream_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpstreamOutput') is not None:
            self.upstream_output = m.get('UpstreamOutput')
        if m.get('UpstreamTaskId') is not None:
            self.upstream_task_id = m.get('UpstreamTaskId')
        return self


class GetTaskResponseBodyTaskInputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        self.name = name
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskResponseBodyTaskInputs(TeaModel):
    def __init__(
        self,
        variables: List[GetTaskResponseBodyTaskInputsVariables] = None,
    ):
        self.variables = variables

    def validate(self):
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = GetTaskResponseBodyTaskInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetTaskResponseBodyTaskOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class GetTaskResponseBodyTaskOutputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        self.name = name
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskResponseBodyTaskOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[GetTaskResponseBodyTaskOutputsTaskOutputs] = None,
        variables: List[GetTaskResponseBodyTaskOutputsVariables] = None,
    ):
        self.task_outputs = task_outputs
        self.variables = variables

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = GetTaskResponseBodyTaskOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = GetTaskResponseBodyTaskOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetTaskResponseBodyTaskRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        self.cu = cu
        self.image = image
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetTaskResponseBodyTaskScript(TeaModel):
    def __init__(
        self,
        content: str = None,
        parameters: str = None,
    ):
        self.content = content
        self.parameters = parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class GetTaskResponseBodyTaskSubTasksSubTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        self.cu = cu
        self.image = image
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetTaskResponseBodyTaskSubTasksSubTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        self.cron = cron
        self.end_time = end_time
        self.recurrence = recurrence
        self.start_time = start_time
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTaskResponseBodyTaskSubTasksSubTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: GetTaskResponseBodyTaskSubTasksSubTasksDataSource = None,
        description: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger: GetTaskResponseBodyTaskSubTasksSubTasksTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        self.baseline_id = baseline_id
        self.create_time = create_time
        self.create_user = create_user
        self.data_source = data_source
        self.description = description
        self.id = id
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.name = name
        self.owner = owner
        self.priority = priority
        self.project_env = project_env
        self.project_id = project_id
        self.rerun_interval = rerun_interval
        self.rerun_mode = rerun_mode
        self.rerun_times = rerun_times
        self.runtime_resource = runtime_resource
        self.tenant_id = tenant_id
        self.timeout = timeout
        self.trigger = trigger
        self.type = type
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = GetTaskResponseBodyTaskSubTasksSubTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = GetTaskResponseBodyTaskSubTasksSubTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class GetTaskResponseBodyTaskSubTasks(TeaModel):
    def __init__(
        self,
        sub_tasks: List[GetTaskResponseBodyTaskSubTasksSubTasks] = None,
        type: str = None,
    ):
        self.sub_tasks = sub_tasks
        self.type = type

    def validate(self):
        if self.sub_tasks:
            for k in self.sub_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubTasks'] = []
        if self.sub_tasks is not None:
            for k in self.sub_tasks:
                result['SubTasks'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sub_tasks = []
        if m.get('SubTasks') is not None:
            for k in m.get('SubTasks'):
                temp_model = GetTaskResponseBodyTaskSubTasksSubTasks()
                self.sub_tasks.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTaskResponseBodyTaskTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskResponseBodyTaskTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        self.cron = cron
        self.end_time = end_time
        self.recurrence = recurrence
        self.start_time = start_time
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTaskResponseBodyTask(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: GetTaskResponseBodyTaskDataSource = None,
        dependencies: List[GetTaskResponseBodyTaskDependencies] = None,
        description: str = None,
        id: int = None,
        inputs: GetTaskResponseBodyTaskInputs = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        outputs: GetTaskResponseBodyTaskOutputs = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: GetTaskResponseBodyTaskRuntimeResource = None,
        script: GetTaskResponseBodyTaskScript = None,
        sub_tasks: GetTaskResponseBodyTaskSubTasks = None,
        tags: List[GetTaskResponseBodyTaskTags] = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger: GetTaskResponseBodyTaskTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        self.baseline_id = baseline_id
        self.create_time = create_time
        self.create_user = create_user
        self.data_source = data_source
        self.dependencies = dependencies
        self.description = description
        self.id = id
        self.inputs = inputs
        self.instance_mode = instance_mode
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.name = name
        self.outputs = outputs
        self.owner = owner
        self.priority = priority
        self.project_env = project_env
        self.project_id = project_id
        self.rerun_interval = rerun_interval
        self.rerun_mode = rerun_mode
        self.rerun_times = rerun_times
        self.runtime_resource = runtime_resource
        self.script = script
        self.sub_tasks = sub_tasks
        self.tags = tags
        self.tenant_id = tenant_id
        self.timeout = timeout
        self.trigger = trigger
        self.type = type
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.dependencies:
            for k in self.dependencies:
                if k:
                    k.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.sub_tasks:
            self.sub_tasks.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        result['Dependencies'] = []
        if self.dependencies is not None:
            for k in self.dependencies:
                result['Dependencies'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.sub_tasks is not None:
            result['SubTasks'] = self.sub_tasks.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = GetTaskResponseBodyTaskDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        self.dependencies = []
        if m.get('Dependencies') is not None:
            for k in m.get('Dependencies'):
                temp_model = GetTaskResponseBodyTaskDependencies()
                self.dependencies.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = GetTaskResponseBodyTaskInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = GetTaskResponseBodyTaskOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = GetTaskResponseBodyTaskRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = GetTaskResponseBodyTaskScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('SubTasks') is not None:
            temp_model = GetTaskResponseBodyTaskSubTasks()
            self.sub_tasks = temp_model.from_map(m['SubTasks'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetTaskResponseBodyTaskTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = GetTaskResponseBodyTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class GetTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task: GetTaskResponseBodyTask = None,
    ):
        self.request_id = request_id
        self.task = task

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Task') is not None:
            temp_model = GetTaskResponseBodyTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class GetTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskInstanceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetTaskInstanceResponseBodyTaskInstanceDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetTaskInstanceResponseBodyTaskInstanceInputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskInstanceResponseBodyTaskInstanceInputs(TeaModel):
    def __init__(
        self,
        variables: List[GetTaskInstanceResponseBodyTaskInstanceInputsVariables] = None,
    ):
        # The variables.
        self.variables = variables

    def validate(self):
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = GetTaskInstanceResponseBodyTaskInstanceInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output identifier.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class GetTaskInstanceResponseBodyTaskInstanceOutputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskInstanceResponseBodyTaskInstanceOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs] = None,
        variables: List[GetTaskInstanceResponseBodyTaskInstanceOutputsVariables] = None,
    ):
        # The task outputs.
        self.task_outputs = task_outputs
        # The variables.
        self.variables = variables

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = GetTaskInstanceResponseBodyTaskInstanceOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetTaskInstanceResponseBodyTaskInstanceRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        # The host for running.
        self.gateway = gateway
        # The instance run ID.
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class GetTaskInstanceResponseBodyTaskInstanceRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of CUs configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetTaskInstanceResponseBodyTaskInstanceScript(TeaModel):
    def __init__(
        self,
        content: str = None,
        parameters: str = None,
    ):
        # The script content.
        self.content = content
        # The script parameters.
        self.parameters = parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class GetTaskInstanceResponseBodyTaskInstanceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskInstanceResponseBodyTaskInstance(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: GetTaskInstanceResponseBodyTaskInstanceDataSource = None,
        description: str = None,
        finished_time: int = None,
        id: int = None,
        inputs: GetTaskInstanceResponseBodyTaskInstanceInputs = None,
        modify_time: int = None,
        modify_user: str = None,
        outputs: GetTaskInstanceResponseBodyTaskInstanceOutputs = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: GetTaskInstanceResponseBodyTaskInstanceRuntime = None,
        runtime_resource: GetTaskInstanceResponseBodyTaskInstanceRuntimeResource = None,
        script: GetTaskInstanceResponseBodyTaskInstanceScript = None,
        started_time: int = None,
        status: str = None,
        tags: List[GetTaskInstanceResponseBodyTaskInstanceTags] = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The data timestamp.
        self.bizdate = bizdate
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The instance ID.
        self.id = id
        # The input information.
        self.inputs = inputs
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The output information.
        self.outputs = outputs
        # The account ID of the task owner.
        self.owner = owner
        self.period_number = period_number
        # The task priority. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        self.rerun_mode = rerun_mode
        # The number of times the instance is run. By default, the value starts from 1.
        self.run_number = run_number
        # The runtime information about the instance.
        self.runtime = runtime
        # The information about the resource group with which the instance is associated.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the instance. Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        self.status = status
        # The tags of the task.
        self.tags = tags
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The name of the task for which the instance is generated.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The tenant ID.
        self.tenant_id = tenant_id
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The scheduling time.
        self.trigger_time = trigger_time
        # The method to trigger instance scheduling. The value of the Trigger.Type parameter in the response of the GetTask operation is used. Valid values:
        # 
        # *   Scheduler
        # *   Manual
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance. Valid values:
        # 
        # *   SmokeTest
        # *   SupplementData
        # *   Manual
        # *   ManualWorkflow
        # *   Normal
        # *   ManualFlow
        self.workflow_instance_type = workflow_instance_type
        # The name of the workflow to which the instance belongs.
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Outputs') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetTaskInstanceResponseBodyTaskInstanceTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class GetTaskInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_instance: GetTaskInstanceResponseBodyTaskInstance = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the instance.
        self.task_instance = task_instance

    def validate(self):
        if self.task_instance:
            self.task_instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_instance is not None:
            result['TaskInstance'] = self.task_instance.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskInstance') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstance()
            self.task_instance = temp_model.from_map(m['TaskInstance'])
        return self


class GetTaskInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskInstanceLogRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        run_number: int = None,
    ):
        # This parameter is required.
        self.id = id
        self.run_number = run_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        return self


class GetTaskInstanceLogResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_instance_log: str = None,
    ):
        self.request_id = request_id
        self.task_instance_log = task_instance_log

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_instance_log is not None:
            result['TaskInstanceLog'] = self.task_instance_log
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskInstanceLog') is not None:
            self.task_instance_log = m.get('TaskInstanceLog')
        return self


class GetTaskInstanceLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskInstanceLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskInstanceLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetWorkflowDefinitionResponseBodyWorkflowDefinition(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: str = None,
        spec: str = None,
    ):
        # The time when the workflow was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the workflow.
        self.id = id
        # The time when the workflow was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the workflow.
        self.name = name
        # The owner of the workflow.
        self.owner = owner
        # The ID of the workspace to which the workflow belongs.
        self.project_id = project_id
        # The FlowSpec field information about the workflow. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow/).
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class GetWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workflow_definition: GetWorkflowDefinitionResponseBodyWorkflowDefinition = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the workflow.
        self.workflow_definition = workflow_definition

    def validate(self):
        if self.workflow_definition:
            self.workflow_definition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.workflow_definition is not None:
            result['WorkflowDefinition'] = self.workflow_definition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WorkflowDefinition') is not None:
            temp_model = GetWorkflowDefinitionResponseBodyWorkflowDefinition()
            self.workflow_definition = temp_model.from_map(m['WorkflowDefinition'])
        return self


class GetWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GrantMemberProjectRolesRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes: List[str] = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/zh/dataworks/developer-reference/api-dataworks-public-2024-05-18-listprojectroles?spm=a2c4g.11186623.0.0.43841daeywTtF3) operation to query the codes of all roles in the workspace.
        # 
        # You must configure this parameter to specify the roles that you want to assign to members in the workspace.
        # 
        # This parameter is required.
        self.role_codes = role_codes
        # The IDs of the accounts used by the members in the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=openapi-amp.newDocPublishment.0.0.51d7281fjgBRmo), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the IDs of the accounts used by the members in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes is not None:
            result['RoleCodes'] = self.role_codes
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GrantMemberProjectRolesShrinkRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes_shrink: str = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/zh/dataworks/developer-reference/api-dataworks-public-2024-05-18-listprojectroles?spm=a2c4g.11186623.0.0.43841daeywTtF3) operation to query the codes of all roles in the workspace.
        # 
        # You must configure this parameter to specify the roles that you want to assign to members in the workspace.
        # 
        # This parameter is required.
        self.role_codes_shrink = role_codes_shrink
        # The IDs of the accounts used by the members in the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=openapi-amp.newDocPublishment.0.0.51d7281fjgBRmo), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the IDs of the accounts used by the members in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes_shrink is not None:
            result['RoleCodes'] = self.role_codes_shrink
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes_shrink = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GrantMemberProjectRolesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GrantMemberProjectRolesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GrantMemberProjectRolesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GrantMemberProjectRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        project_id: str = None,
        spec: str = None,
    ):
        # This parameter is required.
        self.project_id = project_id
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class ImportWorkflowDefinitionResponseBodyAsyncJob(TeaModel):
    def __init__(
        self,
        completed: bool = None,
        create_time: int = None,
        error: str = None,
        id: str = None,
        progress: int = None,
        response: str = None,
        status: str = None,
        type: str = None,
    ):
        self.completed = completed
        self.create_time = create_time
        self.error = error
        self.id = id
        self.progress = progress
        self.response = response
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completed is not None:
            result['Completed'] = self.completed
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.error is not None:
            result['Error'] = self.error
        if self.id is not None:
            result['Id'] = self.id
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.response is not None:
            result['Response'] = self.response
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Completed') is not None:
            self.completed = m.get('Completed')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Response') is not None:
            self.response = m.get('Response')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ImportWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        async_job: ImportWorkflowDefinitionResponseBodyAsyncJob = None,
        request_id: str = None,
    ):
        self.async_job = async_job
        self.request_id = request_id

    def validate(self):
        if self.async_job:
            self.async_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_job is not None:
            result['AsyncJob'] = self.async_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsyncJob') is not None:
            temp_model = ImportWorkflowDefinitionResponseBodyAsyncJob()
            self.async_job = temp_model.from_map(m['AsyncJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertRulesRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        receiver: str = None,
        task_ids: List[int] = None,
        types: List[str] = None,
    ):
        self.name = name
        self.owner = owner
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.receiver = receiver
        self.task_ids = task_ids
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.receiver is not None:
            result['Receiver'] = self.receiver
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Receiver') is not None:
            self.receiver = m.get('Receiver')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListAlertRulesShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        receiver: str = None,
        task_ids_shrink: str = None,
        types_shrink: str = None,
    ):
        self.name = name
        self.owner = owner
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.receiver = receiver
        self.task_ids_shrink = task_ids_shrink
        self.types_shrink = types_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.receiver is not None:
            result['Receiver'] = self.receiver
        if self.task_ids_shrink is not None:
            result['TaskIds'] = self.task_ids_shrink
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Receiver') is not None:
            self.receiver = m.get('Receiver')
        if m.get('TaskIds') is not None:
            self.task_ids_shrink = m.get('TaskIds')
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime(TeaModel):
    def __init__(
        self,
        cycle_id: int = None,
        time: str = None,
    ):
        self.cycle_id = cycle_id
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_id is not None:
            result['CycleId'] = self.cycle_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleId') is not None:
            self.cycle_id = m.get('CycleId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished(TeaModel):
    def __init__(
        self,
        cycle_and_time: List[ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime] = None,
    ):
        self.cycle_and_time = cycle_and_time

    def validate(self):
        if self.cycle_and_time:
            for k in self.cycle_and_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleAndTime'] = []
        if self.cycle_and_time is not None:
            for k in self.cycle_and_time:
                result['CycleAndTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_and_time = []
        if m.get('CycleAndTime') is not None:
            for k in m.get('CycleAndTime'):
                temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime()
                self.cycle_and_time.append(temp_model.from_map(k))
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError(TeaModel):
    def __init__(
        self,
        auto_rerun_alert: bool = None,
        stream_task_ids: List[int] = None,
    ):
        self.auto_rerun_alert = auto_rerun_alert
        self.stream_task_ids = stream_task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_alert is not None:
            result['AutoRerunAlert'] = self.auto_rerun_alert
        if self.stream_task_ids is not None:
            result['StreamTaskIds'] = self.stream_task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunAlert') is not None:
            self.auto_rerun_alert = m.get('AutoRerunAlert')
        if m.get('StreamTaskIds') is not None:
            self.stream_task_ids = m.get('StreamTaskIds')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount(TeaModel):
    def __init__(
        self,
        count: int = None,
    ):
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage(TeaModel):
    def __init__(
        self,
        percentage: int = None,
    ):
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate(TeaModel):
    def __init__(
        self,
        percentage: int = None,
        trend: str = None,
    ):
        self.percentage = percentage
        self.trend = trend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.trend is not None:
            result['Trend'] = self.trend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Trend') is not None:
            self.trend = m.get('Trend')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout(TeaModel):
    def __init__(
        self,
        timeout_in_minutes: int = None,
    ):
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished(TeaModel):
    def __init__(
        self,
        un_finished_time: str = None,
    ):
        self.un_finished_time = un_finished_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.un_finished_time is not None:
            result['UnFinishedTime'] = self.un_finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UnFinishedTime') is not None:
            self.un_finished_time = m.get('UnFinishedTime')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension(TeaModel):
    def __init__(
        self,
        cycle_unfinished: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished = None,
        error: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError = None,
        instance_error_count: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount = None,
        instance_error_percentage: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage = None,
        instance_transfer_fluctuate: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate = None,
        timeout: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout = None,
        un_finished: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished = None,
    ):
        self.cycle_unfinished = cycle_unfinished
        self.error = error
        self.instance_error_count = instance_error_count
        self.instance_error_percentage = instance_error_percentage
        self.instance_transfer_fluctuate = instance_transfer_fluctuate
        self.timeout = timeout
        self.un_finished = un_finished

    def validate(self):
        if self.cycle_unfinished:
            self.cycle_unfinished.validate()
        if self.error:
            self.error.validate()
        if self.instance_error_count:
            self.instance_error_count.validate()
        if self.instance_error_percentage:
            self.instance_error_percentage.validate()
        if self.instance_transfer_fluctuate:
            self.instance_transfer_fluctuate.validate()
        if self.timeout:
            self.timeout.validate()
        if self.un_finished:
            self.un_finished.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_unfinished is not None:
            result['CycleUnfinished'] = self.cycle_unfinished.to_map()
        if self.error is not None:
            result['Error'] = self.error.to_map()
        if self.instance_error_count is not None:
            result['InstanceErrorCount'] = self.instance_error_count.to_map()
        if self.instance_error_percentage is not None:
            result['InstanceErrorPercentage'] = self.instance_error_percentage.to_map()
        if self.instance_transfer_fluctuate is not None:
            result['InstanceTransferFluctuate'] = self.instance_transfer_fluctuate.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        if self.un_finished is not None:
            result['UnFinished'] = self.un_finished.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleUnfinished') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished()
            self.cycle_unfinished = temp_model.from_map(m['CycleUnfinished'])
        if m.get('Error') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError()
            self.error = temp_model.from_map(m['Error'])
        if m.get('InstanceErrorCount') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount()
            self.instance_error_count = temp_model.from_map(m['InstanceErrorCount'])
        if m.get('InstanceErrorPercentage') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage()
            self.instance_error_percentage = temp_model.from_map(m['InstanceErrorPercentage'])
        if m.get('InstanceTransferFluctuate') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate()
            self.instance_transfer_fluctuate = temp_model.from_map(m['InstanceTransferFluctuate'])
        if m.get('Timeout') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        if m.get('UnFinished') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished()
            self.un_finished = temp_model.from_map(m['UnFinished'])
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget(TeaModel):
    def __init__(
        self,
        allow_tasks: List[int] = None,
        ids: List[int] = None,
        type: str = None,
    ):
        self.allow_tasks = allow_tasks
        self.ids = ids
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_tasks is not None:
            result['AllowTasks'] = self.allow_tasks
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowTasks') is not None:
            self.allow_tasks = m.get('AllowTasks')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition(TeaModel):
    def __init__(
        self,
        extension: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension = None,
        target: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget = None,
        type: str = None,
    ):
        self.extension = extension
        self.target = target
        self.type = type

    def validate(self):
        if self.extension:
            self.extension.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Target') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRules(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        id: int = None,
        name: str = None,
        owner: str = None,
        trigger_condition: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition = None,
    ):
        self.enabled = enabled
        self.id = id
        self.name = name
        self.owner = owner
        self.trigger_condition = trigger_condition

    def validate(self):
        if self.trigger_condition:
            self.trigger_condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition is not None:
            result['TriggerCondition'] = self.trigger_condition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition()
            self.trigger_condition = temp_model.from_map(m['TriggerCondition'])
        return self


class ListAlertRulesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        alert_rules: List[ListAlertRulesResponseBodyPagingInfoAlertRules] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.alert_rules = alert_rules
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.alert_rules:
            for k in self.alert_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertRules'] = []
        if self.alert_rules is not None:
            for k in self.alert_rules:
                result['AlertRules'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_rules = []
        if m.get('AlertRules') is not None:
            for k in m.get('AlertRules'):
                temp_model = ListAlertRulesResponseBodyPagingInfoAlertRules()
                self.alert_rules.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListAlertRulesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIAlarmRulesRequest(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        job_id: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.dialarm_rule_id = dialarm_rule_id
        self.job_id = job_id
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        severity: str = None,
    ):
        self.channels = channels
        self.severity = severity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers(TeaModel):
    def __init__(
        self,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings(TeaModel):
    def __init__(
        self,
        inhibition_interval: int = None,
        notification_channels: List[ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels] = None,
        notification_receivers: List[ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers] = None,
    ):
        self.inhibition_interval = inhibition_interval
        self.notification_channels = notification_channels
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inhibition_interval is not None:
            result['InhibitionInterval'] = self.inhibition_interval
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InhibitionInterval') is not None:
            self.inhibition_interval = m.get('InhibitionInterval')
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions(TeaModel):
    def __init__(
        self,
        ddl_report_tags: List[str] = None,
        duration: int = None,
        severity: str = None,
        threshold: int = None,
    ):
        self.ddl_report_tags = ddl_report_tags
        self.duration = duration
        self.severity = severity
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ddl_report_tags is not None:
            result['DdlReportTags'] = self.ddl_report_tags
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DdlReportTags') is not None:
            self.ddl_report_tags = m.get('DdlReportTags')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        metric_type: str = None,
        name: str = None,
        notification_settings: ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings = None,
        trigger_conditions: List[ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions] = None,
    ):
        self.dialarm_rule_id = dialarm_rule_id
        self.dijob_id = dijob_id
        self.description = description
        self.enabled = enabled
        self.metric_type = metric_type
        self.name = name
        self.notification_settings = notification_settings
        self.trigger_conditions = trigger_conditions

    def validate(self):
        if self.notification_settings:
            self.notification_settings.validate()
        if self.trigger_conditions:
            for k in self.trigger_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings is not None:
            result['NotificationSettings'] = self.notification_settings.to_map()
        result['TriggerConditions'] = []
        if self.trigger_conditions is not None:
            for k in self.trigger_conditions:
                result['TriggerConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings()
            self.notification_settings = temp_model.from_map(m['NotificationSettings'])
        self.trigger_conditions = []
        if m.get('TriggerConditions') is not None:
            for k in m.get('TriggerConditions'):
                temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions()
                self.trigger_conditions.append(temp_model.from_map(k))
        return self


class ListDIAlarmRulesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        dijob_alarm_rules: List[ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.dijob_alarm_rules = dijob_alarm_rules
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.dijob_alarm_rules:
            for k in self.dijob_alarm_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DIJobAlarmRules'] = []
        if self.dijob_alarm_rules is not None:
            for k in self.dijob_alarm_rules:
                result['DIJobAlarmRules'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dijob_alarm_rules = []
        if m.get('DIJobAlarmRules') is not None:
            for k in m.get('DIJobAlarmRules'):
                temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules()
                self.dijob_alarm_rules.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDIAlarmRulesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIAlarmRulesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIAlarmRulesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIAlarmRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIAlarmRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIAlarmRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIJobEventsRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        end_time: int = None,
        event_type: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
    ):
        self.dijob_id = dijob_id
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.event_type = event_type
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDIJobEventsResponseBodyPagingInfoDIJobEvent(TeaModel):
    def __init__(
        self,
        action: str = None,
        channels: str = None,
        create_time: str = None,
        detail: str = None,
        dst_sql: str = None,
        dst_table: str = None,
        failover_message: str = None,
        id: str = None,
        severity: str = None,
        src_sql: str = None,
        src_table: str = None,
        status: str = None,
        type: str = None,
    ):
        self.action = action
        self.channels = channels
        self.create_time = create_time
        self.detail = detail
        self.dst_sql = dst_sql
        self.dst_table = dst_table
        self.failover_message = failover_message
        self.id = id
        self.severity = severity
        self.src_sql = src_sql
        self.src_table = src_table
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.dst_sql is not None:
            result['DstSql'] = self.dst_sql
        if self.dst_table is not None:
            result['DstTable'] = self.dst_table
        if self.failover_message is not None:
            result['FailoverMessage'] = self.failover_message
        if self.id is not None:
            result['Id'] = self.id
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.src_sql is not None:
            result['SrcSql'] = self.src_sql
        if self.src_table is not None:
            result['SrcTable'] = self.src_table
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('DstSql') is not None:
            self.dst_sql = m.get('DstSql')
        if m.get('DstTable') is not None:
            self.dst_table = m.get('DstTable')
        if m.get('FailoverMessage') is not None:
            self.failover_message = m.get('FailoverMessage')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('SrcSql') is not None:
            self.src_sql = m.get('SrcSql')
        if m.get('SrcTable') is not None:
            self.src_table = m.get('SrcTable')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDIJobEventsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        dijob_event: List[ListDIJobEventsResponseBodyPagingInfoDIJobEvent] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.dijob_event = dijob_event
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.dijob_event:
            for k in self.dijob_event:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DIJobEvent'] = []
        if self.dijob_event is not None:
            for k in self.dijob_event:
                result['DIJobEvent'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dijob_event = []
        if m.get('DIJobEvent') is not None:
            for k in m.get('DIJobEvent'):
                temp_model = ListDIJobEventsResponseBodyPagingInfoDIJobEvent()
                self.dijob_event.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDIJobEventsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIJobEventsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIJobEventsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIJobEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIJobEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIJobEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIJobMetricsRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        end_time: int = None,
        metric_name: List[str] = None,
        start_time: int = None,
    ):
        self.dijob_id = dijob_id
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.metric_name = metric_name
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDIJobMetricsShrinkRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        end_time: int = None,
        metric_name_shrink: str = None,
        start_time: int = None,
    ):
        self.dijob_id = dijob_id
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.metric_name_shrink = metric_name_shrink
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.metric_name_shrink is not None:
            result['MetricName'] = self.metric_name_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MetricName') is not None:
            self.metric_name_shrink = m.get('MetricName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: float = None,
    ):
        self.time = time
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDIJobMetricsResponseBodyPagingInfoJobMetrics(TeaModel):
    def __init__(
        self,
        name: str = None,
        series_list: List[ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList] = None,
    ):
        self.name = name
        self.series_list = series_list

    def validate(self):
        if self.series_list:
            for k in self.series_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['SeriesList'] = []
        if self.series_list is not None:
            for k in self.series_list:
                result['SeriesList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.series_list = []
        if m.get('SeriesList') is not None:
            for k in m.get('SeriesList'):
                temp_model = ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList()
                self.series_list.append(temp_model.from_map(k))
        return self


class ListDIJobMetricsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        job_metrics: List[ListDIJobMetricsResponseBodyPagingInfoJobMetrics] = None,
    ):
        self.job_metrics = job_metrics

    def validate(self):
        if self.job_metrics:
            for k in self.job_metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobMetrics'] = []
        if self.job_metrics is not None:
            for k in self.job_metrics:
                result['JobMetrics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_metrics = []
        if m.get('JobMetrics') is not None:
            for k in m.get('JobMetrics'):
                temp_model = ListDIJobMetricsResponseBodyPagingInfoJobMetrics()
                self.job_metrics.append(temp_model.from_map(k))
        return self


class ListDIJobMetricsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIJobMetricsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIJobMetricsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIJobMetricsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIJobMetricsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIJobMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIJobRunDetailsRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        instance_id: int = None,
        page_number: int = None,
        page_size: int = None,
        source_data_source_name: str = None,
        source_database_name: str = None,
        source_schema_name: str = None,
        source_table_name: str = None,
    ):
        # This parameter is required.
        self.dijob_id = dijob_id
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.source_data_source_name = source_data_source_name
        self.source_database_name = source_database_name
        self.source_schema_name = source_schema_name
        self.source_table_name = source_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source_data_source_name is not None:
            result['SourceDataSourceName'] = self.source_data_source_name
        if self.source_database_name is not None:
            result['SourceDatabaseName'] = self.source_database_name
        if self.source_schema_name is not None:
            result['SourceSchemaName'] = self.source_schema_name
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SourceDataSourceName') is not None:
            self.source_data_source_name = m.get('SourceDataSourceName')
        if m.get('SourceDatabaseName') is not None:
            self.source_database_name = m.get('SourceDatabaseName')
        if m.get('SourceSchemaName') is not None:
            self.source_schema_name = m.get('SourceSchemaName')
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        return self


class ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos(TeaModel):
    def __init__(
        self,
        destination_database_name: str = None,
        destination_datasource_name: str = None,
        destination_schema_name: str = None,
        destination_table_name: str = None,
        full_migration_error_message: str = None,
        full_migration_status: str = None,
        offline_error_records: int = None,
        offline_total_bytes: int = None,
        offline_total_records: int = None,
        realtime_migration_error_message: str = None,
        realtime_migration_status: str = None,
        source_database_name: str = None,
        source_datasource_name: str = None,
        source_schema_name: str = None,
        source_table_name: str = None,
        structure_migration_error_message: str = None,
        structure_migration_status: str = None,
    ):
        self.destination_database_name = destination_database_name
        self.destination_datasource_name = destination_datasource_name
        self.destination_schema_name = destination_schema_name
        self.destination_table_name = destination_table_name
        self.full_migration_error_message = full_migration_error_message
        self.full_migration_status = full_migration_status
        self.offline_error_records = offline_error_records
        self.offline_total_bytes = offline_total_bytes
        self.offline_total_records = offline_total_records
        self.realtime_migration_error_message = realtime_migration_error_message
        self.realtime_migration_status = realtime_migration_status
        self.source_database_name = source_database_name
        self.source_datasource_name = source_datasource_name
        self.source_schema_name = source_schema_name
        self.source_table_name = source_table_name
        self.structure_migration_error_message = structure_migration_error_message
        self.structure_migration_status = structure_migration_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_database_name is not None:
            result['DestinationDatabaseName'] = self.destination_database_name
        if self.destination_datasource_name is not None:
            result['DestinationDatasourceName'] = self.destination_datasource_name
        if self.destination_schema_name is not None:
            result['DestinationSchemaName'] = self.destination_schema_name
        if self.destination_table_name is not None:
            result['DestinationTableName'] = self.destination_table_name
        if self.full_migration_error_message is not None:
            result['FullMigrationErrorMessage'] = self.full_migration_error_message
        if self.full_migration_status is not None:
            result['FullMigrationStatus'] = self.full_migration_status
        if self.offline_error_records is not None:
            result['OfflineErrorRecords'] = self.offline_error_records
        if self.offline_total_bytes is not None:
            result['OfflineTotalBytes'] = self.offline_total_bytes
        if self.offline_total_records is not None:
            result['OfflineTotalRecords'] = self.offline_total_records
        if self.realtime_migration_error_message is not None:
            result['RealtimeMigrationErrorMessage'] = self.realtime_migration_error_message
        if self.realtime_migration_status is not None:
            result['RealtimeMigrationStatus'] = self.realtime_migration_status
        if self.source_database_name is not None:
            result['SourceDatabaseName'] = self.source_database_name
        if self.source_datasource_name is not None:
            result['SourceDatasourceName'] = self.source_datasource_name
        if self.source_schema_name is not None:
            result['SourceSchemaName'] = self.source_schema_name
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.structure_migration_error_message is not None:
            result['StructureMigrationErrorMessage'] = self.structure_migration_error_message
        if self.structure_migration_status is not None:
            result['StructureMigrationStatus'] = self.structure_migration_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDatabaseName') is not None:
            self.destination_database_name = m.get('DestinationDatabaseName')
        if m.get('DestinationDatasourceName') is not None:
            self.destination_datasource_name = m.get('DestinationDatasourceName')
        if m.get('DestinationSchemaName') is not None:
            self.destination_schema_name = m.get('DestinationSchemaName')
        if m.get('DestinationTableName') is not None:
            self.destination_table_name = m.get('DestinationTableName')
        if m.get('FullMigrationErrorMessage') is not None:
            self.full_migration_error_message = m.get('FullMigrationErrorMessage')
        if m.get('FullMigrationStatus') is not None:
            self.full_migration_status = m.get('FullMigrationStatus')
        if m.get('OfflineErrorRecords') is not None:
            self.offline_error_records = m.get('OfflineErrorRecords')
        if m.get('OfflineTotalBytes') is not None:
            self.offline_total_bytes = m.get('OfflineTotalBytes')
        if m.get('OfflineTotalRecords') is not None:
            self.offline_total_records = m.get('OfflineTotalRecords')
        if m.get('RealtimeMigrationErrorMessage') is not None:
            self.realtime_migration_error_message = m.get('RealtimeMigrationErrorMessage')
        if m.get('RealtimeMigrationStatus') is not None:
            self.realtime_migration_status = m.get('RealtimeMigrationStatus')
        if m.get('SourceDatabaseName') is not None:
            self.source_database_name = m.get('SourceDatabaseName')
        if m.get('SourceDatasourceName') is not None:
            self.source_datasource_name = m.get('SourceDatasourceName')
        if m.get('SourceSchemaName') is not None:
            self.source_schema_name = m.get('SourceSchemaName')
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('StructureMigrationErrorMessage') is not None:
            self.structure_migration_error_message = m.get('StructureMigrationErrorMessage')
        if m.get('StructureMigrationStatus') is not None:
            self.structure_migration_status = m.get('StructureMigrationStatus')
        return self


class ListDIJobRunDetailsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        job_run_infos: List[ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        self.job_run_infos = job_run_infos
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.job_run_infos:
            for k in self.job_run_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobRunInfos'] = []
        if self.job_run_infos is not None:
            for k in self.job_run_infos:
                result['JobRunInfos'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_run_infos = []
        if m.get('JobRunInfos') is not None:
            for k in m.get('JobRunInfos'):
                temp_model = ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos()
                self.job_run_infos.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDIJobRunDetailsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIJobRunDetailsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIJobRunDetailsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIJobRunDetailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIJobRunDetailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIJobRunDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIJobsRequest(TeaModel):
    def __init__(
        self,
        destination_data_source_type: str = None,
        migration_type: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        source_data_source_type: str = None,
    ):
        # The destination type. If you do not configure this parameter, no limits are imposed on the tasks.
        self.destination_data_source_type = destination_data_source_type
        # The synchronization type. Valid values:
        # 
        # *   FullAndRealtimeIncremental: one-time full synchronization and real-time incremental synchronization
        # *   RealtimeIncremental: real-time incremental synchronization
        # *   Full: full synchronization
        # *   OfflineIncremental: batch incremental synchronization
        # *   FullAndOfflineIncremental: one-time full synchronization and batch incremental synchronization
        self.migration_type = migration_type
        # The name of the export task.
        # 
        # The name of each export task must be unique. You must make sure that the names of the export tasks in the current workspace are unique.
        self.name = name
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The source type. If you do not configure this parameter, no limits are imposed on the tasks.
        self.source_data_source_type = source_data_source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        return self


class ListDIJobsResponseBodyPagingInfoDIJobs(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        destination_data_source_type: str = None,
        job_name: str = None,
        job_status: str = None,
        migration_type: str = None,
        project_id: int = None,
        source_data_source_type: str = None,
    ):
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The destination type. Valid values: Hologres and Hive.
        self.destination_data_source_type = destination_data_source_type
        # The name of the synchronization task.
        self.job_name = job_name
        # The status of the synchronization task. Valid values:
        # 
        # *   Finished
        # *   Initialized
        # *   Stopped
        # *   Failed
        # *   Running
        # *   Stopping
        self.job_status = job_status
        # The synchronization type. Valid values:
        # 
        # *   FullAndRealtimeIncremental: one-time full synchronization and real-time incremental synchronization
        # *   RealtimeIncremental: real-time incremental synchronization
        # *   Full: full synchronization
        # *   OfflineIncremental: batch incremental synchronization
        # *   FullAndOfflineIncremental: one-time full synchronization and batch incremental synchronization
        self.migration_type = migration_type
        # The ID of the DataWorks workspace to which the synchronization task belongs.
        self.project_id = project_id
        # The source type. The value MySQL is returned.
        self.source_data_source_type = source_data_source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        return self


class ListDIJobsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        dijobs: List[ListDIJobsResponseBodyPagingInfoDIJobs] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The synchronization tasks returned.
        self.dijobs = dijobs
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.dijobs:
            for k in self.dijobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DIJobs'] = []
        if self.dijobs is not None:
            for k in self.dijobs:
                result['DIJobs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dijobs = []
        if m.get('DIJobs') is not None:
            for k in m.get('DIJobs'):
                temp_model = ListDIJobsResponseBodyPagingInfoDIJobs()
                self.dijobs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDIJobsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIJobsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIJobsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityEvaluationTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        bizdate_from: str = None,
        bizdate_to: str = None,
        create_time_from: int = None,
        create_time_to: int = None,
        data_quality_evaluation_task_id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        table_guid: str = None,
        trigger_client: str = None,
        trigger_client_id: str = None,
    ):
        # The start time of the data quality monitoring task.
        self.bizdate_from = bizdate_from
        # The end time of the data quality monitoring task.
        self.bizdate_to = bizdate_to
        # The earliest start time at which the instances are generated.
        self.create_time_from = create_time_from
        # The latest start time at which the instances are generated.
        self.create_time_to = create_time_to
        # The ID of the data quality monitoring task.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The ID of the table in Data Map.
        self.table_guid = table_guid
        # The name of the trigger module of the instance.
        self.trigger_client = trigger_client
        # The ID of the instance that is generated by the task.
        self.trigger_client_id = trigger_client_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bizdate_from is not None:
            result['BizdateFrom'] = self.bizdate_from
        if self.bizdate_to is not None:
            result['BizdateTo'] = self.bizdate_to
        if self.create_time_from is not None:
            result['CreateTimeFrom'] = self.create_time_from
        if self.create_time_to is not None:
            result['CreateTimeTo'] = self.create_time_to
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.trigger_client is not None:
            result['TriggerClient'] = self.trigger_client
        if self.trigger_client_id is not None:
            result['TriggerClientId'] = self.trigger_client_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizdateFrom') is not None:
            self.bizdate_from = m.get('BizdateFrom')
        if m.get('BizdateTo') is not None:
            self.bizdate_to = m.get('BizdateTo')
        if m.get('CreateTimeFrom') is not None:
            self.create_time_from = m.get('CreateTimeFrom')
        if m.get('CreateTimeTo') is not None:
            self.create_time_to = m.get('CreateTimeTo')
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TriggerClient') is not None:
            self.trigger_client = m.get('TriggerClient')
        if m.get('TriggerClientId') is not None:
            self.trigger_client_id = m.get('TriggerClientId')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        # The trigger configuration of the callback event.
        self.condition = condition
        # The type of the callback event.
        # 
        # *   Valid values: BlockTaskInstance. The value indicates that an auto triggered node is blocked.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The extended information in the JSON format. For example, the DingTalk chatbot can remind all members in a DingTalk group by using the at sign (@).
        self.extension = extension
        # The type of the alert recipient. Valid values:
        # 
        # *   AliUid: Alibaba Cloud account ID
        # *   WebhookUrl: URL of a custom webhook
        # *   DingdingUrl: DingTalk chatbot URL
        # *   FeishuUrl: Lark chatbot URL
        # *   WeixinUrl: WeCom chatbot URL
        self.receiver_type = receiver_type
        # The alert recipients.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        # The alert notification methods.
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications(TeaModel):
    def __init__(
        self,
        nofitication_receivers: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers] = None,
        notification_channels: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels] = None,
    ):
        # The alert recipients.
        self.nofitication_receivers = nofitication_receivers
        # The alert notification methods.
        self.notification_channels = notification_channels

    def validate(self):
        if self.nofitication_receivers:
            for k in self.nofitication_receivers:
                if k:
                    k.validate()
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NofiticationReceivers'] = []
        if self.nofitication_receivers is not None:
            for k in self.nofitication_receivers:
                result['NofiticationReceivers'].append(k.to_map() if k else None)
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nofitication_receivers = []
        if m.get('NofiticationReceivers') is not None:
            for k in m.get('NofiticationReceivers'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers()
                self.nofitication_receivers.append(temp_model.from_map(k))
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications] = None,
    ):
        # The trigger condition of the alert notification.
        self.condition = condition
        # The configurations for the alert notification.
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table in Data Map.
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        # The IDs of the auto triggered nodes of which the instances are successfully run.
        self.task_ids = task_ids
        # The trigger condition of the task.
        # 
        # *   Valid values: ByScheduledTaskInstance. The value indicates that the task is triggered when the instance of an auto triggered node is successfully run.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask(TeaModel):
    def __init__(
        self,
        description: str = None,
        hooks: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks] = None,
        id: int = None,
        name: str = None,
        notifications: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications = None,
        project_id: int = None,
        region_id: str = None,
        runtime_conf: str = None,
        target: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget = None,
        tenant_id: int = None,
        trigger: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger = None,
    ):
        # The description of the task.
        self.description = description
        # The callback configurations of the task during the instance lifecycle. Blocking an auto triggered node is a type of callback event. Only this type is supported.
        self.hooks = hooks
        # The task ID.
        self.id = id
        # The name of the task.
        # 
        # This parameter is required.
        self.name = name
        # The configurations for alert notifications.
        self.notifications = notifications
        # The workspace ID.
        self.project_id = project_id
        # The region ID.
        self.region_id = region_id
        # The configuration of the data source. The value of the queue field is default, and that of the sqlEngine field is SPARK-SQL. The value default indicates the YARN queue for E-MapReduce (EMR) tasks, and the value SPARK-SQL indicates the SQL engine that is used to collect EMR data.
        self.runtime_conf = runtime_conf
        # The monitored object of the task.
        self.target = target
        # The tenant ID.
        self.tenant_id = tenant_id
        # The trigger configuration of the task.
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            self.notifications.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications is not None:
            result['Notifications'] = self.notifications.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications()
            self.notifications = temp_model.from_map(m['Notifications'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Trigger') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        finish_time: int = None,
        id: int = None,
        parameters: str = None,
        project_id: int = None,
        status: str = None,
        task: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask = None,
        trigger_context: str = None,
    ):
        # The time at which the instance was generated.
        self.create_time = create_time
        # The time at which the instance finished running.
        self.finish_time = finish_time
        # The ID of the instance.
        self.id = id
        # The parameters configured for the instance.
        self.parameters = parameters
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The status of the instance. Valid values:
        # 
        # *   Running
        # *   Error
        # *   Passed
        # *   Warned
        # *   Critical
        self.status = status
        # The snapshot of the configurations for the task when the task starts.
        self.task = task
        # The information about the trigger module of the instance.
        self.trigger_context = trigger_context

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.id is not None:
            result['Id'] = self.id
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.task is not None:
            result['Task'] = self.task.to_map()
        if self.trigger_context is not None:
            result['TriggerContext'] = self.trigger_context
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Task') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask()
            self.task = temp_model.from_map(m['Task'])
        if m.get('TriggerContext') is not None:
            self.trigger_context = m.get('TriggerContext')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_instances: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The instances generated by the task.
        self.data_quality_evaluation_task_instances = data_quality_evaluation_task_instances
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_quality_evaluation_task_instances:
            for k in self.data_quality_evaluation_task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityEvaluationTaskInstances'] = []
        if self.data_quality_evaluation_task_instances is not None:
            for k in self.data_quality_evaluation_task_instances:
                result['DataQualityEvaluationTaskInstances'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_evaluation_task_instances = []
        if m.get('DataQualityEvaluationTaskInstances') is not None:
            for k in m.get('DataQualityEvaluationTaskInstances'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances()
                self.data_quality_evaluation_task_instances.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityEvaluationTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityEvaluationTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityEvaluationTasksRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        table_guid: str = None,
    ):
        # The name of the data quality monitoring task. Fuzzy match is supported.
        self.name = name
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The ID of the table in Data Map.
        self.table_guid = table_guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        # The trigger configuration of the callback event.
        self.condition = condition
        # The type of the callback event.
        # 
        # *   Valid values: BlockTaskInstance. The value indicates that an auto triggered node is blocked.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        # The alert notification methods.
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The extended information in the JSON format. For example, the DingTalk chatbot can remind all members in a DingTalk group by using the at sign (@).
        self.extension = extension
        # The type of the alert recipient. Valid values:
        # 
        # *   AliUid: Alibaba Cloud account ID
        # *   WebhookUrl: URL of a custom webhook
        # *   DingdingUrl: DingTalk chatbot URL
        # *   FeishuUrl: Lark chatbot URL
        # *   WeixinUrl: WeCom chatbot URL
        self.receiver_type = receiver_type
        # The alert recipients.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers] = None,
    ):
        # The alert notification methods.
        self.notification_channels = notification_channels
        # The alert recipients.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications] = None,
    ):
        # The trigger condition of the alert notification.
        self.condition = condition
        # The configurations for the alert notification.
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table in Data Map.
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        # The IDs of the auto triggered nodes of which the instances are successfully run. This parameter takes effect only if the Type parameter is set to ByScheduledTaskInstance.
        self.task_ids = task_ids
        # The trigger condition of the task.
        # 
        # *   Valid values: ByScheduledTaskInstance. The value indicates that the task is triggered when the instance of an auto triggered node is successfully run.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks(TeaModel):
    def __init__(
        self,
        description: str = None,
        hooks: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks] = None,
        id: int = None,
        name: str = None,
        notifications: ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget = None,
        tenant_id: int = None,
        trigger: ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger = None,
    ):
        # The description of the data quality monitoring task. The description can be up to 65,535 characters in length.
        self.description = description
        # The callback configurations of the task during the instance lifecycle. Blocking an auto triggered node is a type of callback event. Only this type is supported.
        self.hooks = hooks
        # The ID of the data quality monitoring task.
        self.id = id
        # The name of the data quality monitoring task. The name can be up to 255 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # The configurations for alert notifications.
        self.notifications = notifications
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The configuration of the data source. The value of the queue field is default, and that of the sqlEngine field is SPARK-SQL. The value default indicates the YARN queue for E-MapReduce (EMR) tasks, and the value SPARK-SQL indicates the SQL engine that is used to collect EMR data.
        self.runtime_conf = runtime_conf
        # The monitored object of the task.
        self.target = target
        # The DataWorks tenant ID.
        self.tenant_id = tenant_id
        # The trigger configuration of the task.
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            self.notifications.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications is not None:
            result['Notifications'] = self.notifications.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications()
            self.notifications = temp_model.from_map(m['Notifications'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Trigger') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_tasks: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        # The data quality monitoring tasks.
        self.data_quality_evaluation_tasks = data_quality_evaluation_tasks
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_quality_evaluation_tasks:
            for k in self.data_quality_evaluation_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityEvaluationTasks'] = []
        if self.data_quality_evaluation_tasks is not None:
            for k in self.data_quality_evaluation_tasks:
                result['DataQualityEvaluationTasks'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_evaluation_tasks = []
        if m.get('DataQualityEvaluationTasks') is not None:
            for k in m.get('DataQualityEvaluationTasks'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks()
                self.data_quality_evaluation_tasks.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityEvaluationTasksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityEvaluationTasksResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityEvaluationTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityEvaluationTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityResultsRequest(TeaModel):
    def __init__(
        self,
        bizdate_from: str = None,
        bizdate_to: str = None,
        create_time_from: int = None,
        create_time_to: int = None,
        data_quality_evaluation_task_id: int = None,
        data_quality_evaluation_task_instance_id: int = None,
        data_quality_rule_id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
    ):
        # The beginning of the time range to query.
        self.bizdate_from = bizdate_from
        # The end of the time range to query.
        self.bizdate_to = bizdate_to
        self.create_time_from = create_time_from
        self.create_time_to = create_time_to
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        self.data_quality_evaluation_task_instance_id = data_quality_evaluation_task_instance_id
        self.data_quality_rule_id = data_quality_rule_id
        self.page_number = page_number
        self.page_size = page_size
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bizdate_from is not None:
            result['BizdateFrom'] = self.bizdate_from
        if self.bizdate_to is not None:
            result['BizdateTo'] = self.bizdate_to
        if self.create_time_from is not None:
            result['CreateTimeFrom'] = self.create_time_from
        if self.create_time_to is not None:
            result['CreateTimeTo'] = self.create_time_to
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.data_quality_evaluation_task_instance_id is not None:
            result['DataQualityEvaluationTaskInstanceId'] = self.data_quality_evaluation_task_instance_id
        if self.data_quality_rule_id is not None:
            result['DataQualityRuleId'] = self.data_quality_rule_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizdateFrom') is not None:
            self.bizdate_from = m.get('BizdateFrom')
        if m.get('BizdateTo') is not None:
            self.bizdate_to = m.get('BizdateTo')
        if m.get('CreateTimeFrom') is not None:
            self.create_time_from = m.get('CreateTimeFrom')
        if m.get('CreateTimeTo') is not None:
            self.create_time_to = m.get('CreateTimeTo')
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('DataQualityEvaluationTaskInstanceId') is not None:
            self.data_quality_evaluation_task_instance_id = m.get('DataQualityEvaluationTaskInstanceId')
        if m.get('DataQualityRuleId') is not None:
            self.data_quality_rule_id = m.get('DataQualityRuleId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails(TeaModel):
    def __init__(
        self,
        checked_value: str = None,
        referenced_value: str = None,
        status: str = None,
    ):
        self.checked_value = checked_value
        self.referenced_value = referenced_value
        # The comparison result between the value of CheckedValue and the threshold. Valid values:
        # 
        # *   Error
        # *   Passed
        # *   Warned
        # *   Critical
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checked_value is not None:
            result['CheckedValue'] = self.checked_value
        if self.referenced_value is not None:
            result['ReferencedValue'] = self.referenced_value
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckedValue') is not None:
            self.checked_value = m.get('CheckedValue')
        if m.get('ReferencedValue') is not None:
            self.referenced_value = m.get('ReferencedValue')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical = None,
        expected: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected = None,
        warned: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned = None,
    ):
        self.critical = critical
        self.expected = expected
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds = None,
        type: str = None,
    ):
        self.referenced_samples_filter = referenced_samples_filter
        self.thresholds = thresholds
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        self.error_data_filter = error_data_filter
        # The type of the operation. Valid values:
        # 
        # *   SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: indicates that data is sampled by executing custom SQL statements.
        self.metric = metric
        self.metric_parameters = metric_parameters
        self.sampling_filter = sampling_filter
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule(TeaModel):
    def __init__(
        self,
        checking_config: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig = None,
        severity: str = None,
        target: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget = None,
        template_code: str = None,
        tenant_id: int = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        self.description = description
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        self.id = id
        self.name = name
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config = sampling_config
        # The strength of the rule. Valid values:
        # 
        # *   High
        # *   Normal
        self.severity = severity
        # The monitored object of the rule.
        self.target = target
        self.template_code = template_code
        self.tenant_id = tenant_id

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResults(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        details: List[ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails] = None,
        id: int = None,
        rule: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule = None,
        sample: str = None,
        status: str = None,
        task_instance_id: int = None,
    ):
        self.create_time = create_time
        # The check details.
        self.details = details
        self.id = id
        # The snapshot of the rule configuration when the check starts.
        self.rule = rule
        self.sample = sample
        # The status of the check result. Valid values:
        # 
        # *   Running
        # *   Error
        # *   Passed
        # *   Warned
        # *   Critical
        self.status = status
        self.task_instance_id = task_instance_id

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()
        if self.rule:
            self.rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.rule is not None:
            result['Rule'] = self.rule.to_map()
        if self.sample is not None:
            result['Sample'] = self.sample
        if self.status is not None:
            result['Status'] = self.status
        if self.task_instance_id is not None:
            result['TaskInstanceId'] = self.task_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Rule') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule()
            self.rule = temp_model.from_map(m['Rule'])
        if m.get('Sample') is not None:
            self.sample = m.get('Sample')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskInstanceId') is not None:
            self.task_instance_id = m.get('TaskInstanceId')
        return self


class ListDataQualityResultsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_results: List[ListDataQualityResultsResponseBodyPagingInfoDataQualityResults] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The data quality check results.
        self.data_quality_results = data_quality_results
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.data_quality_results:
            for k in self.data_quality_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityResults'] = []
        if self.data_quality_results is not None:
            for k in self.data_quality_results:
                result['DataQualityResults'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_results = []
        if m.get('DataQualityResults') is not None:
            for k in m.get('DataQualityResults'):
                temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResults()
                self.data_quality_results.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityResultsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityResultsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityResultsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityResultsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityResultsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityRulesRequest(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_id: int = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        table_guid: str = None,
    ):
        # The ID of the data quality monitoring task that is associated with the rule.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The name of the rule. Fuzzy match is supported.
        self.name = name
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 200.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The ID of the table that is limited by the rule in Data Map.
        self.table_guid = table_guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical = None,
        expected: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected = None,
        warned: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned = None,
    ):
        # The threshold settings for critical alerts.
        self.critical = critical
        # The expected threshold setting.
        self.expected = expected
        # The threshold settings for normal alerts.
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference values. In this example, an expression is used to indicate the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold settings.
        self.thresholds = thresholds
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        # The SQL statement that is used to filter failed tasks. If the rule is defined by custom SQL statements, you must specify an SQL statement to filter failed tasks.
        self.error_data_filter = error_data_filter
        # The type of the operation. Valid values:
        # 
        # *   SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the percentage of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values in the field.
        # *   DuplicatedPercent: the percentage of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field is set to null.
        # *   NullValuePercent: the percentage of the number of rows in which the field is set to null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: indicates that the data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to filter unnecessary data during sampling. The statements can be up to 16,777,215 characters in length.
        self.sampling_filter = sampling_filter
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table that is limited by the rule in Data Map.
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRules(TeaModel):
    def __init__(
        self,
        checking_config: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig = None,
        severity: str = None,
        target: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget = None,
        template_code: str = None,
        tenant_id: int = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The description of the rule. The description can be up to 500 characters in length.
        self.description = description
        # Indicates whether the rule is enabled.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        # The rule ID.
        self.id = id
        # The rule name.
        self.name = name
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The settings for sampling.
        self.sampling_config = sampling_config
        # The strength of the rule. Valid values:
        # 
        # *   Normal
        # *   High
        self.severity = severity
        # The monitored object of the rule.
        self.target = target
        # The ID of the template used by the rule.
        self.template_code = template_code
        # The ID of the DataWorks tenant.
        self.tenant_id = tenant_id

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class ListDataQualityRulesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_rules: List[ListDataQualityRulesResponseBodyPagingInfoDataQualityRules] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The rules.
        self.data_quality_rules = data_quality_rules
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_quality_rules:
            for k in self.data_quality_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityRules'] = []
        if self.data_quality_rules is not None:
            for k in self.data_quality_rules:
                result['DataQualityRules'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_rules = []
        if m.get('DataQualityRules') is not None:
            for k in m.get('DataQualityRules'):
                temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRules()
                self.data_quality_rules.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityRulesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityRulesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataSourceSharedRulesRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        target_project_id: int = None,
    ):
        # This parameter is required.
        self.data_source_id = data_source_id
        self.target_project_id = target_project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.target_project_id is not None:
            result['TargetProjectId'] = self.target_project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('TargetProjectId') is not None:
            self.target_project_id = m.get('TargetProjectId')
        return self


class ListDataSourceSharedRulesResponseBodyDataSourceSharedRules(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        data_source_id: int = None,
        env_type: str = None,
        id: int = None,
        shared_data_source_name: str = None,
        shared_user: str = None,
        source_project_id: int = None,
        target_project_id: int = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.data_source_id = data_source_id
        self.env_type = env_type
        self.id = id
        self.shared_data_source_name = shared_data_source_name
        self.shared_user = shared_user
        self.source_project_id = source_project_id
        self.target_project_id = target_project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.shared_data_source_name is not None:
            result['SharedDataSourceName'] = self.shared_data_source_name
        if self.shared_user is not None:
            result['SharedUser'] = self.shared_user
        if self.source_project_id is not None:
            result['SourceProjectId'] = self.source_project_id
        if self.target_project_id is not None:
            result['TargetProjectId'] = self.target_project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('SharedDataSourceName') is not None:
            self.shared_data_source_name = m.get('SharedDataSourceName')
        if m.get('SharedUser') is not None:
            self.shared_user = m.get('SharedUser')
        if m.get('SourceProjectId') is not None:
            self.source_project_id = m.get('SourceProjectId')
        if m.get('TargetProjectId') is not None:
            self.target_project_id = m.get('TargetProjectId')
        return self


class ListDataSourceSharedRulesResponseBody(TeaModel):
    def __init__(
        self,
        data_source_shared_rules: List[ListDataSourceSharedRulesResponseBodyDataSourceSharedRules] = None,
        request_id: str = None,
    ):
        self.data_source_shared_rules = data_source_shared_rules
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data_source_shared_rules:
            for k in self.data_source_shared_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSourceSharedRules'] = []
        if self.data_source_shared_rules is not None:
            for k in self.data_source_shared_rules:
                result['DataSourceSharedRules'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source_shared_rules = []
        if m.get('DataSourceSharedRules') is not None:
            for k in m.get('DataSourceSharedRules'):
                temp_model = ListDataSourceSharedRulesResponseBodyDataSourceSharedRules()
                self.data_source_shared_rules.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataSourceSharedRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataSourceSharedRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataSourceSharedRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataSourcesRequest(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        tags: str = None,
        types: List[str] = None,
    ):
        self.env_type = env_type
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.project_id = project_id
        self.sort_by = sort_by
        self.tags = tags
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListDataSourcesShrinkRequest(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        tags: str = None,
        types_shrink: str = None,
    ):
        self.env_type = env_type
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.project_id = project_id
        self.sort_by = sort_by
        self.tags = tags
        self.types_shrink = types_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        return self


class ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource(TeaModel):
    def __init__(
        self,
        connection_properties: Any = None,
        connection_properties_mode: str = None,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        qualified_name: str = None,
    ):
        self.connection_properties = connection_properties
        self.connection_properties_mode = connection_properties_mode
        self.create_time = create_time
        self.create_user = create_user
        self.description = description
        self.id = id
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.qualified_name = qualified_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_properties is not None:
            result['ConnectionProperties'] = self.connection_properties
        if self.connection_properties_mode is not None:
            result['ConnectionPropertiesMode'] = self.connection_properties_mode
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.qualified_name is not None:
            result['QualifiedName'] = self.qualified_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionProperties') is not None:
            self.connection_properties = m.get('ConnectionProperties')
        if m.get('ConnectionPropertiesMode') is not None:
            self.connection_properties_mode = m.get('ConnectionPropertiesMode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('QualifiedName') is not None:
            self.qualified_name = m.get('QualifiedName')
        return self


class ListDataSourcesResponseBodyPagingInfoDataSources(TeaModel):
    def __init__(
        self,
        data_source: List[ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource] = None,
        name: str = None,
        type: str = None,
    ):
        self.data_source = data_source
        self.name = name
        self.type = type

    def validate(self):
        if self.data_source:
            for k in self.data_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSource'] = []
        if self.data_source is not None:
            for k in self.data_source:
                result['DataSource'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source = []
        if m.get('DataSource') is not None:
            for k in m.get('DataSource'):
                temp_model = ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource()
                self.data_source.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataSourcesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_sources: List[ListDataSourcesResponseBodyPagingInfoDataSources] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.data_sources = data_sources
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.data_sources:
            for k in self.data_sources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSources'] = []
        if self.data_sources is not None:
            for k in self.data_sources:
                result['DataSources'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_sources = []
        if m.get('DataSources') is not None:
            for k in m.get('DataSources'):
                temp_model = ListDataSourcesResponseBodyPagingInfoDataSources()
                self.data_sources.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataSourcesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataSourcesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataSourcesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataSourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataSourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataSourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDeploymentsRequest(TeaModel):
    def __init__(
        self,
        creator: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: str = None,
        status: str = None,
    ):
        # The ID of the user who creates the processes. This parameter specifies a filter condition.
        self.creator = creator
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The status of the processes. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   INIT
        # *   RUNNING
        # *   SUCCESS
        # *   FAIL
        # *   TERMINATION
        # *   CANCEL
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDeploymentsResponseBodyPagingInfoDeploymentsStages(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        detail: Dict[str, Any] = None,
        message: str = None,
        name: str = None,
        status: str = None,
        step: int = None,
        type: str = None,
    ):
        # The code of the stage.
        self.code = code
        # The description of the stage.
        self.description = description
        # The additional information about the stage.
        self.detail = detail
        # The error message returned during the stage.
        self.message = message
        # The name of the stage.
        self.name = name
        # The status of the stage.
        # 
        # Valid values:
        # 
        # *   INIT
        # *   RUNNING
        # *   SUCCESS
        # *   FAIL
        # *   TERMINATION
        # *   CANCEL
        self.status = status
        # The step number of the stage.
        self.step = step
        # The type of the stage. This parameter indicates the operation type in the stage.
        # 
        # Valid values:
        # 
        # *   DEPLOY
        # *   CHECK
        # *   OFFLINE.
        # *   BUILD
        # *   DELETE
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.description is not None:
            result['Description'] = self.description
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.step is not None:
            result['Step'] = self.step
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDeploymentsResponseBodyPagingInfoDeployments(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator: str = None,
        id: str = None,
        message: str = None,
        modify_time: int = None,
        project_id: str = None,
        stages: List[ListDeploymentsResponseBodyPagingInfoDeploymentsStages] = None,
        status: str = None,
    ):
        # The time when the process was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the user who creates the process.
        self.creator = creator
        # The process ID.
        self.id = id
        # The error message returned if the process fails.
        self.message = message
        # The time when the process was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The stages of the process.
        self.stages = stages
        # The status of the process.
        # 
        # Valid values:
        # 
        # *   INIT
        # *   RUNNING
        # *   FAIL
        # *   SUCCESS
        # *   TERMINATION
        # *   CANCEL
        self.status = status

    def validate(self):
        if self.stages:
            for k in self.stages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Stages'] = []
        if self.stages is not None:
            for k in self.stages:
                result['Stages'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.stages = []
        if m.get('Stages') is not None:
            for k in m.get('Stages'):
                temp_model = ListDeploymentsResponseBodyPagingInfoDeploymentsStages()
                self.stages.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDeploymentsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        deployments: List[ListDeploymentsResponseBodyPagingInfoDeployments] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        # The processes.
        self.deployments = deployments
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.deployments:
            for k in self.deployments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Deployments'] = []
        if self.deployments is not None:
            for k in self.deployments:
                result['Deployments'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deployments = []
        if m.get('Deployments') is not None:
            for k in m.get('Deployments'):
                temp_model = ListDeploymentsResponseBodyPagingInfoDeployments()
                self.deployments.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDeploymentsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDeploymentsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDeploymentsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDeploymentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDeploymentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDeploymentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDownstreamTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.id = id
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        self.gateway = gateway
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        self.cu = cu
        self.image = image
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource = None,
        description: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime = None,
        runtime_resource: ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource = None,
        started_time: int = None,
        status: str = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        self.baseline_id = baseline_id
        self.bizdate = bizdate
        self.create_time = create_time
        self.create_user = create_user
        self.data_source = data_source
        self.description = description
        self.finished_time = finished_time
        self.id = id
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.owner = owner
        self.period_number = period_number
        self.priority = priority
        self.project_env = project_env
        self.project_id = project_id
        self.rerun_mode = rerun_mode
        self.run_number = run_number
        self.runtime = runtime
        self.runtime_resource = runtime_resource
        self.started_time = started_time
        self.status = status
        self.task_id = task_id
        self.task_name = task_name
        self.task_type = task_type
        self.tenant_id = tenant_id
        self.timeout = timeout
        self.trigger_recurrence = trigger_recurrence
        self.trigger_time = trigger_time
        self.trigger_type = trigger_type
        self.workflow_id = workflow_id
        self.workflow_instance_id = workflow_instance_id
        self.workflow_instance_type = workflow_instance_type
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        task_instances: List[ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.task_instances = task_instances
        self.total_count = total_count

    def validate(self):
        if self.task_instances:
            for k in self.task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['TaskInstances'] = []
        if self.task_instances is not None:
            for k in self.task_instances:
                result['TaskInstances'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.task_instances = []
        if m.get('TaskInstances') is not None:
            for k in m.get('TaskInstances'):
                temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances()
                self.task_instances.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDownstreamTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDownstreamTaskInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDownstreamTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDownstreamTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDownstreamTasksRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
    ):
        # This parameter is required.
        self.id = id
        self.page_number = page_number
        self.page_size = page_size
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class ListDownstreamTasksResponseBodyPagingInfoTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        self.cu = cu
        self.image = image
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListDownstreamTasksResponseBodyPagingInfoTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        self.cron = cron
        self.end_time = end_time
        self.recurrence = recurrence
        self.start_time = start_time
        self.timezone = timezone
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDownstreamTasksResponseBodyPagingInfoTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListDownstreamTasksResponseBodyPagingInfoTasksDataSource = None,
        description: str = None,
        id: int = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource = None,
        step_type: str = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger: ListDownstreamTasksResponseBodyPagingInfoTasksTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        self.baseline_id = baseline_id
        self.create_time = create_time
        self.create_user = create_user
        self.data_source = data_source
        self.description = description
        self.id = id
        self.instance_mode = instance_mode
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.name = name
        self.owner = owner
        self.priority = priority
        self.project_env = project_env
        self.project_id = project_id
        self.rerun_interval = rerun_interval
        self.rerun_mode = rerun_mode
        self.rerun_times = rerun_times
        self.runtime_resource = runtime_resource
        self.step_type = step_type
        self.tenant_id = tenant_id
        self.timeout = timeout
        self.trigger = trigger
        self.type = type
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.step_type is not None:
            result['StepType'] = self.step_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StepType') is not None:
            self.step_type = m.get('StepType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListDownstreamTasksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        tasks: List[ListDownstreamTasksResponseBodyPagingInfoTasks] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.tasks = tasks
        self.total_count = total_count

    def validate(self):
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = ListDownstreamTasksResponseBodyPagingInfoTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDownstreamTasksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDownstreamTasksResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDownstreamTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDownstreamTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDownstreamTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFunctionsRequest(TeaModel):
    def __init__(
        self,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: str = None,
        type: str = None,
    ):
        # The ID of the owner of the UDF. This parameter specifies a filter condition.
        self.owner = owner
        # The page number. Default value: 1. Minimum value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The UDF type. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   MATH: mathematical operation function
        # *   AGGREGATE: aggregate function
        # *   STRING: string processing function
        # *   DATE: date function
        # *   ANALYTIC: window function
        # *   OTHER: others
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListFunctionsResponseBodyPagingInfoFunctionsDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
    ):
        # The ID of the resource group used when you run the UDF.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListFunctionsResponseBodyPagingInfoFunctionsScript(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        runtime: ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListFunctionsResponseBodyPagingInfoFunctions(TeaModel):
    def __init__(
        self,
        arm_resource: str = None,
        class_name: str = None,
        command_description: str = None,
        create_time: int = None,
        data_source: ListFunctionsResponseBodyPagingInfoFunctionsDataSource = None,
        database_name: str = None,
        description: str = None,
        embedded_code: str = None,
        embedded_code_type: str = None,
        embedded_resource_type: str = None,
        example_description: str = None,
        file_resource: str = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        parameter_description: str = None,
        project_id: str = None,
        return_value_description: str = None,
        runtime_resource: ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource = None,
        script: ListFunctionsResponseBodyPagingInfoFunctionsScript = None,
        type: str = None,
    ):
        # The file resources in an Advanced RISC Machines (ARM) cluster.
        self.arm_resource = arm_resource
        # The fully qualified class name of the UDF.
        self.class_name = class_name
        # The description of the command.
        self.command_description = command_description
        # The time when the UDF was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The data source information about the UDF.
        self.data_source = data_source
        # The name of the database. This parameter is returned for E-MapReduce (EMR) functions.
        self.database_name = database_name
        # The overall description of the UDF.
        self.description = description
        # The code of the embedded UDF.
        self.embedded_code = embedded_code
        # The type of the nested code.
        # 
        # Valid values:
        # 
        # *   Python2
        # *   Python3
        # *   Java8
        # *   Java11
        # *   Java17
        self.embedded_code_type = embedded_code_type
        # The type of the nested resource.
        # 
        # Valid values:
        # 
        # *   File: general resources
        # *   Embedded: embedded resources
        self.embedded_resource_type = embedded_resource_type
        # The description of the example.
        self.example_description = example_description
        # The files resources.
        self.file_resource = file_resource
        # The ID of the UDF.
        self.id = id
        # The time when the UDF was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the UDF.
        self.name = name
        # The owner of the UDF.
        self.owner = owner
        # The description of the parameter.
        self.parameter_description = parameter_description
        # The ID of the workspace to which the UDF belongs.
        self.project_id = project_id
        # The description of the return value.
        self.return_value_description = return_value_description
        # The information about the resource group used when you run the UDF.
        self.runtime_resource = runtime_resource
        # The script information about the UDF.
        self.script = script
        # The UDF type.
        # 
        # Valid values:
        # 
        # *   MATH: mathematical operation function
        # *   AGGREGATE: aggregate function
        # *   STRING: string processing function
        # *   DATE: date function
        # *   ANALYTIC: window function
        # *   OTHER: others
        self.type = type

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arm_resource is not None:
            result['ArmResource'] = self.arm_resource
        if self.class_name is not None:
            result['ClassName'] = self.class_name
        if self.command_description is not None:
            result['CommandDescription'] = self.command_description
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.description is not None:
            result['Description'] = self.description
        if self.embedded_code is not None:
            result['EmbeddedCode'] = self.embedded_code
        if self.embedded_code_type is not None:
            result['EmbeddedCodeType'] = self.embedded_code_type
        if self.embedded_resource_type is not None:
            result['EmbeddedResourceType'] = self.embedded_resource_type
        if self.example_description is not None:
            result['ExampleDescription'] = self.example_description
        if self.file_resource is not None:
            result['FileResource'] = self.file_resource
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parameter_description is not None:
            result['ParameterDescription'] = self.parameter_description
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.return_value_description is not None:
            result['ReturnValueDescription'] = self.return_value_description
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArmResource') is not None:
            self.arm_resource = m.get('ArmResource')
        if m.get('ClassName') is not None:
            self.class_name = m.get('ClassName')
        if m.get('CommandDescription') is not None:
            self.command_description = m.get('CommandDescription')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSource') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfoFunctionsDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EmbeddedCode') is not None:
            self.embedded_code = m.get('EmbeddedCode')
        if m.get('EmbeddedCodeType') is not None:
            self.embedded_code_type = m.get('EmbeddedCodeType')
        if m.get('EmbeddedResourceType') is not None:
            self.embedded_resource_type = m.get('EmbeddedResourceType')
        if m.get('ExampleDescription') is not None:
            self.example_description = m.get('ExampleDescription')
        if m.get('FileResource') is not None:
            self.file_resource = m.get('FileResource')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ParameterDescription') is not None:
            self.parameter_description = m.get('ParameterDescription')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ReturnValueDescription') is not None:
            self.return_value_description = m.get('ReturnValueDescription')
        if m.get('RuntimeResource') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfoFunctionsScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListFunctionsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        functions: List[ListFunctionsResponseBodyPagingInfoFunctions] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The UDFs.
        self.functions = functions
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.functions:
            for k in self.functions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Functions'] = []
        if self.functions is not None:
            for k in self.functions:
                result['Functions'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.functions = []
        if m.get('Functions') is not None:
            for k in m.get('Functions'):
                temp_model = ListFunctionsResponseBodyPagingInfoFunctions()
                self.functions.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListFunctionsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListFunctionsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListFunctionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFunctionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFunctionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNetworksRequest(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
    ):
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListNetworksResponseBodyNetworkList(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        id: int = None,
        resource_group_id: str = None,
        security_group_id: str = None,
        status: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.id = id
        self.resource_group_id = resource_group_id
        self.security_group_id = security_group_id
        self.status = status
        self.vpc_id = vpc_id
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class ListNetworksResponseBody(TeaModel):
    def __init__(
        self,
        network_list: List[ListNetworksResponseBodyNetworkList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.network_list = network_list
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.network_list:
            for k in self.network_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkList'] = []
        if self.network_list is not None:
            for k in self.network_list:
                result['NetworkList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.network_list = []
        if m.get('NetworkList') is not None:
            for k in m.get('NetworkList'):
                temp_model = ListNetworksResponseBodyNetworkList()
                self.network_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListNetworksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNetworksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNetworksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNodeDependenciesRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: str = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        # The node output.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables(TeaModel):
    def __init__(
        self,
        guid: str = None,
    ):
        # The table ID.
        self.guid = guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.guid is not None:
            result['Guid'] = self.guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Guid') is not None:
            self.guid = m.get('Guid')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output of the node.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables(TeaModel):
    def __init__(
        self,
        artifact_type: str = None,
        id: str = None,
        name: str = None,
        node: ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode = None,
        scope: str = None,
        type: str = None,
        value: str = None,
    ):
        # The artifact type.
        self.artifact_type = artifact_type
        # The variable ID.
        self.id = id
        # The name of the variable.
        self.name = name
        # The node to which the variable belongs.
        self.node = node
        # The scope of the variable.
        # 
        # Valid values:
        # 
        # *   NodeParameter
        # *   NodeContext
        # *   Workflow
        # *   Workspace
        self.scope = scope
        # The type of the variable.
        # 
        # Valid values:
        # 
        # *   NoKvVariableExpression
        # *   Constant
        # *   PassThrough
        # *   System
        # *   NodeOutput
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.artifact_type is not None:
            result['ArtifactType'] = self.artifact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArtifactType') is not None:
            self.artifact_type = m.get('ArtifactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Node') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputs(TeaModel):
    def __init__(
        self,
        node_outputs: List[ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs] = None,
        tables: List[ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables] = None,
        variables: List[ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables] = None,
    ):
        # The node outputs.
        self.node_outputs = node_outputs
        # The tables.
        self.tables = tables
        # The variables.
        self.variables = variables

    def validate(self):
        if self.node_outputs:
            for k in self.node_outputs:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeOutputs'] = []
        if self.node_outputs is not None:
            for k in self.node_outputs:
                result['NodeOutputs'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_outputs = []
        if m.get('NodeOutputs') is not None:
            for k in m.get('NodeOutputs'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs()
                self.node_outputs.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables()
                self.tables.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        # The node output.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables(TeaModel):
    def __init__(
        self,
        guid: str = None,
    ):
        # The table ID.
        self.guid = guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.guid is not None:
            result['Guid'] = self.guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Guid') is not None:
            self.guid = m.get('Guid')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output of the node to which the variable belongs.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables(TeaModel):
    def __init__(
        self,
        artifact_type: str = None,
        id: str = None,
        name: str = None,
        node: ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode = None,
        scope: str = None,
        type: str = None,
        value: str = None,
    ):
        # The artifact type.
        self.artifact_type = artifact_type
        # The variable ID.
        self.id = id
        # The name of the variable.
        self.name = name
        # The node to which the variable belongs.
        self.node = node
        # The scope of the variable.
        # 
        # Valid values:
        # 
        # *   NodeParameter
        # *   NodeContext
        # *   Workflow
        # *   Workspace
        self.scope = scope
        # The type of the variable.
        # 
        # Valid values:
        # 
        # *   NoKvVariableExpression
        # *   Constant
        # *   PassThrough
        # *   System
        # *   NodeOutput
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.artifact_type is not None:
            result['ArtifactType'] = self.artifact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArtifactType') is not None:
            self.artifact_type = m.get('ArtifactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Node') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputs(TeaModel):
    def __init__(
        self,
        node_outputs: List[ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs] = None,
        tables: List[ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables] = None,
        variables: List[ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables] = None,
    ):
        # The node outputs.
        self.node_outputs = node_outputs
        # The tables.
        self.tables = tables
        # The variables.
        self.variables = variables

    def validate(self):
        if self.node_outputs:
            for k in self.node_outputs:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeOutputs'] = []
        if self.node_outputs is not None:
            for k in self.node_outputs:
                result['NodeOutputs'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_outputs = []
        if m.get('NodeOutputs') is not None:
            for k in m.get('NodeOutputs'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs()
                self.node_outputs.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables()
                self.tables.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
    ):
        # The resource group ID.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command used to distinguish node types.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesScript(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        runtime: ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesStrategy(TeaModel):
    def __init__(
        self,
        instance_mode: str = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        timeout: int = None,
    ):
        # The instance generation mode.
        self.instance_mode = instance_mode
        # The rerun interval after a failure. Unit: milliseconds.
        self.rerun_interval = rerun_interval
        # The rerun mode.
        self.rerun_mode = rerun_mode
        # The number of reruns after a failure.
        self.rerun_times = rerun_times
        # The timeout period. Unit: milliseconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        id: str = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        # The CRON expression for scheduling.
        self.cron = cron
        # The end time of the validity period of the scheduling. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.end_time = end_time
        # The trigger ID.
        self.id = id
        # The start time of the validity period of the scheduling. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.start_time = start_time
        # The time zone.
        self.timezone = timezone
        # The type of the trigger.
        # 
        # Valid values:
        # 
        # *   Scheduler
        # *   Manual
        # *   Streaming
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodes(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        data_source: ListNodeDependenciesResponseBodyPagingInfoNodesDataSource = None,
        description: str = None,
        id: str = None,
        inputs: ListNodeDependenciesResponseBodyPagingInfoNodesInputs = None,
        modify_time: int = None,
        name: str = None,
        outputs: ListNodeDependenciesResponseBodyPagingInfoNodesOutputs = None,
        owner: str = None,
        project_id: str = None,
        recurrence: str = None,
        runtime_resource: ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource = None,
        script: ListNodeDependenciesResponseBodyPagingInfoNodesScript = None,
        strategy: ListNodeDependenciesResponseBodyPagingInfoNodesStrategy = None,
        tags: List[ListNodeDependenciesResponseBodyPagingInfoNodesTags] = None,
        task_id: str = None,
        trigger: ListNodeDependenciesResponseBodyPagingInfoNodesTrigger = None,
    ):
        # The time when the node was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The information about the data source.
        self.data_source = data_source
        # The description of the node.
        self.description = description
        # The ID of the node.
        self.id = id
        # The input of the node.
        self.inputs = inputs
        # The time when the node was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the node.
        self.name = name
        # The output of the node.
        self.outputs = outputs
        # The owner of the node.
        self.owner = owner
        # The ID of the workspace to which the node belongs.
        self.project_id = project_id
        # The scheduling type.
        # 
        # Valid values:
        # 
        # *   Normal: The node is scheduled as expected.
        # *   Pause: The node is paused, and the running of its descendant nodes is blocked.
        # *   Skip: The node is dry run. The system does not actually run the node but directly prompts that the node is successfully run. The running duration of the node is 0 seconds. In addition, the node does not occupy resources or block the running of its descendant nodes.
        self.recurrence = recurrence
        # The information about the resource group.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The scheduling policy.
        self.strategy = strategy
        # The tags. This parameter is not in use.
        self.tags = tags
        # The scheduling task ID.
        self.task_id = task_id
        # The trigger.
        self.trigger = trigger

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.strategy:
            self.strategy.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.strategy is not None:
            result['Strategy'] = self.strategy.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSource') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('RuntimeResource') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Strategy') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesStrategy()
            self.strategy = temp_model.from_map(m['Strategy'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Trigger') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListNodeDependenciesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        nodes: List[ListNodeDependenciesResponseBodyPagingInfoNodes] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        # The descendant nodes.
        self.nodes = nodes
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListNodeDependenciesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListNodeDependenciesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListNodeDependenciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNodeDependenciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNodeDependenciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNodesRequest(TeaModel):
    def __init__(
        self,
        container_id: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: str = None,
        recurrence: str = None,
        rerun_mode: str = None,
        scene: str = None,
    ):
        # The container ID. This parameter specifies a filter condition.
        self.container_id = container_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        self.recurrence = recurrence
        # The rerun mode. Valid values:
        # 
        # *   Allowed: The nodes can be rerun regardless of whether they are successfully run or fail to run.
        # *   FailureAllowed: The nodes can be rerun only after they fail to run.
        # *   Denied: The nodes cannot be rerun regardless of whether they are successfully run or fail to run.
        self.rerun_mode = rerun_mode
        # The scene of nodes. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   DATAWORKS_PROJECT
        # *   MANUAL_WORKFLOW
        # *   MANUAL_NODE
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.scene is not None:
            result['Scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        return self


class ListNodesResponseBodyPagingInfoNodesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        # The node output.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ListNodesResponseBodyPagingInfoNodesInputsTables(TeaModel):
    def __init__(
        self,
        guid: str = None,
    ):
        # The table ID.
        self.guid = guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.guid is not None:
            result['Guid'] = self.guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Guid') is not None:
            self.guid = m.get('Guid')
        return self


class ListNodesResponseBodyPagingInfoNodesInputsVariablesNode(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output of the node.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ListNodesResponseBodyPagingInfoNodesInputsVariables(TeaModel):
    def __init__(
        self,
        artifact_type: str = None,
        id: str = None,
        name: str = None,
        node: ListNodesResponseBodyPagingInfoNodesInputsVariablesNode = None,
        scope: str = None,
        type: str = None,
        value: str = None,
    ):
        # The artifact type.
        self.artifact_type = artifact_type
        # The variable ID.
        self.id = id
        # The name of the variable.
        self.name = name
        # The node to which the variable belongs.
        self.node = node
        # The scope of the variable.
        # 
        # Valid values:
        # 
        # *   WorkSpace
        # *   NodeParameter
        # *   NodeContext
        # *   Workflow
        self.scope = scope
        # The type of the variable.
        # 
        # Valid values:
        # 
        # *   NoKvVariableExpression
        # *   Constant
        # *   PassThrough
        # *   System
        # *   NodeOutput
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.artifact_type is not None:
            result['ArtifactType'] = self.artifact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArtifactType') is not None:
            self.artifact_type = m.get('ArtifactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Node') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesInputsVariablesNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodesResponseBodyPagingInfoNodesInputs(TeaModel):
    def __init__(
        self,
        node_outputs: List[ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs] = None,
        tables: List[ListNodesResponseBodyPagingInfoNodesInputsTables] = None,
        variables: List[ListNodesResponseBodyPagingInfoNodesInputsVariables] = None,
    ):
        # The node outputs.
        self.node_outputs = node_outputs
        # The tables.
        self.tables = tables
        # The variables.
        self.variables = variables

    def validate(self):
        if self.node_outputs:
            for k in self.node_outputs:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeOutputs'] = []
        if self.node_outputs is not None:
            for k in self.node_outputs:
                result['NodeOutputs'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_outputs = []
        if m.get('NodeOutputs') is not None:
            for k in m.get('NodeOutputs'):
                temp_model = ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs()
                self.node_outputs.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = ListNodesResponseBodyPagingInfoNodesInputsTables()
                self.tables.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ListNodesResponseBodyPagingInfoNodesInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        # The node output.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ListNodesResponseBodyPagingInfoNodesOutputsTables(TeaModel):
    def __init__(
        self,
        guid: str = None,
    ):
        # The table ID.
        self.guid = guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.guid is not None:
            result['Guid'] = self.guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Guid') is not None:
            self.guid = m.get('Guid')
        return self


class ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output of the node.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ListNodesResponseBodyPagingInfoNodesOutputsVariables(TeaModel):
    def __init__(
        self,
        artifact_type: str = None,
        id: str = None,
        name: str = None,
        node: ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode = None,
        scope: str = None,
        type: str = None,
        value: str = None,
    ):
        # The artifact type.
        self.artifact_type = artifact_type
        # The variable ID.
        self.id = id
        # The name of the variable.
        self.name = name
        # The node to which the variable belongs.
        self.node = node
        # The scope of the variable.
        # 
        # Valid values:
        # 
        # *   NodeParameter
        # *   NodeContext
        # *   Workflow
        # *   Workspace
        self.scope = scope
        # The type of the variable.
        # 
        # Valid values:
        # 
        # *   NoKvVariableExpression
        # *   Constant
        # *   PassThrough
        # *   System
        # *   NodeOutput
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.artifact_type is not None:
            result['ArtifactType'] = self.artifact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArtifactType') is not None:
            self.artifact_type = m.get('ArtifactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Node') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodesResponseBodyPagingInfoNodesOutputs(TeaModel):
    def __init__(
        self,
        node_outputs: List[ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs] = None,
        tables: List[ListNodesResponseBodyPagingInfoNodesOutputsTables] = None,
        variables: List[ListNodesResponseBodyPagingInfoNodesOutputsVariables] = None,
    ):
        # The node outputs.
        self.node_outputs = node_outputs
        # The tables.
        self.tables = tables
        # The variables.
        self.variables = variables

    def validate(self):
        if self.node_outputs:
            for k in self.node_outputs:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeOutputs'] = []
        if self.node_outputs is not None:
            for k in self.node_outputs:
                result['NodeOutputs'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_outputs = []
        if m.get('NodeOutputs') is not None:
            for k in m.get('NodeOutputs'):
                temp_model = ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs()
                self.node_outputs.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = ListNodesResponseBodyPagingInfoNodesOutputsTables()
                self.tables.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ListNodesResponseBodyPagingInfoNodesOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListNodesResponseBodyPagingInfoNodesRuntimeResource(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
    ):
        # The resource group ID.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListNodesResponseBodyPagingInfoNodesScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command used to distinguish node types.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListNodesResponseBodyPagingInfoNodesScript(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        runtime: ListNodesResponseBodyPagingInfoNodesScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListNodesResponseBodyPagingInfoNodesStrategy(TeaModel):
    def __init__(
        self,
        instance_mode: str = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        timeout: int = None,
    ):
        # The instance generation mode.
        self.instance_mode = instance_mode
        # The rerun interval. Unit: milliseconds.
        self.rerun_interval = rerun_interval
        # The rerun mode.
        self.rerun_mode = rerun_mode
        # The number of reruns.
        self.rerun_times = rerun_times
        # The timeout period.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class ListNodesResponseBodyPagingInfoNodesTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodesResponseBodyPagingInfoNodesTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        id: str = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        # The CRON expression for scheduling.
        self.cron = cron
        # The end time of the validity period of the trigger.
        self.end_time = end_time
        # The trigger ID.
        self.id = id
        # The start time of the validity period of the trigger.
        self.start_time = start_time
        # The time zone.
        self.timezone = timezone
        # The type of the trigger.
        # 
        # Valid values:
        # 
        # *   Scheduler
        # *   Manual
        # *   Steaming
        # 
        # <!---->
        # 
        # *\
        # *\
        # *\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNodesResponseBodyPagingInfoNodes(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        data_source: ListNodesResponseBodyPagingInfoNodesDataSource = None,
        description: str = None,
        id: str = None,
        inputs: ListNodesResponseBodyPagingInfoNodesInputs = None,
        modify_time: int = None,
        name: str = None,
        outputs: ListNodesResponseBodyPagingInfoNodesOutputs = None,
        owner: str = None,
        project_id: str = None,
        recurrence: str = None,
        runtime_resource: ListNodesResponseBodyPagingInfoNodesRuntimeResource = None,
        script: ListNodesResponseBodyPagingInfoNodesScript = None,
        strategy: ListNodesResponseBodyPagingInfoNodesStrategy = None,
        tags: List[ListNodesResponseBodyPagingInfoNodesTags] = None,
        task_id: str = None,
        trigger: ListNodesResponseBodyPagingInfoNodesTrigger = None,
    ):
        # The time when the node was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The information about the data source.
        self.data_source = data_source
        # The description of the node.
        self.description = description
        # The ID of the node.
        self.id = id
        # The input of the node.
        self.inputs = inputs
        # The time when the node was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the node.
        self.name = name
        # The output of the node.
        self.outputs = outputs
        # The owner of the node.
        self.owner = owner
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        self.project_id = project_id
        # The scheduling type.
        # 
        # Valid values:
        # 
        # *   Normal: The node is scheduled as expected.
        # *   Pause: The node is paused, and the running of its descendant nodes is blocked.
        # *   Skip: The node is dry run. The system does not actually run the node but directly prompts that the node is successfully run. The running duration of the node is 0 seconds. In addition, the node does not occupy resources or block the running of its descendant nodes.
        self.recurrence = recurrence
        # The information about the resource group.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The scheduling policy.
        self.strategy = strategy
        # The tags. This parameter is not in use.
        self.tags = tags
        # The scheduling task ID.
        self.task_id = task_id
        # The trigger.
        self.trigger = trigger

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.strategy:
            self.strategy.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.strategy is not None:
            result['Strategy'] = self.strategy.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSource') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('RuntimeResource') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Strategy') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesStrategy()
            self.strategy = temp_model.from_map(m['Strategy'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListNodesResponseBodyPagingInfoNodesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Trigger') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListNodesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        nodes: List[ListNodesResponseBodyPagingInfoNodes] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        # The nodes.
        self.nodes = nodes
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = ListNodesResponseBodyPagingInfoNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListNodesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListNodesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListNodesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectMembersRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        role_codes: List[str] = None,
        user_ids: List[str] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/zh/dataworks/developer-reference/api-dataworks-public-2024-05-18-listprojectroles?spm=a2c4g.11186623.0.0.43841daeywTtF3) operation to query the codes of all roles in the workspace.
        self.role_codes = role_codes
        # The IDs of the accounts used by the members in the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=a2c4g.11186623.0.0.7f96340a3HFgqS), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the IDs of the accounts used by the members in the workspace.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes is not None:
            result['RoleCodes'] = self.role_codes
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes = m.get('RoleCodes')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class ListProjectMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        role_codes_shrink: str = None,
        user_ids_shrink: str = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/zh/dataworks/developer-reference/api-dataworks-public-2024-05-18-listprojectroles?spm=a2c4g.11186623.0.0.43841daeywTtF3) operation to query the codes of all roles in the workspace.
        self.role_codes_shrink = role_codes_shrink
        # The IDs of the accounts used by the members in the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=a2c4g.11186623.0.0.7f96340a3HFgqS), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the IDs of the accounts used by the members in the workspace.
        self.user_ids_shrink = user_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes_shrink is not None:
            result['RoleCodes'] = self.role_codes_shrink
        if self.user_ids_shrink is not None:
            result['UserIds'] = self.user_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes_shrink = m.get('RoleCodes')
        if m.get('UserIds') is not None:
            self.user_ids_shrink = m.get('UserIds')
        return self


class ListProjectMembersResponseBodyPagingInfoProjectMembersRoles(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
        type: str = None,
    ):
        # The code of the role.
        self.code = code
        # The name of the role.
        self.name = name
        # The type of the role. Valid values:
        # 
        # *   UserCustom: custom role
        # *   System: built-in role
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectMembersResponseBodyPagingInfoProjectMembers(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        roles: List[ListProjectMembersResponseBodyPagingInfoProjectMembersRoles] = None,
        status: str = None,
        user_id: str = None,
    ):
        # The ID of the DataWorks workspace.
        self.project_id = project_id
        # The roles that are assigned to the member.
        self.roles = roles
        # The status of the member. Valid values:
        # 
        # *   Normal
        # *   Forbidden
        self.status = status
        # The ID of the account used by the member.
        self.user_id = user_id

    def validate(self):
        if self.roles:
            for k in self.roles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Roles'] = []
        if self.roles is not None:
            for k in self.roles:
                result['Roles'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.roles = []
        if m.get('Roles') is not None:
            for k in m.get('Roles'):
                temp_model = ListProjectMembersResponseBodyPagingInfoProjectMembersRoles()
                self.roles.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListProjectMembersResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        project_members: List[ListProjectMembersResponseBodyPagingInfoProjectMembers] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The members in the workspace.
        self.project_members = project_members
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.project_members:
            for k in self.project_members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['ProjectMembers'] = []
        if self.project_members is not None:
            for k in self.project_members:
                result['ProjectMembers'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.project_members = []
        if m.get('ProjectMembers') is not None:
            for k in m.get('ProjectMembers'):
                temp_model = ListProjectMembersResponseBodyPagingInfoProjectMembers()
                self.project_members.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProjectMembersResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListProjectMembersResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListProjectMembersResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListProjectMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectRolesRequest(TeaModel):
    def __init__(
        self,
        codes: List[str] = None,
        names: List[str] = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        type: str = None,
    ):
        self.codes = codes
        self.names = names
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.project_id = project_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codes is not None:
            result['Codes'] = self.codes
        if self.names is not None:
            result['Names'] = self.names
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codes') is not None:
            self.codes = m.get('Codes')
        if m.get('Names') is not None:
            self.names = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectRolesShrinkRequest(TeaModel):
    def __init__(
        self,
        codes_shrink: str = None,
        names_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        type: str = None,
    ):
        self.codes_shrink = codes_shrink
        self.names_shrink = names_shrink
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.project_id = project_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codes_shrink is not None:
            result['Codes'] = self.codes_shrink
        if self.names_shrink is not None:
            result['Names'] = self.names_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codes') is not None:
            self.codes_shrink = m.get('Codes')
        if m.get('Names') is not None:
            self.names_shrink = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectRolesResponseBodyPagingInfoProjectRoles(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
        project_id: int = None,
        type: str = None,
    ):
        self.code = code
        self.name = name
        self.project_id = project_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectRolesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: str = None,
        page_size: str = None,
        project_roles: List[ListProjectRolesResponseBodyPagingInfoProjectRoles] = None,
        total_count: str = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.project_roles = project_roles
        self.total_count = total_count

    def validate(self):
        if self.project_roles:
            for k in self.project_roles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['ProjectRoles'] = []
        if self.project_roles is not None:
            for k in self.project_roles:
                result['ProjectRoles'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.project_roles = []
        if m.get('ProjectRoles') is not None:
            for k in m.get('ProjectRoles'):
                temp_model = ListProjectRolesResponseBodyPagingInfoProjectRoles()
                self.project_roles.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProjectRolesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListProjectRolesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListProjectRolesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListProjectRolesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectRolesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectsRequestAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListProjectsRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[ListProjectsRequestAliyunResourceTags] = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        ids: List[int] = None,
        names: List[str] = None,
        page_number: int = None,
        page_size: int = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        self.aliyun_resource_group_id = aliyun_resource_group_id
        self.aliyun_resource_tags = aliyun_resource_tags
        self.dev_environment_enabled = dev_environment_enabled
        self.dev_role_disabled = dev_role_disabled
        self.ids = ids
        self.names = names
        self.page_number = page_number
        self.page_size = page_size
        self.pai_task_enabled = pai_task_enabled
        self.status = status

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.names is not None:
            result['Names'] = self.names
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = ListProjectsRequestAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Names') is not None:
            self.names = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectsShrinkRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags_shrink: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        ids_shrink: str = None,
        names_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        self.aliyun_resource_group_id = aliyun_resource_group_id
        self.aliyun_resource_tags_shrink = aliyun_resource_tags_shrink
        self.dev_environment_enabled = dev_environment_enabled
        self.dev_role_disabled = dev_role_disabled
        self.ids_shrink = ids_shrink
        self.names_shrink = names_shrink
        self.page_number = page_number
        self.page_size = page_size
        self.pai_task_enabled = pai_task_enabled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        if self.aliyun_resource_tags_shrink is not None:
            result['AliyunResourceTags'] = self.aliyun_resource_tags_shrink
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        if self.names_shrink is not None:
            result['Names'] = self.names_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        if m.get('AliyunResourceTags') is not None:
            self.aliyun_resource_tags_shrink = m.get('AliyunResourceTags')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        if m.get('Names') is not None:
            self.names_shrink = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListProjectsResponseBodyPagingInfoProjects(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags] = None,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        id: int = None,
        name: str = None,
        owner: str = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        self.aliyun_resource_group_id = aliyun_resource_group_id
        self.aliyun_resource_tags = aliyun_resource_tags
        self.description = description
        self.dev_environment_enabled = dev_environment_enabled
        self.dev_role_disabled = dev_role_disabled
        self.display_name = display_name
        self.id = id
        self.name = name
        self.owner = owner
        self.pai_task_enabled = pai_task_enabled
        self.status = status

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        projects: List[ListProjectsResponseBodyPagingInfoProjects] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.projects = projects
        self.total_count = total_count

    def validate(self):
        if self.projects:
            for k in self.projects:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Projects'] = []
        if self.projects is not None:
            for k in self.projects:
                result['Projects'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.projects = []
        if m.get('Projects') is not None:
            for k in m.get('Projects'):
                temp_model = ListProjectsResponseBodyPagingInfoProjects()
                self.projects.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProjectsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListProjectsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListProjectsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListProjectsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListResourceGroupsRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        payment_type: str = None,
        project_id: int = None,
        resource_group_types: List[str] = None,
        statuses: List[str] = None,
    ):
        self.name = name
        self.payment_type = payment_type
        self.project_id = project_id
        self.resource_group_types = resource_group_types
        self.statuses = statuses

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_types is not None:
            result['ResourceGroupTypes'] = self.resource_group_types
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupTypes') is not None:
            self.resource_group_types = m.get('ResourceGroupTypes')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        return self


class ListResourceGroupsShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        payment_type: str = None,
        project_id: int = None,
        resource_group_types_shrink: str = None,
        statuses_shrink: str = None,
    ):
        self.name = name
        self.payment_type = payment_type
        self.project_id = project_id
        self.resource_group_types_shrink = resource_group_types_shrink
        self.statuses_shrink = statuses_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_types_shrink is not None:
            result['ResourceGroupTypes'] = self.resource_group_types_shrink
        if self.statuses_shrink is not None:
            result['Statuses'] = self.statuses_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupTypes') is not None:
            self.resource_group_types_shrink = m.get('ResourceGroupTypes')
        if m.get('Statuses') is not None:
            self.statuses_shrink = m.get('Statuses')
        return self


class ListResourceGroupsResponseBodyResourceGroupListSpec(TeaModel):
    def __init__(
        self,
        amount: int = None,
        standard: str = None,
    ):
        self.amount = amount
        self.standard = standard

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.standard is not None:
            result['Standard'] = self.standard
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Standard') is not None:
            self.standard = m.get('Standard')
        return self


class ListResourceGroupsResponseBodyResourceGroupList(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        default_vpc_id: str = None,
        default_vswicth_id: str = None,
        id: str = None,
        name: str = None,
        order_instance_id: str = None,
        payment_type: str = None,
        remark: str = None,
        resource_group_type: str = None,
        spec: ListResourceGroupsResponseBodyResourceGroupListSpec = None,
        status: str = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.default_vpc_id = default_vpc_id
        self.default_vswicth_id = default_vswicth_id
        self.id = id
        self.name = name
        self.order_instance_id = order_instance_id
        self.payment_type = payment_type
        self.remark = remark
        self.resource_group_type = resource_group_type
        self.spec = spec
        self.status = status

    def validate(self):
        if self.spec:
            self.spec.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.default_vpc_id is not None:
            result['DefaultVpcId'] = self.default_vpc_id
        if self.default_vswicth_id is not None:
            result['DefaultVswicthId'] = self.default_vswicth_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.order_instance_id is not None:
            result['OrderInstanceId'] = self.order_instance_id
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.resource_group_type is not None:
            result['ResourceGroupType'] = self.resource_group_type
        if self.spec is not None:
            result['Spec'] = self.spec.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DefaultVpcId') is not None:
            self.default_vpc_id = m.get('DefaultVpcId')
        if m.get('DefaultVswicthId') is not None:
            self.default_vswicth_id = m.get('DefaultVswicthId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OrderInstanceId') is not None:
            self.order_instance_id = m.get('OrderInstanceId')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ResourceGroupType') is not None:
            self.resource_group_type = m.get('ResourceGroupType')
        if m.get('Spec') is not None:
            temp_model = ListResourceGroupsResponseBodyResourceGroupListSpec()
            self.spec = temp_model.from_map(m['Spec'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListResourceGroupsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource_group_list: List[ListResourceGroupsResponseBodyResourceGroupList] = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.resource_group_list = resource_group_list
        self.success = success

    def validate(self):
        if self.resource_group_list:
            for k in self.resource_group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ResourceGroupList'] = []
        if self.resource_group_list is not None:
            for k in self.resource_group_list:
                result['ResourceGroupList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.resource_group_list = []
        if m.get('ResourceGroupList') is not None:
            for k in m.get('ResourceGroupList'):
                temp_model = ListResourceGroupsResponseBodyResourceGroupList()
                self.resource_group_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListResourceGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListResourceGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListResourceGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListResourcesRequest(TeaModel):
    def __init__(
        self,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: str = None,
        type: str = None,
    ):
        # The ID of the Alibaba Cloud account used by the workspace administrator. You can log on to the Alibaba Cloud Management Console and view the ID on the Security Settings page.
        self.owner = owner
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The resource type. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   Python
        # *   Jar
        # *   Archive
        # *   File
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListResourcesResponseBodyPagingInfoResourcesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListResourcesResponseBodyPagingInfoResourcesScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command used to distinguish file resource types.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListResourcesResponseBodyPagingInfoResourcesScript(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        runtime: ListResourcesResponseBodyPagingInfoResourcesScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListResourcesResponseBodyPagingInfoResourcesScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListResourcesResponseBodyPagingInfoResources(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        data_source: ListResourcesResponseBodyPagingInfoResourcesDataSource = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: str = None,
        script: ListResourcesResponseBodyPagingInfoResourcesScript = None,
        source_path: str = None,
        source_type: str = None,
        target_path: str = None,
        target_type: str = None,
        type: str = None,
    ):
        # The time when the file resource was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The information about the data source.
        self.data_source = data_source
        # The ID of the file resource.
        self.id = id
        # The times when the file resource was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the file resource.
        self.name = name
        # The owner of the file resource.
        self.owner = owner
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        self.project_id = project_id
        # The script information.
        self.script = script
        # The path of the source of the file resource. If the SourecType parameter is set to Local, this parameter is left empty.
        self.source_path = source_path
        # The storage type of the source of the file resource.
        # 
        # Valid values:
        # 
        # *   Local
        # *   Oss
        self.source_type = source_type
        # The storage path of the destination of the file resource.
        self.target_path = target_path
        # The storage type of the destination of the file resource.
        # 
        # Valid values:
        # 
        # *   Gateway
        # *   Oss
        # *   Hdfs
        self.target_type = target_type
        # The type of the file resource.
        # 
        # Valid values:
        # 
        # *   Python
        # *   Jar
        # *   Archive
        # *   File
        self.type = type

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.script:
            self.script.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.source_path is not None:
            result['SourcePath'] = self.source_path
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.target_path is not None:
            result['TargetPath'] = self.target_path
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSource') is not None:
            temp_model = ListResourcesResponseBodyPagingInfoResourcesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Script') is not None:
            temp_model = ListResourcesResponseBodyPagingInfoResourcesScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('SourcePath') is not None:
            self.source_path = m.get('SourcePath')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('TargetPath') is not None:
            self.target_path = m.get('TargetPath')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListResourcesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        resources: List[ListResourcesResponseBodyPagingInfoResources] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The file resources.
        self.resources = resources
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = ListResourcesResponseBodyPagingInfoResources()
                self.resources.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListResourcesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListResourcesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListResourcesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRoutesRequest(TeaModel):
    def __init__(
        self,
        network_id: int = None,
    ):
        # This parameter is required.
        self.network_id = network_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        return self


class ListRoutesResponseBodyRouteList(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        destination_cidr: str = None,
        id: int = None,
        network_id: int = None,
        resource_group_id: str = None,
        resource_id: str = None,
    ):
        self.create_time = create_time
        self.destination_cidr = destination_cidr
        self.id = id
        self.network_id = network_id
        self.resource_group_id = resource_group_id
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.destination_cidr is not None:
            result['DestinationCidr'] = self.destination_cidr
        if self.id is not None:
            result['Id'] = self.id
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DestinationCidr') is not None:
            self.destination_cidr = m.get('DestinationCidr')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class ListRoutesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        route_list: List[ListRoutesResponseBodyRouteList] = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.route_list = route_list
        self.success = success

    def validate(self):
        if self.route_list:
            for k in self.route_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RouteList'] = []
        if self.route_list is not None:
            for k in self.route_list:
                result['RouteList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.route_list = []
        if m.get('RouteList') is not None:
            for k in m.get('RouteList'):
                temp_model = ListRoutesResponseBodyRouteList()
                self.route_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListRoutesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRoutesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRoutesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskInstanceOperationLogsRequest(TeaModel):
    def __init__(
        self,
        date: int = None,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.date = date
        # This parameter is required.
        self.id = id
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        operation_content: str = None,
        operation_seq: int = None,
        task_instance_id: int = None,
        user: str = None,
    ):
        self.create_time = create_time
        self.operation_content = operation_content
        self.operation_seq = operation_seq
        self.task_instance_id = task_instance_id
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.operation_content is not None:
            result['OperationContent'] = self.operation_content
        if self.operation_seq is not None:
            result['OperationSeq'] = self.operation_seq
        if self.task_instance_id is not None:
            result['TaskInstanceId'] = self.task_instance_id
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('OperationContent') is not None:
            self.operation_content = m.get('OperationContent')
        if m.get('OperationSeq') is not None:
            self.operation_seq = m.get('OperationSeq')
        if m.get('TaskInstanceId') is not None:
            self.task_instance_id = m.get('TaskInstanceId')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class ListTaskInstanceOperationLogsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        operation_logs: List[ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.operation_logs = operation_logs
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.operation_logs:
            for k in self.operation_logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationLogs'] = []
        if self.operation_logs is not None:
            for k in self.operation_logs:
                result['OperationLogs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.operation_logs = []
        if m.get('OperationLogs') is not None:
            for k in m.get('OperationLogs'):
                temp_model = ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs()
                self.operation_logs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskInstanceOperationLogsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTaskInstanceOperationLogsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTaskInstanceOperationLogsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTaskInstanceOperationLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskInstanceOperationLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskInstanceOperationLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        bizdate: int = None,
        id: int = None,
        ids: List[int] = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
        project_id: int = None,
        runtime_resource: str = None,
        sort_by: str = None,
        task_id: int = None,
        task_ids: List[int] = None,
        task_name: str = None,
        task_type: str = None,
        trigger_recurrence: str = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
    ):
        # This parameter is required.
        self.bizdate = bizdate
        self.id = id
        self.ids = ids
        self.owner = owner
        self.page_number = page_number
        self.page_size = page_size
        self.project_env = project_env
        # This parameter is required.
        self.project_id = project_id
        self.runtime_resource = runtime_resource
        self.sort_by = sort_by
        self.task_id = task_id
        self.task_ids = task_ids
        self.task_name = task_name
        self.task_type = task_type
        self.trigger_recurrence = trigger_recurrence
        self.trigger_type = trigger_type
        self.workflow_id = workflow_id
        self.workflow_instance_id = workflow_instance_id
        self.workflow_instance_type = workflow_instance_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.id is not None:
            result['Id'] = self.id
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        return self


class ListTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        bizdate: int = None,
        id: int = None,
        ids_shrink: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
        project_id: int = None,
        runtime_resource: str = None,
        sort_by: str = None,
        task_id: int = None,
        task_ids_shrink: str = None,
        task_name: str = None,
        task_type: str = None,
        trigger_recurrence: str = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
    ):
        # This parameter is required.
        self.bizdate = bizdate
        self.id = id
        self.ids_shrink = ids_shrink
        self.owner = owner
        self.page_number = page_number
        self.page_size = page_size
        self.project_env = project_env
        # This parameter is required.
        self.project_id = project_id
        self.runtime_resource = runtime_resource
        self.sort_by = sort_by
        self.task_id = task_id
        self.task_ids_shrink = task_ids_shrink
        self.task_name = task_name
        self.task_type = task_type
        self.trigger_recurrence = trigger_recurrence
        self.trigger_type = trigger_type
        self.workflow_id = workflow_id
        self.workflow_instance_id = workflow_instance_id
        self.workflow_instance_type = workflow_instance_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.id is not None:
            result['Id'] = self.id
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_ids_shrink is not None:
            result['TaskIds'] = self.task_ids_shrink
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskIds') is not None:
            self.task_ids_shrink = m.get('TaskIds')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        return self


class ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        self.gateway = gateway
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        self.cu = cu
        self.image = image
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListTaskInstancesResponseBodyPagingInfoTaskInstances(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource = None,
        description: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime = None,
        runtime_resource: ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource = None,
        started_time: int = None,
        status: str = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        self.baseline_id = baseline_id
        self.bizdate = bizdate
        self.create_time = create_time
        self.create_user = create_user
        self.data_source = data_source
        self.description = description
        self.finished_time = finished_time
        self.id = id
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.owner = owner
        self.period_number = period_number
        self.priority = priority
        self.project_env = project_env
        self.project_id = project_id
        self.rerun_mode = rerun_mode
        self.run_number = run_number
        self.runtime = runtime
        self.runtime_resource = runtime_resource
        self.started_time = started_time
        self.status = status
        self.task_id = task_id
        self.task_name = task_name
        self.task_type = task_type
        self.tenant_id = tenant_id
        self.timeout = timeout
        self.trigger_recurrence = trigger_recurrence
        self.trigger_time = trigger_time
        self.trigger_type = trigger_type
        self.workflow_id = workflow_id
        self.workflow_instance_id = workflow_instance_id
        self.workflow_instance_type = workflow_instance_type
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class ListTaskInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        task_instances: List[ListTaskInstancesResponseBodyPagingInfoTaskInstances] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.task_instances = task_instances
        self.total_count = total_count

    def validate(self):
        if self.task_instances:
            for k in self.task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['TaskInstances'] = []
        if self.task_instances is not None:
            for k in self.task_instances:
                result['TaskInstances'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.task_instances = []
        if m.get('TaskInstances') is not None:
            for k in m.get('TaskInstances'):
                temp_model = ListTaskInstancesResponseBodyPagingInfoTaskInstances()
                self.task_instances.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTaskInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTaskInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskOperationLogsRequest(TeaModel):
    def __init__(
        self,
        date: int = None,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
    ):
        self.date = date
        # This parameter is required.
        self.id = id
        self.page_number = page_number
        self.page_size = page_size
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class ListTaskOperationLogsResponseBodyPagingInfoOperationLogs(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        operation_content: str = None,
        operation_seq: int = None,
        task_id: int = None,
        user: str = None,
    ):
        self.create_time = create_time
        self.operation_content = operation_content
        self.operation_seq = operation_seq
        self.task_id = task_id
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.operation_content is not None:
            result['OperationContent'] = self.operation_content
        if self.operation_seq is not None:
            result['OperationSeq'] = self.operation_seq
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('OperationContent') is not None:
            self.operation_content = m.get('OperationContent')
        if m.get('OperationSeq') is not None:
            self.operation_seq = m.get('OperationSeq')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class ListTaskOperationLogsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        operation_logs: List[ListTaskOperationLogsResponseBodyPagingInfoOperationLogs] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.operation_logs = operation_logs
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.operation_logs:
            for k in self.operation_logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationLogs'] = []
        if self.operation_logs is not None:
            for k in self.operation_logs:
                result['OperationLogs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.operation_logs = []
        if m.get('OperationLogs') is not None:
            for k in m.get('OperationLogs'):
                temp_model = ListTaskOperationLogsResponseBodyPagingInfoOperationLogs()
                self.operation_logs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskOperationLogsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTaskOperationLogsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTaskOperationLogsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTaskOperationLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskOperationLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskOperationLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTasksRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
        project_id: int = None,
        runtime_resource: str = None,
        sort_by: str = None,
        task_type: str = None,
        trigger_recurrence: str = None,
        trigger_type: str = None,
        workflow_id: int = None,
    ):
        self.name = name
        self.owner = owner
        self.page_number = page_number
        self.page_size = page_size
        self.project_env = project_env
        # This parameter is required.
        self.project_id = project_id
        self.runtime_resource = runtime_resource
        self.sort_by = sort_by
        self.task_type = task_type
        self.trigger_recurrence = trigger_recurrence
        self.trigger_type = trigger_type
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListTasksResponseBodyPagingInfoTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListTasksResponseBodyPagingInfoTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        self.cu = cu
        self.image = image
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListTasksResponseBodyPagingInfoTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        self.cron = cron
        self.end_time = end_time
        self.recurrence = recurrence
        self.start_time = start_time
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTasksResponseBodyPagingInfoTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListTasksResponseBodyPagingInfoTasksDataSource = None,
        description: str = None,
        id: int = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: ListTasksResponseBodyPagingInfoTasksRuntimeResource = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger: ListTasksResponseBodyPagingInfoTasksTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        self.baseline_id = baseline_id
        self.create_time = create_time
        self.create_user = create_user
        self.data_source = data_source
        self.description = description
        self.id = id
        self.instance_mode = instance_mode
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.name = name
        self.owner = owner
        self.priority = priority
        self.project_env = project_env
        self.project_id = project_id
        self.rerun_interval = rerun_interval
        self.rerun_mode = rerun_mode
        self.rerun_times = rerun_times
        self.runtime_resource = runtime_resource
        self.tenant_id = tenant_id
        self.timeout = timeout
        self.trigger = trigger
        self.type = type
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListTasksResponseBodyPagingInfoTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = ListTasksResponseBodyPagingInfoTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = ListTasksResponseBodyPagingInfoTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListTasksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        tasks: List[ListTasksResponseBodyPagingInfoTasks] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.tasks = tasks
        self.total_count = total_count

    def validate(self):
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = ListTasksResponseBodyPagingInfoTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTasksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTasksResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTasksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUpstreamTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.id = id
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        self.gateway = gateway
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        self.cu = cu
        self.image = image
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource = None,
        description: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime = None,
        runtime_resource: ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource = None,
        started_time: int = None,
        status: str = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        self.baseline_id = baseline_id
        self.bizdate = bizdate
        self.create_time = create_time
        self.create_user = create_user
        self.data_source = data_source
        self.description = description
        self.finished_time = finished_time
        self.id = id
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.owner = owner
        self.period_number = period_number
        self.priority = priority
        self.project_env = project_env
        self.project_id = project_id
        self.rerun_mode = rerun_mode
        self.run_number = run_number
        self.runtime = runtime
        self.runtime_resource = runtime_resource
        self.started_time = started_time
        self.status = status
        self.task_id = task_id
        self.task_name = task_name
        self.task_type = task_type
        self.tenant_id = tenant_id
        self.timeout = timeout
        self.trigger_recurrence = trigger_recurrence
        self.trigger_time = trigger_time
        self.trigger_type = trigger_type
        self.workflow_id = workflow_id
        self.workflow_instance_id = workflow_instance_id
        self.workflow_instance_type = workflow_instance_type
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        task_instances: List[ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.task_instances = task_instances
        self.total_count = total_count

    def validate(self):
        if self.task_instances:
            for k in self.task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['TaskInstances'] = []
        if self.task_instances is not None:
            for k in self.task_instances:
                result['TaskInstances'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.task_instances = []
        if m.get('TaskInstances') is not None:
            for k in m.get('TaskInstances'):
                temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances()
                self.task_instances.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUpstreamTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListUpstreamTaskInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUpstreamTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUpstreamTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUpstreamTasksRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
    ):
        # This parameter is required.
        self.id = id
        self.page_number = page_number
        self.page_size = page_size
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class ListUpstreamTasksResponseBodyPagingInfoTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        self.cu = cu
        self.image = image
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListUpstreamTasksResponseBodyPagingInfoTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        self.cron = cron
        self.end_time = end_time
        self.recurrence = recurrence
        self.start_time = start_time
        self.timezone = timezone
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListUpstreamTasksResponseBodyPagingInfoTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListUpstreamTasksResponseBodyPagingInfoTasksDataSource = None,
        description: str = None,
        id: int = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource = None,
        step_type: str = None,
        tenant_id: int = None,
        timeout: int = None,
        trigger: ListUpstreamTasksResponseBodyPagingInfoTasksTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        self.baseline_id = baseline_id
        self.create_time = create_time
        self.create_user = create_user
        self.data_source = data_source
        self.description = description
        self.id = id
        self.instance_mode = instance_mode
        self.modify_time = modify_time
        self.modify_user = modify_user
        self.name = name
        self.owner = owner
        self.priority = priority
        self.project_env = project_env
        self.project_id = project_id
        self.rerun_interval = rerun_interval
        self.rerun_mode = rerun_mode
        self.rerun_times = rerun_times
        self.runtime_resource = runtime_resource
        self.step_type = step_type
        self.tenant_id = tenant_id
        self.timeout = timeout
        self.trigger = trigger
        self.type = type
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.step_type is not None:
            result['StepType'] = self.step_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StepType') is not None:
            self.step_type = m.get('StepType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListUpstreamTasksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        tasks: List[ListUpstreamTasksResponseBodyPagingInfoTasks] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.tasks = tasks
        self.total_count = total_count

    def validate(self):
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = ListUpstreamTasksResponseBodyPagingInfoTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListUpstreamTasksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListUpstreamTasksResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUpstreamTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUpstreamTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUpstreamTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkflowDefinitionsRequest(TeaModel):
    def __init__(
        self,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: str = None,
        type: str = None,
    ):
        # The ID of the Alibaba Cloud account used by the workspace administrator. You can log on to the Alibaba Cloud Management Console and view the ID on the Security Settings page.
        self.owner = owner
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The workflow type. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   CycleWorkflow
        # *   ManualWorkflow
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        runtime: ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        description: str = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: str = None,
        script: ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript = None,
        type: str = None,
    ):
        # The time when the workflow was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The description of the workflow.
        self.description = description
        # The ID of the workflow.
        self.id = id
        # The times when the workflow was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the workflow.
        self.name = name
        # The owner.
        self.owner = owner
        # The ID of the DataWorks workspace to which the workflow belongs.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The script information.
        self.script = script
        # The type of the workflow.
        # 
        # Valid values:
        # 
        # *   CycleWorkflow
        # *   ManualWorkflow
        self.type = type

    def validate(self):
        if self.script:
            self.script.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Script') is not None:
            temp_model = ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListWorkflowDefinitionsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
        workflow_definitions: List[ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count
        # The workflows.
        self.workflow_definitions = workflow_definitions

    def validate(self):
        if self.workflow_definitions:
            for k in self.workflow_definitions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['WorkflowDefinitions'] = []
        if self.workflow_definitions is not None:
            for k in self.workflow_definitions:
                result['WorkflowDefinitions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.workflow_definitions = []
        if m.get('WorkflowDefinitions') is not None:
            for k in m.get('WorkflowDefinitions'):
                temp_model = ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions()
                self.workflow_definitions.append(temp_model.from_map(k))
        return self


class ListWorkflowDefinitionsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListWorkflowDefinitionsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListWorkflowDefinitionsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListWorkflowDefinitionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkflowDefinitionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkflowDefinitionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveFunctionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        project_id: str = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The path to which you want to move the UDF. You do not need to specify a UDF name in the path.
        # 
        # For example, if you want to move the test UDF to root/demo/test, you must set this parameter to root/demo.
        # 
        # This parameter is required.
        self.path = path
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MoveFunctionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveNodeRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        project_id: str = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The path to which you want to move the node. You do not need to specify a node name in the path.
        # 
        # For example, if you want to move the test node to root/demo/test, you must set this parameter to root/demo.
        # 
        # This parameter is required.
        self.path = path
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MoveNodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveResourceRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        project_id: str = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The path to which you want to move the file resource. You do not need to specify a file resource name in the path.
        # 
        # For example, if you want to move the test file resource to root/demo/test, you must set this parameter to root/demo.
        # 
        # This parameter is required.
        self.path = path
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MoveResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        path: str = None,
        project_id: str = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The path to which you want to move the workflow. You do not need to specify a workflow name in the path.
        # 
        # For example, if you want to move the test workflow to root/demo/test, you must set this parameter to root/demo.
        # 
        # This parameter is required.
        self.path = path
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MoveWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveTaskInstanceDependenciesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        id: int = None,
        upstream_task_instance_ids: List[int] = None,
    ):
        self.comment = comment
        # This parameter is required.
        self.id = id
        self.upstream_task_instance_ids = upstream_task_instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.id is not None:
            result['Id'] = self.id
        if self.upstream_task_instance_ids is not None:
            result['UpstreamTaskInstanceIds'] = self.upstream_task_instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('UpstreamTaskInstanceIds') is not None:
            self.upstream_task_instance_ids = m.get('UpstreamTaskInstanceIds')
        return self


class RemoveTaskInstanceDependenciesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        id: int = None,
        upstream_task_instance_ids_shrink: str = None,
    ):
        self.comment = comment
        # This parameter is required.
        self.id = id
        self.upstream_task_instance_ids_shrink = upstream_task_instance_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.id is not None:
            result['Id'] = self.id
        if self.upstream_task_instance_ids_shrink is not None:
            result['UpstreamTaskInstanceIds'] = self.upstream_task_instance_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('UpstreamTaskInstanceIds') is not None:
            self.upstream_task_instance_ids_shrink = m.get('UpstreamTaskInstanceIds')
        return self


class RemoveTaskInstanceDependenciesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveTaskInstanceDependenciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveTaskInstanceDependenciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveTaskInstanceDependenciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenameFunctionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        project_id: str = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The new name.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RenameFunctionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RenameFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenameFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenameFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenameNodeRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        project_id: str = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The new name.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RenameNodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RenameNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenameNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenameNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenameResourceRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        project_id: str = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The new name.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RenameResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RenameResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenameResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenameResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenameWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        project_id: str = None,
    ):
        # The unique identifier of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The new name.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RenameWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RenameWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenameWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenameWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RerunTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        self.comment = comment
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class RerunTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        self.comment = comment
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class RerunTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        self.request_id = request_id
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class RerunTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RerunTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RerunTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        self.comment = comment
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class ResumeTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        self.comment = comment
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class ResumeTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        self.request_id = request_id
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class ResumeTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResumeTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeMemberProjectRolesRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes: List[str] = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/zh/dataworks/developer-reference/api-dataworks-public-2024-05-18-listprojectroles?spm=a2c4g.11186623.0.0.43841daeywTtF3) operation to query the codes of all roles in the workspace.
        # 
        # You must configure this parameter to specify the roles that you want to revoke from the member in the workspace.
        # 
        # This parameter is required.
        self.role_codes = role_codes
        # The ID of the account used by the member in the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=openapi-amp.newDocPublishment.0.0.51d7281fjgBRmo), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the ID of the account used by the member in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes is not None:
            result['RoleCodes'] = self.role_codes
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RevokeMemberProjectRolesShrinkRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes_shrink: str = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/zh/dataworks/developer-reference/api-dataworks-public-2024-05-18-listprojectroles?spm=a2c4g.11186623.0.0.43841daeywTtF3) operation to query the codes of all roles in the workspace.
        # 
        # You must configure this parameter to specify the roles that you want to revoke from the member in the workspace.
        # 
        # This parameter is required.
        self.role_codes_shrink = role_codes_shrink
        # The ID of the account used by the member in the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=openapi-amp.newDocPublishment.0.0.51d7281fjgBRmo), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the ID of the account used by the member in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes_shrink is not None:
            result['RoleCodes'] = self.role_codes_shrink
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes_shrink = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RevokeMemberProjectRolesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RevokeMemberProjectRolesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RevokeMemberProjectRolesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeMemberProjectRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetSuccessTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        self.comment = comment
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class SetSuccessTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        self.comment = comment
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class SetSuccessTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        self.request_id = request_id
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class SetSuccessTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetSuccessTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetSuccessTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartDIJobRequestRealtimeStartSettingsFailoverSettings(TeaModel):
    def __init__(
        self,
        interval: int = None,
        upper_limit: int = None,
    ):
        self.interval = interval
        self.upper_limit = upper_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.upper_limit is not None:
            result['UpperLimit'] = self.upper_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('UpperLimit') is not None:
            self.upper_limit = m.get('UpperLimit')
        return self


class StartDIJobRequestRealtimeStartSettings(TeaModel):
    def __init__(
        self,
        failover_settings: StartDIJobRequestRealtimeStartSettingsFailoverSettings = None,
        start_time: int = None,
    ):
        self.failover_settings = failover_settings
        self.start_time = start_time

    def validate(self):
        if self.failover_settings:
            self.failover_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failover_settings is not None:
            result['FailoverSettings'] = self.failover_settings.to_map()
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailoverSettings') is not None:
            temp_model = StartDIJobRequestRealtimeStartSettingsFailoverSettings()
            self.failover_settings = temp_model.from_map(m['FailoverSettings'])
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class StartDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        force_to_rerun: bool = None,
        realtime_start_settings: StartDIJobRequestRealtimeStartSettings = None,
    ):
        # The instance ID.
        self.dijob_id = dijob_id
        self.force_to_rerun = force_to_rerun
        self.realtime_start_settings = realtime_start_settings

    def validate(self):
        if self.realtime_start_settings:
            self.realtime_start_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.force_to_rerun is not None:
            result['ForceToRerun'] = self.force_to_rerun
        if self.realtime_start_settings is not None:
            result['RealtimeStartSettings'] = self.realtime_start_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('ForceToRerun') is not None:
            self.force_to_rerun = m.get('ForceToRerun')
        if m.get('RealtimeStartSettings') is not None:
            temp_model = StartDIJobRequestRealtimeStartSettings()
            self.realtime_start_settings = temp_model.from_map(m['RealtimeStartSettings'])
        return self


class StartDIJobShrinkRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        force_to_rerun: bool = None,
        realtime_start_settings_shrink: str = None,
    ):
        # The instance ID.
        self.dijob_id = dijob_id
        self.force_to_rerun = force_to_rerun
        self.realtime_start_settings_shrink = realtime_start_settings_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.force_to_rerun is not None:
            result['ForceToRerun'] = self.force_to_rerun
        if self.realtime_start_settings_shrink is not None:
            result['RealtimeStartSettings'] = self.realtime_start_settings_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('ForceToRerun') is not None:
            self.force_to_rerun = m.get('ForceToRerun')
        if m.get('RealtimeStartSettings') is not None:
            self.realtime_start_settings_shrink = m.get('RealtimeStartSettings')
        return self


class StartDIJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StartDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        instance_id: int = None,
    ):
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The instance ID.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class StopDIJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StopDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        self.comment = comment
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class StopTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        self.comment = comment
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class StopTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        self.request_id = request_id
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class StopTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SuspendTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        self.comment = comment
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class SuspendTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        self.comment = comment
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class SuspendTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        self.request_id = request_id
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class SuspendTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SuspendTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SuspendTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TriggerSchedulerTaskInstanceRequest(TeaModel):
    def __init__(
        self,
        task_id: int = None,
        trigger_time: int = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.trigger_time = trigger_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        return self


class TriggerSchedulerTaskInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class TriggerSchedulerTaskInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TriggerSchedulerTaskInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TriggerSchedulerTaskInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertRuleRequestNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.extension = extension
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class UpdateAlertRuleRequestNotification(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        interval_in_minutes: int = None,
        maximum: int = None,
        receivers: List[UpdateAlertRuleRequestNotificationReceivers] = None,
        silence_end_time: str = None,
        silence_start_time: str = None,
    ):
        self.channels = channels
        self.interval_in_minutes = interval_in_minutes
        self.maximum = maximum
        self.receivers = receivers
        self.silence_end_time = silence_end_time
        self.silence_start_time = silence_start_time

    def validate(self):
        if self.receivers:
            for k in self.receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.interval_in_minutes is not None:
            result['IntervalInMinutes'] = self.interval_in_minutes
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        result['Receivers'] = []
        if self.receivers is not None:
            for k in self.receivers:
                result['Receivers'].append(k.to_map() if k else None)
        if self.silence_end_time is not None:
            result['SilenceEndTime'] = self.silence_end_time
        if self.silence_start_time is not None:
            result['SilenceStartTime'] = self.silence_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('IntervalInMinutes') is not None:
            self.interval_in_minutes = m.get('IntervalInMinutes')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        self.receivers = []
        if m.get('Receivers') is not None:
            for k in m.get('Receivers'):
                temp_model = UpdateAlertRuleRequestNotificationReceivers()
                self.receivers.append(temp_model.from_map(k))
        if m.get('SilenceEndTime') is not None:
            self.silence_end_time = m.get('SilenceEndTime')
        if m.get('SilenceStartTime') is not None:
            self.silence_start_time = m.get('SilenceStartTime')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime(TeaModel):
    def __init__(
        self,
        cycle_id: int = None,
        time: str = None,
    ):
        self.cycle_id = cycle_id
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_id is not None:
            result['CycleId'] = self.cycle_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleId') is not None:
            self.cycle_id = m.get('CycleId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished(TeaModel):
    def __init__(
        self,
        cycle_and_time: List[UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime] = None,
    ):
        self.cycle_and_time = cycle_and_time

    def validate(self):
        if self.cycle_and_time:
            for k in self.cycle_and_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleAndTime'] = []
        if self.cycle_and_time is not None:
            for k in self.cycle_and_time:
                result['CycleAndTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_and_time = []
        if m.get('CycleAndTime') is not None:
            for k in m.get('CycleAndTime'):
                temp_model = UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime()
                self.cycle_and_time.append(temp_model.from_map(k))
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionError(TeaModel):
    def __init__(
        self,
        auto_rerun_alert: bool = None,
        stream_task_ids: List[int] = None,
    ):
        self.auto_rerun_alert = auto_rerun_alert
        self.stream_task_ids = stream_task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_alert is not None:
            result['AutoRerunAlert'] = self.auto_rerun_alert
        if self.stream_task_ids is not None:
            result['StreamTaskIds'] = self.stream_task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunAlert') is not None:
            self.auto_rerun_alert = m.get('AutoRerunAlert')
        if m.get('StreamTaskIds') is not None:
            self.stream_task_ids = m.get('StreamTaskIds')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount(TeaModel):
    def __init__(
        self,
        count: int = None,
    ):
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage(TeaModel):
    def __init__(
        self,
        percentage: int = None,
    ):
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate(TeaModel):
    def __init__(
        self,
        percentage: int = None,
        trend: str = None,
    ):
        self.percentage = percentage
        self.trend = trend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.trend is not None:
            result['Trend'] = self.trend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Trend') is not None:
            self.trend = m.get('Trend')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionTimeout(TeaModel):
    def __init__(
        self,
        timeout_in_minutes: int = None,
    ):
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionUnFinished(TeaModel):
    def __init__(
        self,
        un_finished_time: str = None,
    ):
        self.un_finished_time = un_finished_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.un_finished_time is not None:
            result['UnFinishedTime'] = self.un_finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UnFinishedTime') is not None:
            self.un_finished_time = m.get('UnFinishedTime')
        return self


class UpdateAlertRuleRequestTriggerConditionExtension(TeaModel):
    def __init__(
        self,
        cycle_unfinished: UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished = None,
        error: UpdateAlertRuleRequestTriggerConditionExtensionError = None,
        instance_error_count: UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount = None,
        instance_error_percentage: UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage = None,
        instance_transfer_fluctuate: UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate = None,
        timeout: UpdateAlertRuleRequestTriggerConditionExtensionTimeout = None,
        un_finished: UpdateAlertRuleRequestTriggerConditionExtensionUnFinished = None,
    ):
        self.cycle_unfinished = cycle_unfinished
        self.error = error
        self.instance_error_count = instance_error_count
        self.instance_error_percentage = instance_error_percentage
        self.instance_transfer_fluctuate = instance_transfer_fluctuate
        self.timeout = timeout
        self.un_finished = un_finished

    def validate(self):
        if self.cycle_unfinished:
            self.cycle_unfinished.validate()
        if self.error:
            self.error.validate()
        if self.instance_error_count:
            self.instance_error_count.validate()
        if self.instance_error_percentage:
            self.instance_error_percentage.validate()
        if self.instance_transfer_fluctuate:
            self.instance_transfer_fluctuate.validate()
        if self.timeout:
            self.timeout.validate()
        if self.un_finished:
            self.un_finished.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_unfinished is not None:
            result['CycleUnfinished'] = self.cycle_unfinished.to_map()
        if self.error is not None:
            result['Error'] = self.error.to_map()
        if self.instance_error_count is not None:
            result['InstanceErrorCount'] = self.instance_error_count.to_map()
        if self.instance_error_percentage is not None:
            result['InstanceErrorPercentage'] = self.instance_error_percentage.to_map()
        if self.instance_transfer_fluctuate is not None:
            result['InstanceTransferFluctuate'] = self.instance_transfer_fluctuate.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        if self.un_finished is not None:
            result['UnFinished'] = self.un_finished.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleUnfinished') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished()
            self.cycle_unfinished = temp_model.from_map(m['CycleUnfinished'])
        if m.get('Error') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionError()
            self.error = temp_model.from_map(m['Error'])
        if m.get('InstanceErrorCount') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount()
            self.instance_error_count = temp_model.from_map(m['InstanceErrorCount'])
        if m.get('InstanceErrorPercentage') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage()
            self.instance_error_percentage = temp_model.from_map(m['InstanceErrorPercentage'])
        if m.get('InstanceTransferFluctuate') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate()
            self.instance_transfer_fluctuate = temp_model.from_map(m['InstanceTransferFluctuate'])
        if m.get('Timeout') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        if m.get('UnFinished') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionUnFinished()
            self.un_finished = temp_model.from_map(m['UnFinished'])
        return self


class UpdateAlertRuleRequestTriggerConditionTarget(TeaModel):
    def __init__(
        self,
        allow_tasks: List[int] = None,
        ids: List[int] = None,
        type: str = None,
    ):
        self.allow_tasks = allow_tasks
        self.ids = ids
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_tasks is not None:
            result['AllowTasks'] = self.allow_tasks
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowTasks') is not None:
            self.allow_tasks = m.get('AllowTasks')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateAlertRuleRequestTriggerCondition(TeaModel):
    def __init__(
        self,
        extension: UpdateAlertRuleRequestTriggerConditionExtension = None,
        target: UpdateAlertRuleRequestTriggerConditionTarget = None,
        type: str = None,
    ):
        self.extension = extension
        self.target = target
        self.type = type

    def validate(self):
        if self.extension:
            self.extension.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Target') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateAlertRuleRequest(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        id: int = None,
        name: str = None,
        notification: UpdateAlertRuleRequestNotification = None,
        owner: str = None,
        trigger_condition: UpdateAlertRuleRequestTriggerCondition = None,
    ):
        self.enabled = enabled
        self.id = id
        self.name = name
        self.notification = notification
        self.owner = owner
        self.trigger_condition = trigger_condition

    def validate(self):
        if self.notification:
            self.notification.validate()
        if self.trigger_condition:
            self.trigger_condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition is not None:
            result['TriggerCondition'] = self.trigger_condition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            temp_model = UpdateAlertRuleRequestNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            temp_model = UpdateAlertRuleRequestTriggerCondition()
            self.trigger_condition = temp_model.from_map(m['TriggerCondition'])
        return self


class UpdateAlertRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        id: int = None,
        name: str = None,
        notification_shrink: str = None,
        owner: str = None,
        trigger_condition_shrink: str = None,
    ):
        self.enabled = enabled
        self.id = id
        self.name = name
        self.notification_shrink = notification_shrink
        self.owner = owner
        self.trigger_condition_shrink = trigger_condition_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_shrink is not None:
            result['Notification'] = self.notification_shrink
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition_shrink is not None:
            result['TriggerCondition'] = self.trigger_condition_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            self.notification_shrink = m.get('Notification')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            self.trigger_condition_shrink = m.get('TriggerCondition')
        return self


class UpdateAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        severity: str = None,
    ):
        self.channels = channels
        self.severity = severity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers(TeaModel):
    def __init__(
        self,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class UpdateDIAlarmRuleRequestNotificationSettings(TeaModel):
    def __init__(
        self,
        inhibition_interval: int = None,
        notification_channels: List[UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels] = None,
        notification_receivers: List[UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers] = None,
    ):
        self.inhibition_interval = inhibition_interval
        self.notification_channels = notification_channels
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inhibition_interval is not None:
            result['InhibitionInterval'] = self.inhibition_interval
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InhibitionInterval') is not None:
            self.inhibition_interval = m.get('InhibitionInterval')
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class UpdateDIAlarmRuleRequestTriggerConditions(TeaModel):
    def __init__(
        self,
        ddl_report_tags: List[str] = None,
        duration: int = None,
        severity: str = None,
        threshold: int = None,
    ):
        self.ddl_report_tags = ddl_report_tags
        self.duration = duration
        self.severity = severity
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ddl_report_tags is not None:
            result['DdlReportTags'] = self.ddl_report_tags
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DdlReportTags') is not None:
            self.ddl_report_tags = m.get('DdlReportTags')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class UpdateDIAlarmRuleRequest(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        metric_type: str = None,
        name: str = None,
        notification_settings: UpdateDIAlarmRuleRequestNotificationSettings = None,
        trigger_conditions: List[UpdateDIAlarmRuleRequestTriggerConditions] = None,
    ):
        # This parameter is required.
        self.dialarm_rule_id = dialarm_rule_id
        self.dijob_id = dijob_id
        self.description = description
        self.enabled = enabled
        self.metric_type = metric_type
        self.name = name
        self.notification_settings = notification_settings
        self.trigger_conditions = trigger_conditions

    def validate(self):
        if self.notification_settings:
            self.notification_settings.validate()
        if self.trigger_conditions:
            for k in self.trigger_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings is not None:
            result['NotificationSettings'] = self.notification_settings.to_map()
        result['TriggerConditions'] = []
        if self.trigger_conditions is not None:
            for k in self.trigger_conditions:
                result['TriggerConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            temp_model = UpdateDIAlarmRuleRequestNotificationSettings()
            self.notification_settings = temp_model.from_map(m['NotificationSettings'])
        self.trigger_conditions = []
        if m.get('TriggerConditions') is not None:
            for k in m.get('TriggerConditions'):
                temp_model = UpdateDIAlarmRuleRequestTriggerConditions()
                self.trigger_conditions.append(temp_model.from_map(k))
        return self


class UpdateDIAlarmRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        metric_type: str = None,
        name: str = None,
        notification_settings_shrink: str = None,
        trigger_conditions_shrink: str = None,
    ):
        # This parameter is required.
        self.dialarm_rule_id = dialarm_rule_id
        self.dijob_id = dijob_id
        self.description = description
        self.enabled = enabled
        self.metric_type = metric_type
        self.name = name
        self.notification_settings_shrink = notification_settings_shrink
        self.trigger_conditions_shrink = trigger_conditions_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings_shrink is not None:
            result['NotificationSettings'] = self.notification_settings_shrink
        if self.trigger_conditions_shrink is not None:
            result['TriggerConditions'] = self.trigger_conditions_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            self.notification_settings_shrink = m.get('NotificationSettings')
        if m.get('TriggerConditions') is not None:
            self.trigger_conditions_shrink = m.get('TriggerConditions')
        return self


class UpdateDIAlarmRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDIAlarmRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDIAlarmRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDIAlarmRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDIJobRequestJobSettingsColumnDataTypeSettings(TeaModel):
    def __init__(
        self,
        destination_data_type: str = None,
        source_data_type: str = None,
    ):
        self.destination_data_type = destination_data_type
        self.source_data_type = source_data_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_data_type is not None:
            result['DestinationDataType'] = self.destination_data_type
        if self.source_data_type is not None:
            result['SourceDataType'] = self.source_data_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDataType') is not None:
            self.destination_data_type = m.get('DestinationDataType')
        if m.get('SourceDataType') is not None:
            self.source_data_type = m.get('SourceDataType')
        return self


class UpdateDIJobRequestJobSettingsCycleScheduleSettings(TeaModel):
    def __init__(
        self,
        schedule_parameters: str = None,
    ):
        self.schedule_parameters = schedule_parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.schedule_parameters is not None:
            result['ScheduleParameters'] = self.schedule_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScheduleParameters') is not None:
            self.schedule_parameters = m.get('ScheduleParameters')
        return self


class UpdateDIJobRequestJobSettingsDdlHandlingSettings(TeaModel):
    def __init__(
        self,
        action: str = None,
        type: str = None,
    ):
        self.action = action
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDIJobRequestJobSettingsRuntimeSettings(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDIJobRequestJobSettings(TeaModel):
    def __init__(
        self,
        channel_settings: str = None,
        column_data_type_settings: List[UpdateDIJobRequestJobSettingsColumnDataTypeSettings] = None,
        cycle_schedule_settings: UpdateDIJobRequestJobSettingsCycleScheduleSettings = None,
        ddl_handling_settings: List[UpdateDIJobRequestJobSettingsDdlHandlingSettings] = None,
        runtime_settings: List[UpdateDIJobRequestJobSettingsRuntimeSettings] = None,
    ):
        self.channel_settings = channel_settings
        self.column_data_type_settings = column_data_type_settings
        self.cycle_schedule_settings = cycle_schedule_settings
        self.ddl_handling_settings = ddl_handling_settings
        self.runtime_settings = runtime_settings

    def validate(self):
        if self.column_data_type_settings:
            for k in self.column_data_type_settings:
                if k:
                    k.validate()
        if self.cycle_schedule_settings:
            self.cycle_schedule_settings.validate()
        if self.ddl_handling_settings:
            for k in self.ddl_handling_settings:
                if k:
                    k.validate()
        if self.runtime_settings:
            for k in self.runtime_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_settings is not None:
            result['ChannelSettings'] = self.channel_settings
        result['ColumnDataTypeSettings'] = []
        if self.column_data_type_settings is not None:
            for k in self.column_data_type_settings:
                result['ColumnDataTypeSettings'].append(k.to_map() if k else None)
        if self.cycle_schedule_settings is not None:
            result['CycleScheduleSettings'] = self.cycle_schedule_settings.to_map()
        result['DdlHandlingSettings'] = []
        if self.ddl_handling_settings is not None:
            for k in self.ddl_handling_settings:
                result['DdlHandlingSettings'].append(k.to_map() if k else None)
        result['RuntimeSettings'] = []
        if self.runtime_settings is not None:
            for k in self.runtime_settings:
                result['RuntimeSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelSettings') is not None:
            self.channel_settings = m.get('ChannelSettings')
        self.column_data_type_settings = []
        if m.get('ColumnDataTypeSettings') is not None:
            for k in m.get('ColumnDataTypeSettings'):
                temp_model = UpdateDIJobRequestJobSettingsColumnDataTypeSettings()
                self.column_data_type_settings.append(temp_model.from_map(k))
        if m.get('CycleScheduleSettings') is not None:
            temp_model = UpdateDIJobRequestJobSettingsCycleScheduleSettings()
            self.cycle_schedule_settings = temp_model.from_map(m['CycleScheduleSettings'])
        self.ddl_handling_settings = []
        if m.get('DdlHandlingSettings') is not None:
            for k in m.get('DdlHandlingSettings'):
                temp_model = UpdateDIJobRequestJobSettingsDdlHandlingSettings()
                self.ddl_handling_settings.append(temp_model.from_map(k))
        self.runtime_settings = []
        if m.get('RuntimeSettings') is not None:
            for k in m.get('RuntimeSettings'):
                temp_model = UpdateDIJobRequestJobSettingsRuntimeSettings()
                self.runtime_settings.append(temp_model.from_map(k))
        return self


class UpdateDIJobRequestResourceSettingsOfflineResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: int = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class UpdateDIJobRequestResourceSettingsRealtimeResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: int = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class UpdateDIJobRequestResourceSettingsScheduleResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: int = None,
        resource_group_identifier: str = None,
    ):
        self.requested_cu = requested_cu
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class UpdateDIJobRequestResourceSettings(TeaModel):
    def __init__(
        self,
        offline_resource_settings: UpdateDIJobRequestResourceSettingsOfflineResourceSettings = None,
        realtime_resource_settings: UpdateDIJobRequestResourceSettingsRealtimeResourceSettings = None,
        schedule_resource_settings: UpdateDIJobRequestResourceSettingsScheduleResourceSettings = None,
    ):
        self.offline_resource_settings = offline_resource_settings
        self.realtime_resource_settings = realtime_resource_settings
        self.schedule_resource_settings = schedule_resource_settings

    def validate(self):
        if self.offline_resource_settings:
            self.offline_resource_settings.validate()
        if self.realtime_resource_settings:
            self.realtime_resource_settings.validate()
        if self.schedule_resource_settings:
            self.schedule_resource_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offline_resource_settings is not None:
            result['OfflineResourceSettings'] = self.offline_resource_settings.to_map()
        if self.realtime_resource_settings is not None:
            result['RealtimeResourceSettings'] = self.realtime_resource_settings.to_map()
        if self.schedule_resource_settings is not None:
            result['ScheduleResourceSettings'] = self.schedule_resource_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OfflineResourceSettings') is not None:
            temp_model = UpdateDIJobRequestResourceSettingsOfflineResourceSettings()
            self.offline_resource_settings = temp_model.from_map(m['OfflineResourceSettings'])
        if m.get('RealtimeResourceSettings') is not None:
            temp_model = UpdateDIJobRequestResourceSettingsRealtimeResourceSettings()
            self.realtime_resource_settings = temp_model.from_map(m['RealtimeResourceSettings'])
        if m.get('ScheduleResourceSettings') is not None:
            temp_model = UpdateDIJobRequestResourceSettingsScheduleResourceSettings()
            self.schedule_resource_settings = temp_model.from_map(m['ScheduleResourceSettings'])
        return self


class UpdateDIJobRequestTableMappingsSourceObjectSelectionRules(TeaModel):
    def __init__(
        self,
        action: str = None,
        expression: str = None,
        expression_type: str = None,
        object_type: str = None,
    ):
        self.action = action
        self.expression = expression
        self.expression_type = expression_type
        self.object_type = object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.expression_type is not None:
            result['ExpressionType'] = self.expression_type
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('ExpressionType') is not None:
            self.expression_type = m.get('ExpressionType')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        return self


class UpdateDIJobRequestTableMappingsTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        self.rule_action_type = rule_action_type
        self.rule_name = rule_name
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class UpdateDIJobRequestTableMappings(TeaModel):
    def __init__(
        self,
        source_object_selection_rules: List[UpdateDIJobRequestTableMappingsSourceObjectSelectionRules] = None,
        transformation_rules: List[UpdateDIJobRequestTableMappingsTransformationRules] = None,
    ):
        self.source_object_selection_rules = source_object_selection_rules
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.source_object_selection_rules:
            for k in self.source_object_selection_rules:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SourceObjectSelectionRules'] = []
        if self.source_object_selection_rules is not None:
            for k in self.source_object_selection_rules:
                result['SourceObjectSelectionRules'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.source_object_selection_rules = []
        if m.get('SourceObjectSelectionRules') is not None:
            for k in m.get('SourceObjectSelectionRules'):
                temp_model = UpdateDIJobRequestTableMappingsSourceObjectSelectionRules()
                self.source_object_selection_rules.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = UpdateDIJobRequestTableMappingsTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class UpdateDIJobRequestTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_expression: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        self.rule_action_type = rule_action_type
        self.rule_expression = rule_expression
        self.rule_name = rule_name
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_expression is not None:
            result['RuleExpression'] = self.rule_expression
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleExpression') is not None:
            self.rule_expression = m.get('RuleExpression')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class UpdateDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        description: str = None,
        job_settings: UpdateDIJobRequestJobSettings = None,
        project_id: int = None,
        resource_settings: UpdateDIJobRequestResourceSettings = None,
        table_mappings: List[UpdateDIJobRequestTableMappings] = None,
        transformation_rules: List[UpdateDIJobRequestTransformationRules] = None,
    ):
        # This parameter is required.
        self.dijob_id = dijob_id
        self.description = description
        self.job_settings = job_settings
        self.project_id = project_id
        self.resource_settings = resource_settings
        self.table_mappings = table_mappings
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.job_settings:
            self.job_settings.validate()
        if self.resource_settings:
            self.resource_settings.validate()
        if self.table_mappings:
            for k in self.table_mappings:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.job_settings is not None:
            result['JobSettings'] = self.job_settings.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings is not None:
            result['ResourceSettings'] = self.resource_settings.to_map()
        result['TableMappings'] = []
        if self.table_mappings is not None:
            for k in self.table_mappings:
                result['TableMappings'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('JobSettings') is not None:
            temp_model = UpdateDIJobRequestJobSettings()
            self.job_settings = temp_model.from_map(m['JobSettings'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            temp_model = UpdateDIJobRequestResourceSettings()
            self.resource_settings = temp_model.from_map(m['ResourceSettings'])
        self.table_mappings = []
        if m.get('TableMappings') is not None:
            for k in m.get('TableMappings'):
                temp_model = UpdateDIJobRequestTableMappings()
                self.table_mappings.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = UpdateDIJobRequestTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class UpdateDIJobShrinkRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        description: str = None,
        job_settings_shrink: str = None,
        project_id: int = None,
        resource_settings_shrink: str = None,
        table_mappings_shrink: str = None,
        transformation_rules_shrink: str = None,
    ):
        # This parameter is required.
        self.dijob_id = dijob_id
        self.description = description
        self.job_settings_shrink = job_settings_shrink
        self.project_id = project_id
        self.resource_settings_shrink = resource_settings_shrink
        self.table_mappings_shrink = table_mappings_shrink
        self.transformation_rules_shrink = transformation_rules_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.job_settings_shrink is not None:
            result['JobSettings'] = self.job_settings_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings_shrink is not None:
            result['ResourceSettings'] = self.resource_settings_shrink
        if self.table_mappings_shrink is not None:
            result['TableMappings'] = self.table_mappings_shrink
        if self.transformation_rules_shrink is not None:
            result['TransformationRules'] = self.transformation_rules_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('JobSettings') is not None:
            self.job_settings_shrink = m.get('JobSettings')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            self.resource_settings_shrink = m.get('ResourceSettings')
        if m.get('TableMappings') is not None:
            self.table_mappings_shrink = m.get('TableMappings')
        if m.get('TransformationRules') is not None:
            self.transformation_rules_shrink = m.get('TransformationRules')
        return self


class UpdateDIJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataSourceRequest(TeaModel):
    def __init__(
        self,
        connection_properties: str = None,
        connection_properties_mode: str = None,
        description: str = None,
        id: int = None,
        project_id: int = None,
    ):
        # This parameter is required.
        self.connection_properties = connection_properties
        self.connection_properties_mode = connection_properties_mode
        self.description = description
        # This parameter is required.
        self.id = id
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_properties is not None:
            result['ConnectionProperties'] = self.connection_properties
        if self.connection_properties_mode is not None:
            result['ConnectionPropertiesMode'] = self.connection_properties_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionProperties') is not None:
            self.connection_properties = m.get('ConnectionProperties')
        if m.get('ConnectionPropertiesMode') is not None:
            self.connection_properties_mode = m.get('ConnectionPropertiesMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class UpdateDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFunctionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
        spec: str = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the UDF. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateFunctionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # true
        # 
        # false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateNodeRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
        spec: str = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the node. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateNodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProjectRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        id: int = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        self.description = description
        self.dev_environment_enabled = dev_environment_enabled
        self.dev_role_disabled = dev_role_disabled
        self.display_name = display_name
        # This parameter is required.
        self.id = id
        self.pai_task_enabled = pai_task_enabled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class UpdateProjectResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateResourceRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
        spec: str = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the file resource. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateResourceGroupRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        remark: str = None,
    ):
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.id = id
        # The new name that you want to change for the resource group.
        self.name = name
        # The new remarks that you want to modify for the resource group.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRouteRequest(TeaModel):
    def __init__(
        self,
        destination_cidr: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.destination_cidr = destination_cidr
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_cidr is not None:
            result['DestinationCidr'] = self.destination_cidr
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationCidr') is not None:
            self.destination_cidr = m.get('DestinationCidr')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class UpdateRouteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskInstancesRequestTaskInstancesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateTaskInstancesRequestTaskInstances(TeaModel):
    def __init__(
        self,
        data_source: UpdateTaskInstancesRequestTaskInstancesDataSource = None,
        id: int = None,
        priority: int = None,
        runtime_resource: str = None,
    ):
        self.data_source = data_source
        # This parameter is required.
        self.id = id
        self.priority = priority
        self.runtime_resource = runtime_resource

    def validate(self):
        if self.data_source:
            self.data_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSource') is not None:
            temp_model = UpdateTaskInstancesRequestTaskInstancesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        return self


class UpdateTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        task_instances: List[UpdateTaskInstancesRequestTaskInstances] = None,
    ):
        self.comment = comment
        self.task_instances = task_instances

    def validate(self):
        if self.task_instances:
            for k in self.task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        result['TaskInstances'] = []
        if self.task_instances is not None:
            for k in self.task_instances:
                result['TaskInstances'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        self.task_instances = []
        if m.get('TaskInstances') is not None:
            for k in m.get('TaskInstances'):
                temp_model = UpdateTaskInstancesRequestTaskInstances()
                self.task_instances.append(temp_model.from_map(k))
        return self


class UpdateTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        task_instances_shrink: str = None,
    ):
        self.comment = comment
        self.task_instances_shrink = task_instances_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.task_instances_shrink is not None:
            result['TaskInstances'] = self.task_instances_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('TaskInstances') is not None:
            self.task_instances_shrink = m.get('TaskInstances')
        return self


class UpdateTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        self.request_id = request_id
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class UpdateTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: str = None,
        spec: str = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the workflow. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


